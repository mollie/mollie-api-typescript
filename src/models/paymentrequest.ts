/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { RFCDate } from "../types/rfcdate.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  CaptureMode,
  CaptureMode$inboundSchema,
  CaptureMode$outboundSchema,
} from "./capturemode.js";
import {
  EntityPaymentRoute,
  EntityPaymentRoute$inboundSchema,
  EntityPaymentRoute$Outbound,
  EntityPaymentRoute$outboundSchema,
} from "./entitypaymentroute.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LineCategories,
  LineCategories$inboundSchema,
  LineCategories$outboundSchema,
} from "./linecategories.js";
import {
  Locale,
  Locale$inboundSchema,
  Locale$outboundSchema,
} from "./locale.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  MethodEnum,
  MethodEnum$inboundSchema,
  MethodEnum$outboundSchema,
} from "./methodenum.js";
import {
  PaymentAddress,
  PaymentAddress$inboundSchema,
  PaymentAddress$Outbound,
  PaymentAddress$outboundSchema,
} from "./paymentaddress.js";
import {
  PaymentLineType,
  PaymentLineType$inboundSchema,
  PaymentLineType$outboundSchema,
} from "./paymentlinetype.js";
import {
  RecurringLineItem,
  RecurringLineItem$inboundSchema,
  RecurringLineItem$Outbound,
  RecurringLineItem$outboundSchema,
} from "./recurringlineitem.js";
import {
  SequenceType,
  SequenceType$inboundSchema,
  SequenceType$outboundSchema,
} from "./sequencetype.js";

export type PaymentRequestLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: PaymentLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  unitPrice: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount: Amount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  vatAmount?: Amount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
   */
  categories?: Array<LineCategories> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  recurring?: RecurringLineItem | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `alma`, `in3`, `klarna`, `billie` and `riverty`.
 */
export type PaymentRequestBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   *
   * @remarks
   *
   * Required for payment method `billie`.
   */
  organizationName?: any | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

export type Method = MethodEnum | Array<MethodEnum | null>;

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type PaymentRequestApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
 *
 * @remarks
 * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
 * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
 */
export type Company = {
  /**
   * The organization's registration number.
   */
  registrationNumber?: string | undefined;
  /**
   * The organization's VAT number.
   */
  vatNumber?: string | undefined;
  /**
   * The organization's entity type.
   */
  entityType?: string | undefined;
};

export type PaymentRequest = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl: string | null;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<PaymentRequestLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `alma`, `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: PaymentRequestBillingAddress | undefined;
  shippingAddress?: PaymentAddress | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: Locale | null | undefined;
  method?: MethodEnum | Array<MethodEnum | null> | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: PaymentRequestApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<EntityPaymentRoute> | null | undefined;
  sequenceType?: SequenceType | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  customerId?: string | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
  /**
   * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
   *
   * @remarks
   * The token contains the payment information needed to authorize the payment.
   *
   * The object should be passed encoded in a JSON string.
   */
  applePayPaymentToken?: string | undefined;
  /**
   * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
   *
   * @remarks
   * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
   * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
   */
  company?: Company | undefined;
  /**
   * When creating credit card payments using Mollie Components, you need to provide the card token you received from
   *
   * @remarks
   * the card component in this field. The token represents the customer's card information needed to complete the
   * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
   * enough.
   */
  cardToken?: string | undefined;
  /**
   * The card token you received from the card component of Mollie Components. The token represents the customer's card
   *
   * @remarks
   * information needed to complete the payment.
   */
  voucherNumber?: string | undefined;
  /**
   * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
   */
  voucherPin?: string | undefined;
  /**
   * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
   *
   * @remarks
   * the payment process.
   */
  consumerDateOfBirth?: RFCDate | undefined;
  /**
   * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
   *
   * @remarks
   * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
   * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
   */
  extraMerchantData?: { [k: string]: any } | undefined;
  /**
   * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
   *
   * @remarks
   * on-demand payment.
   */
  sessionId?: string | undefined;
  /**
   * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
   *
   * @remarks
   * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
   */
  digitalGoods?: boolean | undefined;
  /**
   * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
   *
   * @remarks
   * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
   */
  customerReference?: string | undefined;
  /**
   * The ID of the terminal device where you want to initiate the payment on.
   */
  terminalId?: string | undefined;
};

/** @internal */
export const PaymentRequestLine$inboundSchema: z.ZodType<
  PaymentRequestLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaymentLineType$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$inboundSchema,
  discountAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$inboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategories$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$inboundSchema.optional(),
});
/** @internal */
export type PaymentRequestLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: Amount$Outbound;
  discountAmount?: Amount$Outbound | undefined;
  totalAmount: Amount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: Amount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: RecurringLineItem$Outbound | undefined;
};

/** @internal */
export const PaymentRequestLine$outboundSchema: z.ZodType<
  PaymentRequestLine$Outbound,
  z.ZodTypeDef,
  PaymentRequestLine
> = z.object({
  type: PaymentLineType$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$outboundSchema,
  discountAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$outboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategories$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$outboundSchema.optional(),
});

export function paymentRequestLineToJSON(
  paymentRequestLine: PaymentRequestLine,
): string {
  return JSON.stringify(
    PaymentRequestLine$outboundSchema.parse(paymentRequestLine),
  );
}
export function paymentRequestLineFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequestLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequestLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequestLine' from JSON`,
  );
}

/** @internal */
export const PaymentRequestBillingAddress$inboundSchema: z.ZodType<
  PaymentRequestBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.any().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});
/** @internal */
export type PaymentRequestBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: any | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const PaymentRequestBillingAddress$outboundSchema: z.ZodType<
  PaymentRequestBillingAddress$Outbound,
  z.ZodTypeDef,
  PaymentRequestBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.any().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

export function paymentRequestBillingAddressToJSON(
  paymentRequestBillingAddress: PaymentRequestBillingAddress,
): string {
  return JSON.stringify(
    PaymentRequestBillingAddress$outboundSchema.parse(
      paymentRequestBillingAddress,
    ),
  );
}
export function paymentRequestBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequestBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequestBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequestBillingAddress' from JSON`,
  );
}

/** @internal */
export const Method$inboundSchema: z.ZodType<Method, z.ZodTypeDef, unknown> = z
  .union([
    MethodEnum$inboundSchema,
    z.array(z.nullable(MethodEnum$inboundSchema)),
  ]);
/** @internal */
export type Method$Outbound = string | Array<string | null>;

/** @internal */
export const Method$outboundSchema: z.ZodType<
  Method$Outbound,
  z.ZodTypeDef,
  Method
> = z.union([
  MethodEnum$outboundSchema,
  z.array(z.nullable(MethodEnum$outboundSchema)),
]);

export function methodToJSON(method: Method): string {
  return JSON.stringify(Method$outboundSchema.parse(method));
}
export function methodFromJSON(
  jsonString: string,
): SafeParseResult<Method, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Method$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Method' from JSON`,
  );
}

/** @internal */
export const PaymentRequestApplicationFee$inboundSchema: z.ZodType<
  PaymentRequestApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  description: z.string().optional(),
});
/** @internal */
export type PaymentRequestApplicationFee$Outbound = {
  amount?: Amount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const PaymentRequestApplicationFee$outboundSchema: z.ZodType<
  PaymentRequestApplicationFee$Outbound,
  z.ZodTypeDef,
  PaymentRequestApplicationFee
> = z.object({
  amount: Amount$outboundSchema.optional(),
  description: z.string().optional(),
});

export function paymentRequestApplicationFeeToJSON(
  paymentRequestApplicationFee: PaymentRequestApplicationFee,
): string {
  return JSON.stringify(
    PaymentRequestApplicationFee$outboundSchema.parse(
      paymentRequestApplicationFee,
    ),
  );
}
export function paymentRequestApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequestApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequestApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequestApplicationFee' from JSON`,
  );
}

/** @internal */
export const Company$inboundSchema: z.ZodType<Company, z.ZodTypeDef, unknown> =
  z.object({
    registrationNumber: z.string().optional(),
    vatNumber: z.string().optional(),
    entityType: z.string().optional(),
  });
/** @internal */
export type Company$Outbound = {
  registrationNumber?: string | undefined;
  vatNumber?: string | undefined;
  entityType?: string | undefined;
};

/** @internal */
export const Company$outboundSchema: z.ZodType<
  Company$Outbound,
  z.ZodTypeDef,
  Company
> = z.object({
  registrationNumber: z.string().optional(),
  vatNumber: z.string().optional(),
  entityType: z.string().optional(),
});

export function companyToJSON(company: Company): string {
  return JSON.stringify(Company$outboundSchema.parse(company));
}
export function companyFromJSON(
  jsonString: string,
): SafeParseResult<Company, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Company$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Company' from JSON`,
  );
}

/** @internal */
export const PaymentRequest$inboundSchema: z.ZodType<
  PaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: Amount$inboundSchema,
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentRequestLine$inboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => PaymentRequestBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: PaymentAddress$inboundSchema.optional(),
  locale: z.nullable(Locale$inboundSchema).optional(),
  method: z.nullable(
    z.union([
      MethodEnum$inboundSchema,
      z.array(z.nullable(MethodEnum$inboundSchema)),
    ]),
  ).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  captureMode: z.nullable(CaptureMode$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentRequestApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRoute$inboundSchema)).optional(),
  sequenceType: SequenceType$inboundSchema.optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  applePayPaymentToken: z.string().optional(),
  company: z.lazy(() => Company$inboundSchema).optional(),
  cardToken: z.string().optional(),
  voucherNumber: z.string().optional(),
  voucherPin: z.string().optional(),
  consumerDateOfBirth: z.string().transform(v => new RFCDate(v)).optional(),
  extraMerchantData: z.record(z.any()).optional(),
  sessionId: z.string().optional(),
  digitalGoods: z.boolean().optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
});
/** @internal */
export type PaymentRequest$Outbound = {
  description: string;
  amount: Amount$Outbound;
  redirectUrl: string | null;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<PaymentRequestLine$Outbound> | null | undefined;
  billingAddress?: PaymentRequestBillingAddress$Outbound | undefined;
  shippingAddress?: PaymentAddress$Outbound | undefined;
  locale?: string | null | undefined;
  method?: string | Array<string | null> | null | undefined;
  issuer?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  applicationFee?: PaymentRequestApplicationFee$Outbound | null | undefined;
  routing?: Array<EntityPaymentRoute$Outbound> | null | undefined;
  sequenceType?: string | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | undefined;
  profileId?: string | undefined;
  dueDate?: string | undefined;
  testmode?: boolean | null | undefined;
  applePayPaymentToken?: string | undefined;
  company?: Company$Outbound | undefined;
  cardToken?: string | undefined;
  voucherNumber?: string | undefined;
  voucherPin?: string | undefined;
  consumerDateOfBirth?: string | undefined;
  extraMerchantData?: { [k: string]: any } | undefined;
  sessionId?: string | undefined;
  digitalGoods?: boolean | undefined;
  customerReference?: string | undefined;
  terminalId?: string | undefined;
};

/** @internal */
export const PaymentRequest$outboundSchema: z.ZodType<
  PaymentRequest$Outbound,
  z.ZodTypeDef,
  PaymentRequest
> = z.object({
  description: z.string(),
  amount: Amount$outboundSchema,
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentRequestLine$outboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => PaymentRequestBillingAddress$outboundSchema)
    .optional(),
  shippingAddress: PaymentAddress$outboundSchema.optional(),
  locale: z.nullable(Locale$outboundSchema).optional(),
  method: z.nullable(
    z.union([
      MethodEnum$outboundSchema,
      z.array(z.nullable(MethodEnum$outboundSchema)),
    ]),
  ).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  captureMode: z.nullable(CaptureMode$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentRequestApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRoute$outboundSchema)).optional(),
  sequenceType: SequenceType$outboundSchema.optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  applePayPaymentToken: z.string().optional(),
  company: z.lazy(() => Company$outboundSchema).optional(),
  cardToken: z.string().optional(),
  voucherNumber: z.string().optional(),
  voucherPin: z.string().optional(),
  consumerDateOfBirth: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  extraMerchantData: z.record(z.any()).optional(),
  sessionId: z.string().optional(),
  digitalGoods: z.boolean().optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
});

export function paymentRequestToJSON(paymentRequest: PaymentRequest): string {
  return JSON.stringify(PaymentRequest$outboundSchema.parse(paymentRequest));
}
export function paymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequest' from JSON`,
  );
}
