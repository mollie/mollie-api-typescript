/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { RFCDate } from "../types/rfcdate.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  CaptureMode,
  CaptureMode$inboundSchema,
  CaptureMode$outboundSchema,
} from "./capturemode.js";
import {
  EntityPaymentRoute,
  EntityPaymentRoute$inboundSchema,
  EntityPaymentRoute$Outbound,
  EntityPaymentRoute$outboundSchema,
} from "./entitypaymentroute.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Locale,
  Locale$inboundSchema,
  Locale$outboundSchema,
} from "./locale.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  Method,
  Method$inboundSchema,
  Method$outboundSchema,
} from "./method.js";
import {
  PaymentAddress,
  PaymentAddress$inboundSchema,
  PaymentAddress$Outbound,
  PaymentAddress$outboundSchema,
} from "./paymentaddress.js";
import {
  RecurringLineItem,
  RecurringLineItem$inboundSchema,
  RecurringLineItem$Outbound,
  RecurringLineItem$outboundSchema,
} from "./recurringlineitem.js";
import {
  SequenceType,
  SequenceType$inboundSchema,
  SequenceType$outboundSchema,
} from "./sequencetype.js";

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const PaymentRequestType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type PaymentRequestType = ClosedEnum<typeof PaymentRequestType>;

export const PaymentRequestCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type PaymentRequestCategory = ClosedEnum<typeof PaymentRequestCategory>;

export type PaymentRequestLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: PaymentRequestType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  unitPrice: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount: Amount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  vatAmount?: Amount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
   */
  categories?: Array<PaymentRequestCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  recurring?: RecurringLineItem | undefined;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type PaymentRequestApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
 *
 * @remarks
 * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
 * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
 */
export type Company = {
  /**
   * The organization's registration number.
   */
  registrationNumber?: string | undefined;
  /**
   * The organization's VAT number.
   */
  vatNumber?: string | undefined;
  /**
   * The organization's entity type.
   */
  entityType?: string | undefined;
};

export type PaymentRequest = {
  id?: string | undefined;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountRefunded?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountRemaining?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountCaptured?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountChargedBack?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  settlementAmount?: Amount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<PaymentRequestLine> | null | undefined;
  billingAddress?: PaymentAddress | undefined;
  shippingAddress?: PaymentAddress | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: Locale | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: Method | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: PaymentRequestApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<EntityPaymentRoute> | null | undefined;
  sequenceType?: SequenceType | undefined;
  subscriptionId?: string | undefined;
  mandateId?: string | undefined;
  customerId?: string | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | undefined;
  settlementId?: string | undefined;
  orderId?: string | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
  /**
   * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
   *
   * @remarks
   * The token contains the payment information needed to authorize the payment.
   *
   * The object should be passed encoded in a JSON string.
   */
  applePayPaymentToken?: string | undefined;
  /**
   * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
   *
   * @remarks
   * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
   * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
   */
  company?: Company | undefined;
  /**
   * When creating credit card payments using Mollie Components, you need to provide the card token you received from
   *
   * @remarks
   * the card component in this field. The token represents the customer's card information needed to complete the
   * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
   * enough.
   */
  cardToken?: string | undefined;
  /**
   * The card token you received from the card component of Mollie Components. The token represents the customer's card
   *
   * @remarks
   * information needed to complete the payment.
   */
  voucherNumber?: string | undefined;
  /**
   * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
   */
  voucherPin?: string | undefined;
  /**
   * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
   *
   * @remarks
   * the payment process.
   */
  consumerDateOfBirth?: RFCDate | undefined;
  /**
   * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
   *
   * @remarks
   * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
   * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
   */
  extraMerchantData?: { [k: string]: any } | undefined;
  /**
   * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
   *
   * @remarks
   * on-demand payment.
   */
  sessionId?: string | undefined;
  /**
   * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
   *
   * @remarks
   * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
   */
  digitalGoods?: boolean | undefined;
  /**
   * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
   *
   * @remarks
   * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
   */
  customerReference?: string | undefined;
  /**
   * The ID of the terminal device where you want to initiate the payment on.
   */
  terminalId?: string | undefined;
};

/** @internal */
export const PaymentRequestType$inboundSchema: z.ZodNativeEnum<
  typeof PaymentRequestType
> = z.nativeEnum(PaymentRequestType);

/** @internal */
export const PaymentRequestType$outboundSchema: z.ZodNativeEnum<
  typeof PaymentRequestType
> = PaymentRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentRequestType$ {
  /** @deprecated use `PaymentRequestType$inboundSchema` instead. */
  export const inboundSchema = PaymentRequestType$inboundSchema;
  /** @deprecated use `PaymentRequestType$outboundSchema` instead. */
  export const outboundSchema = PaymentRequestType$outboundSchema;
}

/** @internal */
export const PaymentRequestCategory$inboundSchema: z.ZodNativeEnum<
  typeof PaymentRequestCategory
> = z.nativeEnum(PaymentRequestCategory);

/** @internal */
export const PaymentRequestCategory$outboundSchema: z.ZodNativeEnum<
  typeof PaymentRequestCategory
> = PaymentRequestCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentRequestCategory$ {
  /** @deprecated use `PaymentRequestCategory$inboundSchema` instead. */
  export const inboundSchema = PaymentRequestCategory$inboundSchema;
  /** @deprecated use `PaymentRequestCategory$outboundSchema` instead. */
  export const outboundSchema = PaymentRequestCategory$outboundSchema;
}

/** @internal */
export const PaymentRequestLine$inboundSchema: z.ZodType<
  PaymentRequestLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaymentRequestType$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$inboundSchema,
  discountAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$inboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(PaymentRequestCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$inboundSchema.optional(),
});

/** @internal */
export type PaymentRequestLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: Amount$Outbound;
  discountAmount?: Amount$Outbound | undefined;
  totalAmount: Amount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: Amount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: RecurringLineItem$Outbound | undefined;
};

/** @internal */
export const PaymentRequestLine$outboundSchema: z.ZodType<
  PaymentRequestLine$Outbound,
  z.ZodTypeDef,
  PaymentRequestLine
> = z.object({
  type: PaymentRequestType$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$outboundSchema,
  discountAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$outboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(PaymentRequestCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentRequestLine$ {
  /** @deprecated use `PaymentRequestLine$inboundSchema` instead. */
  export const inboundSchema = PaymentRequestLine$inboundSchema;
  /** @deprecated use `PaymentRequestLine$outboundSchema` instead. */
  export const outboundSchema = PaymentRequestLine$outboundSchema;
  /** @deprecated use `PaymentRequestLine$Outbound` instead. */
  export type Outbound = PaymentRequestLine$Outbound;
}

export function paymentRequestLineToJSON(
  paymentRequestLine: PaymentRequestLine,
): string {
  return JSON.stringify(
    PaymentRequestLine$outboundSchema.parse(paymentRequestLine),
  );
}

export function paymentRequestLineFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequestLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequestLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequestLine' from JSON`,
  );
}

/** @internal */
export const PaymentRequestApplicationFee$inboundSchema: z.ZodType<
  PaymentRequestApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  description: z.string().optional(),
});

/** @internal */
export type PaymentRequestApplicationFee$Outbound = {
  amount?: Amount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const PaymentRequestApplicationFee$outboundSchema: z.ZodType<
  PaymentRequestApplicationFee$Outbound,
  z.ZodTypeDef,
  PaymentRequestApplicationFee
> = z.object({
  amount: Amount$outboundSchema.optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentRequestApplicationFee$ {
  /** @deprecated use `PaymentRequestApplicationFee$inboundSchema` instead. */
  export const inboundSchema = PaymentRequestApplicationFee$inboundSchema;
  /** @deprecated use `PaymentRequestApplicationFee$outboundSchema` instead. */
  export const outboundSchema = PaymentRequestApplicationFee$outboundSchema;
  /** @deprecated use `PaymentRequestApplicationFee$Outbound` instead. */
  export type Outbound = PaymentRequestApplicationFee$Outbound;
}

export function paymentRequestApplicationFeeToJSON(
  paymentRequestApplicationFee: PaymentRequestApplicationFee,
): string {
  return JSON.stringify(
    PaymentRequestApplicationFee$outboundSchema.parse(
      paymentRequestApplicationFee,
    ),
  );
}

export function paymentRequestApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequestApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequestApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequestApplicationFee' from JSON`,
  );
}

/** @internal */
export const Company$inboundSchema: z.ZodType<Company, z.ZodTypeDef, unknown> =
  z.object({
    registrationNumber: z.string().optional(),
    vatNumber: z.string().optional(),
    entityType: z.string().optional(),
  });

/** @internal */
export type Company$Outbound = {
  registrationNumber?: string | undefined;
  vatNumber?: string | undefined;
  entityType?: string | undefined;
};

/** @internal */
export const Company$outboundSchema: z.ZodType<
  Company$Outbound,
  z.ZodTypeDef,
  Company
> = z.object({
  registrationNumber: z.string().optional(),
  vatNumber: z.string().optional(),
  entityType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Company$ {
  /** @deprecated use `Company$inboundSchema` instead. */
  export const inboundSchema = Company$inboundSchema;
  /** @deprecated use `Company$outboundSchema` instead. */
  export const outboundSchema = Company$outboundSchema;
  /** @deprecated use `Company$Outbound` instead. */
  export type Outbound = Company$Outbound;
}

export function companyToJSON(company: Company): string {
  return JSON.stringify(Company$outboundSchema.parse(company));
}

export function companyFromJSON(
  jsonString: string,
): SafeParseResult<Company, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Company$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Company' from JSON`,
  );
}

/** @internal */
export const PaymentRequest$inboundSchema: z.ZodType<
  PaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  description: z.string().optional(),
  amount: Amount$inboundSchema.optional(),
  amountRefunded: Amount$inboundSchema.optional(),
  amountRemaining: Amount$inboundSchema.optional(),
  amountCaptured: Amount$inboundSchema.optional(),
  amountChargedBack: Amount$inboundSchema.optional(),
  settlementAmount: Amount$inboundSchema.optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentRequestLine$inboundSchema)))
    .optional(),
  billingAddress: PaymentAddress$inboundSchema.optional(),
  shippingAddress: PaymentAddress$inboundSchema.optional(),
  locale: Locale$inboundSchema.optional(),
  method: z.nullable(Method$inboundSchema).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  captureMode: z.nullable(CaptureMode$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentRequestApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRoute$inboundSchema)).optional(),
  sequenceType: SequenceType$inboundSchema.optional(),
  subscriptionId: z.string().optional(),
  mandateId: z.string().optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  settlementId: z.string().optional(),
  orderId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  applePayPaymentToken: z.string().optional(),
  company: z.lazy(() => Company$inboundSchema).optional(),
  cardToken: z.string().optional(),
  voucherNumber: z.string().optional(),
  voucherPin: z.string().optional(),
  consumerDateOfBirth: z.string().transform(v => new RFCDate(v)).optional(),
  extraMerchantData: z.record(z.any()).optional(),
  sessionId: z.string().optional(),
  digitalGoods: z.boolean().optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
});

/** @internal */
export type PaymentRequest$Outbound = {
  id?: string | undefined;
  description?: string | undefined;
  amount?: Amount$Outbound | undefined;
  amountRefunded?: Amount$Outbound | undefined;
  amountRemaining?: Amount$Outbound | undefined;
  amountCaptured?: Amount$Outbound | undefined;
  amountChargedBack?: Amount$Outbound | undefined;
  settlementAmount?: Amount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<PaymentRequestLine$Outbound> | null | undefined;
  billingAddress?: PaymentAddress$Outbound | undefined;
  shippingAddress?: PaymentAddress$Outbound | undefined;
  locale?: string | undefined;
  method?: string | null | undefined;
  issuer?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  applicationFee?: PaymentRequestApplicationFee$Outbound | null | undefined;
  routing?: Array<EntityPaymentRoute$Outbound> | null | undefined;
  sequenceType?: string | undefined;
  subscriptionId?: string | undefined;
  mandateId?: string | undefined;
  customerId?: string | undefined;
  profileId?: string | undefined;
  settlementId?: string | undefined;
  orderId?: string | undefined;
  dueDate?: string | undefined;
  testmode?: boolean | null | undefined;
  applePayPaymentToken?: string | undefined;
  company?: Company$Outbound | undefined;
  cardToken?: string | undefined;
  voucherNumber?: string | undefined;
  voucherPin?: string | undefined;
  consumerDateOfBirth?: string | undefined;
  extraMerchantData?: { [k: string]: any } | undefined;
  sessionId?: string | undefined;
  digitalGoods?: boolean | undefined;
  customerReference?: string | undefined;
  terminalId?: string | undefined;
};

/** @internal */
export const PaymentRequest$outboundSchema: z.ZodType<
  PaymentRequest$Outbound,
  z.ZodTypeDef,
  PaymentRequest
> = z.object({
  id: z.string().optional(),
  description: z.string().optional(),
  amount: Amount$outboundSchema.optional(),
  amountRefunded: Amount$outboundSchema.optional(),
  amountRemaining: Amount$outboundSchema.optional(),
  amountCaptured: Amount$outboundSchema.optional(),
  amountChargedBack: Amount$outboundSchema.optional(),
  settlementAmount: Amount$outboundSchema.optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentRequestLine$outboundSchema)))
    .optional(),
  billingAddress: PaymentAddress$outboundSchema.optional(),
  shippingAddress: PaymentAddress$outboundSchema.optional(),
  locale: Locale$outboundSchema.optional(),
  method: z.nullable(Method$outboundSchema).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  captureMode: z.nullable(CaptureMode$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentRequestApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRoute$outboundSchema)).optional(),
  sequenceType: SequenceType$outboundSchema.optional(),
  subscriptionId: z.string().optional(),
  mandateId: z.string().optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  settlementId: z.string().optional(),
  orderId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  applePayPaymentToken: z.string().optional(),
  company: z.lazy(() => Company$outboundSchema).optional(),
  cardToken: z.string().optional(),
  voucherNumber: z.string().optional(),
  voucherPin: z.string().optional(),
  consumerDateOfBirth: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  extraMerchantData: z.record(z.any()).optional(),
  sessionId: z.string().optional(),
  digitalGoods: z.boolean().optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentRequest$ {
  /** @deprecated use `PaymentRequest$inboundSchema` instead. */
  export const inboundSchema = PaymentRequest$inboundSchema;
  /** @deprecated use `PaymentRequest$outboundSchema` instead. */
  export const outboundSchema = PaymentRequest$outboundSchema;
  /** @deprecated use `PaymentRequest$Outbound` instead. */
  export type Outbound = PaymentRequest$Outbound;
}

export function paymentRequestToJSON(paymentRequest: PaymentRequest): string {
  return JSON.stringify(PaymentRequest$outboundSchema.parse(paymentRequest));
}

export function paymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<PaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentRequest' from JSON`,
  );
}
