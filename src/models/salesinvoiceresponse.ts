/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  SalesInvoiceDiscountResponse,
  SalesInvoiceDiscountResponse$inboundSchema,
  SalesInvoiceDiscountResponse$Outbound,
  SalesInvoiceDiscountResponse$outboundSchema,
} from "./salesinvoicediscountresponse.js";
import {
  SalesInvoiceEmailDetails,
  SalesInvoiceEmailDetails$inboundSchema,
  SalesInvoiceEmailDetails$Outbound,
  SalesInvoiceEmailDetails$outboundSchema,
} from "./salesinvoiceemaildetails.js";
import {
  SalesInvoiceLineItemResponse,
  SalesInvoiceLineItemResponse$inboundSchema,
  SalesInvoiceLineItemResponse$Outbound,
  SalesInvoiceLineItemResponse$outboundSchema,
} from "./salesinvoicelineitemresponse.js";
import {
  SalesInvoicePaymentDetailsResponse,
  SalesInvoicePaymentDetailsResponse$inboundSchema,
  SalesInvoicePaymentDetailsResponse$Outbound,
  SalesInvoicePaymentDetailsResponse$outboundSchema,
} from "./salesinvoicepaymentdetailsresponse.js";
import {
  SalesInvoicePaymentTermResponse,
  SalesInvoicePaymentTermResponse$inboundSchema,
  SalesInvoicePaymentTermResponse$outboundSchema,
} from "./salesinvoicepaymenttermresponse.js";
import {
  SalesInvoiceRecipientResponse,
  SalesInvoiceRecipientResponse$inboundSchema,
  SalesInvoiceRecipientResponse$Outbound,
  SalesInvoiceRecipientResponse$outboundSchema,
} from "./salesinvoicerecipientresponse.js";
import {
  SalesInvoiceStatusResponse,
  SalesInvoiceStatusResponse$inboundSchema,
  SalesInvoiceStatusResponse$outboundSchema,
} from "./salesinvoicestatusresponse.js";
import {
  SalesInvoiceVatModeResponse,
  SalesInvoiceVatModeResponse$inboundSchema,
  SalesInvoiceVatModeResponse$outboundSchema,
} from "./salesinvoicevatmoderesponse.js";
import {
  SalesInvoiceVatSchemeResponse,
  SalesInvoiceVatSchemeResponse$inboundSchema,
  SalesInvoiceVatSchemeResponse$outboundSchema,
} from "./salesinvoicevatschemeresponse.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type SalesInvoiceResponseMetadata = {};

/**
 * The amount that is left to be paid.
 */
export type SalesInvoiceResponseAmountDue = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount without VAT before discounts.
 */
export type SalesInvoiceResponseSubtotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount with VAT.
 */
export type SalesInvoiceResponseTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total VAT amount.
 */
export type SalesInvoiceResponseTotalVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount without VAT after discounts.
 */
export type SalesInvoiceResponseDiscountedSubtotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type SalesInvoiceResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  invoicePayment?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  pdfLink?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  next?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  previous?: Url | undefined;
};

export type SalesInvoiceResponse = {
  /**
   * Indicates the response contains a sales invoice object. Will always contain the string `sales-invoice` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this invoice. Example: `invoice_4Y0eZitmBnQ6IDoMqZQKh`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * When issued, an invoice number will be set for the sales invoice.
   */
  invoiceNumber?: string | null | undefined;
  /**
   * The status for the invoice to end up in.
   *
   * @remarks
   *
   * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
   * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
   * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
   *
   * A status value that cannot be set but can be returned is `canceled`, for invoices which were
   * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
   *
   * Dependent parameters:
   *   - `paymentDetails` is required if invoice should be set directly to `paid`
   *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
   *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
   */
  status?: SalesInvoiceStatusResponse | undefined;
  /**
   * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
   */
  vatScheme?: SalesInvoiceVatSchemeResponse | undefined;
  /**
   * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
   *
   * @remarks
   * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
   */
  vatMode?: SalesInvoiceVatModeResponse | undefined;
  /**
   * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
   */
  memo?: string | null | undefined;
  /**
   * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: SalesInvoiceResponseMetadata | null | undefined;
  /**
   * The payment term to be set on the invoice.
   */
  paymentTerm?: SalesInvoicePaymentTermResponse | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetailsResponse | undefined;
  emailDetails?: SalesInvoiceEmailDetails | null | undefined;
  /**
   * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
   *
   * @remarks
   * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  customerId?: string | undefined;
  /**
   * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
   *
   * @remarks
   * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  mandateId?: string | undefined;
  /**
   * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
   *
   * @remarks
   * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
   * is not required to send a first invoice to a recipient.
   */
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse | null | undefined;
  /**
   * Provide the line items for the invoice. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the invoice.
   */
  lines?: Array<SalesInvoiceLineItemResponse> | null | undefined;
  discount?: SalesInvoiceDiscountResponse | null | undefined;
  /**
   * The amount that is left to be paid.
   */
  amountDue?: SalesInvoiceResponseAmountDue | undefined;
  /**
   * The total amount without VAT before discounts.
   */
  subtotalAmount?: SalesInvoiceResponseSubtotalAmount | undefined;
  /**
   * The total amount with VAT.
   */
  totalAmount?: SalesInvoiceResponseTotalAmount | undefined;
  /**
   * The total VAT amount.
   */
  totalVatAmount?: SalesInvoiceResponseTotalVatAmount | undefined;
  /**
   * The total amount without VAT after discounts.
   */
  discountedSubtotalAmount?:
    | SalesInvoiceResponseDiscountedSubtotalAmount
    | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  issuedAt?: string | null | undefined;
  /**
   * If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  paidAt?: string | null | undefined;
  /**
   * If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  dueAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: SalesInvoiceResponseLinks | undefined;
};

/** @internal */
export const SalesInvoiceResponseMetadata$inboundSchema: z.ZodType<
  SalesInvoiceResponseMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type SalesInvoiceResponseMetadata$Outbound = {};

/** @internal */
export const SalesInvoiceResponseMetadata$outboundSchema: z.ZodType<
  SalesInvoiceResponseMetadata$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseMetadata
> = z.object({});

export function salesInvoiceResponseMetadataToJSON(
  salesInvoiceResponseMetadata: SalesInvoiceResponseMetadata,
): string {
  return JSON.stringify(
    SalesInvoiceResponseMetadata$outboundSchema.parse(
      salesInvoiceResponseMetadata,
    ),
  );
}
export function salesInvoiceResponseMetadataFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceResponseMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseMetadata' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseAmountDue$inboundSchema: z.ZodType<
  SalesInvoiceResponseAmountDue,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type SalesInvoiceResponseAmountDue$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const SalesInvoiceResponseAmountDue$outboundSchema: z.ZodType<
  SalesInvoiceResponseAmountDue$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseAmountDue
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function salesInvoiceResponseAmountDueToJSON(
  salesInvoiceResponseAmountDue: SalesInvoiceResponseAmountDue,
): string {
  return JSON.stringify(
    SalesInvoiceResponseAmountDue$outboundSchema.parse(
      salesInvoiceResponseAmountDue,
    ),
  );
}
export function salesInvoiceResponseAmountDueFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseAmountDue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceResponseAmountDue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseAmountDue' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseSubtotalAmount$inboundSchema: z.ZodType<
  SalesInvoiceResponseSubtotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type SalesInvoiceResponseSubtotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const SalesInvoiceResponseSubtotalAmount$outboundSchema: z.ZodType<
  SalesInvoiceResponseSubtotalAmount$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseSubtotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function salesInvoiceResponseSubtotalAmountToJSON(
  salesInvoiceResponseSubtotalAmount: SalesInvoiceResponseSubtotalAmount,
): string {
  return JSON.stringify(
    SalesInvoiceResponseSubtotalAmount$outboundSchema.parse(
      salesInvoiceResponseSubtotalAmount,
    ),
  );
}
export function salesInvoiceResponseSubtotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseSubtotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SalesInvoiceResponseSubtotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseSubtotalAmount' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseTotalAmount$inboundSchema: z.ZodType<
  SalesInvoiceResponseTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type SalesInvoiceResponseTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const SalesInvoiceResponseTotalAmount$outboundSchema: z.ZodType<
  SalesInvoiceResponseTotalAmount$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function salesInvoiceResponseTotalAmountToJSON(
  salesInvoiceResponseTotalAmount: SalesInvoiceResponseTotalAmount,
): string {
  return JSON.stringify(
    SalesInvoiceResponseTotalAmount$outboundSchema.parse(
      salesInvoiceResponseTotalAmount,
    ),
  );
}
export function salesInvoiceResponseTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceResponseTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseTotalAmount' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseTotalVatAmount$inboundSchema: z.ZodType<
  SalesInvoiceResponseTotalVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type SalesInvoiceResponseTotalVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const SalesInvoiceResponseTotalVatAmount$outboundSchema: z.ZodType<
  SalesInvoiceResponseTotalVatAmount$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseTotalVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function salesInvoiceResponseTotalVatAmountToJSON(
  salesInvoiceResponseTotalVatAmount: SalesInvoiceResponseTotalVatAmount,
): string {
  return JSON.stringify(
    SalesInvoiceResponseTotalVatAmount$outboundSchema.parse(
      salesInvoiceResponseTotalVatAmount,
    ),
  );
}
export function salesInvoiceResponseTotalVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseTotalVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SalesInvoiceResponseTotalVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseTotalVatAmount' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema:
  z.ZodType<
    SalesInvoiceResponseDiscountedSubtotalAmount,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });
/** @internal */
export type SalesInvoiceResponseDiscountedSubtotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const SalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema:
  z.ZodType<
    SalesInvoiceResponseDiscountedSubtotalAmount$Outbound,
    z.ZodTypeDef,
    SalesInvoiceResponseDiscountedSubtotalAmount
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

export function salesInvoiceResponseDiscountedSubtotalAmountToJSON(
  salesInvoiceResponseDiscountedSubtotalAmount:
    SalesInvoiceResponseDiscountedSubtotalAmount,
): string {
  return JSON.stringify(
    SalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema.parse(
      salesInvoiceResponseDiscountedSubtotalAmount,
    ),
  );
}
export function salesInvoiceResponseDiscountedSubtotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  SalesInvoiceResponseDiscountedSubtotalAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SalesInvoiceResponseDiscountedSubtotalAmount' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponseLinks$inboundSchema: z.ZodType<
  SalesInvoiceResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  invoicePayment: Url$inboundSchema.optional(),
  pdfLink: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
  next: Url$inboundSchema.optional(),
  previous: Url$inboundSchema.optional(),
});
/** @internal */
export type SalesInvoiceResponseLinks$Outbound = {
  self?: Url$Outbound | undefined;
  invoicePayment?: Url$Outbound | undefined;
  pdfLink?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
  next?: Url$Outbound | undefined;
  previous?: Url$Outbound | undefined;
};

/** @internal */
export const SalesInvoiceResponseLinks$outboundSchema: z.ZodType<
  SalesInvoiceResponseLinks$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponseLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  invoicePayment: Url$outboundSchema.optional(),
  pdfLink: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
  next: Url$outboundSchema.optional(),
  previous: Url$outboundSchema.optional(),
});

export function salesInvoiceResponseLinksToJSON(
  salesInvoiceResponseLinks: SalesInvoiceResponseLinks,
): string {
  return JSON.stringify(
    SalesInvoiceResponseLinks$outboundSchema.parse(salesInvoiceResponseLinks),
  );
}
export function salesInvoiceResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponseLinks' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceResponse$inboundSchema: z.ZodType<
  SalesInvoiceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$inboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$inboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$inboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.lazy(() => SalesInvoiceResponseMetadata$inboundSchema))
    .optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$inboundSchema)
    .optional(),
  paymentDetails: SalesInvoicePaymentDetailsResponse$inboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$inboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$inboundSchema).optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$inboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$inboundSchema).optional(),
  amountDue: z.lazy(() => SalesInvoiceResponseAmountDue$inboundSchema)
    .optional(),
  subtotalAmount: z.lazy(() => SalesInvoiceResponseSubtotalAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => SalesInvoiceResponseTotalAmount$inboundSchema)
    .optional(),
  totalVatAmount: z.lazy(() => SalesInvoiceResponseTotalVatAmount$inboundSchema)
    .optional(),
  discountedSubtotalAmount: z.lazy(() =>
    SalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema
  ).optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => SalesInvoiceResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type SalesInvoiceResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  invoiceNumber?: string | null | undefined;
  status?: string | undefined;
  vatScheme?: string | undefined;
  vatMode?: string | undefined;
  memo?: string | null | undefined;
  metadata?: SalesInvoiceResponseMetadata$Outbound | null | undefined;
  paymentTerm?: string | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetailsResponse$Outbound | undefined;
  emailDetails?: SalesInvoiceEmailDetails$Outbound | null | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse$Outbound | null | undefined;
  lines?: Array<SalesInvoiceLineItemResponse$Outbound> | null | undefined;
  discount?: SalesInvoiceDiscountResponse$Outbound | null | undefined;
  amountDue?: SalesInvoiceResponseAmountDue$Outbound | undefined;
  subtotalAmount?: SalesInvoiceResponseSubtotalAmount$Outbound | undefined;
  totalAmount?: SalesInvoiceResponseTotalAmount$Outbound | undefined;
  totalVatAmount?: SalesInvoiceResponseTotalVatAmount$Outbound | undefined;
  discountedSubtotalAmount?:
    | SalesInvoiceResponseDiscountedSubtotalAmount$Outbound
    | undefined;
  createdAt?: string | undefined;
  issuedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  dueAt?: string | null | undefined;
  _links?: SalesInvoiceResponseLinks$Outbound | undefined;
};

/** @internal */
export const SalesInvoiceResponse$outboundSchema: z.ZodType<
  SalesInvoiceResponse$Outbound,
  z.ZodTypeDef,
  SalesInvoiceResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$outboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$outboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$outboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.lazy(() => SalesInvoiceResponseMetadata$outboundSchema),
  ).optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$outboundSchema)
    .optional(),
  paymentDetails: SalesInvoicePaymentDetailsResponse$outboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$outboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$outboundSchema)
    .optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$outboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$outboundSchema).optional(),
  amountDue: z.lazy(() => SalesInvoiceResponseAmountDue$outboundSchema)
    .optional(),
  subtotalAmount: z.lazy(() =>
    SalesInvoiceResponseSubtotalAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => SalesInvoiceResponseTotalAmount$outboundSchema)
    .optional(),
  totalVatAmount: z.lazy(() =>
    SalesInvoiceResponseTotalVatAmount$outboundSchema
  ).optional(),
  discountedSubtotalAmount: z.lazy(() =>
    SalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema
  ).optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => SalesInvoiceResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function salesInvoiceResponseToJSON(
  salesInvoiceResponse: SalesInvoiceResponse,
): string {
  return JSON.stringify(
    SalesInvoiceResponse$outboundSchema.parse(salesInvoiceResponse),
  );
}
export function salesInvoiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceResponse' from JSON`,
  );
}
