/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  SubscriptionMethodResponse,
  SubscriptionMethodResponse$inboundSchema,
  SubscriptionMethodResponse$outboundSchema,
} from "./subscriptionmethodresponse.js";
import {
  SubscriptionStatus,
  SubscriptionStatus$inboundSchema,
  SubscriptionStatus$outboundSchema,
} from "./subscriptionstatus.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";
import {
  UrlNullable,
  UrlNullable$inboundSchema,
  UrlNullable$Outbound,
  UrlNullable$outboundSchema,
} from "./urlnullable.js";

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type SubscriptionResponseApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  description: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type SubscriptionResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer: UrlNullable | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mandate?: UrlNullable | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  profile: UrlNullable | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payments?: UrlNullable | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: Url;
};

export type SubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: Mode | undefined;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status?: SubscriptionStatus | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | null | undefined;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining?: number | null | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval?: string | undefined;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description?: string | undefined;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method?: SubscriptionMethodResponse | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: SubscriptionResponseApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: SubscriptionResponseLinks | undefined;
};

/** @internal */
export const SubscriptionResponseApplicationFee$inboundSchema: z.ZodType<
  SubscriptionResponseApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema,
  description: z.string(),
});

/** @internal */
export type SubscriptionResponseApplicationFee$Outbound = {
  amount: Amount$Outbound;
  description: string;
};

/** @internal */
export const SubscriptionResponseApplicationFee$outboundSchema: z.ZodType<
  SubscriptionResponseApplicationFee$Outbound,
  z.ZodTypeDef,
  SubscriptionResponseApplicationFee
> = z.object({
  amount: Amount$outboundSchema,
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionResponseApplicationFee$ {
  /** @deprecated use `SubscriptionResponseApplicationFee$inboundSchema` instead. */
  export const inboundSchema = SubscriptionResponseApplicationFee$inboundSchema;
  /** @deprecated use `SubscriptionResponseApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    SubscriptionResponseApplicationFee$outboundSchema;
  /** @deprecated use `SubscriptionResponseApplicationFee$Outbound` instead. */
  export type Outbound = SubscriptionResponseApplicationFee$Outbound;
}

export function subscriptionResponseApplicationFeeToJSON(
  subscriptionResponseApplicationFee: SubscriptionResponseApplicationFee,
): string {
  return JSON.stringify(
    SubscriptionResponseApplicationFee$outboundSchema.parse(
      subscriptionResponseApplicationFee,
    ),
  );
}

export function subscriptionResponseApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionResponseApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SubscriptionResponseApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionResponseApplicationFee' from JSON`,
  );
}

/** @internal */
export const SubscriptionResponseLinks$inboundSchema: z.ZodType<
  SubscriptionResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  customer: z.nullable(UrlNullable$inboundSchema),
  mandate: z.nullable(UrlNullable$inboundSchema).optional(),
  profile: z.nullable(UrlNullable$inboundSchema),
  payments: z.nullable(UrlNullable$inboundSchema).optional(),
  documentation: Url$inboundSchema,
});

/** @internal */
export type SubscriptionResponseLinks$Outbound = {
  self: Url$Outbound;
  customer: UrlNullable$Outbound | null;
  mandate?: UrlNullable$Outbound | null | undefined;
  profile: UrlNullable$Outbound | null;
  payments?: UrlNullable$Outbound | null | undefined;
  documentation: Url$Outbound;
};

/** @internal */
export const SubscriptionResponseLinks$outboundSchema: z.ZodType<
  SubscriptionResponseLinks$Outbound,
  z.ZodTypeDef,
  SubscriptionResponseLinks
> = z.object({
  self: Url$outboundSchema,
  customer: z.nullable(UrlNullable$outboundSchema),
  mandate: z.nullable(UrlNullable$outboundSchema).optional(),
  profile: z.nullable(UrlNullable$outboundSchema),
  payments: z.nullable(UrlNullable$outboundSchema).optional(),
  documentation: Url$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionResponseLinks$ {
  /** @deprecated use `SubscriptionResponseLinks$inboundSchema` instead. */
  export const inboundSchema = SubscriptionResponseLinks$inboundSchema;
  /** @deprecated use `SubscriptionResponseLinks$outboundSchema` instead. */
  export const outboundSchema = SubscriptionResponseLinks$outboundSchema;
  /** @deprecated use `SubscriptionResponseLinks$Outbound` instead. */
  export type Outbound = SubscriptionResponseLinks$Outbound;
}

export function subscriptionResponseLinksToJSON(
  subscriptionResponseLinks: SubscriptionResponseLinks,
): string {
  return JSON.stringify(
    SubscriptionResponseLinks$outboundSchema.parse(subscriptionResponseLinks),
  );
}

export function subscriptionResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionResponseLinks' from JSON`,
  );
}

/** @internal */
export const SubscriptionResponse$inboundSchema: z.ZodType<
  SubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$inboundSchema.optional(),
  status: SubscriptionStatus$inboundSchema.optional(),
  amount: Amount$inboundSchema.optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.nullable(z.number().int()).optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(SubscriptionMethodResponse$inboundSchema).optional(),
  applicationFee: z.lazy(() => SubscriptionResponseApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => SubscriptionResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type SubscriptionResponse$Outbound = {
  resource?: string | undefined;
  id?: string | undefined;
  mode?: string | undefined;
  status?: string | undefined;
  amount?: Amount$Outbound | undefined;
  times?: number | null | undefined;
  timesRemaining?: number | null | undefined;
  interval?: string | undefined;
  startDate?: string | undefined;
  nextPaymentDate?: string | null | undefined;
  description?: string | undefined;
  method?: string | null | undefined;
  applicationFee?: SubscriptionResponseApplicationFee$Outbound | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  createdAt?: string | undefined;
  canceledAt?: string | null | undefined;
  _links?: SubscriptionResponseLinks$Outbound | undefined;
};

/** @internal */
export const SubscriptionResponse$outboundSchema: z.ZodType<
  SubscriptionResponse$Outbound,
  z.ZodTypeDef,
  SubscriptionResponse
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$outboundSchema.optional(),
  status: SubscriptionStatus$outboundSchema.optional(),
  amount: Amount$outboundSchema.optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.nullable(z.number().int()).optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(SubscriptionMethodResponse$outboundSchema).optional(),
  applicationFee: z.lazy(() =>
    SubscriptionResponseApplicationFee$outboundSchema
  ).optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => SubscriptionResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionResponse$ {
  /** @deprecated use `SubscriptionResponse$inboundSchema` instead. */
  export const inboundSchema = SubscriptionResponse$inboundSchema;
  /** @deprecated use `SubscriptionResponse$outboundSchema` instead. */
  export const outboundSchema = SubscriptionResponse$outboundSchema;
  /** @deprecated use `SubscriptionResponse$Outbound` instead. */
  export type Outbound = SubscriptionResponse$Outbound;
}

export function subscriptionResponseToJSON(
  subscriptionResponse: SubscriptionResponse,
): string {
  return JSON.stringify(
    SubscriptionResponse$outboundSchema.parse(subscriptionResponse),
  );
}

export function subscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionResponse' from JSON`,
  );
}
