/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SalesInvoiceDiscountResponse,
  SalesInvoiceDiscountResponse$inboundSchema,
  SalesInvoiceDiscountResponse$Outbound,
  SalesInvoiceDiscountResponse$outboundSchema,
} from "./salesinvoicediscountresponse.js";
import {
  SalesInvoiceEmailDetails,
  SalesInvoiceEmailDetails$inboundSchema,
  SalesInvoiceEmailDetails$Outbound,
  SalesInvoiceEmailDetails$outboundSchema,
} from "./salesinvoiceemaildetails.js";
import {
  SalesInvoiceLineItemResponse,
  SalesInvoiceLineItemResponse$inboundSchema,
  SalesInvoiceLineItemResponse$Outbound,
  SalesInvoiceLineItemResponse$outboundSchema,
} from "./salesinvoicelineitemresponse.js";
import {
  SalesInvoicePaymentDetailsResponse,
  SalesInvoicePaymentDetailsResponse$inboundSchema,
  SalesInvoicePaymentDetailsResponse$Outbound,
  SalesInvoicePaymentDetailsResponse$outboundSchema,
} from "./salesinvoicepaymentdetailsresponse.js";
import {
  SalesInvoicePaymentTermResponse,
  SalesInvoicePaymentTermResponse$inboundSchema,
  SalesInvoicePaymentTermResponse$outboundSchema,
} from "./salesinvoicepaymenttermresponse.js";
import {
  SalesInvoiceRecipientResponse,
  SalesInvoiceRecipientResponse$inboundSchema,
  SalesInvoiceRecipientResponse$Outbound,
  SalesInvoiceRecipientResponse$outboundSchema,
} from "./salesinvoicerecipientresponse.js";
import {
  SalesInvoiceStatusResponse,
  SalesInvoiceStatusResponse$inboundSchema,
  SalesInvoiceStatusResponse$outboundSchema,
} from "./salesinvoicestatusresponse.js";
import {
  SalesInvoiceVatModeResponse,
  SalesInvoiceVatModeResponse$inboundSchema,
  SalesInvoiceVatModeResponse$outboundSchema,
} from "./salesinvoicevatmoderesponse.js";
import {
  SalesInvoiceVatSchemeResponse,
  SalesInvoiceVatSchemeResponse$inboundSchema,
  SalesInvoiceVatSchemeResponse$outboundSchema,
} from "./salesinvoicevatschemeresponse.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type EntitySalesInvoiceResponseMetadata = {};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntitySalesInvoiceResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  invoicePayment?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  pdfLink?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  next?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  previous?: Url | undefined;
};

export type EntitySalesInvoiceResponse = {
  /**
   * Indicates the response contains a sales invoice object. Will always contain the string `sales-invoice` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  id?: string | undefined;
  /**
   * When issued, an invoice number will be set for the sales invoice.
   */
  invoiceNumber?: string | null | undefined;
  /**
   * The status for the invoice to end up in.
   *
   * @remarks
   *
   * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
   * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
   * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
   *
   * A status value that cannot be set but can be returned is `canceled`, for invoices which were
   * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
   *
   * Dependent parameters:
   *   - `paymentDetails` is required if invoice should be set directly to `paid`
   *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
   *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
   */
  status?: SalesInvoiceStatusResponse | undefined;
  /**
   * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
   */
  vatScheme?: SalesInvoiceVatSchemeResponse | undefined;
  /**
   * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
   *
   * @remarks
   * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
   */
  vatMode?: SalesInvoiceVatModeResponse | undefined;
  /**
   * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
   */
  memo?: string | null | undefined;
  /**
   * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: EntitySalesInvoiceResponseMetadata | null | undefined;
  /**
   * The payment term to be set on the invoice.
   */
  paymentTerm?: SalesInvoicePaymentTermResponse | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetailsResponse | null | undefined;
  emailDetails?: SalesInvoiceEmailDetails | null | undefined;
  /**
   * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
   *
   * @remarks
   * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  customerId?: string | undefined;
  /**
   * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
   *
   * @remarks
   * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  mandateId?: string | undefined;
  /**
   * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
   *
   * @remarks
   * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
   * is not required to send a first invoice to a recipient.
   */
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse | null | undefined;
  /**
   * Provide the line items for the invoice. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the invoice.
   */
  lines?: Array<SalesInvoiceLineItemResponse> | null | undefined;
  discount?: SalesInvoiceDiscountResponse | null | undefined;
  /**
   * This indicates whether the invoice is an e-invoice. The default value is `false` and can't be changed
   *
   * @remarks
   * after the invoice has been issued.
   *
   * When `emailDetails` is provided, an additional email is sent to the recipient.
   */
  isEInvoice?: boolean | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountDue?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  subtotalAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalVatAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountedSubtotalAmount?: Amount | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  issuedAt?: string | null | undefined;
  /**
   * If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  paidAt?: string | null | undefined;
  /**
   * If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  dueAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: EntitySalesInvoiceResponseLinks | undefined;
};

/** @internal */
export const EntitySalesInvoiceResponseMetadata$inboundSchema: z.ZodType<
  EntitySalesInvoiceResponseMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type EntitySalesInvoiceResponseMetadata$Outbound = {};

/** @internal */
export const EntitySalesInvoiceResponseMetadata$outboundSchema: z.ZodType<
  EntitySalesInvoiceResponseMetadata$Outbound,
  z.ZodTypeDef,
  EntitySalesInvoiceResponseMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceResponseMetadata$ {
  /** @deprecated use `EntitySalesInvoiceResponseMetadata$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceResponseMetadata$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponseMetadata$outboundSchema` instead. */
  export const outboundSchema =
    EntitySalesInvoiceResponseMetadata$outboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponseMetadata$Outbound` instead. */
  export type Outbound = EntitySalesInvoiceResponseMetadata$Outbound;
}

export function entitySalesInvoiceResponseMetadataToJSON(
  entitySalesInvoiceResponseMetadata: EntitySalesInvoiceResponseMetadata,
): string {
  return JSON.stringify(
    EntitySalesInvoiceResponseMetadata$outboundSchema.parse(
      entitySalesInvoiceResponseMetadata,
    ),
  );
}

export function entitySalesInvoiceResponseMetadataFromJSON(
  jsonString: string,
): SafeParseResult<EntitySalesInvoiceResponseMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EntitySalesInvoiceResponseMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySalesInvoiceResponseMetadata' from JSON`,
  );
}

/** @internal */
export const EntitySalesInvoiceResponseLinks$inboundSchema: z.ZodType<
  EntitySalesInvoiceResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  invoicePayment: Url$inboundSchema.optional(),
  pdfLink: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
  next: Url$inboundSchema.optional(),
  previous: Url$inboundSchema.optional(),
});

/** @internal */
export type EntitySalesInvoiceResponseLinks$Outbound = {
  self?: Url$Outbound | undefined;
  invoicePayment?: Url$Outbound | undefined;
  pdfLink?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
  next?: Url$Outbound | undefined;
  previous?: Url$Outbound | undefined;
};

/** @internal */
export const EntitySalesInvoiceResponseLinks$outboundSchema: z.ZodType<
  EntitySalesInvoiceResponseLinks$Outbound,
  z.ZodTypeDef,
  EntitySalesInvoiceResponseLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  invoicePayment: Url$outboundSchema.optional(),
  pdfLink: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
  next: Url$outboundSchema.optional(),
  previous: Url$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceResponseLinks$ {
  /** @deprecated use `EntitySalesInvoiceResponseLinks$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceResponseLinks$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponseLinks$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceResponseLinks$outboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponseLinks$Outbound` instead. */
  export type Outbound = EntitySalesInvoiceResponseLinks$Outbound;
}

export function entitySalesInvoiceResponseLinksToJSON(
  entitySalesInvoiceResponseLinks: EntitySalesInvoiceResponseLinks,
): string {
  return JSON.stringify(
    EntitySalesInvoiceResponseLinks$outboundSchema.parse(
      entitySalesInvoiceResponseLinks,
    ),
  );
}

export function entitySalesInvoiceResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntitySalesInvoiceResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySalesInvoiceResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySalesInvoiceResponseLinks' from JSON`,
  );
}

/** @internal */
export const EntitySalesInvoiceResponse$inboundSchema: z.ZodType<
  EntitySalesInvoiceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$inboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$inboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$inboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.lazy(() => EntitySalesInvoiceResponseMetadata$inboundSchema),
  ).optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$inboundSchema)
    .optional(),
  paymentDetails: z.nullable(SalesInvoicePaymentDetailsResponse$inboundSchema)
    .optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$inboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$inboundSchema).optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$inboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$inboundSchema).optional(),
  isEInvoice: z.boolean().optional(),
  amountDue: Amount$inboundSchema.optional(),
  subtotalAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema.optional(),
  totalVatAmount: Amount$inboundSchema.optional(),
  discountedSubtotalAmount: Amount$inboundSchema.optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => EntitySalesInvoiceResponseLinks$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type EntitySalesInvoiceResponse$Outbound = {
  resource?: string | undefined;
  id?: string | undefined;
  invoiceNumber?: string | null | undefined;
  status?: string | undefined;
  vatScheme?: string | undefined;
  vatMode?: string | undefined;
  memo?: string | null | undefined;
  metadata?: EntitySalesInvoiceResponseMetadata$Outbound | null | undefined;
  paymentTerm?: string | null | undefined;
  paymentDetails?:
    | SalesInvoicePaymentDetailsResponse$Outbound
    | null
    | undefined;
  emailDetails?: SalesInvoiceEmailDetails$Outbound | null | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse$Outbound | null | undefined;
  lines?: Array<SalesInvoiceLineItemResponse$Outbound> | null | undefined;
  discount?: SalesInvoiceDiscountResponse$Outbound | null | undefined;
  isEInvoice?: boolean | undefined;
  amountDue?: Amount$Outbound | undefined;
  subtotalAmount?: Amount$Outbound | undefined;
  totalAmount?: Amount$Outbound | undefined;
  totalVatAmount?: Amount$Outbound | undefined;
  discountedSubtotalAmount?: Amount$Outbound | undefined;
  createdAt?: string | undefined;
  issuedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  dueAt?: string | null | undefined;
  _links?: EntitySalesInvoiceResponseLinks$Outbound | undefined;
};

/** @internal */
export const EntitySalesInvoiceResponse$outboundSchema: z.ZodType<
  EntitySalesInvoiceResponse$Outbound,
  z.ZodTypeDef,
  EntitySalesInvoiceResponse
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$outboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$outboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$outboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.lazy(() => EntitySalesInvoiceResponseMetadata$outboundSchema),
  ).optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$outboundSchema)
    .optional(),
  paymentDetails: z.nullable(SalesInvoicePaymentDetailsResponse$outboundSchema)
    .optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$outboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$outboundSchema)
    .optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$outboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$outboundSchema).optional(),
  isEInvoice: z.boolean().optional(),
  amountDue: Amount$outboundSchema.optional(),
  subtotalAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema.optional(),
  totalVatAmount: Amount$outboundSchema.optional(),
  discountedSubtotalAmount: Amount$outboundSchema.optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => EntitySalesInvoiceResponseLinks$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceResponse$ {
  /** @deprecated use `EntitySalesInvoiceResponse$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceResponse$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponse$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceResponse$outboundSchema;
  /** @deprecated use `EntitySalesInvoiceResponse$Outbound` instead. */
  export type Outbound = EntitySalesInvoiceResponse$Outbound;
}

export function entitySalesInvoiceResponseToJSON(
  entitySalesInvoiceResponse: EntitySalesInvoiceResponse,
): string {
  return JSON.stringify(
    EntitySalesInvoiceResponse$outboundSchema.parse(entitySalesInvoiceResponse),
  );
}

export function entitySalesInvoiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<EntitySalesInvoiceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySalesInvoiceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySalesInvoiceResponse' from JSON`,
  );
}
