/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  PaymentMethod,
  PaymentMethod$inboundSchema,
  PaymentMethod$outboundSchema,
} from "./paymentmethod.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";
import {
  UrlNullable,
  UrlNullable$inboundSchema,
  UrlNullable$Outbound,
  UrlNullable$outboundSchema,
} from "./urlnullable.js";

/**
 * The status of the settlement.
 */
export const ListEntitySettlementStatus = {
  Open: "open",
  Pending: "pending",
  Paidout: "paidout",
  Failed: "failed",
} as const;
/**
 * The status of the settlement.
 */
export type ListEntitySettlementStatus = OpenEnum<
  typeof ListEntitySettlementStatus
>;

/**
 * The total amount of the settlement.
 */
export type ListEntitySettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The service rates, further divided into `fixed` and `percentage` costs.
 */
export type ListEntitySettlementRate = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  fixed?: Amount | undefined;
  percentage?: string | undefined;
};

export type ListEntitySettlementCost = {
  /**
   * A description of the cost subtotal
   */
  description: string;
  /**
   * The payment method, if applicable
   */
  method: PaymentMethod | null;
  /**
   * The number of fees
   */
  count: number;
  /**
   * The service rates, further divided into `fixed` and `percentage` costs.
   */
  rate: ListEntitySettlementRate;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountNet: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountVat: AmountNullable | null;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountGross: Amount;
};

export type ListEntitySettlementRevenue = {
  /**
   * A description of the revenue subtotal
   */
  description: string;
  /**
   * The payment method, if applicable
   */
  method: PaymentMethod | null;
  /**
   * The number of payments
   */
  count: number;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountNet: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountVat: AmountNullable | null;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountGross: Amount;
};

export type ListEntitySettlementPeriods = {
  /**
   * An array of cost objects, describing the fees withheld for each payment method during this period.
   */
  costs?: Array<ListEntitySettlementCost> | undefined;
  /**
   * An array of revenue objects containing the total revenue for each payment method during this period.
   */
  revenue?: Array<ListEntitySettlementRevenue> | undefined;
  invoiceId?: string | undefined;
  /**
   * The invoice reference, if the invoice has been created already.
   */
  invoiceReference?: string | null | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListEntitySettlementLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payments?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  captures?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  refunds?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  chargebacks?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  invoice?: UrlNullable | null | undefined;
};

export type ListEntitySettlement = {
  /**
   * Indicates the response contains a settlement object. Will always contain the string `settlement` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this settlement.
   */
  id: string;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The settlement's bank reference, as found in your Mollie account and on your bank statement.
   */
  reference?: string | null | undefined;
  /**
   * The date on which the settlement was settled, in ISO 8601 format.
   *
   * @remarks
   *
   * For an [open settlement](get-open-settlement) or for the [next settlement](get-next-settlement), no settlement
   * date is available.
   */
  settledAt?: string | null | undefined;
  status: ListEntitySettlementStatus;
  /**
   * The total amount of the settlement.
   */
  amount: ListEntitySettlementAmount;
  /**
   * The balance token that the settlement was settled to.
   */
  balanceId: string;
  /**
   * The ID of the oldest invoice created for all the periods, if the invoice has been created yet.
   */
  invoiceId?: string | null | undefined;
  /**
   * For bookkeeping purposes, the settlement includes an overview of transactions included in the settlement. These
   *
   * @remarks
   * transactions are grouped into 'period' objects â€” one for each calendar month.
   *
   * For example, if a settlement includes funds from 15 April until 4 May, it will include two period objects. One for
   * all transactions processed between 15 April and 30 April, and one for all transactions between 1 May and 4 May.
   *
   * Period objects are grouped by year, and then by month. So in the above example, the full `periods` collection will
   * look as follows: `{"2024": {"04": {...}, "05": {...}}}`. The year and month in this documentation are referred as `<year>` and `<month>`.
   *
   * The example response should give a good idea of what this looks like in practise.
   */
  periods?:
    | { [k: string]: { [k: string]: ListEntitySettlementPeriods } }
    | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListEntitySettlementLinks;
};

/** @internal */
export const ListEntitySettlementStatus$inboundSchema: z.ZodType<
  ListEntitySettlementStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ListEntitySettlementStatus);
/** @internal */
export const ListEntitySettlementStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ListEntitySettlementStatus
> = openEnums.outboundSchema(ListEntitySettlementStatus);

/** @internal */
export const ListEntitySettlementAmount$inboundSchema: z.ZodType<
  ListEntitySettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListEntitySettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListEntitySettlementAmount$outboundSchema: z.ZodType<
  ListEntitySettlementAmount$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listEntitySettlementAmountToJSON(
  listEntitySettlementAmount: ListEntitySettlementAmount,
): string {
  return JSON.stringify(
    ListEntitySettlementAmount$outboundSchema.parse(listEntitySettlementAmount),
  );
}
export function listEntitySettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlementRate$inboundSchema: z.ZodType<
  ListEntitySettlementRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  fixed: Amount$inboundSchema.optional(),
  percentage: z.string().optional(),
});
/** @internal */
export type ListEntitySettlementRate$Outbound = {
  fixed?: Amount$Outbound | undefined;
  percentage?: string | undefined;
};

/** @internal */
export const ListEntitySettlementRate$outboundSchema: z.ZodType<
  ListEntitySettlementRate$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementRate
> = z.object({
  fixed: Amount$outboundSchema.optional(),
  percentage: z.string().optional(),
});

export function listEntitySettlementRateToJSON(
  listEntitySettlementRate: ListEntitySettlementRate,
): string {
  return JSON.stringify(
    ListEntitySettlementRate$outboundSchema.parse(listEntitySettlementRate),
  );
}
export function listEntitySettlementRateFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementRate' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlementCost$inboundSchema: z.ZodType<
  ListEntitySettlementCost,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$inboundSchema),
  count: z.number().int(),
  rate: z.lazy(() => ListEntitySettlementRate$inboundSchema),
  amountNet: Amount$inboundSchema,
  amountVat: z.nullable(AmountNullable$inboundSchema),
  amountGross: Amount$inboundSchema,
});
/** @internal */
export type ListEntitySettlementCost$Outbound = {
  description: string;
  method: string | null;
  count: number;
  rate: ListEntitySettlementRate$Outbound;
  amountNet: Amount$Outbound;
  amountVat: AmountNullable$Outbound | null;
  amountGross: Amount$Outbound;
};

/** @internal */
export const ListEntitySettlementCost$outboundSchema: z.ZodType<
  ListEntitySettlementCost$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementCost
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$outboundSchema),
  count: z.number().int(),
  rate: z.lazy(() => ListEntitySettlementRate$outboundSchema),
  amountNet: Amount$outboundSchema,
  amountVat: z.nullable(AmountNullable$outboundSchema),
  amountGross: Amount$outboundSchema,
});

export function listEntitySettlementCostToJSON(
  listEntitySettlementCost: ListEntitySettlementCost,
): string {
  return JSON.stringify(
    ListEntitySettlementCost$outboundSchema.parse(listEntitySettlementCost),
  );
}
export function listEntitySettlementCostFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementCost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementCost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementCost' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlementRevenue$inboundSchema: z.ZodType<
  ListEntitySettlementRevenue,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$inboundSchema),
  count: z.number().int(),
  amountNet: Amount$inboundSchema,
  amountVat: z.nullable(AmountNullable$inboundSchema),
  amountGross: Amount$inboundSchema,
});
/** @internal */
export type ListEntitySettlementRevenue$Outbound = {
  description: string;
  method: string | null;
  count: number;
  amountNet: Amount$Outbound;
  amountVat: AmountNullable$Outbound | null;
  amountGross: Amount$Outbound;
};

/** @internal */
export const ListEntitySettlementRevenue$outboundSchema: z.ZodType<
  ListEntitySettlementRevenue$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementRevenue
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$outboundSchema),
  count: z.number().int(),
  amountNet: Amount$outboundSchema,
  amountVat: z.nullable(AmountNullable$outboundSchema),
  amountGross: Amount$outboundSchema,
});

export function listEntitySettlementRevenueToJSON(
  listEntitySettlementRevenue: ListEntitySettlementRevenue,
): string {
  return JSON.stringify(
    ListEntitySettlementRevenue$outboundSchema.parse(
      listEntitySettlementRevenue,
    ),
  );
}
export function listEntitySettlementRevenueFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementRevenue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementRevenue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementRevenue' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlementPeriods$inboundSchema: z.ZodType<
  ListEntitySettlementPeriods,
  z.ZodTypeDef,
  unknown
> = z.object({
  costs: z.array(z.lazy(() => ListEntitySettlementCost$inboundSchema))
    .optional(),
  revenue: z.array(z.lazy(() => ListEntitySettlementRevenue$inboundSchema))
    .optional(),
  invoiceId: z.string().optional(),
  invoiceReference: z.nullable(z.string()).optional(),
});
/** @internal */
export type ListEntitySettlementPeriods$Outbound = {
  costs?: Array<ListEntitySettlementCost$Outbound> | undefined;
  revenue?: Array<ListEntitySettlementRevenue$Outbound> | undefined;
  invoiceId?: string | undefined;
  invoiceReference?: string | null | undefined;
};

/** @internal */
export const ListEntitySettlementPeriods$outboundSchema: z.ZodType<
  ListEntitySettlementPeriods$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementPeriods
> = z.object({
  costs: z.array(z.lazy(() => ListEntitySettlementCost$outboundSchema))
    .optional(),
  revenue: z.array(z.lazy(() => ListEntitySettlementRevenue$outboundSchema))
    .optional(),
  invoiceId: z.string().optional(),
  invoiceReference: z.nullable(z.string()).optional(),
});

export function listEntitySettlementPeriodsToJSON(
  listEntitySettlementPeriods: ListEntitySettlementPeriods,
): string {
  return JSON.stringify(
    ListEntitySettlementPeriods$outboundSchema.parse(
      listEntitySettlementPeriods,
    ),
  );
}
export function listEntitySettlementPeriodsFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementPeriods, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementPeriods$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementPeriods' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlementLinks$inboundSchema: z.ZodType<
  ListEntitySettlementLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  payments: Url$inboundSchema.optional(),
  captures: Url$inboundSchema.optional(),
  refunds: Url$inboundSchema.optional(),
  chargebacks: Url$inboundSchema.optional(),
  invoice: z.nullable(UrlNullable$inboundSchema).optional(),
});
/** @internal */
export type ListEntitySettlementLinks$Outbound = {
  self: Url$Outbound;
  payments?: Url$Outbound | undefined;
  captures?: Url$Outbound | undefined;
  refunds?: Url$Outbound | undefined;
  chargebacks?: Url$Outbound | undefined;
  invoice?: UrlNullable$Outbound | null | undefined;
};

/** @internal */
export const ListEntitySettlementLinks$outboundSchema: z.ZodType<
  ListEntitySettlementLinks$Outbound,
  z.ZodTypeDef,
  ListEntitySettlementLinks
> = z.object({
  self: Url$outboundSchema,
  payments: Url$outboundSchema.optional(),
  captures: Url$outboundSchema.optional(),
  refunds: Url$outboundSchema.optional(),
  chargebacks: Url$outboundSchema.optional(),
  invoice: z.nullable(UrlNullable$outboundSchema).optional(),
});

export function listEntitySettlementLinksToJSON(
  listEntitySettlementLinks: ListEntitySettlementLinks,
): string {
  return JSON.stringify(
    ListEntitySettlementLinks$outboundSchema.parse(listEntitySettlementLinks),
  );
}
export function listEntitySettlementLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlementLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlementLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlementLinks' from JSON`,
  );
}

/** @internal */
export const ListEntitySettlement$inboundSchema: z.ZodType<
  ListEntitySettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  createdAt: z.string().optional(),
  reference: z.nullable(z.string()).optional(),
  settledAt: z.nullable(z.string()).optional(),
  status: ListEntitySettlementStatus$inboundSchema,
  amount: z.lazy(() => ListEntitySettlementAmount$inboundSchema),
  balanceId: z.string(),
  invoiceId: z.nullable(z.string()).optional(),
  periods: z.record(
    z.record(z.lazy(() => ListEntitySettlementPeriods$inboundSchema)),
  ).optional(),
  _links: z.lazy(() => ListEntitySettlementLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListEntitySettlement$Outbound = {
  resource: string;
  id: string;
  createdAt?: string | undefined;
  reference?: string | null | undefined;
  settledAt?: string | null | undefined;
  status: string;
  amount: ListEntitySettlementAmount$Outbound;
  balanceId: string;
  invoiceId?: string | null | undefined;
  periods?: {
    [k: string]: { [k: string]: ListEntitySettlementPeriods$Outbound };
  } | undefined;
  _links: ListEntitySettlementLinks$Outbound;
};

/** @internal */
export const ListEntitySettlement$outboundSchema: z.ZodType<
  ListEntitySettlement$Outbound,
  z.ZodTypeDef,
  ListEntitySettlement
> = z.object({
  resource: z.string(),
  id: z.string(),
  createdAt: z.string().optional(),
  reference: z.nullable(z.string()).optional(),
  settledAt: z.nullable(z.string()).optional(),
  status: ListEntitySettlementStatus$outboundSchema,
  amount: z.lazy(() => ListEntitySettlementAmount$outboundSchema),
  balanceId: z.string(),
  invoiceId: z.nullable(z.string()).optional(),
  periods: z.record(
    z.record(z.lazy(() => ListEntitySettlementPeriods$outboundSchema)),
  ).optional(),
  links: z.lazy(() => ListEntitySettlementLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listEntitySettlementToJSON(
  listEntitySettlement: ListEntitySettlement,
): string {
  return JSON.stringify(
    ListEntitySettlement$outboundSchema.parse(listEntitySettlement),
  );
}
export function listEntitySettlementFromJSON(
  jsonString: string,
): SafeParseResult<ListEntitySettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntitySettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntitySettlement' from JSON`,
  );
}
