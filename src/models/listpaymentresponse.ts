/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { RFCDate } from "../types/rfcdate.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import {
  CaptureModeResponse,
  CaptureModeResponse$inboundSchema,
  CaptureModeResponse$outboundSchema,
} from "./capturemoderesponse.js";
import {
  EntityPaymentRouteResponse,
  EntityPaymentRouteResponse$inboundSchema,
  EntityPaymentRouteResponse$Outbound,
  EntityPaymentRouteResponse$outboundSchema,
} from "./entitypaymentrouteresponse.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LineCategoriesResponse,
  LineCategoriesResponse$inboundSchema,
  LineCategoriesResponse$outboundSchema,
} from "./linecategoriesresponse.js";
import {
  LocaleResponse,
  LocaleResponse$inboundSchema,
  LocaleResponse$outboundSchema,
} from "./localeresponse.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  MethodResponse,
  MethodResponse$inboundSchema,
  MethodResponse$outboundSchema,
} from "./methodresponse.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  PaymentAddress,
  PaymentAddress$inboundSchema,
  PaymentAddress$Outbound,
  PaymentAddress$outboundSchema,
} from "./paymentaddress.js";
import {
  PaymentDetailsCardAuditionResponse,
  PaymentDetailsCardAuditionResponse$inboundSchema,
  PaymentDetailsCardAuditionResponse$outboundSchema,
} from "./paymentdetailscardauditionresponse.js";
import {
  PaymentDetailsCardFundingResponse,
  PaymentDetailsCardFundingResponse$inboundSchema,
  PaymentDetailsCardFundingResponse$outboundSchema,
} from "./paymentdetailscardfundingresponse.js";
import {
  PaymentDetailsCardLabelResponse,
  PaymentDetailsCardLabelResponse$inboundSchema,
  PaymentDetailsCardLabelResponse$outboundSchema,
} from "./paymentdetailscardlabelresponse.js";
import {
  PaymentDetailsCardSecurityResponse,
  PaymentDetailsCardSecurityResponse$inboundSchema,
  PaymentDetailsCardSecurityResponse$outboundSchema,
} from "./paymentdetailscardsecurityresponse.js";
import {
  PaymentDetailsFailureReasonResponse,
  PaymentDetailsFailureReasonResponse$inboundSchema,
  PaymentDetailsFailureReasonResponse$outboundSchema,
} from "./paymentdetailsfailurereasonresponse.js";
import {
  PaymentDetailsFeeRegionResponse,
  PaymentDetailsFeeRegionResponse$inboundSchema,
  PaymentDetailsFeeRegionResponse$outboundSchema,
} from "./paymentdetailsfeeregionresponse.js";
import {
  PaymentDetailsReceiptCardReadMethodResponse,
  PaymentDetailsReceiptCardReadMethodResponse$inboundSchema,
  PaymentDetailsReceiptCardReadMethodResponse$outboundSchema,
} from "./paymentdetailsreceiptcardreadmethodresponse.js";
import {
  PaymentDetailsReceiptCardVerificationMethodResponse,
  PaymentDetailsReceiptCardVerificationMethodResponse$inboundSchema,
  PaymentDetailsReceiptCardVerificationMethodResponse$outboundSchema,
} from "./paymentdetailsreceiptcardverificationmethodresponse.js";
import {
  PaymentDetailsSellerProtectionResponse,
  PaymentDetailsSellerProtectionResponse$inboundSchema,
  PaymentDetailsSellerProtectionResponse$outboundSchema,
} from "./paymentdetailssellerprotectionresponse.js";
import {
  PaymentDetailsWalletResponse,
  PaymentDetailsWalletResponse$inboundSchema,
  PaymentDetailsWalletResponse$outboundSchema,
} from "./paymentdetailswalletresponse.js";
import {
  PaymentLineTypeResponse,
  PaymentLineTypeResponse$inboundSchema,
  PaymentLineTypeResponse$outboundSchema,
} from "./paymentlinetyperesponse.js";
import {
  RecurringLineItem,
  RecurringLineItem$inboundSchema,
  RecurringLineItem$Outbound,
  RecurringLineItem$outboundSchema,
} from "./recurringlineitem.js";
import {
  SequenceTypeResponse,
  SequenceTypeResponse$inboundSchema,
  SequenceTypeResponse$outboundSchema,
} from "./sequencetyperesponse.js";
import {
  StatusReason,
  StatusReason$inboundSchema,
  StatusReason$Outbound,
  StatusReason$outboundSchema,
} from "./statusreason.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type ListPaymentResponseAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type ListPaymentResponseAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type ListPaymentResponseAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type ListPaymentResponseAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type ListPaymentResponseSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type ListPaymentResponseLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: PaymentLineTypeResponse | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  unitPrice: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount: Amount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  vatAmount?: Amount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
   */
  categories?: Array<LineCategoriesResponse> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  recurring?: RecurringLineItem | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `alma`, `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListPaymentResponseBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   *
   * @remarks
   *
   * Required for payment method `billie`.
   */
  organizationName?: any | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type ListPaymentResponseApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/handling-payment-status) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const ListPaymentResponseStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/handling-payment-status) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type ListPaymentResponseStatus = OpenEnum<
  typeof ListPaymentResponseStatus
>;

/**
 * The Point of sale receipt object.
 */
export type ListPaymentResponseReceipt = {
  /**
   * A unique code provided by the cardholder’s bank to confirm that the transaction was successfully approved.
   */
  authorizationCode?: string | null | undefined;
  /**
   * The unique number that identifies a specific payment application on a chip card.
   */
  applicationIdentifier?: string | null | undefined;
  /**
   * The method by which the card was read by the terminal.
   */
  cardReadMethod?:
    | PaymentDetailsReceiptCardReadMethodResponse
    | null
    | undefined;
  /**
   * The method used to verify the cardholder's identity.
   */
  cardVerificationMethod?:
    | PaymentDetailsReceiptCardVerificationMethodResponse
    | null
    | undefined;
};

/**
 * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
 *
 * @remarks
 * the QR code details will be available in this object.
 *
 * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
 * Bancontact QR payments can be completed by the customer using the Bancontact app.
 */
export type ListPaymentResponseQrCode = {
  /**
   * The height of the QR code image in pixels.
   */
  height?: number | undefined;
  /**
   * The width of the QR code image in pixels.
   */
  width?: number | undefined;
  /**
   * The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or
   *
   * @remarks
   * downloaded.
   */
  src?: string | undefined;
};

/**
 * An object containing payment details collected during the payment process. For example, details may include the
 *
 * @remarks
 * customer's card or bank details and a payment reference. For the full list of details, please refer to the
 * [method-specific parameters](extra-payment-parameters) guide.
 */
export type ListPaymentResponseDetails = {
  /**
   * The customer's name, if made available by the payment method. For card payments, refer to details.cardHolder.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's account reference.
   *
   * @remarks
   *
   * For banking-based payment methods — such as iDEAL — this is normally either an IBAN or a domestic bank account
   * number.
   *
   * For PayPal, the account reference is an email address.
   *
   * For card and Bancontact payments, refer to details.cardNumber.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank account, if applicable.
   */
  consumerBic?: string | null | undefined;
  /**
   * For wallet payment methods — such as Apple Pay and PayPal — the shipping address is often already known by the
   *
   * @remarks
   * wallet provider. In these cases the shipping address may be available as a payment detail.
   */
  shippingAddress?: { [k: string]: any } | null | undefined;
  /**
   * For bancontact, it will be the customer's masked card number. For cards, it will be the last 4-digit of the
   *
   * @remarks
   * PAN. For Point-of-sale, it will be the the last 4 digits of the customer's masked card number.
   */
  cardNumber?: string | null | undefined;
  /**
   * The name of the bank that the customer will need to make the bank transfer payment towards.
   */
  bankName?: string | undefined;
  /**
   * The bank account number the customer will need to make the bank transfer payment towards.
   */
  bankAccount?: string | undefined;
  /**
   * The BIC of the bank the customer will need to make the bank transfer payment towards.
   */
  bankBic?: string | undefined;
  /**
   * The Mollie-generated reference the customer needs to use when transfering the amount. Do not apply any
   *
   * @remarks
   * formatting here; show it to the customer as-is.
   */
  transferReference?: string | null | undefined;
  /**
   * A unique fingerprint for a specific card. Can be used to identify returning customers.
   *
   * @remarks
   *
   * In the case of Point-of-sale payments, it's a unique identifier assigned to a cardholder's payment account,
   * linking multiple transactions from wallets and physical card to a single account, also across payment methods
   * or when the card is reissued.
   */
  cardFingerprint?: string | null | undefined;
  /**
   * The customer's name as shown on their card.
   */
  cardHolder?: string | null | undefined;
  /**
   * The card's target audience, if known.
   */
  cardAudition?: PaymentDetailsCardAuditionResponse | null | undefined;
  /**
   * The card's label, if known.
   */
  cardLabel?: PaymentDetailsCardLabelResponse | null | undefined;
  /**
   * The ISO 3166-1 alpha-2 country code of the country the card was issued in.
   */
  cardCountryCode?: string | null | undefined;
  /**
   * The expiry date (MM/YY) of the card as displayed on the card.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card type.
   */
  cardFunding?: PaymentDetailsCardFundingResponse | null | undefined;
  /**
   * The level of security applied during card processing.
   */
  cardSecurity?: PaymentDetailsCardSecurityResponse | null | undefined;
  /**
   * The applicable card fee region.
   */
  feeRegion?: PaymentDetailsFeeRegionResponse | null | undefined;
  /**
   * The first 6 and last 4 digits of the card number.
   */
  cardMaskedNumber?: string | null | undefined;
  /**
   * The outcome of authentication attempted on transactions enforced by 3DS (ie valid only for oneoff and first).
   */
  card3dsEci?: string | null | undefined;
  /**
   * The first 6 digit of the card bank identification number.
   */
  cardBin?: string | null | undefined;
  /**
   * The issuer of the Card.
   */
  cardIssuer?: string | null | undefined;
  /**
   * A failure code to help understand why the payment failed.
   */
  failureReason?: PaymentDetailsFailureReasonResponse | null | undefined;
  /**
   * A human-friendly failure message that can be shown to the customer. The message is translated in accordance
   *
   * @remarks
   * with the payment's locale setting.
   */
  failureMessage?: string | null | undefined;
  /**
   * The wallet used when creating the payment.
   */
  wallet?: PaymentDetailsWalletResponse | null | undefined;
  /**
   * PayPal's reference for the payment.
   */
  paypalReference?: string | null | undefined;
  /**
   * ID of the customer's PayPal account.
   */
  paypalPayerId?: string | null | undefined;
  /**
   * Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
   *
   * @remarks
   * payments, and if the information is made available by PayPal.
   */
  sellerProtection?: PaymentDetailsSellerProtectionResponse | null | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  paypalFee?: AmountNullable | null | undefined;
  /**
   * The paysafecard customer reference either provided via the API or otherwise auto-generated by Mollie.
   */
  customerReference?: string | undefined;
  /**
   * The ID of the terminal device where the payment took place on.
   */
  terminalId?: string | undefined;
  /**
   * The first 6 digits & last 4 digits of the customer's masked card number.
   */
  maskedNumber?: string | null | undefined;
  /**
   * The Point of sale receipt object.
   */
  receipt?: ListPaymentResponseReceipt | undefined;
  /**
   * The creditor identifier indicates who is authorized to execute the payment. In this case, it is a
   *
   * @remarks
   * reference to Mollie.
   */
  creditorIdentifier?: string | null | undefined;
  /**
   * Estimated date the payment is debited from the customer's bank account, in YYYY-MM-DD format.
   */
  dueDate?: RFCDate | null | undefined;
  /**
   * Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment
   *
   * @remarks
   * has been signed.
   */
  signatureDate?: RFCDate | null | undefined;
  /**
   * The official reason why this payment has failed. A detailed description of each reason is available on the
   *
   * @remarks
   * website of the European Payments Council.
   */
  bankReasonCode?: string | null | undefined;
  /**
   * A human-friendly description of the failure reason.
   */
  bankReason?: string | null | undefined;
  /**
   * The end-to-end identifier you provided in the batch file.
   */
  endToEndIdentifier?: string | null | undefined;
  /**
   * The mandate reference you provided in the batch file.
   */
  mandateReference?: string | null | undefined;
  /**
   * The batch reference you provided in the batch file.
   */
  batchReference?: string | null | undefined;
  /**
   * The file reference you provided in the batch file.
   */
  fileReference?: string | null | undefined;
  /**
   * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
   *
   * @remarks
   * the QR code details will be available in this object.
   *
   * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
   * Bancontact QR payments can be completed by the customer using the Bancontact app.
   */
  qrCode?: ListPaymentResponseQrCode | undefined;
  /**
   * For payments with gift cards: the masked gift card number of the first gift card applied to the payment.
   */
  voucherNumber?: string | undefined;
  /**
   * An array of detail objects for each gift card that was used on this payment, if any.
   */
  giftcards?: Array<{ [k: string]: any }> | undefined;
  /**
   * For payments with vouchers: the brand name of the first voucher applied.
   */
  issuer?: string | undefined;
  /**
   * An array of detail objects for each voucher that was used on this payment, if any.
   */
  vouchers?: Array<{ [k: string]: any }> | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  remainderAmount?: Amount | undefined;
  /**
   * The payment method used to pay the remainder amount, after all gift cards or vouchers were applied.
   */
  remainderMethod?: string | undefined;
  /**
   * Optional include. The full payment method details of the remainder payment.
   */
  remainderDetails?: { [k: string]: any } | undefined;
  /**
   * Multibanco payment reference of the transaction
   */
  multibancoReference?: string | null | undefined;
  /**
   * Multibanco entity reference of the transaction
   */
  multibancoEntity?: string | null | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListPaymentResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  checkout?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mobileAppCheckout?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  changePaymentState?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  dashboard: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  refunds?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  chargebacks?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  captures?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  settlement?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mandate?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  subscription?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  order?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  terminal?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  status?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payOnline?: Url | undefined;
};

export type ListPaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: ListPaymentResponseAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: ListPaymentResponseAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: ListPaymentResponseAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: ListPaymentResponseAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: ListPaymentResponseSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListPaymentResponseLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `alma`, `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListPaymentResponseBillingAddress | undefined;
  shippingAddress?: PaymentAddress | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: LocaleResponse | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: MethodResponse | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CaptureModeResponse | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: ListPaymentResponseApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<EntityPaymentRouteResponse> | null | undefined;
  sequenceType: SequenceTypeResponse;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  customerId?: string | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  status: ListPaymentResponseStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: StatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: ListPaymentResponseDetails | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListPaymentResponseLinks;
};

/** @internal */
export const ListPaymentResponseAmountRefunded$inboundSchema: z.ZodType<
  ListPaymentResponseAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListPaymentResponseAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentResponseAmountRefunded$outboundSchema: z.ZodType<
  ListPaymentResponseAmountRefunded$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listPaymentResponseAmountRefundedToJSON(
  listPaymentResponseAmountRefunded: ListPaymentResponseAmountRefunded,
): string {
  return JSON.stringify(
    ListPaymentResponseAmountRefunded$outboundSchema.parse(
      listPaymentResponseAmountRefunded,
    ),
  );
}
export function listPaymentResponseAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseAmountRefunded' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseAmountRemaining$inboundSchema: z.ZodType<
  ListPaymentResponseAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListPaymentResponseAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentResponseAmountRemaining$outboundSchema: z.ZodType<
  ListPaymentResponseAmountRemaining$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listPaymentResponseAmountRemainingToJSON(
  listPaymentResponseAmountRemaining: ListPaymentResponseAmountRemaining,
): string {
  return JSON.stringify(
    ListPaymentResponseAmountRemaining$outboundSchema.parse(
      listPaymentResponseAmountRemaining,
    ),
  );
}
export function listPaymentResponseAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPaymentResponseAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseAmountRemaining' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseAmountCaptured$inboundSchema: z.ZodType<
  ListPaymentResponseAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListPaymentResponseAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentResponseAmountCaptured$outboundSchema: z.ZodType<
  ListPaymentResponseAmountCaptured$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listPaymentResponseAmountCapturedToJSON(
  listPaymentResponseAmountCaptured: ListPaymentResponseAmountCaptured,
): string {
  return JSON.stringify(
    ListPaymentResponseAmountCaptured$outboundSchema.parse(
      listPaymentResponseAmountCaptured,
    ),
  );
}
export function listPaymentResponseAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseAmountCaptured' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseAmountChargedBack$inboundSchema: z.ZodType<
  ListPaymentResponseAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListPaymentResponseAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentResponseAmountChargedBack$outboundSchema: z.ZodType<
  ListPaymentResponseAmountChargedBack$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listPaymentResponseAmountChargedBackToJSON(
  listPaymentResponseAmountChargedBack: ListPaymentResponseAmountChargedBack,
): string {
  return JSON.stringify(
    ListPaymentResponseAmountChargedBack$outboundSchema.parse(
      listPaymentResponseAmountChargedBack,
    ),
  );
}
export function listPaymentResponseAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPaymentResponseAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseSettlementAmount$inboundSchema: z.ZodType<
  ListPaymentResponseSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListPaymentResponseSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentResponseSettlementAmount$outboundSchema: z.ZodType<
  ListPaymentResponseSettlementAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listPaymentResponseSettlementAmountToJSON(
  listPaymentResponseSettlementAmount: ListPaymentResponseSettlementAmount,
): string {
  return JSON.stringify(
    ListPaymentResponseSettlementAmount$outboundSchema.parse(
      listPaymentResponseSettlementAmount,
    ),
  );
}
export function listPaymentResponseSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPaymentResponseSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseSettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseLine$inboundSchema: z.ZodType<
  ListPaymentResponseLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaymentLineTypeResponse$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$inboundSchema,
  discountAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$inboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategoriesResponse$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$inboundSchema.optional(),
});
/** @internal */
export type ListPaymentResponseLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: Amount$Outbound;
  discountAmount?: Amount$Outbound | undefined;
  totalAmount: Amount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: Amount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: RecurringLineItem$Outbound | undefined;
};

/** @internal */
export const ListPaymentResponseLine$outboundSchema: z.ZodType<
  ListPaymentResponseLine$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseLine
> = z.object({
  type: PaymentLineTypeResponse$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$outboundSchema,
  discountAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$outboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategoriesResponse$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$outboundSchema.optional(),
});

export function listPaymentResponseLineToJSON(
  listPaymentResponseLine: ListPaymentResponseLine,
): string {
  return JSON.stringify(
    ListPaymentResponseLine$outboundSchema.parse(listPaymentResponseLine),
  );
}
export function listPaymentResponseLineFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseLine' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseBillingAddress$inboundSchema: z.ZodType<
  ListPaymentResponseBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.any().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});
/** @internal */
export type ListPaymentResponseBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: any | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListPaymentResponseBillingAddress$outboundSchema: z.ZodType<
  ListPaymentResponseBillingAddress$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.any().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

export function listPaymentResponseBillingAddressToJSON(
  listPaymentResponseBillingAddress: ListPaymentResponseBillingAddress,
): string {
  return JSON.stringify(
    ListPaymentResponseBillingAddress$outboundSchema.parse(
      listPaymentResponseBillingAddress,
    ),
  );
}
export function listPaymentResponseBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseApplicationFee$inboundSchema: z.ZodType<
  ListPaymentResponseApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  description: z.string().optional(),
});
/** @internal */
export type ListPaymentResponseApplicationFee$Outbound = {
  amount?: Amount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ListPaymentResponseApplicationFee$outboundSchema: z.ZodType<
  ListPaymentResponseApplicationFee$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseApplicationFee
> = z.object({
  amount: Amount$outboundSchema.optional(),
  description: z.string().optional(),
});

export function listPaymentResponseApplicationFeeToJSON(
  listPaymentResponseApplicationFee: ListPaymentResponseApplicationFee,
): string {
  return JSON.stringify(
    ListPaymentResponseApplicationFee$outboundSchema.parse(
      listPaymentResponseApplicationFee,
    ),
  );
}
export function listPaymentResponseApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseStatus$inboundSchema: z.ZodType<
  ListPaymentResponseStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ListPaymentResponseStatus);
/** @internal */
export const ListPaymentResponseStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ListPaymentResponseStatus
> = openEnums.outboundSchema(ListPaymentResponseStatus);

/** @internal */
export const ListPaymentResponseReceipt$inboundSchema: z.ZodType<
  ListPaymentResponseReceipt,
  z.ZodTypeDef,
  unknown
> = z.object({
  authorizationCode: z.nullable(z.string()).optional(),
  applicationIdentifier: z.nullable(z.string()).optional(),
  cardReadMethod: z.nullable(
    PaymentDetailsReceiptCardReadMethodResponse$inboundSchema,
  ).optional(),
  cardVerificationMethod: z.nullable(
    PaymentDetailsReceiptCardVerificationMethodResponse$inboundSchema,
  ).optional(),
});
/** @internal */
export type ListPaymentResponseReceipt$Outbound = {
  authorizationCode?: string | null | undefined;
  applicationIdentifier?: string | null | undefined;
  cardReadMethod?: string | null | undefined;
  cardVerificationMethod?: string | null | undefined;
};

/** @internal */
export const ListPaymentResponseReceipt$outboundSchema: z.ZodType<
  ListPaymentResponseReceipt$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseReceipt
> = z.object({
  authorizationCode: z.nullable(z.string()).optional(),
  applicationIdentifier: z.nullable(z.string()).optional(),
  cardReadMethod: z.nullable(
    PaymentDetailsReceiptCardReadMethodResponse$outboundSchema,
  ).optional(),
  cardVerificationMethod: z.nullable(
    PaymentDetailsReceiptCardVerificationMethodResponse$outboundSchema,
  ).optional(),
});

export function listPaymentResponseReceiptToJSON(
  listPaymentResponseReceipt: ListPaymentResponseReceipt,
): string {
  return JSON.stringify(
    ListPaymentResponseReceipt$outboundSchema.parse(listPaymentResponseReceipt),
  );
}
export function listPaymentResponseReceiptFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseReceipt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseReceipt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseReceipt' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseQrCode$inboundSchema: z.ZodType<
  ListPaymentResponseQrCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  height: z.number().int().optional(),
  width: z.number().int().optional(),
  src: z.string().optional(),
});
/** @internal */
export type ListPaymentResponseQrCode$Outbound = {
  height?: number | undefined;
  width?: number | undefined;
  src?: string | undefined;
};

/** @internal */
export const ListPaymentResponseQrCode$outboundSchema: z.ZodType<
  ListPaymentResponseQrCode$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseQrCode
> = z.object({
  height: z.number().int().optional(),
  width: z.number().int().optional(),
  src: z.string().optional(),
});

export function listPaymentResponseQrCodeToJSON(
  listPaymentResponseQrCode: ListPaymentResponseQrCode,
): string {
  return JSON.stringify(
    ListPaymentResponseQrCode$outboundSchema.parse(listPaymentResponseQrCode),
  );
}
export function listPaymentResponseQrCodeFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseQrCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseQrCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseQrCode' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseDetails$inboundSchema: z.ZodType<
  ListPaymentResponseDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(PaymentDetailsCardAuditionResponse$inboundSchema)
    .optional(),
  cardLabel: z.nullable(PaymentDetailsCardLabelResponse$inboundSchema)
    .optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(PaymentDetailsCardFundingResponse$inboundSchema)
    .optional(),
  cardSecurity: z.nullable(PaymentDetailsCardSecurityResponse$inboundSchema)
    .optional(),
  feeRegion: z.nullable(PaymentDetailsFeeRegionResponse$inboundSchema)
    .optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(PaymentDetailsFailureReasonResponse$inboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(PaymentDetailsWalletResponse$inboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    PaymentDetailsSellerProtectionResponse$inboundSchema,
  ).optional(),
  paypalFee: z.nullable(AmountNullable$inboundSchema).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => ListPaymentResponseReceipt$inboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.string().transform(v => new RFCDate(v))).optional(),
  signatureDate: z.nullable(z.string().transform(v => new RFCDate(v)))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => ListPaymentResponseQrCode$inboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: Amount$inboundSchema.optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
  multibancoReference: z.nullable(z.string()).optional(),
  multibancoEntity: z.nullable(z.string()).optional(),
});
/** @internal */
export type ListPaymentResponseDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  shippingAddress?: { [k: string]: any } | null | undefined;
  cardNumber?: string | null | undefined;
  bankName?: string | undefined;
  bankAccount?: string | undefined;
  bankBic?: string | undefined;
  transferReference?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardAudition?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardCountryCode?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardFunding?: string | null | undefined;
  cardSecurity?: string | null | undefined;
  feeRegion?: string | null | undefined;
  cardMaskedNumber?: string | null | undefined;
  card3dsEci?: string | null | undefined;
  cardBin?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  failureReason?: string | null | undefined;
  failureMessage?: string | null | undefined;
  wallet?: string | null | undefined;
  paypalReference?: string | null | undefined;
  paypalPayerId?: string | null | undefined;
  sellerProtection?: string | null | undefined;
  paypalFee?: AmountNullable$Outbound | null | undefined;
  customerReference?: string | undefined;
  terminalId?: string | undefined;
  maskedNumber?: string | null | undefined;
  receipt?: ListPaymentResponseReceipt$Outbound | undefined;
  creditorIdentifier?: string | null | undefined;
  dueDate?: string | null | undefined;
  signatureDate?: string | null | undefined;
  bankReasonCode?: string | null | undefined;
  bankReason?: string | null | undefined;
  endToEndIdentifier?: string | null | undefined;
  mandateReference?: string | null | undefined;
  batchReference?: string | null | undefined;
  fileReference?: string | null | undefined;
  qrCode?: ListPaymentResponseQrCode$Outbound | undefined;
  voucherNumber?: string | undefined;
  giftcards?: Array<{ [k: string]: any }> | undefined;
  issuer?: string | undefined;
  vouchers?: Array<{ [k: string]: any }> | undefined;
  remainderAmount?: Amount$Outbound | undefined;
  remainderMethod?: string | undefined;
  remainderDetails?: { [k: string]: any } | undefined;
  multibancoReference?: string | null | undefined;
  multibancoEntity?: string | null | undefined;
};

/** @internal */
export const ListPaymentResponseDetails$outboundSchema: z.ZodType<
  ListPaymentResponseDetails$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(PaymentDetailsCardAuditionResponse$outboundSchema)
    .optional(),
  cardLabel: z.nullable(PaymentDetailsCardLabelResponse$outboundSchema)
    .optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(PaymentDetailsCardFundingResponse$outboundSchema)
    .optional(),
  cardSecurity: z.nullable(PaymentDetailsCardSecurityResponse$outboundSchema)
    .optional(),
  feeRegion: z.nullable(PaymentDetailsFeeRegionResponse$outboundSchema)
    .optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(PaymentDetailsFailureReasonResponse$outboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(PaymentDetailsWalletResponse$outboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    PaymentDetailsSellerProtectionResponse$outboundSchema,
  ).optional(),
  paypalFee: z.nullable(AmountNullable$outboundSchema).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => ListPaymentResponseReceipt$outboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  signatureDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => ListPaymentResponseQrCode$outboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: Amount$outboundSchema.optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
  multibancoReference: z.nullable(z.string()).optional(),
  multibancoEntity: z.nullable(z.string()).optional(),
});

export function listPaymentResponseDetailsToJSON(
  listPaymentResponseDetails: ListPaymentResponseDetails,
): string {
  return JSON.stringify(
    ListPaymentResponseDetails$outboundSchema.parse(listPaymentResponseDetails),
  );
}
export function listPaymentResponseDetailsFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseDetails' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponseLinks$inboundSchema: z.ZodType<
  ListPaymentResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  checkout: Url$inboundSchema.optional(),
  mobileAppCheckout: Url$inboundSchema.optional(),
  changePaymentState: Url$inboundSchema.optional(),
  dashboard: Url$inboundSchema,
  refunds: Url$inboundSchema.optional(),
  chargebacks: Url$inboundSchema.optional(),
  captures: Url$inboundSchema.optional(),
  settlement: Url$inboundSchema.optional(),
  customer: Url$inboundSchema.optional(),
  mandate: Url$inboundSchema.optional(),
  subscription: Url$inboundSchema.optional(),
  order: Url$inboundSchema.optional(),
  terminal: Url$inboundSchema.optional(),
  status: Url$inboundSchema.optional(),
  payOnline: Url$inboundSchema.optional(),
});
/** @internal */
export type ListPaymentResponseLinks$Outbound = {
  self: Url$Outbound;
  checkout?: Url$Outbound | undefined;
  mobileAppCheckout?: Url$Outbound | undefined;
  changePaymentState?: Url$Outbound | undefined;
  dashboard: Url$Outbound;
  refunds?: Url$Outbound | undefined;
  chargebacks?: Url$Outbound | undefined;
  captures?: Url$Outbound | undefined;
  settlement?: Url$Outbound | undefined;
  customer?: Url$Outbound | undefined;
  mandate?: Url$Outbound | undefined;
  subscription?: Url$Outbound | undefined;
  order?: Url$Outbound | undefined;
  terminal?: Url$Outbound | undefined;
  status?: Url$Outbound | undefined;
  payOnline?: Url$Outbound | undefined;
};

/** @internal */
export const ListPaymentResponseLinks$outboundSchema: z.ZodType<
  ListPaymentResponseLinks$Outbound,
  z.ZodTypeDef,
  ListPaymentResponseLinks
> = z.object({
  self: Url$outboundSchema,
  checkout: Url$outboundSchema.optional(),
  mobileAppCheckout: Url$outboundSchema.optional(),
  changePaymentState: Url$outboundSchema.optional(),
  dashboard: Url$outboundSchema,
  refunds: Url$outboundSchema.optional(),
  chargebacks: Url$outboundSchema.optional(),
  captures: Url$outboundSchema.optional(),
  settlement: Url$outboundSchema.optional(),
  customer: Url$outboundSchema.optional(),
  mandate: Url$outboundSchema.optional(),
  subscription: Url$outboundSchema.optional(),
  order: Url$outboundSchema.optional(),
  terminal: Url$outboundSchema.optional(),
  status: Url$outboundSchema.optional(),
  payOnline: Url$outboundSchema.optional(),
});

export function listPaymentResponseLinksToJSON(
  listPaymentResponseLinks: ListPaymentResponseLinks,
): string {
  return JSON.stringify(
    ListPaymentResponseLinks$outboundSchema.parse(listPaymentResponseLinks),
  );
}
export function listPaymentResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListPaymentResponse$inboundSchema: z.ZodType<
  ListPaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  description: z.string(),
  amount: Amount$inboundSchema,
  amountRefunded: z.lazy(() => ListPaymentResponseAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() =>
    ListPaymentResponseAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() => ListPaymentResponseAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() =>
    ListPaymentResponseAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListPaymentResponseSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListPaymentResponseLine$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() => ListPaymentResponseBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: PaymentAddress$inboundSchema.optional(),
  locale: z.nullable(LocaleResponse$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(MethodResponse$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  captureMode: z.nullable(CaptureModeResponse$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListPaymentResponseApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRouteResponse$inboundSchema))
    .optional(),
  sequenceType: SequenceTypeResponse$inboundSchema,
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.string().optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListPaymentResponseStatus$inboundSchema,
  statusReason: z.nullable(StatusReason$inboundSchema).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => ListPaymentResponseDetails$inboundSchema))
    .optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListPaymentResponseLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListPaymentResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: Amount$Outbound;
  amountRefunded?: ListPaymentResponseAmountRefunded$Outbound | undefined;
  amountRemaining?: ListPaymentResponseAmountRemaining$Outbound | undefined;
  amountCaptured?: ListPaymentResponseAmountCaptured$Outbound | undefined;
  amountChargedBack?: ListPaymentResponseAmountChargedBack$Outbound | undefined;
  settlementAmount?: ListPaymentResponseSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<ListPaymentResponseLine$Outbound> | null | undefined;
  billingAddress?: ListPaymentResponseBillingAddress$Outbound | undefined;
  shippingAddress?: PaymentAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | ListPaymentResponseApplicationFee$Outbound
    | null
    | undefined;
  routing?: Array<EntityPaymentRouteResponse$Outbound> | null | undefined;
  sequenceType: string;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: StatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: ListPaymentResponseDetails$Outbound | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: ListPaymentResponseLinks$Outbound;
};

/** @internal */
export const ListPaymentResponse$outboundSchema: z.ZodType<
  ListPaymentResponse$Outbound,
  z.ZodTypeDef,
  ListPaymentResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  description: z.string(),
  amount: Amount$outboundSchema,
  amountRefunded: z.lazy(() => ListPaymentResponseAmountRefunded$outboundSchema)
    .optional(),
  amountRemaining: z.lazy(() =>
    ListPaymentResponseAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() => ListPaymentResponseAmountCaptured$outboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() =>
    ListPaymentResponseAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListPaymentResponseSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListPaymentResponseLine$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() => ListPaymentResponseBillingAddress$outboundSchema)
    .optional(),
  shippingAddress: PaymentAddress$outboundSchema.optional(),
  locale: z.nullable(LocaleResponse$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(MethodResponse$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  captureMode: z.nullable(CaptureModeResponse$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListPaymentResponseApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRouteResponse$outboundSchema))
    .optional(),
  sequenceType: SequenceTypeResponse$outboundSchema,
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.string().optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListPaymentResponseStatus$outboundSchema,
  statusReason: z.nullable(StatusReason$outboundSchema).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => ListPaymentResponseDetails$outboundSchema))
    .optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListPaymentResponseLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listPaymentResponseToJSON(
  listPaymentResponse: ListPaymentResponse,
): string {
  return JSON.stringify(
    ListPaymentResponse$outboundSchema.parse(listPaymentResponse),
  );
}
export function listPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentResponse' from JSON`,
  );
}
