/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  SubscriptionMethod,
  SubscriptionMethod$inboundSchema,
  SubscriptionMethod$outboundSchema,
} from "./subscriptionmethod.js";
import {
  SubscriptionStatus,
  SubscriptionStatus$inboundSchema,
  SubscriptionStatus$outboundSchema,
} from "./subscriptionstatus.js";

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type SubscriptionRequestApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  description: string;
};

export type SubscriptionRequest = {
  id?: string | undefined;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status?: SubscriptionStatus | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | null | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval?: string | undefined;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description?: string | undefined;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method?: SubscriptionMethod | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: SubscriptionRequestApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

/** @internal */
export const SubscriptionRequestApplicationFee$inboundSchema: z.ZodType<
  SubscriptionRequestApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema,
  description: z.string(),
});

/** @internal */
export type SubscriptionRequestApplicationFee$Outbound = {
  amount: Amount$Outbound;
  description: string;
};

/** @internal */
export const SubscriptionRequestApplicationFee$outboundSchema: z.ZodType<
  SubscriptionRequestApplicationFee$Outbound,
  z.ZodTypeDef,
  SubscriptionRequestApplicationFee
> = z.object({
  amount: Amount$outboundSchema,
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionRequestApplicationFee$ {
  /** @deprecated use `SubscriptionRequestApplicationFee$inboundSchema` instead. */
  export const inboundSchema = SubscriptionRequestApplicationFee$inboundSchema;
  /** @deprecated use `SubscriptionRequestApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    SubscriptionRequestApplicationFee$outboundSchema;
  /** @deprecated use `SubscriptionRequestApplicationFee$Outbound` instead. */
  export type Outbound = SubscriptionRequestApplicationFee$Outbound;
}

export function subscriptionRequestApplicationFeeToJSON(
  subscriptionRequestApplicationFee: SubscriptionRequestApplicationFee,
): string {
  return JSON.stringify(
    SubscriptionRequestApplicationFee$outboundSchema.parse(
      subscriptionRequestApplicationFee,
    ),
  );
}

export function subscriptionRequestApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionRequestApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionRequestApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionRequestApplicationFee' from JSON`,
  );
}

/** @internal */
export const SubscriptionRequest$inboundSchema: z.ZodType<
  SubscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  status: SubscriptionStatus$inboundSchema.optional(),
  amount: Amount$inboundSchema.optional(),
  times: z.nullable(z.number().int()).optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  description: z.string().optional(),
  method: z.nullable(SubscriptionMethod$inboundSchema).optional(),
  applicationFee: z.lazy(() => SubscriptionRequestApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type SubscriptionRequest$Outbound = {
  id?: string | undefined;
  status?: string | undefined;
  amount?: Amount$Outbound | undefined;
  times?: number | null | undefined;
  interval?: string | undefined;
  startDate?: string | undefined;
  description?: string | undefined;
  method?: string | null | undefined;
  applicationFee?: SubscriptionRequestApplicationFee$Outbound | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const SubscriptionRequest$outboundSchema: z.ZodType<
  SubscriptionRequest$Outbound,
  z.ZodTypeDef,
  SubscriptionRequest
> = z.object({
  id: z.string().optional(),
  status: SubscriptionStatus$outboundSchema.optional(),
  amount: Amount$outboundSchema.optional(),
  times: z.nullable(z.number().int()).optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  description: z.string().optional(),
  method: z.nullable(SubscriptionMethod$outboundSchema).optional(),
  applicationFee: z.lazy(() => SubscriptionRequestApplicationFee$outboundSchema)
    .optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionRequest$ {
  /** @deprecated use `SubscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = SubscriptionRequest$inboundSchema;
  /** @deprecated use `SubscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = SubscriptionRequest$outboundSchema;
  /** @deprecated use `SubscriptionRequest$Outbound` instead. */
  export type Outbound = SubscriptionRequest$Outbound;
}

export function subscriptionRequestToJSON(
  subscriptionRequest: SubscriptionRequest,
): string {
  return JSON.stringify(
    SubscriptionRequest$outboundSchema.parse(subscriptionRequest),
  );
}

export function subscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionRequest' from JSON`,
  );
}
