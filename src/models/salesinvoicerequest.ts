/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SalesInvoiceDiscount,
  SalesInvoiceDiscount$inboundSchema,
  SalesInvoiceDiscount$Outbound,
  SalesInvoiceDiscount$outboundSchema,
} from "./salesinvoicediscount.js";
import {
  SalesInvoiceEmailDetails,
  SalesInvoiceEmailDetails$inboundSchema,
  SalesInvoiceEmailDetails$Outbound,
  SalesInvoiceEmailDetails$outboundSchema,
} from "./salesinvoiceemaildetails.js";
import {
  SalesInvoiceLineItem,
  SalesInvoiceLineItem$inboundSchema,
  SalesInvoiceLineItem$Outbound,
  SalesInvoiceLineItem$outboundSchema,
} from "./salesinvoicelineitem.js";
import {
  SalesInvoicePaymentDetails,
  SalesInvoicePaymentDetails$inboundSchema,
  SalesInvoicePaymentDetails$Outbound,
  SalesInvoicePaymentDetails$outboundSchema,
} from "./salesinvoicepaymentdetails.js";
import {
  SalesInvoicePaymentTerm,
  SalesInvoicePaymentTerm$inboundSchema,
  SalesInvoicePaymentTerm$outboundSchema,
} from "./salesinvoicepaymentterm.js";
import {
  SalesInvoiceRecipient,
  SalesInvoiceRecipient$inboundSchema,
  SalesInvoiceRecipient$Outbound,
  SalesInvoiceRecipient$outboundSchema,
} from "./salesinvoicerecipient.js";
import {
  SalesInvoiceStatus,
  SalesInvoiceStatus$inboundSchema,
  SalesInvoiceStatus$outboundSchema,
} from "./salesinvoicestatus.js";
import {
  SalesInvoiceVatMode,
  SalesInvoiceVatMode$inboundSchema,
  SalesInvoiceVatMode$outboundSchema,
} from "./salesinvoicevatmode.js";
import {
  SalesInvoiceVatScheme,
  SalesInvoiceVatScheme$inboundSchema,
  SalesInvoiceVatScheme$outboundSchema,
} from "./salesinvoicevatscheme.js";

/**
 * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type SalesInvoiceRequestMetadata = {};

export type SalesInvoiceRequest = {
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | null | undefined;
  /**
   * The status for the invoice to end up in.
   *
   * @remarks
   *
   * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
   * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
   * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
   *
   * A status value that cannot be set but can be returned is `canceled`, for invoices which were
   * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
   *
   * Dependent parameters:
   *   - `paymentDetails` is required if invoice should be set directly to `paid`
   *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
   *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
   */
  status: SalesInvoiceStatus;
  /**
   * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
   */
  vatScheme?: SalesInvoiceVatScheme | undefined;
  /**
   * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
   *
   * @remarks
   * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
   */
  vatMode?: SalesInvoiceVatMode | undefined;
  /**
   * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
   */
  memo?: string | null | undefined;
  /**
   * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: SalesInvoiceRequestMetadata | null | undefined;
  /**
   * The payment term to be set on the invoice.
   */
  paymentTerm?: SalesInvoicePaymentTerm | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetails | undefined;
  emailDetails?: SalesInvoiceEmailDetails | null | undefined;
  /**
   * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
   *
   * @remarks
   * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  customerId?: string | undefined;
  /**
   * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
   *
   * @remarks
   * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  mandateId?: string | undefined;
  /**
   * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
   *
   * @remarks
   * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
   * is not required to send a first invoice to a recipient.
   */
  recipientIdentifier: string;
  recipient: SalesInvoiceRecipient | null;
  /**
   * Provide the line items for the invoice. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the invoice.
   */
  lines: Array<SalesInvoiceLineItem> | null;
  discount?: SalesInvoiceDiscount | null | undefined;
};

/** @internal */
export const SalesInvoiceRequestMetadata$inboundSchema: z.ZodType<
  SalesInvoiceRequestMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type SalesInvoiceRequestMetadata$Outbound = {};

/** @internal */
export const SalesInvoiceRequestMetadata$outboundSchema: z.ZodType<
  SalesInvoiceRequestMetadata$Outbound,
  z.ZodTypeDef,
  SalesInvoiceRequestMetadata
> = z.object({});

export function salesInvoiceRequestMetadataToJSON(
  salesInvoiceRequestMetadata: SalesInvoiceRequestMetadata,
): string {
  return JSON.stringify(
    SalesInvoiceRequestMetadata$outboundSchema.parse(
      salesInvoiceRequestMetadata,
    ),
  );
}
export function salesInvoiceRequestMetadataFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceRequestMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceRequestMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceRequestMetadata' from JSON`,
  );
}

/** @internal */
export const SalesInvoiceRequest$inboundSchema: z.ZodType<
  SalesInvoiceRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
  profileId: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatus$inboundSchema,
  vatScheme: SalesInvoiceVatScheme$inboundSchema.optional(),
  vatMode: SalesInvoiceVatMode$inboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.lazy(() => SalesInvoiceRequestMetadata$inboundSchema))
    .optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTerm$inboundSchema).optional(),
  paymentDetails: SalesInvoicePaymentDetails$inboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$inboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string(),
  recipient: z.nullable(SalesInvoiceRecipient$inboundSchema),
  lines: z.nullable(z.array(SalesInvoiceLineItem$inboundSchema)),
  discount: z.nullable(SalesInvoiceDiscount$inboundSchema).optional(),
});
/** @internal */
export type SalesInvoiceRequest$Outbound = {
  testmode?: boolean | null | undefined;
  profileId?: string | null | undefined;
  status: string;
  vatScheme?: string | undefined;
  vatMode?: string | undefined;
  memo?: string | null | undefined;
  metadata?: SalesInvoiceRequestMetadata$Outbound | null | undefined;
  paymentTerm?: string | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetails$Outbound | undefined;
  emailDetails?: SalesInvoiceEmailDetails$Outbound | null | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  recipientIdentifier: string;
  recipient: SalesInvoiceRecipient$Outbound | null;
  lines: Array<SalesInvoiceLineItem$Outbound> | null;
  discount?: SalesInvoiceDiscount$Outbound | null | undefined;
};

/** @internal */
export const SalesInvoiceRequest$outboundSchema: z.ZodType<
  SalesInvoiceRequest$Outbound,
  z.ZodTypeDef,
  SalesInvoiceRequest
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
  profileId: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatus$outboundSchema,
  vatScheme: SalesInvoiceVatScheme$outboundSchema.optional(),
  vatMode: SalesInvoiceVatMode$outboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.lazy(() => SalesInvoiceRequestMetadata$outboundSchema))
    .optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTerm$outboundSchema).optional(),
  paymentDetails: SalesInvoicePaymentDetails$outboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$outboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string(),
  recipient: z.nullable(SalesInvoiceRecipient$outboundSchema),
  lines: z.nullable(z.array(SalesInvoiceLineItem$outboundSchema)),
  discount: z.nullable(SalesInvoiceDiscount$outboundSchema).optional(),
});

export function salesInvoiceRequestToJSON(
  salesInvoiceRequest: SalesInvoiceRequest,
): string {
  return JSON.stringify(
    SalesInvoiceRequest$outboundSchema.parse(salesInvoiceRequest),
  );
}
export function salesInvoiceRequestFromJSON(
  jsonString: string,
): SafeParseResult<SalesInvoiceRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SalesInvoiceRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SalesInvoiceRequest' from JSON`,
  );
}
