/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MandateDetailsCardLabelResponse,
  MandateDetailsCardLabelResponse$inboundSchema,
  MandateDetailsCardLabelResponse$outboundSchema,
} from "./mandatedetailscardlabelresponse.js";
import {
  MandateMethodResponse,
  MandateMethodResponse$inboundSchema,
  MandateMethodResponse$outboundSchema,
} from "./mandatemethodresponse.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

export type ListMandateResponseDetails = {
  /**
   * The customer's name. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's IBAN or email address. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank. Available for SEPA Direct Debit mandates.
   */
  consumerBic?: string | null | undefined;
  /**
   * The card holder's name. Available for card mandates.
   */
  cardHolder?: string | null | undefined;
  /**
   * The last four digits of the card number. Available for card mandates.
   */
  cardNumber?: string | null | undefined;
  /**
   * The card's expiry date in `YYYY-MM-DD` format. Available for card mandates.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card's label. Available for card mandates, if the card label could be detected.
   */
  cardLabel?: MandateDetailsCardLabelResponse | null | undefined;
  /**
   * Unique alphanumeric representation of this specific card. Available for card mandates. Can be used to identify
   *
   * @remarks
   * returning customers.
   */
  cardFingerprint?: string | null | undefined;
};

/**
 * The status of the mandate. A status can be `pending` for mandates when the first payment is not yet finalized, or
 *
 * @remarks
 * when we did not received the IBAN yet from the first payment.
 */
export const ListMandateResponseStatus = {
  Valid: "valid",
  Pending: "pending",
  Invalid: "invalid",
} as const;
/**
 * The status of the mandate. A status can be `pending` for mandates when the first payment is not yet finalized, or
 *
 * @remarks
 * when we did not received the IBAN yet from the first payment.
 */
export type ListMandateResponseStatus = OpenEnum<
  typeof ListMandateResponseStatus
>;

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListMandateResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer: Url;
};

export type ListMandateResponse = {
  /**
   * Indicates the response contains a mandate object. Will always contain the string `mandate` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this mandate. Example: `mdt_pWUnw6pkBN`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * Payment method of the mandate.
   *
   * @remarks
   *
   * SEPA Direct Debit and PayPal mandates can be created directly.
   */
  method: MandateMethodResponse;
  details: ListMandateResponseDetails;
  /**
   * The date when the mandate was signed in `YYYY-MM-DD` format.
   */
  signatureDate: string | null;
  /**
   * A custom mandate reference. For SEPA Direct Debit, it is vital to provide a unique reference. Some banks will
   *
   * @remarks
   * decline Direct Debit payments if the mandate reference is not unique.
   */
  mandateReference: string | null;
  status: ListMandateResponseStatus;
  /**
   * The identifier referring to the [customer](get-customer) this mandate was linked to.
   */
  customerId: string;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListMandateResponseLinks;
};

/** @internal */
export const ListMandateResponseDetails$inboundSchema: z.ZodType<
  ListMandateResponseDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$inboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});
/** @internal */
export type ListMandateResponseDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardNumber?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
};

/** @internal */
export const ListMandateResponseDetails$outboundSchema: z.ZodType<
  ListMandateResponseDetails$Outbound,
  z.ZodTypeDef,
  ListMandateResponseDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$outboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});

export function listMandateResponseDetailsToJSON(
  listMandateResponseDetails: ListMandateResponseDetails,
): string {
  return JSON.stringify(
    ListMandateResponseDetails$outboundSchema.parse(listMandateResponseDetails),
  );
}
export function listMandateResponseDetailsFromJSON(
  jsonString: string,
): SafeParseResult<ListMandateResponseDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListMandateResponseDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListMandateResponseDetails' from JSON`,
  );
}

/** @internal */
export const ListMandateResponseStatus$inboundSchema: z.ZodType<
  ListMandateResponseStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ListMandateResponseStatus);
/** @internal */
export const ListMandateResponseStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ListMandateResponseStatus
> = openEnums.outboundSchema(ListMandateResponseStatus);

/** @internal */
export const ListMandateResponseLinks$inboundSchema: z.ZodType<
  ListMandateResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  customer: Url$inboundSchema,
});
/** @internal */
export type ListMandateResponseLinks$Outbound = {
  self: Url$Outbound;
  customer: Url$Outbound;
};

/** @internal */
export const ListMandateResponseLinks$outboundSchema: z.ZodType<
  ListMandateResponseLinks$Outbound,
  z.ZodTypeDef,
  ListMandateResponseLinks
> = z.object({
  self: Url$outboundSchema,
  customer: Url$outboundSchema,
});

export function listMandateResponseLinksToJSON(
  listMandateResponseLinks: ListMandateResponseLinks,
): string {
  return JSON.stringify(
    ListMandateResponseLinks$outboundSchema.parse(listMandateResponseLinks),
  );
}
export function listMandateResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListMandateResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListMandateResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListMandateResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListMandateResponse$inboundSchema: z.ZodType<
  ListMandateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  method: MandateMethodResponse$inboundSchema,
  details: z.lazy(() => ListMandateResponseDetails$inboundSchema),
  signatureDate: z.nullable(z.string()),
  mandateReference: z.nullable(z.string()),
  status: ListMandateResponseStatus$inboundSchema,
  customerId: z.string(),
  createdAt: z.string(),
  _links: z.lazy(() => ListMandateResponseLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListMandateResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  method: string;
  details: ListMandateResponseDetails$Outbound;
  signatureDate: string | null;
  mandateReference: string | null;
  status: string;
  customerId: string;
  createdAt: string;
  _links: ListMandateResponseLinks$Outbound;
};

/** @internal */
export const ListMandateResponse$outboundSchema: z.ZodType<
  ListMandateResponse$Outbound,
  z.ZodTypeDef,
  ListMandateResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  method: MandateMethodResponse$outboundSchema,
  details: z.lazy(() => ListMandateResponseDetails$outboundSchema),
  signatureDate: z.nullable(z.string()),
  mandateReference: z.nullable(z.string()),
  status: ListMandateResponseStatus$outboundSchema,
  customerId: z.string(),
  createdAt: z.string(),
  links: z.lazy(() => ListMandateResponseLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listMandateResponseToJSON(
  listMandateResponse: ListMandateResponse,
): string {
  return JSON.stringify(
    ListMandateResponse$outboundSchema.parse(listMandateResponse),
  );
}
export function listMandateResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListMandateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListMandateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListMandateResponse' from JSON`,
  );
}
