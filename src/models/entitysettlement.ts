/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  PaymentMethod,
  PaymentMethod$inboundSchema,
  PaymentMethod$outboundSchema,
} from "./paymentmethod.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";
import {
  UrlNullable,
  UrlNullable$inboundSchema,
  UrlNullable$Outbound,
  UrlNullable$outboundSchema,
} from "./urlnullable.js";

/**
 * The status of the settlement.
 */
export const EntitySettlementStatus = {
  Open: "open",
  Pending: "pending",
  Paidout: "paidout",
  Failed: "failed",
} as const;
/**
 * The status of the settlement.
 */
export type EntitySettlementStatus = OpenEnum<typeof EntitySettlementStatus>;

/**
 * The total amount of the settlement.
 */
export type EntitySettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The service rates, further divided into `fixed` and `percentage` costs.
 */
export type EntitySettlementRate = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  fixed?: Amount | undefined;
  percentage?: string | undefined;
};

export type EntitySettlementCost = {
  /**
   * A description of the cost subtotal
   */
  description: string;
  /**
   * The payment method, if applicable
   */
  method: PaymentMethod | null;
  /**
   * The number of fees
   */
  count: number;
  /**
   * The service rates, further divided into `fixed` and `percentage` costs.
   */
  rate: EntitySettlementRate;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountNet: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountVat: AmountNullable | null;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountGross: Amount;
};

export type EntitySettlementRevenue = {
  /**
   * A description of the revenue subtotal
   */
  description: string;
  /**
   * The payment method, if applicable
   */
  method: PaymentMethod | null;
  /**
   * The number of payments
   */
  count: number;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountNet: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountVat: AmountNullable | null;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountGross: Amount;
};

export type EntitySettlementPeriods = {
  /**
   * An array of cost objects, describing the fees withheld for each payment method during this period.
   */
  costs?: Array<EntitySettlementCost> | undefined;
  /**
   * An array of revenue objects containing the total revenue for each payment method during this period.
   */
  revenue?: Array<EntitySettlementRevenue> | undefined;
  invoiceId?: string | undefined;
  /**
   * The invoice reference, if the invoice has been created already.
   */
  invoiceReference?: string | null | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntitySettlementLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payments?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  captures?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  refunds?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  chargebacks?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  invoice?: UrlNullable | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
};

export type EntitySettlement = {
  /**
   * Indicates the response contains a settlement object. Will always contain the string `settlement` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this settlement.
   */
  id: string;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The settlement's bank reference, as found in your Mollie account and on your bank statement.
   */
  reference?: string | null | undefined;
  /**
   * The date on which the settlement was settled, in ISO 8601 format.
   *
   * @remarks
   *
   * For an [open settlement](get-open-settlement) or for the [next settlement](get-next-settlement), no settlement
   * date is available.
   */
  settledAt?: string | null | undefined;
  status: EntitySettlementStatus;
  /**
   * The total amount of the settlement.
   */
  amount: EntitySettlementAmount;
  /**
   * The balance token that the settlement was settled to.
   */
  balanceId: string;
  /**
   * The ID of the oldest invoice created for all the periods, if the invoice has been created yet.
   */
  invoiceId?: string | null | undefined;
  /**
   * For bookkeeping purposes, the settlement includes an overview of transactions included in the settlement. These
   *
   * @remarks
   * transactions are grouped into 'period' objects â€” one for each calendar month.
   *
   * For example, if a settlement includes funds from 15 April until 4 May, it will include two period objects. One for
   * all transactions processed between 15 April and 30 April, and one for all transactions between 1 May and 4 May.
   *
   * Period objects are grouped by year, and then by month. So in the above example, the full `periods` collection will
   * look as follows: `{"2024": {"04": {...}, "05": {...}}}`. The year and month in this documentation are referred as `<year>` and `<month>`.
   *
   * The example response should give a good idea of what this looks like in practise.
   */
  periods?:
    | { [k: string]: { [k: string]: EntitySettlementPeriods } }
    | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: EntitySettlementLinks;
};

/** @internal */
export const EntitySettlementStatus$inboundSchema: z.ZodType<
  EntitySettlementStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(EntitySettlementStatus);
/** @internal */
export const EntitySettlementStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EntitySettlementStatus
> = openEnums.outboundSchema(EntitySettlementStatus);

/** @internal */
export const EntitySettlementAmount$inboundSchema: z.ZodType<
  EntitySettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type EntitySettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const EntitySettlementAmount$outboundSchema: z.ZodType<
  EntitySettlementAmount$Outbound,
  z.ZodTypeDef,
  EntitySettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function entitySettlementAmountToJSON(
  entitySettlementAmount: EntitySettlementAmount,
): string {
  return JSON.stringify(
    EntitySettlementAmount$outboundSchema.parse(entitySettlementAmount),
  );
}
export function entitySettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementAmount' from JSON`,
  );
}

/** @internal */
export const EntitySettlementRate$inboundSchema: z.ZodType<
  EntitySettlementRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  fixed: Amount$inboundSchema.optional(),
  percentage: z.string().optional(),
});
/** @internal */
export type EntitySettlementRate$Outbound = {
  fixed?: Amount$Outbound | undefined;
  percentage?: string | undefined;
};

/** @internal */
export const EntitySettlementRate$outboundSchema: z.ZodType<
  EntitySettlementRate$Outbound,
  z.ZodTypeDef,
  EntitySettlementRate
> = z.object({
  fixed: Amount$outboundSchema.optional(),
  percentage: z.string().optional(),
});

export function entitySettlementRateToJSON(
  entitySettlementRate: EntitySettlementRate,
): string {
  return JSON.stringify(
    EntitySettlementRate$outboundSchema.parse(entitySettlementRate),
  );
}
export function entitySettlementRateFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementRate' from JSON`,
  );
}

/** @internal */
export const EntitySettlementCost$inboundSchema: z.ZodType<
  EntitySettlementCost,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$inboundSchema),
  count: z.number().int(),
  rate: z.lazy(() => EntitySettlementRate$inboundSchema),
  amountNet: Amount$inboundSchema,
  amountVat: z.nullable(AmountNullable$inboundSchema),
  amountGross: Amount$inboundSchema,
});
/** @internal */
export type EntitySettlementCost$Outbound = {
  description: string;
  method: string | null;
  count: number;
  rate: EntitySettlementRate$Outbound;
  amountNet: Amount$Outbound;
  amountVat: AmountNullable$Outbound | null;
  amountGross: Amount$Outbound;
};

/** @internal */
export const EntitySettlementCost$outboundSchema: z.ZodType<
  EntitySettlementCost$Outbound,
  z.ZodTypeDef,
  EntitySettlementCost
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$outboundSchema),
  count: z.number().int(),
  rate: z.lazy(() => EntitySettlementRate$outboundSchema),
  amountNet: Amount$outboundSchema,
  amountVat: z.nullable(AmountNullable$outboundSchema),
  amountGross: Amount$outboundSchema,
});

export function entitySettlementCostToJSON(
  entitySettlementCost: EntitySettlementCost,
): string {
  return JSON.stringify(
    EntitySettlementCost$outboundSchema.parse(entitySettlementCost),
  );
}
export function entitySettlementCostFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementCost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementCost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementCost' from JSON`,
  );
}

/** @internal */
export const EntitySettlementRevenue$inboundSchema: z.ZodType<
  EntitySettlementRevenue,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$inboundSchema),
  count: z.number().int(),
  amountNet: Amount$inboundSchema,
  amountVat: z.nullable(AmountNullable$inboundSchema),
  amountGross: Amount$inboundSchema,
});
/** @internal */
export type EntitySettlementRevenue$Outbound = {
  description: string;
  method: string | null;
  count: number;
  amountNet: Amount$Outbound;
  amountVat: AmountNullable$Outbound | null;
  amountGross: Amount$Outbound;
};

/** @internal */
export const EntitySettlementRevenue$outboundSchema: z.ZodType<
  EntitySettlementRevenue$Outbound,
  z.ZodTypeDef,
  EntitySettlementRevenue
> = z.object({
  description: z.string(),
  method: z.nullable(PaymentMethod$outboundSchema),
  count: z.number().int(),
  amountNet: Amount$outboundSchema,
  amountVat: z.nullable(AmountNullable$outboundSchema),
  amountGross: Amount$outboundSchema,
});

export function entitySettlementRevenueToJSON(
  entitySettlementRevenue: EntitySettlementRevenue,
): string {
  return JSON.stringify(
    EntitySettlementRevenue$outboundSchema.parse(entitySettlementRevenue),
  );
}
export function entitySettlementRevenueFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementRevenue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementRevenue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementRevenue' from JSON`,
  );
}

/** @internal */
export const EntitySettlementPeriods$inboundSchema: z.ZodType<
  EntitySettlementPeriods,
  z.ZodTypeDef,
  unknown
> = z.object({
  costs: z.array(z.lazy(() => EntitySettlementCost$inboundSchema)).optional(),
  revenue: z.array(z.lazy(() => EntitySettlementRevenue$inboundSchema))
    .optional(),
  invoiceId: z.string().optional(),
  invoiceReference: z.nullable(z.string()).optional(),
});
/** @internal */
export type EntitySettlementPeriods$Outbound = {
  costs?: Array<EntitySettlementCost$Outbound> | undefined;
  revenue?: Array<EntitySettlementRevenue$Outbound> | undefined;
  invoiceId?: string | undefined;
  invoiceReference?: string | null | undefined;
};

/** @internal */
export const EntitySettlementPeriods$outboundSchema: z.ZodType<
  EntitySettlementPeriods$Outbound,
  z.ZodTypeDef,
  EntitySettlementPeriods
> = z.object({
  costs: z.array(z.lazy(() => EntitySettlementCost$outboundSchema)).optional(),
  revenue: z.array(z.lazy(() => EntitySettlementRevenue$outboundSchema))
    .optional(),
  invoiceId: z.string().optional(),
  invoiceReference: z.nullable(z.string()).optional(),
});

export function entitySettlementPeriodsToJSON(
  entitySettlementPeriods: EntitySettlementPeriods,
): string {
  return JSON.stringify(
    EntitySettlementPeriods$outboundSchema.parse(entitySettlementPeriods),
  );
}
export function entitySettlementPeriodsFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementPeriods, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementPeriods$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementPeriods' from JSON`,
  );
}

/** @internal */
export const EntitySettlementLinks$inboundSchema: z.ZodType<
  EntitySettlementLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  payments: Url$inboundSchema.optional(),
  captures: Url$inboundSchema.optional(),
  refunds: Url$inboundSchema.optional(),
  chargebacks: Url$inboundSchema.optional(),
  invoice: z.nullable(UrlNullable$inboundSchema).optional(),
  documentation: Url$inboundSchema.optional(),
});
/** @internal */
export type EntitySettlementLinks$Outbound = {
  self: Url$Outbound;
  payments?: Url$Outbound | undefined;
  captures?: Url$Outbound | undefined;
  refunds?: Url$Outbound | undefined;
  chargebacks?: Url$Outbound | undefined;
  invoice?: UrlNullable$Outbound | null | undefined;
  documentation?: Url$Outbound | undefined;
};

/** @internal */
export const EntitySettlementLinks$outboundSchema: z.ZodType<
  EntitySettlementLinks$Outbound,
  z.ZodTypeDef,
  EntitySettlementLinks
> = z.object({
  self: Url$outboundSchema,
  payments: Url$outboundSchema.optional(),
  captures: Url$outboundSchema.optional(),
  refunds: Url$outboundSchema.optional(),
  chargebacks: Url$outboundSchema.optional(),
  invoice: z.nullable(UrlNullable$outboundSchema).optional(),
  documentation: Url$outboundSchema.optional(),
});

export function entitySettlementLinksToJSON(
  entitySettlementLinks: EntitySettlementLinks,
): string {
  return JSON.stringify(
    EntitySettlementLinks$outboundSchema.parse(entitySettlementLinks),
  );
}
export function entitySettlementLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlementLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlementLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlementLinks' from JSON`,
  );
}

/** @internal */
export const EntitySettlement$inboundSchema: z.ZodType<
  EntitySettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  createdAt: z.string().optional(),
  reference: z.nullable(z.string()).optional(),
  settledAt: z.nullable(z.string()).optional(),
  status: EntitySettlementStatus$inboundSchema,
  amount: z.lazy(() => EntitySettlementAmount$inboundSchema),
  balanceId: z.string(),
  invoiceId: z.nullable(z.string()).optional(),
  periods: z.record(
    z.record(z.lazy(() => EntitySettlementPeriods$inboundSchema)),
  ).optional(),
  _links: z.lazy(() => EntitySettlementLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type EntitySettlement$Outbound = {
  resource: string;
  id: string;
  createdAt?: string | undefined;
  reference?: string | null | undefined;
  settledAt?: string | null | undefined;
  status: string;
  amount: EntitySettlementAmount$Outbound;
  balanceId: string;
  invoiceId?: string | null | undefined;
  periods?:
    | { [k: string]: { [k: string]: EntitySettlementPeriods$Outbound } }
    | undefined;
  _links: EntitySettlementLinks$Outbound;
};

/** @internal */
export const EntitySettlement$outboundSchema: z.ZodType<
  EntitySettlement$Outbound,
  z.ZodTypeDef,
  EntitySettlement
> = z.object({
  resource: z.string(),
  id: z.string(),
  createdAt: z.string().optional(),
  reference: z.nullable(z.string()).optional(),
  settledAt: z.nullable(z.string()).optional(),
  status: EntitySettlementStatus$outboundSchema,
  amount: z.lazy(() => EntitySettlementAmount$outboundSchema),
  balanceId: z.string(),
  invoiceId: z.nullable(z.string()).optional(),
  periods: z.record(
    z.record(z.lazy(() => EntitySettlementPeriods$outboundSchema)),
  ).optional(),
  links: z.lazy(() => EntitySettlementLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function entitySettlementToJSON(
  entitySettlement: EntitySettlement,
): string {
  return JSON.stringify(
    EntitySettlement$outboundSchema.parse(entitySettlement),
  );
}
export function entitySettlementFromJSON(
  jsonString: string,
): SafeParseResult<EntitySettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySettlement' from JSON`,
  );
}
