/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MandateDetailsCardLabelResponse,
  MandateDetailsCardLabelResponse$inboundSchema,
  MandateDetailsCardLabelResponse$outboundSchema,
} from "./mandatedetailscardlabelresponse.js";
import {
  MandateMethodResponse,
  MandateMethodResponse$inboundSchema,
  MandateMethodResponse$outboundSchema,
} from "./mandatemethodresponse.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

export type MandateResponseDetails = {
  /**
   * The customer's name. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's IBAN or email address. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank. Available for SEPA Direct Debit mandates.
   */
  consumerBic?: string | null | undefined;
  /**
   * The card holder's name. Available for card mandates.
   */
  cardHolder?: string | null | undefined;
  /**
   * The last four digits of the card number. Available for card mandates.
   */
  cardNumber?: string | null | undefined;
  /**
   * The card's expiry date in `YYYY-MM-DD` format. Available for card mandates.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card's label. Available for card mandates, if the card label could be detected.
   */
  cardLabel?: MandateDetailsCardLabelResponse | null | undefined;
  /**
   * Unique alphanumeric representation of this specific card. Available for card mandates. Can be used to identify
   *
   * @remarks
   * returning customers.
   */
  cardFingerprint?: string | null | undefined;
};

/**
 * The status of the mandate. A status can be `pending` for mandates when the first payment is not yet finalized, or
 *
 * @remarks
 * when we did not received the IBAN yet from the first payment.
 */
export const MandateResponseStatus = {
  Valid: "valid",
  Pending: "pending",
  Invalid: "invalid",
} as const;
/**
 * The status of the mandate. A status can be `pending` for mandates when the first payment is not yet finalized, or
 *
 * @remarks
 * when we did not received the IBAN yet from the first payment.
 */
export type MandateResponseStatus = OpenEnum<typeof MandateResponseStatus>;

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type MandateResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: Url;
};

export type MandateResponse = {
  /**
   * Indicates the response contains a mandate object. Will always contain the string `mandate` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this mandate. Example: `mdt_pWUnw6pkBN`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * Payment method of the mandate.
   *
   * @remarks
   *
   * SEPA Direct Debit and PayPal mandates can be created directly.
   */
  method: MandateMethodResponse;
  details: MandateResponseDetails;
  /**
   * The date when the mandate was signed in `YYYY-MM-DD` format.
   */
  signatureDate: string | null;
  /**
   * A custom mandate reference. For SEPA Direct Debit, it is vital to provide a unique reference. Some banks will
   *
   * @remarks
   * decline Direct Debit payments if the mandate reference is not unique.
   */
  mandateReference: string | null;
  status: MandateResponseStatus;
  /**
   * The identifier referring to the [customer](get-customer) this mandate was linked to.
   */
  customerId: string;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: MandateResponseLinks;
};

/** @internal */
export const MandateResponseDetails$inboundSchema: z.ZodType<
  MandateResponseDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$inboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});
/** @internal */
export type MandateResponseDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardNumber?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
};

/** @internal */
export const MandateResponseDetails$outboundSchema: z.ZodType<
  MandateResponseDetails$Outbound,
  z.ZodTypeDef,
  MandateResponseDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$outboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});

export function mandateResponseDetailsToJSON(
  mandateResponseDetails: MandateResponseDetails,
): string {
  return JSON.stringify(
    MandateResponseDetails$outboundSchema.parse(mandateResponseDetails),
  );
}
export function mandateResponseDetailsFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponseDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponseDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponseDetails' from JSON`,
  );
}

/** @internal */
export const MandateResponseStatus$inboundSchema: z.ZodType<
  MandateResponseStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(MandateResponseStatus);
/** @internal */
export const MandateResponseStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  MandateResponseStatus
> = openEnums.outboundSchema(MandateResponseStatus);

/** @internal */
export const MandateResponseLinks$inboundSchema: z.ZodType<
  MandateResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  customer: Url$inboundSchema,
  documentation: Url$inboundSchema,
});
/** @internal */
export type MandateResponseLinks$Outbound = {
  self: Url$Outbound;
  customer: Url$Outbound;
  documentation: Url$Outbound;
};

/** @internal */
export const MandateResponseLinks$outboundSchema: z.ZodType<
  MandateResponseLinks$Outbound,
  z.ZodTypeDef,
  MandateResponseLinks
> = z.object({
  self: Url$outboundSchema,
  customer: Url$outboundSchema,
  documentation: Url$outboundSchema,
});

export function mandateResponseLinksToJSON(
  mandateResponseLinks: MandateResponseLinks,
): string {
  return JSON.stringify(
    MandateResponseLinks$outboundSchema.parse(mandateResponseLinks),
  );
}
export function mandateResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponseLinks' from JSON`,
  );
}

/** @internal */
export const MandateResponse$inboundSchema: z.ZodType<
  MandateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  method: MandateMethodResponse$inboundSchema,
  details: z.lazy(() => MandateResponseDetails$inboundSchema),
  signatureDate: z.nullable(z.string()),
  mandateReference: z.nullable(z.string()),
  status: MandateResponseStatus$inboundSchema,
  customerId: z.string(),
  createdAt: z.string(),
  _links: z.lazy(() => MandateResponseLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type MandateResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  method: string;
  details: MandateResponseDetails$Outbound;
  signatureDate: string | null;
  mandateReference: string | null;
  status: string;
  customerId: string;
  createdAt: string;
  _links: MandateResponseLinks$Outbound;
};

/** @internal */
export const MandateResponse$outboundSchema: z.ZodType<
  MandateResponse$Outbound,
  z.ZodTypeDef,
  MandateResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  method: MandateMethodResponse$outboundSchema,
  details: z.lazy(() => MandateResponseDetails$outboundSchema),
  signatureDate: z.nullable(z.string()),
  mandateReference: z.nullable(z.string()),
  status: MandateResponseStatus$outboundSchema,
  customerId: z.string(),
  createdAt: z.string(),
  links: z.lazy(() => MandateResponseLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function mandateResponseToJSON(
  mandateResponse: MandateResponse,
): string {
  return JSON.stringify(MandateResponse$outboundSchema.parse(mandateResponse));
}
export function mandateResponseFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponse' from JSON`,
  );
}
