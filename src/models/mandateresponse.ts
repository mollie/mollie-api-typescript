/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MandateDetailsCardLabelResponse,
  MandateDetailsCardLabelResponse$inboundSchema,
  MandateDetailsCardLabelResponse$outboundSchema,
} from "./mandatedetailscardlabelresponse.js";
import {
  MandateMethodResponse,
  MandateMethodResponse$inboundSchema,
  MandateMethodResponse$outboundSchema,
} from "./mandatemethodresponse.js";
import {
  MandateStatus,
  MandateStatus$inboundSchema,
  MandateStatus$outboundSchema,
} from "./mandatestatus.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

export type MandateResponseDetails = {
  /**
   * The customer's name. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's IBAN or email address. Available for SEPA Direct Debit and PayPal mandates.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank. Available for SEPA Direct Debit mandates.
   */
  consumerBic?: string | null | undefined;
  /**
   * The card holder's name. Available for card mandates.
   */
  cardHolder?: string | null | undefined;
  /**
   * The last four digits of the card number. Available for card mandates.
   */
  cardNumber?: string | null | undefined;
  /**
   * The card's expiry date in `YYYY-MM-DD` format. Available for card mandates.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card's label. Available for card mandates, if the card label could be detected.
   */
  cardLabel?: MandateDetailsCardLabelResponse | null | undefined;
  /**
   * Unique alphanumeric representation of this specific card. Available for card mandates. Can be used to identify
   *
   * @remarks
   * returning customers.
   */
  cardFingerprint?: string | null | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type MandateResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: Url;
};

export type MandateResponse = {
  /**
   * Indicates the response contains a mandate object. Will always contain the string `mandate` for this endpoint.
   */
  resource?: string | undefined;
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: Mode | undefined;
  /**
   * Payment method of the mandate.
   *
   * @remarks
   *
   * SEPA Direct Debit and PayPal mandates can be created directly.
   */
  method?: MandateMethodResponse | undefined;
  details?: MandateResponseDetails | undefined;
  /**
   * The date when the mandate was signed in `YYYY-MM-DD` format.
   */
  signatureDate?: string | null | undefined;
  /**
   * A custom mandate reference. For SEPA Direct Debit, it is vital to provide a unique reference. Some banks will
   *
   * @remarks
   * decline Direct Debit payments if the mandate reference is not unique.
   */
  mandateReference?: string | null | undefined;
  /**
   * The status of the mandate. A status can be `pending` for mandates when the first payment is not yet finalized, or
   *
   * @remarks
   * when we did not received the IBAN yet from the first payment.
   */
  status?: MandateStatus | undefined;
  customerId?: string | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: MandateResponseLinks | undefined;
};

/** @internal */
export const MandateResponseDetails$inboundSchema: z.ZodType<
  MandateResponseDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$inboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});

/** @internal */
export type MandateResponseDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardNumber?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
};

/** @internal */
export const MandateResponseDetails$outboundSchema: z.ZodType<
  MandateResponseDetails$Outbound,
  z.ZodTypeDef,
  MandateResponseDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardLabel: z.nullable(MandateDetailsCardLabelResponse$outboundSchema)
    .optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MandateResponseDetails$ {
  /** @deprecated use `MandateResponseDetails$inboundSchema` instead. */
  export const inboundSchema = MandateResponseDetails$inboundSchema;
  /** @deprecated use `MandateResponseDetails$outboundSchema` instead. */
  export const outboundSchema = MandateResponseDetails$outboundSchema;
  /** @deprecated use `MandateResponseDetails$Outbound` instead. */
  export type Outbound = MandateResponseDetails$Outbound;
}

export function mandateResponseDetailsToJSON(
  mandateResponseDetails: MandateResponseDetails,
): string {
  return JSON.stringify(
    MandateResponseDetails$outboundSchema.parse(mandateResponseDetails),
  );
}

export function mandateResponseDetailsFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponseDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponseDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponseDetails' from JSON`,
  );
}

/** @internal */
export const MandateResponseLinks$inboundSchema: z.ZodType<
  MandateResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  customer: Url$inboundSchema,
  documentation: Url$inboundSchema,
});

/** @internal */
export type MandateResponseLinks$Outbound = {
  self: Url$Outbound;
  customer: Url$Outbound;
  documentation: Url$Outbound;
};

/** @internal */
export const MandateResponseLinks$outboundSchema: z.ZodType<
  MandateResponseLinks$Outbound,
  z.ZodTypeDef,
  MandateResponseLinks
> = z.object({
  self: Url$outboundSchema,
  customer: Url$outboundSchema,
  documentation: Url$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MandateResponseLinks$ {
  /** @deprecated use `MandateResponseLinks$inboundSchema` instead. */
  export const inboundSchema = MandateResponseLinks$inboundSchema;
  /** @deprecated use `MandateResponseLinks$outboundSchema` instead. */
  export const outboundSchema = MandateResponseLinks$outboundSchema;
  /** @deprecated use `MandateResponseLinks$Outbound` instead. */
  export type Outbound = MandateResponseLinks$Outbound;
}

export function mandateResponseLinksToJSON(
  mandateResponseLinks: MandateResponseLinks,
): string {
  return JSON.stringify(
    MandateResponseLinks$outboundSchema.parse(mandateResponseLinks),
  );
}

export function mandateResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponseLinks' from JSON`,
  );
}

/** @internal */
export const MandateResponse$inboundSchema: z.ZodType<
  MandateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$inboundSchema.optional(),
  method: MandateMethodResponse$inboundSchema.optional(),
  details: z.lazy(() => MandateResponseDetails$inboundSchema).optional(),
  signatureDate: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  status: MandateStatus$inboundSchema.optional(),
  customerId: z.string().optional(),
  createdAt: z.string().optional(),
  _links: z.lazy(() => MandateResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type MandateResponse$Outbound = {
  resource?: string | undefined;
  id?: string | undefined;
  mode?: string | undefined;
  method?: string | undefined;
  details?: MandateResponseDetails$Outbound | undefined;
  signatureDate?: string | null | undefined;
  mandateReference?: string | null | undefined;
  status?: string | undefined;
  customerId?: string | undefined;
  createdAt?: string | undefined;
  _links?: MandateResponseLinks$Outbound | undefined;
};

/** @internal */
export const MandateResponse$outboundSchema: z.ZodType<
  MandateResponse$Outbound,
  z.ZodTypeDef,
  MandateResponse
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$outboundSchema.optional(),
  method: MandateMethodResponse$outboundSchema.optional(),
  details: z.lazy(() => MandateResponseDetails$outboundSchema).optional(),
  signatureDate: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  status: MandateStatus$outboundSchema.optional(),
  customerId: z.string().optional(),
  createdAt: z.string().optional(),
  links: z.lazy(() => MandateResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MandateResponse$ {
  /** @deprecated use `MandateResponse$inboundSchema` instead. */
  export const inboundSchema = MandateResponse$inboundSchema;
  /** @deprecated use `MandateResponse$outboundSchema` instead. */
  export const outboundSchema = MandateResponse$outboundSchema;
  /** @deprecated use `MandateResponse$Outbound` instead. */
  export type Outbound = MandateResponse$Outbound;
}

export function mandateResponseToJSON(
  mandateResponse: MandateResponse,
): string {
  return JSON.stringify(MandateResponse$outboundSchema.parse(mandateResponse));
}

export function mandateResponseFromJSON(
  jsonString: string,
): SafeParseResult<MandateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MandateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MandateResponse' from JSON`,
  );
}
