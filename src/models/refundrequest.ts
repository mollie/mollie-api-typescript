/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  RefundExternalReferenceType,
  RefundExternalReferenceType$inboundSchema,
  RefundExternalReferenceType$outboundSchema,
} from "./refundexternalreferencetype.js";

export type RefundRequestExternalReference = {
  /**
   * Specifies the reference type
   */
  type?: RefundExternalReferenceType | undefined;
  /**
   * Unique reference from the payment provider
   */
  id?: string | undefined;
};

/**
 * The type of source. Currently only the source type `organization` is supported.
 */
export const Type = {
  Organization: "organization",
} as const;
/**
 * The type of source. Currently only the source type `organization` is supported.
 */
export type Type = ClosedEnum<typeof Type>;

/**
 * Where the funds will be pulled back from.
 */
export type RefundRequestSource = {
  type?: Type | undefined;
  organizationId?: string | undefined;
};

export type RefundRequestRoutingReversal = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * Where the funds will be pulled back from.
   */
  source?: RefundRequestSource | undefined;
};

export type RefundRequest = {
  /**
   * The description of the refund that may be shown to your customer, depending on the payment method used.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata: Metadata | null;
  externalReference?: RefundRequestExternalReference | undefined;
  /**
   * *This feature is only available to marketplace operators.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants, by providing the `routing` object during [payment creation](create-payment).
   *
   * When creating refunds for these *routed* payments, by default the full amount is deducted from your balance.
   *
   * If you want to pull back the funds that were routed to the connected merchant(s), you can set this parameter to
   * `true` when issuing a full refund.
   *
   * For more fine-grained control and for partial refunds, use the `routingReversals` parameter instead.
   */
  reverseRouting?: boolean | null | undefined;
  /**
   * *This feature is only available to marketplace operators.*
   *
   * @remarks
   *
   * When creating refunds for *routed* payments, by default the full amount is deducted from your balance.
   *
   * If you want to pull back funds from the connected merchant(s), you can use this parameter to specify what amount
   * needs to be reversed from which merchant(s).
   *
   * If you simply want to fully reverse the routed funds, you can also use the `reverseRouting` parameter instead.
   */
  routingReversals?: Array<RefundRequestRoutingReversal> | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

/** @internal */
export const RefundRequestExternalReference$inboundSchema: z.ZodType<
  RefundRequestExternalReference,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RefundExternalReferenceType$inboundSchema.optional(),
  id: z.string().optional(),
});
/** @internal */
export type RefundRequestExternalReference$Outbound = {
  type?: string | undefined;
  id?: string | undefined;
};

/** @internal */
export const RefundRequestExternalReference$outboundSchema: z.ZodType<
  RefundRequestExternalReference$Outbound,
  z.ZodTypeDef,
  RefundRequestExternalReference
> = z.object({
  type: RefundExternalReferenceType$outboundSchema.optional(),
  id: z.string().optional(),
});

export function refundRequestExternalReferenceToJSON(
  refundRequestExternalReference: RefundRequestExternalReference,
): string {
  return JSON.stringify(
    RefundRequestExternalReference$outboundSchema.parse(
      refundRequestExternalReference,
    ),
  );
}
export function refundRequestExternalReferenceFromJSON(
  jsonString: string,
): SafeParseResult<RefundRequestExternalReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundRequestExternalReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundRequestExternalReference' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);
/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/** @internal */
export const RefundRequestSource$inboundSchema: z.ZodType<
  RefundRequestSource,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Type$inboundSchema.optional(),
  organizationId: z.string().optional(),
});
/** @internal */
export type RefundRequestSource$Outbound = {
  type?: string | undefined;
  organizationId?: string | undefined;
};

/** @internal */
export const RefundRequestSource$outboundSchema: z.ZodType<
  RefundRequestSource$Outbound,
  z.ZodTypeDef,
  RefundRequestSource
> = z.object({
  type: Type$outboundSchema.optional(),
  organizationId: z.string().optional(),
});

export function refundRequestSourceToJSON(
  refundRequestSource: RefundRequestSource,
): string {
  return JSON.stringify(
    RefundRequestSource$outboundSchema.parse(refundRequestSource),
  );
}
export function refundRequestSourceFromJSON(
  jsonString: string,
): SafeParseResult<RefundRequestSource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundRequestSource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundRequestSource' from JSON`,
  );
}

/** @internal */
export const RefundRequestRoutingReversal$inboundSchema: z.ZodType<
  RefundRequestRoutingReversal,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  source: z.lazy(() => RefundRequestSource$inboundSchema).optional(),
});
/** @internal */
export type RefundRequestRoutingReversal$Outbound = {
  amount?: Amount$Outbound | undefined;
  source?: RefundRequestSource$Outbound | undefined;
};

/** @internal */
export const RefundRequestRoutingReversal$outboundSchema: z.ZodType<
  RefundRequestRoutingReversal$Outbound,
  z.ZodTypeDef,
  RefundRequestRoutingReversal
> = z.object({
  amount: Amount$outboundSchema.optional(),
  source: z.lazy(() => RefundRequestSource$outboundSchema).optional(),
});

export function refundRequestRoutingReversalToJSON(
  refundRequestRoutingReversal: RefundRequestRoutingReversal,
): string {
  return JSON.stringify(
    RefundRequestRoutingReversal$outboundSchema.parse(
      refundRequestRoutingReversal,
    ),
  );
}
export function refundRequestRoutingReversalFromJSON(
  jsonString: string,
): SafeParseResult<RefundRequestRoutingReversal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundRequestRoutingReversal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundRequestRoutingReversal' from JSON`,
  );
}

/** @internal */
export const RefundRequest$inboundSchema: z.ZodType<
  RefundRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: Amount$inboundSchema,
  metadata: z.nullable(Metadata$inboundSchema),
  externalReference: z.lazy(() => RefundRequestExternalReference$inboundSchema)
    .optional(),
  reverseRouting: z.nullable(z.boolean()).optional(),
  routingReversals: z.nullable(
    z.array(z.lazy(() => RefundRequestRoutingReversal$inboundSchema)),
  ).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});
/** @internal */
export type RefundRequest$Outbound = {
  description: string;
  amount: Amount$Outbound;
  metadata: Metadata$Outbound | null;
  externalReference?: RefundRequestExternalReference$Outbound | undefined;
  reverseRouting?: boolean | null | undefined;
  routingReversals?:
    | Array<RefundRequestRoutingReversal$Outbound>
    | null
    | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const RefundRequest$outboundSchema: z.ZodType<
  RefundRequest$Outbound,
  z.ZodTypeDef,
  RefundRequest
> = z.object({
  description: z.string(),
  amount: Amount$outboundSchema,
  metadata: z.nullable(Metadata$outboundSchema),
  externalReference: z.lazy(() => RefundRequestExternalReference$outboundSchema)
    .optional(),
  reverseRouting: z.nullable(z.boolean()).optional(),
  routingReversals: z.nullable(
    z.array(z.lazy(() => RefundRequestRoutingReversal$outboundSchema)),
  ).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

export function refundRequestToJSON(refundRequest: RefundRequest): string {
  return JSON.stringify(RefundRequest$outboundSchema.parse(refundRequest));
}
export function refundRequestFromJSON(
  jsonString: string,
): SafeParseResult<RefundRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundRequest' from JSON`,
  );
}
