/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import {
  BalanceTransactionType,
  BalanceTransactionType$inboundSchema,
  BalanceTransactionType$outboundSchema,
} from "./balancetransactiontype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type Payment = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type Capture = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

export type CaptureCommision = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

export type CaptureRollingReserveRelease = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

export type UnauthorizedDirectDebit = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type FailedPayment = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type Refund = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type RefundCompensation = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type ReturnedRefund = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type ReturnedRefundCompensation = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type Chargeback = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type ChargebackReversal = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type ChargebackCompensation = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type ReversedChargebackCompensation = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type OutgoingTransfer = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

export type CanceledOutgoingTransfer = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

export type ReturnedTransfer = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

export type InvoiceCompensation = {
  invoiceId?: string | undefined;
};

export type EntityBalanceTransactionApplicationFee = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  payingOwner?: string | undefined;
};

export type SplitPayment = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  paymentOnwer?: string | undefined;
};

export type PlatformPaymentRefund = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type ReturnedPlatformPaymentRefund = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

export type PlatformPaymentChargeback = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type ReversedPlatformPaymentChargeback = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

export type PaymentCommission = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  organizationId?: string | undefined;
};

export type ReimbursementFee = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type FailedPaymentFee = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type PaymentFee = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

export type ManagedFee = {
  feeType?: string | undefined;
  feeId?: string | undefined;
};

export type ReturnedManagedFee = {
  feeType?: string | undefined;
  feeId?: string | undefined;
};

export type PostPaymentSplitPayment = {
  paymentId?: string | undefined;
};

/**
 * Depending on the type of the balance transaction, we will try to give more context about the specific event that
 *
 * @remarks
 * triggered it. For example, the context object for a payment transaction will look like
 * `{"paymentId": "tr_5B8cwPMGnU6qLbRvo7qEZo", "paymentDescription": "Description"}`.
 *
 * Below is a complete list of the context values that each type of transaction will have.
 *
 * * Type `payment`: `paymentId`, `paymentDescription`
 * * Type `capture`: `paymentId` `captureId`, `paymentDescription`, `captureDescription`
 * * Type `capture-commission`: `paymentId`, `paymentDescription`, `organizationId`
 * * Type `capture-rolling-reserve-release`: `paymentId`, `paymentDescription`, `captureId`, `captureDescription`
 * * Type `unauthorized-direct-debit`: `paymentId`, `paymentDescription`
 * * Type `failed-payment`: `paymentId`, `paymentDescription`
 * * Type `refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `refund-compensation`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `returned-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `returned-refund-compensation`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `chargeback-reversal`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `chargeback-compensation`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `reversed-chargeback-compensation`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `outgoing-transfer`: `settlementId` `transferId`
 * * Type `canceled-outgoing-transfer`: `settlementId` `transferId`
 * * Type `returned-transfer`: `settlementId` `transferId`
 * * Type `invoice-compensation`: `invoiceId`
 * * Type `balance-correction`: none
 * * Type `application-fee`: `paymentId`, `paymentDescription`, `payingOwner`
 * * Type `split-payment`: `paymentId`, `paymentDescription`, `paymentOwner`
 * * Type `platform-payment-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `returned-platform-payment-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
 * * Type `platform-payment-chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `reversed-platform-payment-chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
 * * Type `payment-commission`: `paymentId`, `paymentDescription`, `organizationId`
 * * Type `reimbursement-fee`: `paymentId`, `paymentDescription`
 * * Type `failed-payment-fee`: `paymentId`, `paymentDescription`
 * * Type `payment-fee`: `paymentId`, `paymentDescription`
 * * Type `cash-advance-loan`: none
 * * Type `platform-connected-organizations-fee`: none
 * * Type `managed-fee`: `feeType`, `<name of the fee>Id`
 * * Type `returned-managed-fee`:  `feeType`, `<name of the fee>Id`
 * * Type `topup`: none
 * * Type `balance-reserve`: none
 * * Type `balance-reserve-return`: none
 * * Type `movement`: none
 * * Type `post-payment-split-payment`: `paymentId`
 * * Type `cash-collateral-issuance`: none
 * * Type `cash-collateral-release`: none
 */
export type Context = {
  payment?: Payment | null | undefined;
  capture?: Capture | null | undefined;
  captureCommision?: CaptureCommision | null | undefined;
  captureRollingReserveRelease?:
    | CaptureRollingReserveRelease
    | null
    | undefined;
  unauthorizedDirectDebit?: UnauthorizedDirectDebit | null | undefined;
  failedPayment?: FailedPayment | null | undefined;
  refund?: Refund | null | undefined;
  refundCompensation?: RefundCompensation | null | undefined;
  returnedRefund?: ReturnedRefund | null | undefined;
  returnedRefundCompensation?: ReturnedRefundCompensation | null | undefined;
  chargeback?: Chargeback | null | undefined;
  chargebackReversal?: ChargebackReversal | null | undefined;
  chargebackCompensation?: ChargebackCompensation | null | undefined;
  reversedChargebackCompensation?:
    | ReversedChargebackCompensation
    | null
    | undefined;
  outgoingTransfer?: OutgoingTransfer | null | undefined;
  canceledOutgoingTransfer?: CanceledOutgoingTransfer | null | undefined;
  returnedTransfer?: ReturnedTransfer | null | undefined;
  invoiceCompensation?: InvoiceCompensation | null | undefined;
  applicationFee?: EntityBalanceTransactionApplicationFee | null | undefined;
  splitPayment?: SplitPayment | null | undefined;
  platformPaymentRefund?: PlatformPaymentRefund | null | undefined;
  returnedPlatformPaymentRefund?:
    | ReturnedPlatformPaymentRefund
    | null
    | undefined;
  platformPaymentChargeback?: PlatformPaymentChargeback | null | undefined;
  reversedPlatformPaymentChargeback?:
    | ReversedPlatformPaymentChargeback
    | null
    | undefined;
  paymentCommission?: PaymentCommission | null | undefined;
  reimbursementFee?: ReimbursementFee | null | undefined;
  failedPaymentFee?: FailedPaymentFee | null | undefined;
  paymentFee?: PaymentFee | null | undefined;
  managedFee?: ManagedFee | null | undefined;
  returnedManagedFee?: ReturnedManagedFee | null | undefined;
  postPaymentSplitPayment?: PostPaymentSplitPayment | null | undefined;
};

export type EntityBalanceTransaction = {
  /**
   * Indicates the response contains a balance transaction object. Will always contain the string `balance-transaction`
   *
   * @remarks
   * for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this balance transaction.
   */
  id: string;
  type: BalanceTransactionType;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  resultAmount: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  initialAmount: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  deductions?: AmountNullable | null | undefined;
  /**
   * Depending on the type of the balance transaction, we will try to give more context about the specific event that
   *
   * @remarks
   * triggered it. For example, the context object for a payment transaction will look like
   * `{"paymentId": "tr_5B8cwPMGnU6qLbRvo7qEZo", "paymentDescription": "Description"}`.
   *
   * Below is a complete list of the context values that each type of transaction will have.
   *
   * * Type `payment`: `paymentId`, `paymentDescription`
   * * Type `capture`: `paymentId` `captureId`, `paymentDescription`, `captureDescription`
   * * Type `capture-commission`: `paymentId`, `paymentDescription`, `organizationId`
   * * Type `capture-rolling-reserve-release`: `paymentId`, `paymentDescription`, `captureId`, `captureDescription`
   * * Type `unauthorized-direct-debit`: `paymentId`, `paymentDescription`
   * * Type `failed-payment`: `paymentId`, `paymentDescription`
   * * Type `refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `refund-compensation`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `returned-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `returned-refund-compensation`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `chargeback-reversal`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `chargeback-compensation`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `reversed-chargeback-compensation`: `paymentId`, `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `outgoing-transfer`: `settlementId` `transferId`
   * * Type `canceled-outgoing-transfer`: `settlementId` `transferId`
   * * Type `returned-transfer`: `settlementId` `transferId`
   * * Type `invoice-compensation`: `invoiceId`
   * * Type `balance-correction`: none
   * * Type `application-fee`: `paymentId`, `paymentDescription`, `payingOwner`
   * * Type `split-payment`: `paymentId`, `paymentDescription`, `paymentOwner`
   * * Type `platform-payment-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `returned-platform-payment-refund`: `paymentId` `refundId`, `paymentDescription`, `refundDescription`
   * * Type `platform-payment-chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `reversed-platform-payment-chargeback`: `paymentId` `chargebackId`, `paymentDescription`, `chargebackDescription`
   * * Type `payment-commission`: `paymentId`, `paymentDescription`, `organizationId`
   * * Type `reimbursement-fee`: `paymentId`, `paymentDescription`
   * * Type `failed-payment-fee`: `paymentId`, `paymentDescription`
   * * Type `payment-fee`: `paymentId`, `paymentDescription`
   * * Type `cash-advance-loan`: none
   * * Type `platform-connected-organizations-fee`: none
   * * Type `managed-fee`: `feeType`, `<name of the fee>Id`
   * * Type `returned-managed-fee`:  `feeType`, `<name of the fee>Id`
   * * Type `topup`: none
   * * Type `balance-reserve`: none
   * * Type `balance-reserve-return`: none
   * * Type `movement`: none
   * * Type `post-payment-split-payment`: `paymentId`
   * * Type `cash-collateral-issuance`: none
   * * Type `cash-collateral-release`: none
   */
  context?: Context | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
};

/** @internal */
export const Payment$inboundSchema: z.ZodType<Payment, z.ZodTypeDef, unknown> =
  z.object({
    paymentId: z.string().optional(),
    paymentDescription: z.string().optional(),
  });
/** @internal */
export type Payment$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const Payment$outboundSchema: z.ZodType<
  Payment$Outbound,
  z.ZodTypeDef,
  Payment
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function paymentToJSON(payment: Payment): string {
  return JSON.stringify(Payment$outboundSchema.parse(payment));
}
export function paymentFromJSON(
  jsonString: string,
): SafeParseResult<Payment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payment' from JSON`,
  );
}

/** @internal */
export const Capture$inboundSchema: z.ZodType<Capture, z.ZodTypeDef, unknown> =
  z.object({
    paymentId: z.string().optional(),
    paymentDescription: z.string().optional(),
    captureId: z.string().optional(),
    captureDescription: z.string().optional(),
  });
/** @internal */
export type Capture$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

/** @internal */
export const Capture$outboundSchema: z.ZodType<
  Capture$Outbound,
  z.ZodTypeDef,
  Capture
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  captureId: z.string().optional(),
  captureDescription: z.string().optional(),
});

export function captureToJSON(capture: Capture): string {
  return JSON.stringify(Capture$outboundSchema.parse(capture));
}
export function captureFromJSON(
  jsonString: string,
): SafeParseResult<Capture, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Capture$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Capture' from JSON`,
  );
}

/** @internal */
export const CaptureCommision$inboundSchema: z.ZodType<
  CaptureCommision,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  captureId: z.string().optional(),
  captureDescription: z.string().optional(),
});
/** @internal */
export type CaptureCommision$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

/** @internal */
export const CaptureCommision$outboundSchema: z.ZodType<
  CaptureCommision$Outbound,
  z.ZodTypeDef,
  CaptureCommision
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  captureId: z.string().optional(),
  captureDescription: z.string().optional(),
});

export function captureCommisionToJSON(
  captureCommision: CaptureCommision,
): string {
  return JSON.stringify(
    CaptureCommision$outboundSchema.parse(captureCommision),
  );
}
export function captureCommisionFromJSON(
  jsonString: string,
): SafeParseResult<CaptureCommision, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CaptureCommision$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CaptureCommision' from JSON`,
  );
}

/** @internal */
export const CaptureRollingReserveRelease$inboundSchema: z.ZodType<
  CaptureRollingReserveRelease,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  captureId: z.string().optional(),
  captureDescription: z.string().optional(),
});
/** @internal */
export type CaptureRollingReserveRelease$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  captureId?: string | undefined;
  captureDescription?: string | undefined;
};

/** @internal */
export const CaptureRollingReserveRelease$outboundSchema: z.ZodType<
  CaptureRollingReserveRelease$Outbound,
  z.ZodTypeDef,
  CaptureRollingReserveRelease
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  captureId: z.string().optional(),
  captureDescription: z.string().optional(),
});

export function captureRollingReserveReleaseToJSON(
  captureRollingReserveRelease: CaptureRollingReserveRelease,
): string {
  return JSON.stringify(
    CaptureRollingReserveRelease$outboundSchema.parse(
      captureRollingReserveRelease,
    ),
  );
}
export function captureRollingReserveReleaseFromJSON(
  jsonString: string,
): SafeParseResult<CaptureRollingReserveRelease, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CaptureRollingReserveRelease$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CaptureRollingReserveRelease' from JSON`,
  );
}

/** @internal */
export const UnauthorizedDirectDebit$inboundSchema: z.ZodType<
  UnauthorizedDirectDebit,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});
/** @internal */
export type UnauthorizedDirectDebit$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const UnauthorizedDirectDebit$outboundSchema: z.ZodType<
  UnauthorizedDirectDebit$Outbound,
  z.ZodTypeDef,
  UnauthorizedDirectDebit
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function unauthorizedDirectDebitToJSON(
  unauthorizedDirectDebit: UnauthorizedDirectDebit,
): string {
  return JSON.stringify(
    UnauthorizedDirectDebit$outboundSchema.parse(unauthorizedDirectDebit),
  );
}
export function unauthorizedDirectDebitFromJSON(
  jsonString: string,
): SafeParseResult<UnauthorizedDirectDebit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnauthorizedDirectDebit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnauthorizedDirectDebit' from JSON`,
  );
}

/** @internal */
export const FailedPayment$inboundSchema: z.ZodType<
  FailedPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});
/** @internal */
export type FailedPayment$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const FailedPayment$outboundSchema: z.ZodType<
  FailedPayment$Outbound,
  z.ZodTypeDef,
  FailedPayment
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function failedPaymentToJSON(failedPayment: FailedPayment): string {
  return JSON.stringify(FailedPayment$outboundSchema.parse(failedPayment));
}
export function failedPaymentFromJSON(
  jsonString: string,
): SafeParseResult<FailedPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FailedPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FailedPayment' from JSON`,
  );
}

/** @internal */
export const Refund$inboundSchema: z.ZodType<Refund, z.ZodTypeDef, unknown> = z
  .object({
    paymentId: z.string().optional(),
    paymentDescription: z.string().optional(),
    refundId: z.string().optional(),
    refundDescription: z.string().optional(),
  });
/** @internal */
export type Refund$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const Refund$outboundSchema: z.ZodType<
  Refund$Outbound,
  z.ZodTypeDef,
  Refund
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function refundToJSON(refund: Refund): string {
  return JSON.stringify(Refund$outboundSchema.parse(refund));
}
export function refundFromJSON(
  jsonString: string,
): SafeParseResult<Refund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refund' from JSON`,
  );
}

/** @internal */
export const RefundCompensation$inboundSchema: z.ZodType<
  RefundCompensation,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});
/** @internal */
export type RefundCompensation$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const RefundCompensation$outboundSchema: z.ZodType<
  RefundCompensation$Outbound,
  z.ZodTypeDef,
  RefundCompensation
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function refundCompensationToJSON(
  refundCompensation: RefundCompensation,
): string {
  return JSON.stringify(
    RefundCompensation$outboundSchema.parse(refundCompensation),
  );
}
export function refundCompensationFromJSON(
  jsonString: string,
): SafeParseResult<RefundCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundCompensation' from JSON`,
  );
}

/** @internal */
export const ReturnedRefund$inboundSchema: z.ZodType<
  ReturnedRefund,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});
/** @internal */
export type ReturnedRefund$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const ReturnedRefund$outboundSchema: z.ZodType<
  ReturnedRefund$Outbound,
  z.ZodTypeDef,
  ReturnedRefund
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function returnedRefundToJSON(returnedRefund: ReturnedRefund): string {
  return JSON.stringify(ReturnedRefund$outboundSchema.parse(returnedRefund));
}
export function returnedRefundFromJSON(
  jsonString: string,
): SafeParseResult<ReturnedRefund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReturnedRefund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReturnedRefund' from JSON`,
  );
}

/** @internal */
export const ReturnedRefundCompensation$inboundSchema: z.ZodType<
  ReturnedRefundCompensation,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});
/** @internal */
export type ReturnedRefundCompensation$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const ReturnedRefundCompensation$outboundSchema: z.ZodType<
  ReturnedRefundCompensation$Outbound,
  z.ZodTypeDef,
  ReturnedRefundCompensation
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function returnedRefundCompensationToJSON(
  returnedRefundCompensation: ReturnedRefundCompensation,
): string {
  return JSON.stringify(
    ReturnedRefundCompensation$outboundSchema.parse(returnedRefundCompensation),
  );
}
export function returnedRefundCompensationFromJSON(
  jsonString: string,
): SafeParseResult<ReturnedRefundCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReturnedRefundCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReturnedRefundCompensation' from JSON`,
  );
}

/** @internal */
export const Chargeback$inboundSchema: z.ZodType<
  Chargeback,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type Chargeback$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const Chargeback$outboundSchema: z.ZodType<
  Chargeback$Outbound,
  z.ZodTypeDef,
  Chargeback
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function chargebackToJSON(chargeback: Chargeback): string {
  return JSON.stringify(Chargeback$outboundSchema.parse(chargeback));
}
export function chargebackFromJSON(
  jsonString: string,
): SafeParseResult<Chargeback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Chargeback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Chargeback' from JSON`,
  );
}

/** @internal */
export const ChargebackReversal$inboundSchema: z.ZodType<
  ChargebackReversal,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type ChargebackReversal$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const ChargebackReversal$outboundSchema: z.ZodType<
  ChargebackReversal$Outbound,
  z.ZodTypeDef,
  ChargebackReversal
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function chargebackReversalToJSON(
  chargebackReversal: ChargebackReversal,
): string {
  return JSON.stringify(
    ChargebackReversal$outboundSchema.parse(chargebackReversal),
  );
}
export function chargebackReversalFromJSON(
  jsonString: string,
): SafeParseResult<ChargebackReversal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebackReversal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebackReversal' from JSON`,
  );
}

/** @internal */
export const ChargebackCompensation$inboundSchema: z.ZodType<
  ChargebackCompensation,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type ChargebackCompensation$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const ChargebackCompensation$outboundSchema: z.ZodType<
  ChargebackCompensation$Outbound,
  z.ZodTypeDef,
  ChargebackCompensation
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function chargebackCompensationToJSON(
  chargebackCompensation: ChargebackCompensation,
): string {
  return JSON.stringify(
    ChargebackCompensation$outboundSchema.parse(chargebackCompensation),
  );
}
export function chargebackCompensationFromJSON(
  jsonString: string,
): SafeParseResult<ChargebackCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebackCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebackCompensation' from JSON`,
  );
}

/** @internal */
export const ReversedChargebackCompensation$inboundSchema: z.ZodType<
  ReversedChargebackCompensation,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type ReversedChargebackCompensation$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const ReversedChargebackCompensation$outboundSchema: z.ZodType<
  ReversedChargebackCompensation$Outbound,
  z.ZodTypeDef,
  ReversedChargebackCompensation
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function reversedChargebackCompensationToJSON(
  reversedChargebackCompensation: ReversedChargebackCompensation,
): string {
  return JSON.stringify(
    ReversedChargebackCompensation$outboundSchema.parse(
      reversedChargebackCompensation,
    ),
  );
}
export function reversedChargebackCompensationFromJSON(
  jsonString: string,
): SafeParseResult<ReversedChargebackCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReversedChargebackCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReversedChargebackCompensation' from JSON`,
  );
}

/** @internal */
export const OutgoingTransfer$inboundSchema: z.ZodType<
  OutgoingTransfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});
/** @internal */
export type OutgoingTransfer$Outbound = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

/** @internal */
export const OutgoingTransfer$outboundSchema: z.ZodType<
  OutgoingTransfer$Outbound,
  z.ZodTypeDef,
  OutgoingTransfer
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});

export function outgoingTransferToJSON(
  outgoingTransfer: OutgoingTransfer,
): string {
  return JSON.stringify(
    OutgoingTransfer$outboundSchema.parse(outgoingTransfer),
  );
}
export function outgoingTransferFromJSON(
  jsonString: string,
): SafeParseResult<OutgoingTransfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutgoingTransfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutgoingTransfer' from JSON`,
  );
}

/** @internal */
export const CanceledOutgoingTransfer$inboundSchema: z.ZodType<
  CanceledOutgoingTransfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});
/** @internal */
export type CanceledOutgoingTransfer$Outbound = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

/** @internal */
export const CanceledOutgoingTransfer$outboundSchema: z.ZodType<
  CanceledOutgoingTransfer$Outbound,
  z.ZodTypeDef,
  CanceledOutgoingTransfer
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});

export function canceledOutgoingTransferToJSON(
  canceledOutgoingTransfer: CanceledOutgoingTransfer,
): string {
  return JSON.stringify(
    CanceledOutgoingTransfer$outboundSchema.parse(canceledOutgoingTransfer),
  );
}
export function canceledOutgoingTransferFromJSON(
  jsonString: string,
): SafeParseResult<CanceledOutgoingTransfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CanceledOutgoingTransfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CanceledOutgoingTransfer' from JSON`,
  );
}

/** @internal */
export const ReturnedTransfer$inboundSchema: z.ZodType<
  ReturnedTransfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});
/** @internal */
export type ReturnedTransfer$Outbound = {
  transferId?: string | undefined;
  settlementId?: string | undefined;
};

/** @internal */
export const ReturnedTransfer$outboundSchema: z.ZodType<
  ReturnedTransfer$Outbound,
  z.ZodTypeDef,
  ReturnedTransfer
> = z.object({
  transferId: z.string().optional(),
  settlementId: z.string().optional(),
});

export function returnedTransferToJSON(
  returnedTransfer: ReturnedTransfer,
): string {
  return JSON.stringify(
    ReturnedTransfer$outboundSchema.parse(returnedTransfer),
  );
}
export function returnedTransferFromJSON(
  jsonString: string,
): SafeParseResult<ReturnedTransfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReturnedTransfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReturnedTransfer' from JSON`,
  );
}

/** @internal */
export const InvoiceCompensation$inboundSchema: z.ZodType<
  InvoiceCompensation,
  z.ZodTypeDef,
  unknown
> = z.object({
  invoiceId: z.string().optional(),
});
/** @internal */
export type InvoiceCompensation$Outbound = {
  invoiceId?: string | undefined;
};

/** @internal */
export const InvoiceCompensation$outboundSchema: z.ZodType<
  InvoiceCompensation$Outbound,
  z.ZodTypeDef,
  InvoiceCompensation
> = z.object({
  invoiceId: z.string().optional(),
});

export function invoiceCompensationToJSON(
  invoiceCompensation: InvoiceCompensation,
): string {
  return JSON.stringify(
    InvoiceCompensation$outboundSchema.parse(invoiceCompensation),
  );
}
export function invoiceCompensationFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceCompensation' from JSON`,
  );
}

/** @internal */
export const EntityBalanceTransactionApplicationFee$inboundSchema: z.ZodType<
  EntityBalanceTransactionApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  payingOwner: z.string().optional(),
});
/** @internal */
export type EntityBalanceTransactionApplicationFee$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  payingOwner?: string | undefined;
};

/** @internal */
export const EntityBalanceTransactionApplicationFee$outboundSchema: z.ZodType<
  EntityBalanceTransactionApplicationFee$Outbound,
  z.ZodTypeDef,
  EntityBalanceTransactionApplicationFee
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  payingOwner: z.string().optional(),
});

export function entityBalanceTransactionApplicationFeeToJSON(
  entityBalanceTransactionApplicationFee:
    EntityBalanceTransactionApplicationFee,
): string {
  return JSON.stringify(
    EntityBalanceTransactionApplicationFee$outboundSchema.parse(
      entityBalanceTransactionApplicationFee,
    ),
  );
}
export function entityBalanceTransactionApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceTransactionApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EntityBalanceTransactionApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceTransactionApplicationFee' from JSON`,
  );
}

/** @internal */
export const SplitPayment$inboundSchema: z.ZodType<
  SplitPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  paymentOnwer: z.string().optional(),
});
/** @internal */
export type SplitPayment$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  paymentOnwer?: string | undefined;
};

/** @internal */
export const SplitPayment$outboundSchema: z.ZodType<
  SplitPayment$Outbound,
  z.ZodTypeDef,
  SplitPayment
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  paymentOnwer: z.string().optional(),
});

export function splitPaymentToJSON(splitPayment: SplitPayment): string {
  return JSON.stringify(SplitPayment$outboundSchema.parse(splitPayment));
}
export function splitPaymentFromJSON(
  jsonString: string,
): SafeParseResult<SplitPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplitPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplitPayment' from JSON`,
  );
}

/** @internal */
export const PlatformPaymentRefund$inboundSchema: z.ZodType<
  PlatformPaymentRefund,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});
/** @internal */
export type PlatformPaymentRefund$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const PlatformPaymentRefund$outboundSchema: z.ZodType<
  PlatformPaymentRefund$Outbound,
  z.ZodTypeDef,
  PlatformPaymentRefund
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function platformPaymentRefundToJSON(
  platformPaymentRefund: PlatformPaymentRefund,
): string {
  return JSON.stringify(
    PlatformPaymentRefund$outboundSchema.parse(platformPaymentRefund),
  );
}
export function platformPaymentRefundFromJSON(
  jsonString: string,
): SafeParseResult<PlatformPaymentRefund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlatformPaymentRefund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlatformPaymentRefund' from JSON`,
  );
}

/** @internal */
export const ReturnedPlatformPaymentRefund$inboundSchema: z.ZodType<
  ReturnedPlatformPaymentRefund,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});
/** @internal */
export type ReturnedPlatformPaymentRefund$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  refundId?: string | undefined;
  refundDescription?: string | undefined;
};

/** @internal */
export const ReturnedPlatformPaymentRefund$outboundSchema: z.ZodType<
  ReturnedPlatformPaymentRefund$Outbound,
  z.ZodTypeDef,
  ReturnedPlatformPaymentRefund
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  refundId: z.string().optional(),
  refundDescription: z.string().optional(),
});

export function returnedPlatformPaymentRefundToJSON(
  returnedPlatformPaymentRefund: ReturnedPlatformPaymentRefund,
): string {
  return JSON.stringify(
    ReturnedPlatformPaymentRefund$outboundSchema.parse(
      returnedPlatformPaymentRefund,
    ),
  );
}
export function returnedPlatformPaymentRefundFromJSON(
  jsonString: string,
): SafeParseResult<ReturnedPlatformPaymentRefund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReturnedPlatformPaymentRefund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReturnedPlatformPaymentRefund' from JSON`,
  );
}

/** @internal */
export const PlatformPaymentChargeback$inboundSchema: z.ZodType<
  PlatformPaymentChargeback,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type PlatformPaymentChargeback$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const PlatformPaymentChargeback$outboundSchema: z.ZodType<
  PlatformPaymentChargeback$Outbound,
  z.ZodTypeDef,
  PlatformPaymentChargeback
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function platformPaymentChargebackToJSON(
  platformPaymentChargeback: PlatformPaymentChargeback,
): string {
  return JSON.stringify(
    PlatformPaymentChargeback$outboundSchema.parse(platformPaymentChargeback),
  );
}
export function platformPaymentChargebackFromJSON(
  jsonString: string,
): SafeParseResult<PlatformPaymentChargeback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlatformPaymentChargeback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlatformPaymentChargeback' from JSON`,
  );
}

/** @internal */
export const ReversedPlatformPaymentChargeback$inboundSchema: z.ZodType<
  ReversedPlatformPaymentChargeback,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});
/** @internal */
export type ReversedPlatformPaymentChargeback$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  chargebackId?: string | undefined;
  chargebackDescription?: string | undefined;
};

/** @internal */
export const ReversedPlatformPaymentChargeback$outboundSchema: z.ZodType<
  ReversedPlatformPaymentChargeback$Outbound,
  z.ZodTypeDef,
  ReversedPlatformPaymentChargeback
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  chargebackId: z.string().optional(),
  chargebackDescription: z.string().optional(),
});

export function reversedPlatformPaymentChargebackToJSON(
  reversedPlatformPaymentChargeback: ReversedPlatformPaymentChargeback,
): string {
  return JSON.stringify(
    ReversedPlatformPaymentChargeback$outboundSchema.parse(
      reversedPlatformPaymentChargeback,
    ),
  );
}
export function reversedPlatformPaymentChargebackFromJSON(
  jsonString: string,
): SafeParseResult<ReversedPlatformPaymentChargeback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReversedPlatformPaymentChargeback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReversedPlatformPaymentChargeback' from JSON`,
  );
}

/** @internal */
export const PaymentCommission$inboundSchema: z.ZodType<
  PaymentCommission,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  organizationId: z.string().optional(),
});
/** @internal */
export type PaymentCommission$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
  organizationId?: string | undefined;
};

/** @internal */
export const PaymentCommission$outboundSchema: z.ZodType<
  PaymentCommission$Outbound,
  z.ZodTypeDef,
  PaymentCommission
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
  organizationId: z.string().optional(),
});

export function paymentCommissionToJSON(
  paymentCommission: PaymentCommission,
): string {
  return JSON.stringify(
    PaymentCommission$outboundSchema.parse(paymentCommission),
  );
}
export function paymentCommissionFromJSON(
  jsonString: string,
): SafeParseResult<PaymentCommission, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentCommission$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentCommission' from JSON`,
  );
}

/** @internal */
export const ReimbursementFee$inboundSchema: z.ZodType<
  ReimbursementFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});
/** @internal */
export type ReimbursementFee$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const ReimbursementFee$outboundSchema: z.ZodType<
  ReimbursementFee$Outbound,
  z.ZodTypeDef,
  ReimbursementFee
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function reimbursementFeeToJSON(
  reimbursementFee: ReimbursementFee,
): string {
  return JSON.stringify(
    ReimbursementFee$outboundSchema.parse(reimbursementFee),
  );
}
export function reimbursementFeeFromJSON(
  jsonString: string,
): SafeParseResult<ReimbursementFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReimbursementFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReimbursementFee' from JSON`,
  );
}

/** @internal */
export const FailedPaymentFee$inboundSchema: z.ZodType<
  FailedPaymentFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});
/** @internal */
export type FailedPaymentFee$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const FailedPaymentFee$outboundSchema: z.ZodType<
  FailedPaymentFee$Outbound,
  z.ZodTypeDef,
  FailedPaymentFee
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function failedPaymentFeeToJSON(
  failedPaymentFee: FailedPaymentFee,
): string {
  return JSON.stringify(
    FailedPaymentFee$outboundSchema.parse(failedPaymentFee),
  );
}
export function failedPaymentFeeFromJSON(
  jsonString: string,
): SafeParseResult<FailedPaymentFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FailedPaymentFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FailedPaymentFee' from JSON`,
  );
}

/** @internal */
export const PaymentFee$inboundSchema: z.ZodType<
  PaymentFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});
/** @internal */
export type PaymentFee$Outbound = {
  paymentId?: string | undefined;
  paymentDescription?: string | undefined;
};

/** @internal */
export const PaymentFee$outboundSchema: z.ZodType<
  PaymentFee$Outbound,
  z.ZodTypeDef,
  PaymentFee
> = z.object({
  paymentId: z.string().optional(),
  paymentDescription: z.string().optional(),
});

export function paymentFeeToJSON(paymentFee: PaymentFee): string {
  return JSON.stringify(PaymentFee$outboundSchema.parse(paymentFee));
}
export function paymentFeeFromJSON(
  jsonString: string,
): SafeParseResult<PaymentFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentFee' from JSON`,
  );
}

/** @internal */
export const ManagedFee$inboundSchema: z.ZodType<
  ManagedFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  feeType: z.string().optional(),
  feeId: z.string().optional(),
});
/** @internal */
export type ManagedFee$Outbound = {
  feeType?: string | undefined;
  feeId?: string | undefined;
};

/** @internal */
export const ManagedFee$outboundSchema: z.ZodType<
  ManagedFee$Outbound,
  z.ZodTypeDef,
  ManagedFee
> = z.object({
  feeType: z.string().optional(),
  feeId: z.string().optional(),
});

export function managedFeeToJSON(managedFee: ManagedFee): string {
  return JSON.stringify(ManagedFee$outboundSchema.parse(managedFee));
}
export function managedFeeFromJSON(
  jsonString: string,
): SafeParseResult<ManagedFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ManagedFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ManagedFee' from JSON`,
  );
}

/** @internal */
export const ReturnedManagedFee$inboundSchema: z.ZodType<
  ReturnedManagedFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  feeType: z.string().optional(),
  feeId: z.string().optional(),
});
/** @internal */
export type ReturnedManagedFee$Outbound = {
  feeType?: string | undefined;
  feeId?: string | undefined;
};

/** @internal */
export const ReturnedManagedFee$outboundSchema: z.ZodType<
  ReturnedManagedFee$Outbound,
  z.ZodTypeDef,
  ReturnedManagedFee
> = z.object({
  feeType: z.string().optional(),
  feeId: z.string().optional(),
});

export function returnedManagedFeeToJSON(
  returnedManagedFee: ReturnedManagedFee,
): string {
  return JSON.stringify(
    ReturnedManagedFee$outboundSchema.parse(returnedManagedFee),
  );
}
export function returnedManagedFeeFromJSON(
  jsonString: string,
): SafeParseResult<ReturnedManagedFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReturnedManagedFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReturnedManagedFee' from JSON`,
  );
}

/** @internal */
export const PostPaymentSplitPayment$inboundSchema: z.ZodType<
  PostPaymentSplitPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string().optional(),
});
/** @internal */
export type PostPaymentSplitPayment$Outbound = {
  paymentId?: string | undefined;
};

/** @internal */
export const PostPaymentSplitPayment$outboundSchema: z.ZodType<
  PostPaymentSplitPayment$Outbound,
  z.ZodTypeDef,
  PostPaymentSplitPayment
> = z.object({
  paymentId: z.string().optional(),
});

export function postPaymentSplitPaymentToJSON(
  postPaymentSplitPayment: PostPaymentSplitPayment,
): string {
  return JSON.stringify(
    PostPaymentSplitPayment$outboundSchema.parse(postPaymentSplitPayment),
  );
}
export function postPaymentSplitPaymentFromJSON(
  jsonString: string,
): SafeParseResult<PostPaymentSplitPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostPaymentSplitPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostPaymentSplitPayment' from JSON`,
  );
}

/** @internal */
export const Context$inboundSchema: z.ZodType<Context, z.ZodTypeDef, unknown> =
  z.object({
    payment: z.nullable(z.lazy(() => Payment$inboundSchema)).optional(),
    capture: z.nullable(z.lazy(() => Capture$inboundSchema)).optional(),
    "capture-commision": z.nullable(
      z.lazy(() => CaptureCommision$inboundSchema),
    ).optional(),
    "capture-rolling-reserve-release": z.nullable(
      z.lazy(() => CaptureRollingReserveRelease$inboundSchema),
    ).optional(),
    "unauthorized-direct-debit": z.nullable(
      z.lazy(() => UnauthorizedDirectDebit$inboundSchema),
    ).optional(),
    "failed-payment": z.nullable(z.lazy(() => FailedPayment$inboundSchema))
      .optional(),
    refund: z.nullable(z.lazy(() => Refund$inboundSchema)).optional(),
    "refund-compensation": z.nullable(
      z.lazy(() => RefundCompensation$inboundSchema),
    ).optional(),
    "returned-refund": z.nullable(z.lazy(() => ReturnedRefund$inboundSchema))
      .optional(),
    "returned-refund-compensation": z.nullable(
      z.lazy(() => ReturnedRefundCompensation$inboundSchema),
    ).optional(),
    chargeback: z.nullable(z.lazy(() => Chargeback$inboundSchema)).optional(),
    "chargeback-reversal": z.nullable(
      z.lazy(() => ChargebackReversal$inboundSchema),
    ).optional(),
    "chargeback-compensation": z.nullable(
      z.lazy(() => ChargebackCompensation$inboundSchema),
    ).optional(),
    "reversed-chargeback-compensation": z.nullable(
      z.lazy(() => ReversedChargebackCompensation$inboundSchema),
    ).optional(),
    "outgoing-transfer": z.nullable(
      z.lazy(() => OutgoingTransfer$inboundSchema),
    ).optional(),
    "canceled-outgoing-transfer": z.nullable(
      z.lazy(() => CanceledOutgoingTransfer$inboundSchema),
    ).optional(),
    "returned-transfer": z.nullable(
      z.lazy(() => ReturnedTransfer$inboundSchema),
    ).optional(),
    "invoice-compensation": z.nullable(
      z.lazy(() => InvoiceCompensation$inboundSchema),
    ).optional(),
    "application-fee": z.nullable(
      z.lazy(() => EntityBalanceTransactionApplicationFee$inboundSchema),
    ).optional(),
    "split-payment": z.nullable(z.lazy(() => SplitPayment$inboundSchema))
      .optional(),
    "platform-payment-refund": z.nullable(
      z.lazy(() => PlatformPaymentRefund$inboundSchema),
    ).optional(),
    "returned-platform-payment-refund": z.nullable(
      z.lazy(() => ReturnedPlatformPaymentRefund$inboundSchema),
    ).optional(),
    "platform-payment-chargeback": z.nullable(
      z.lazy(() => PlatformPaymentChargeback$inboundSchema),
    ).optional(),
    "reversed-platform-payment-chargeback": z.nullable(
      z.lazy(() => ReversedPlatformPaymentChargeback$inboundSchema),
    ).optional(),
    "payment-commission": z.nullable(
      z.lazy(() => PaymentCommission$inboundSchema),
    ).optional(),
    "reimbursement-fee": z.nullable(
      z.lazy(() => ReimbursementFee$inboundSchema),
    ).optional(),
    "failed-payment-fee": z.nullable(
      z.lazy(() => FailedPaymentFee$inboundSchema),
    ).optional(),
    "payment-fee": z.nullable(z.lazy(() => PaymentFee$inboundSchema))
      .optional(),
    "managed-fee": z.nullable(z.lazy(() => ManagedFee$inboundSchema))
      .optional(),
    "returned-managed-fee": z.nullable(
      z.lazy(() => ReturnedManagedFee$inboundSchema),
    ).optional(),
    "post-payment-split-payment": z.nullable(
      z.lazy(() => PostPaymentSplitPayment$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "capture-commision": "captureCommision",
      "capture-rolling-reserve-release": "captureRollingReserveRelease",
      "unauthorized-direct-debit": "unauthorizedDirectDebit",
      "failed-payment": "failedPayment",
      "refund-compensation": "refundCompensation",
      "returned-refund": "returnedRefund",
      "returned-refund-compensation": "returnedRefundCompensation",
      "chargeback-reversal": "chargebackReversal",
      "chargeback-compensation": "chargebackCompensation",
      "reversed-chargeback-compensation": "reversedChargebackCompensation",
      "outgoing-transfer": "outgoingTransfer",
      "canceled-outgoing-transfer": "canceledOutgoingTransfer",
      "returned-transfer": "returnedTransfer",
      "invoice-compensation": "invoiceCompensation",
      "application-fee": "applicationFee",
      "split-payment": "splitPayment",
      "platform-payment-refund": "platformPaymentRefund",
      "returned-platform-payment-refund": "returnedPlatformPaymentRefund",
      "platform-payment-chargeback": "platformPaymentChargeback",
      "reversed-platform-payment-chargeback":
        "reversedPlatformPaymentChargeback",
      "payment-commission": "paymentCommission",
      "reimbursement-fee": "reimbursementFee",
      "failed-payment-fee": "failedPaymentFee",
      "payment-fee": "paymentFee",
      "managed-fee": "managedFee",
      "returned-managed-fee": "returnedManagedFee",
      "post-payment-split-payment": "postPaymentSplitPayment",
    });
  });
/** @internal */
export type Context$Outbound = {
  payment?: Payment$Outbound | null | undefined;
  capture?: Capture$Outbound | null | undefined;
  "capture-commision"?: CaptureCommision$Outbound | null | undefined;
  "capture-rolling-reserve-release"?:
    | CaptureRollingReserveRelease$Outbound
    | null
    | undefined;
  "unauthorized-direct-debit"?:
    | UnauthorizedDirectDebit$Outbound
    | null
    | undefined;
  "failed-payment"?: FailedPayment$Outbound | null | undefined;
  refund?: Refund$Outbound | null | undefined;
  "refund-compensation"?: RefundCompensation$Outbound | null | undefined;
  "returned-refund"?: ReturnedRefund$Outbound | null | undefined;
  "returned-refund-compensation"?:
    | ReturnedRefundCompensation$Outbound
    | null
    | undefined;
  chargeback?: Chargeback$Outbound | null | undefined;
  "chargeback-reversal"?: ChargebackReversal$Outbound | null | undefined;
  "chargeback-compensation"?:
    | ChargebackCompensation$Outbound
    | null
    | undefined;
  "reversed-chargeback-compensation"?:
    | ReversedChargebackCompensation$Outbound
    | null
    | undefined;
  "outgoing-transfer"?: OutgoingTransfer$Outbound | null | undefined;
  "canceled-outgoing-transfer"?:
    | CanceledOutgoingTransfer$Outbound
    | null
    | undefined;
  "returned-transfer"?: ReturnedTransfer$Outbound | null | undefined;
  "invoice-compensation"?: InvoiceCompensation$Outbound | null | undefined;
  "application-fee"?:
    | EntityBalanceTransactionApplicationFee$Outbound
    | null
    | undefined;
  "split-payment"?: SplitPayment$Outbound | null | undefined;
  "platform-payment-refund"?: PlatformPaymentRefund$Outbound | null | undefined;
  "returned-platform-payment-refund"?:
    | ReturnedPlatformPaymentRefund$Outbound
    | null
    | undefined;
  "platform-payment-chargeback"?:
    | PlatformPaymentChargeback$Outbound
    | null
    | undefined;
  "reversed-platform-payment-chargeback"?:
    | ReversedPlatformPaymentChargeback$Outbound
    | null
    | undefined;
  "payment-commission"?: PaymentCommission$Outbound | null | undefined;
  "reimbursement-fee"?: ReimbursementFee$Outbound | null | undefined;
  "failed-payment-fee"?: FailedPaymentFee$Outbound | null | undefined;
  "payment-fee"?: PaymentFee$Outbound | null | undefined;
  "managed-fee"?: ManagedFee$Outbound | null | undefined;
  "returned-managed-fee"?: ReturnedManagedFee$Outbound | null | undefined;
  "post-payment-split-payment"?:
    | PostPaymentSplitPayment$Outbound
    | null
    | undefined;
};

/** @internal */
export const Context$outboundSchema: z.ZodType<
  Context$Outbound,
  z.ZodTypeDef,
  Context
> = z.object({
  payment: z.nullable(z.lazy(() => Payment$outboundSchema)).optional(),
  capture: z.nullable(z.lazy(() => Capture$outboundSchema)).optional(),
  captureCommision: z.nullable(z.lazy(() => CaptureCommision$outboundSchema))
    .optional(),
  captureRollingReserveRelease: z.nullable(
    z.lazy(() => CaptureRollingReserveRelease$outboundSchema),
  ).optional(),
  unauthorizedDirectDebit: z.nullable(
    z.lazy(() => UnauthorizedDirectDebit$outboundSchema),
  ).optional(),
  failedPayment: z.nullable(z.lazy(() => FailedPayment$outboundSchema))
    .optional(),
  refund: z.nullable(z.lazy(() => Refund$outboundSchema)).optional(),
  refundCompensation: z.nullable(
    z.lazy(() => RefundCompensation$outboundSchema),
  ).optional(),
  returnedRefund: z.nullable(z.lazy(() => ReturnedRefund$outboundSchema))
    .optional(),
  returnedRefundCompensation: z.nullable(
    z.lazy(() => ReturnedRefundCompensation$outboundSchema),
  ).optional(),
  chargeback: z.nullable(z.lazy(() => Chargeback$outboundSchema)).optional(),
  chargebackReversal: z.nullable(
    z.lazy(() => ChargebackReversal$outboundSchema),
  ).optional(),
  chargebackCompensation: z.nullable(
    z.lazy(() => ChargebackCompensation$outboundSchema),
  ).optional(),
  reversedChargebackCompensation: z.nullable(
    z.lazy(() => ReversedChargebackCompensation$outboundSchema),
  ).optional(),
  outgoingTransfer: z.nullable(z.lazy(() => OutgoingTransfer$outboundSchema))
    .optional(),
  canceledOutgoingTransfer: z.nullable(
    z.lazy(() => CanceledOutgoingTransfer$outboundSchema),
  ).optional(),
  returnedTransfer: z.nullable(z.lazy(() => ReturnedTransfer$outboundSchema))
    .optional(),
  invoiceCompensation: z.nullable(
    z.lazy(() => InvoiceCompensation$outboundSchema),
  ).optional(),
  applicationFee: z.nullable(
    z.lazy(() => EntityBalanceTransactionApplicationFee$outboundSchema),
  ).optional(),
  splitPayment: z.nullable(z.lazy(() => SplitPayment$outboundSchema))
    .optional(),
  platformPaymentRefund: z.nullable(
    z.lazy(() => PlatformPaymentRefund$outboundSchema),
  ).optional(),
  returnedPlatformPaymentRefund: z.nullable(
    z.lazy(() => ReturnedPlatformPaymentRefund$outboundSchema),
  ).optional(),
  platformPaymentChargeback: z.nullable(
    z.lazy(() => PlatformPaymentChargeback$outboundSchema),
  ).optional(),
  reversedPlatformPaymentChargeback: z.nullable(
    z.lazy(() => ReversedPlatformPaymentChargeback$outboundSchema),
  ).optional(),
  paymentCommission: z.nullable(z.lazy(() => PaymentCommission$outboundSchema))
    .optional(),
  reimbursementFee: z.nullable(z.lazy(() => ReimbursementFee$outboundSchema))
    .optional(),
  failedPaymentFee: z.nullable(z.lazy(() => FailedPaymentFee$outboundSchema))
    .optional(),
  paymentFee: z.nullable(z.lazy(() => PaymentFee$outboundSchema)).optional(),
  managedFee: z.nullable(z.lazy(() => ManagedFee$outboundSchema)).optional(),
  returnedManagedFee: z.nullable(
    z.lazy(() => ReturnedManagedFee$outboundSchema),
  ).optional(),
  postPaymentSplitPayment: z.nullable(
    z.lazy(() => PostPaymentSplitPayment$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    captureCommision: "capture-commision",
    captureRollingReserveRelease: "capture-rolling-reserve-release",
    unauthorizedDirectDebit: "unauthorized-direct-debit",
    failedPayment: "failed-payment",
    refundCompensation: "refund-compensation",
    returnedRefund: "returned-refund",
    returnedRefundCompensation: "returned-refund-compensation",
    chargebackReversal: "chargeback-reversal",
    chargebackCompensation: "chargeback-compensation",
    reversedChargebackCompensation: "reversed-chargeback-compensation",
    outgoingTransfer: "outgoing-transfer",
    canceledOutgoingTransfer: "canceled-outgoing-transfer",
    returnedTransfer: "returned-transfer",
    invoiceCompensation: "invoice-compensation",
    applicationFee: "application-fee",
    splitPayment: "split-payment",
    platformPaymentRefund: "platform-payment-refund",
    returnedPlatformPaymentRefund: "returned-platform-payment-refund",
    platformPaymentChargeback: "platform-payment-chargeback",
    reversedPlatformPaymentChargeback: "reversed-platform-payment-chargeback",
    paymentCommission: "payment-commission",
    reimbursementFee: "reimbursement-fee",
    failedPaymentFee: "failed-payment-fee",
    paymentFee: "payment-fee",
    managedFee: "managed-fee",
    returnedManagedFee: "returned-managed-fee",
    postPaymentSplitPayment: "post-payment-split-payment",
  });
});

export function contextToJSON(context: Context): string {
  return JSON.stringify(Context$outboundSchema.parse(context));
}
export function contextFromJSON(
  jsonString: string,
): SafeParseResult<Context, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Context$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Context' from JSON`,
  );
}

/** @internal */
export const EntityBalanceTransaction$inboundSchema: z.ZodType<
  EntityBalanceTransaction,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  type: BalanceTransactionType$inboundSchema,
  resultAmount: Amount$inboundSchema,
  initialAmount: Amount$inboundSchema,
  deductions: z.nullable(AmountNullable$inboundSchema).optional(),
  context: z.nullable(z.lazy(() => Context$inboundSchema)).optional(),
  createdAt: z.string(),
});
/** @internal */
export type EntityBalanceTransaction$Outbound = {
  resource: string;
  id: string;
  type: string;
  resultAmount: Amount$Outbound;
  initialAmount: Amount$Outbound;
  deductions?: AmountNullable$Outbound | null | undefined;
  context?: Context$Outbound | null | undefined;
  createdAt: string;
};

/** @internal */
export const EntityBalanceTransaction$outboundSchema: z.ZodType<
  EntityBalanceTransaction$Outbound,
  z.ZodTypeDef,
  EntityBalanceTransaction
> = z.object({
  resource: z.string(),
  id: z.string(),
  type: BalanceTransactionType$outboundSchema,
  resultAmount: Amount$outboundSchema,
  initialAmount: Amount$outboundSchema,
  deductions: z.nullable(AmountNullable$outboundSchema).optional(),
  context: z.nullable(z.lazy(() => Context$outboundSchema)).optional(),
  createdAt: z.string(),
});

export function entityBalanceTransactionToJSON(
  entityBalanceTransaction: EntityBalanceTransaction,
): string {
  return JSON.stringify(
    EntityBalanceTransaction$outboundSchema.parse(entityBalanceTransaction),
  );
}
export function entityBalanceTransactionFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceTransaction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceTransaction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceTransaction' from JSON`,
  );
}
