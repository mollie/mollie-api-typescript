/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  SalesInvoiceDiscountResponse,
  SalesInvoiceDiscountResponse$inboundSchema,
  SalesInvoiceDiscountResponse$Outbound,
  SalesInvoiceDiscountResponse$outboundSchema,
} from "./salesinvoicediscountresponse.js";
import {
  SalesInvoiceEmailDetails,
  SalesInvoiceEmailDetails$inboundSchema,
  SalesInvoiceEmailDetails$Outbound,
  SalesInvoiceEmailDetails$outboundSchema,
} from "./salesinvoiceemaildetails.js";
import {
  SalesInvoiceLineItemResponse,
  SalesInvoiceLineItemResponse$inboundSchema,
  SalesInvoiceLineItemResponse$Outbound,
  SalesInvoiceLineItemResponse$outboundSchema,
} from "./salesinvoicelineitemresponse.js";
import {
  SalesInvoicePaymentDetailsResponse,
  SalesInvoicePaymentDetailsResponse$inboundSchema,
  SalesInvoicePaymentDetailsResponse$Outbound,
  SalesInvoicePaymentDetailsResponse$outboundSchema,
} from "./salesinvoicepaymentdetailsresponse.js";
import {
  SalesInvoicePaymentTermResponse,
  SalesInvoicePaymentTermResponse$inboundSchema,
  SalesInvoicePaymentTermResponse$outboundSchema,
} from "./salesinvoicepaymenttermresponse.js";
import {
  SalesInvoiceRecipientResponse,
  SalesInvoiceRecipientResponse$inboundSchema,
  SalesInvoiceRecipientResponse$Outbound,
  SalesInvoiceRecipientResponse$outboundSchema,
} from "./salesinvoicerecipientresponse.js";
import {
  SalesInvoiceStatusResponse,
  SalesInvoiceStatusResponse$inboundSchema,
  SalesInvoiceStatusResponse$outboundSchema,
} from "./salesinvoicestatusresponse.js";
import {
  SalesInvoiceVatModeResponse,
  SalesInvoiceVatModeResponse$inboundSchema,
  SalesInvoiceVatModeResponse$outboundSchema,
} from "./salesinvoicevatmoderesponse.js";
import {
  SalesInvoiceVatSchemeResponse,
  SalesInvoiceVatSchemeResponse$inboundSchema,
  SalesInvoiceVatSchemeResponse$outboundSchema,
} from "./salesinvoicevatschemeresponse.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListSalesInvoiceResponseMetadata = {};

/**
 * The amount that is left to be paid.
 */
export type ListSalesInvoiceResponseAmountDue = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount without VAT before discounts.
 */
export type ListSalesInvoiceResponseSubtotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount with VAT.
 */
export type ListSalesInvoiceResponseTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total VAT amount.
 */
export type ListSalesInvoiceResponseTotalVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount without VAT after discounts.
 */
export type ListSalesInvoiceResponseDiscountedSubtotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSalesInvoiceResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  invoicePayment?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  pdfLink?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  next?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  previous?: Url | undefined;
};

export type ListSalesInvoiceResponse = {
  /**
   * Indicates the response contains a sales invoice object. Will always contain the string `sales-invoice` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this invoice. Example: `invoice_4Y0eZitmBnQ6IDoMqZQKh`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * When issued, an invoice number will be set for the sales invoice.
   */
  invoiceNumber?: string | null | undefined;
  /**
   * The status for the invoice to end up in.
   *
   * @remarks
   *
   * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
   * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
   * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
   *
   * A status value that cannot be set but can be returned is `canceled`, for invoices which were
   * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
   *
   * Dependent parameters:
   *   - `paymentDetails` is required if invoice should be set directly to `paid`
   *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
   *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
   */
  status?: SalesInvoiceStatusResponse | undefined;
  /**
   * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
   */
  vatScheme?: SalesInvoiceVatSchemeResponse | undefined;
  /**
   * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
   *
   * @remarks
   * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
   */
  vatMode?: SalesInvoiceVatModeResponse | undefined;
  /**
   * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
   */
  memo?: string | null | undefined;
  /**
   * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: ListSalesInvoiceResponseMetadata | null | undefined;
  /**
   * The payment term to be set on the invoice.
   */
  paymentTerm?: SalesInvoicePaymentTermResponse | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetailsResponse | undefined;
  emailDetails?: SalesInvoiceEmailDetails | null | undefined;
  /**
   * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
   *
   * @remarks
   * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  customerId?: string | undefined;
  /**
   * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
   *
   * @remarks
   * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  mandateId?: string | undefined;
  /**
   * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
   *
   * @remarks
   * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
   * is not required to send a first invoice to a recipient.
   */
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse | null | undefined;
  /**
   * Provide the line items for the invoice. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the invoice.
   */
  lines?: Array<SalesInvoiceLineItemResponse> | null | undefined;
  discount?: SalesInvoiceDiscountResponse | null | undefined;
  /**
   * The amount that is left to be paid.
   */
  amountDue?: ListSalesInvoiceResponseAmountDue | undefined;
  /**
   * The total amount without VAT before discounts.
   */
  subtotalAmount?: ListSalesInvoiceResponseSubtotalAmount | undefined;
  /**
   * The total amount with VAT.
   */
  totalAmount?: ListSalesInvoiceResponseTotalAmount | undefined;
  /**
   * The total VAT amount.
   */
  totalVatAmount?: ListSalesInvoiceResponseTotalVatAmount | undefined;
  /**
   * The total amount without VAT after discounts.
   */
  discountedSubtotalAmount?:
    | ListSalesInvoiceResponseDiscountedSubtotalAmount
    | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * If issued, the date when the sales invoice was issued, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  issuedAt?: string | null | undefined;
  /**
   * If paid, the date when the sales invoice was paid, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  paidAt?: string | null | undefined;
  /**
   * If issued, the date when the sales invoice payment is due, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   *
   * @remarks
   * format.
   */
  dueAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListSalesInvoiceResponseLinks | undefined;
};

/** @internal */
export const ListSalesInvoiceResponseMetadata$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type ListSalesInvoiceResponseMetadata$Outbound = {};

/** @internal */
export const ListSalesInvoiceResponseMetadata$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseMetadata$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseMetadata
> = z.object({});

export function listSalesInvoiceResponseMetadataToJSON(
  listSalesInvoiceResponseMetadata: ListSalesInvoiceResponseMetadata,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseMetadata$outboundSchema.parse(
      listSalesInvoiceResponseMetadata,
    ),
  );
}
export function listSalesInvoiceResponseMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSalesInvoiceResponseMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseMetadata' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseAmountDue$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseAmountDue,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListSalesInvoiceResponseAmountDue$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSalesInvoiceResponseAmountDue$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseAmountDue$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseAmountDue
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listSalesInvoiceResponseAmountDueToJSON(
  listSalesInvoiceResponseAmountDue: ListSalesInvoiceResponseAmountDue,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseAmountDue$outboundSchema.parse(
      listSalesInvoiceResponseAmountDue,
    ),
  );
}
export function listSalesInvoiceResponseAmountDueFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseAmountDue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSalesInvoiceResponseAmountDue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseAmountDue' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseSubtotalAmount$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseSubtotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListSalesInvoiceResponseSubtotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSalesInvoiceResponseSubtotalAmount$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseSubtotalAmount$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseSubtotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listSalesInvoiceResponseSubtotalAmountToJSON(
  listSalesInvoiceResponseSubtotalAmount:
    ListSalesInvoiceResponseSubtotalAmount,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseSubtotalAmount$outboundSchema.parse(
      listSalesInvoiceResponseSubtotalAmount,
    ),
  );
}
export function listSalesInvoiceResponseSubtotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseSubtotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSalesInvoiceResponseSubtotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseSubtotalAmount' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseTotalAmount$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListSalesInvoiceResponseTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSalesInvoiceResponseTotalAmount$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseTotalAmount$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listSalesInvoiceResponseTotalAmountToJSON(
  listSalesInvoiceResponseTotalAmount: ListSalesInvoiceResponseTotalAmount,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseTotalAmount$outboundSchema.parse(
      listSalesInvoiceResponseTotalAmount,
    ),
  );
}
export function listSalesInvoiceResponseTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSalesInvoiceResponseTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseTotalVatAmount$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseTotalVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListSalesInvoiceResponseTotalVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSalesInvoiceResponseTotalVatAmount$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseTotalVatAmount$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseTotalVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listSalesInvoiceResponseTotalVatAmountToJSON(
  listSalesInvoiceResponseTotalVatAmount:
    ListSalesInvoiceResponseTotalVatAmount,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseTotalVatAmount$outboundSchema.parse(
      listSalesInvoiceResponseTotalVatAmount,
    ),
  );
}
export function listSalesInvoiceResponseTotalVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseTotalVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSalesInvoiceResponseTotalVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseTotalVatAmount' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema:
  z.ZodType<
    ListSalesInvoiceResponseDiscountedSubtotalAmount,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });
/** @internal */
export type ListSalesInvoiceResponseDiscountedSubtotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema:
  z.ZodType<
    ListSalesInvoiceResponseDiscountedSubtotalAmount$Outbound,
    z.ZodTypeDef,
    ListSalesInvoiceResponseDiscountedSubtotalAmount
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

export function listSalesInvoiceResponseDiscountedSubtotalAmountToJSON(
  listSalesInvoiceResponseDiscountedSubtotalAmount:
    ListSalesInvoiceResponseDiscountedSubtotalAmount,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema.parse(
      listSalesInvoiceResponseDiscountedSubtotalAmount,
    ),
  );
}
export function listSalesInvoiceResponseDiscountedSubtotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSalesInvoiceResponseDiscountedSubtotalAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSalesInvoiceResponseDiscountedSubtotalAmount' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponseLinks$inboundSchema: z.ZodType<
  ListSalesInvoiceResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  invoicePayment: Url$inboundSchema.optional(),
  pdfLink: Url$inboundSchema.optional(),
  next: Url$inboundSchema.optional(),
  previous: Url$inboundSchema.optional(),
});
/** @internal */
export type ListSalesInvoiceResponseLinks$Outbound = {
  self?: Url$Outbound | undefined;
  invoicePayment?: Url$Outbound | undefined;
  pdfLink?: Url$Outbound | undefined;
  next?: Url$Outbound | undefined;
  previous?: Url$Outbound | undefined;
};

/** @internal */
export const ListSalesInvoiceResponseLinks$outboundSchema: z.ZodType<
  ListSalesInvoiceResponseLinks$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponseLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  invoicePayment: Url$outboundSchema.optional(),
  pdfLink: Url$outboundSchema.optional(),
  next: Url$outboundSchema.optional(),
  previous: Url$outboundSchema.optional(),
});

export function listSalesInvoiceResponseLinksToJSON(
  listSalesInvoiceResponseLinks: ListSalesInvoiceResponseLinks,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponseLinks$outboundSchema.parse(
      listSalesInvoiceResponseLinks,
    ),
  );
}
export function listSalesInvoiceResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSalesInvoiceResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListSalesInvoiceResponse$inboundSchema: z.ZodType<
  ListSalesInvoiceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$inboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$inboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$inboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.lazy(() => ListSalesInvoiceResponseMetadata$inboundSchema),
  ).optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$inboundSchema)
    .optional(),
  paymentDetails: SalesInvoicePaymentDetailsResponse$inboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$inboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$inboundSchema).optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$inboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$inboundSchema).optional(),
  amountDue: z.lazy(() => ListSalesInvoiceResponseAmountDue$inboundSchema)
    .optional(),
  subtotalAmount: z.lazy(() =>
    ListSalesInvoiceResponseSubtotalAmount$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSalesInvoiceResponseTotalAmount$inboundSchema)
    .optional(),
  totalVatAmount: z.lazy(() =>
    ListSalesInvoiceResponseTotalVatAmount$inboundSchema
  ).optional(),
  discountedSubtotalAmount: z.lazy(() =>
    ListSalesInvoiceResponseDiscountedSubtotalAmount$inboundSchema
  ).optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSalesInvoiceResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListSalesInvoiceResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  invoiceNumber?: string | null | undefined;
  status?: string | undefined;
  vatScheme?: string | undefined;
  vatMode?: string | undefined;
  memo?: string | null | undefined;
  metadata?: ListSalesInvoiceResponseMetadata$Outbound | null | undefined;
  paymentTerm?: string | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetailsResponse$Outbound | undefined;
  emailDetails?: SalesInvoiceEmailDetails$Outbound | null | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipientResponse$Outbound | null | undefined;
  lines?: Array<SalesInvoiceLineItemResponse$Outbound> | null | undefined;
  discount?: SalesInvoiceDiscountResponse$Outbound | null | undefined;
  amountDue?: ListSalesInvoiceResponseAmountDue$Outbound | undefined;
  subtotalAmount?: ListSalesInvoiceResponseSubtotalAmount$Outbound | undefined;
  totalAmount?: ListSalesInvoiceResponseTotalAmount$Outbound | undefined;
  totalVatAmount?: ListSalesInvoiceResponseTotalVatAmount$Outbound | undefined;
  discountedSubtotalAmount?:
    | ListSalesInvoiceResponseDiscountedSubtotalAmount$Outbound
    | undefined;
  createdAt?: string | undefined;
  issuedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  dueAt?: string | null | undefined;
  _links?: ListSalesInvoiceResponseLinks$Outbound | undefined;
};

/** @internal */
export const ListSalesInvoiceResponse$outboundSchema: z.ZodType<
  ListSalesInvoiceResponse$Outbound,
  z.ZodTypeDef,
  ListSalesInvoiceResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  invoiceNumber: z.nullable(z.string()).optional(),
  status: SalesInvoiceStatusResponse$outboundSchema.optional(),
  vatScheme: SalesInvoiceVatSchemeResponse$outboundSchema.optional(),
  vatMode: SalesInvoiceVatModeResponse$outboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.lazy(() => ListSalesInvoiceResponseMetadata$outboundSchema),
  ).optional(),
  paymentTerm: z.nullable(SalesInvoicePaymentTermResponse$outboundSchema)
    .optional(),
  paymentDetails: SalesInvoicePaymentDetailsResponse$outboundSchema.optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$outboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipientResponse$outboundSchema)
    .optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItemResponse$outboundSchema))
    .optional(),
  discount: z.nullable(SalesInvoiceDiscountResponse$outboundSchema).optional(),
  amountDue: z.lazy(() => ListSalesInvoiceResponseAmountDue$outboundSchema)
    .optional(),
  subtotalAmount: z.lazy(() =>
    ListSalesInvoiceResponseSubtotalAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSalesInvoiceResponseTotalAmount$outboundSchema)
    .optional(),
  totalVatAmount: z.lazy(() =>
    ListSalesInvoiceResponseTotalVatAmount$outboundSchema
  ).optional(),
  discountedSubtotalAmount: z.lazy(() =>
    ListSalesInvoiceResponseDiscountedSubtotalAmount$outboundSchema
  ).optional(),
  createdAt: z.string().optional(),
  issuedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  dueAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSalesInvoiceResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listSalesInvoiceResponseToJSON(
  listSalesInvoiceResponse: ListSalesInvoiceResponse,
): string {
  return JSON.stringify(
    ListSalesInvoiceResponse$outboundSchema.parse(listSalesInvoiceResponse),
  );
}
export function listSalesInvoiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListSalesInvoiceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSalesInvoiceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSalesInvoiceResponse' from JSON`,
  );
}
