/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  BalanceTransferDestinationType,
  BalanceTransferDestinationType$inboundSchema,
  BalanceTransferDestinationType$outboundSchema,
} from "./balancetransferdestinationtype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * The balance's ISO 4217 currency code.
 */
export const EntityBalanceCurrency = {
  Eur: "EUR",
  Gbp: "GBP",
  Chf: "CHF",
  Dkk: "DKK",
  Nok: "NOK",
  Pln: "PLN",
  Sek: "SEK",
  Usd: "USD",
  Czk: "CZK",
  Huf: "HUF",
  Aud: "AUD",
  Cad: "CAD",
} as const;
/**
 * The balance's ISO 4217 currency code.
 */
export type EntityBalanceCurrency = OpenEnum<typeof EntityBalanceCurrency>;

/**
 * The status of the balance.
 */
export const EntityBalanceStatus = {
  Active: "active",
  Inactive: "inactive",
} as const;
/**
 * The status of the balance.
 */
export type EntityBalanceStatus = OpenEnum<typeof EntityBalanceStatus>;

/**
 * The frequency with which the available amount on the balance will be settled to the configured transfer
 *
 * @remarks
 * destination.
 *
 * Settlements created during weekends or on bank holidays will take place on the next business day.
 */
export const EntityBalanceTransferFrequency = {
  EveryDay: "every-day",
  Daily: "daily",
  EveryMonday: "every-monday",
  EveryTuesday: "every-tuesday",
  EveryWednesday: "every-wednesday",
  EveryThursday: "every-thursday",
  EveryFriday: "every-friday",
  Monthly: "monthly",
  RevenueDay: "revenue-day",
  Never: "never",
} as const;
/**
 * The frequency with which the available amount on the balance will be settled to the configured transfer
 *
 * @remarks
 * destination.
 *
 * Settlements created during weekends or on bank holidays will take place on the next business day.
 */
export type EntityBalanceTransferFrequency = OpenEnum<
  typeof EntityBalanceTransferFrequency
>;

/**
 * The minimum amount configured for scheduled automatic settlements. As soon as the amount on the balance exceeds
 *
 * @remarks
 * this threshold, the complete balance will be paid out to the transfer destination according to the configured
 * frequency.
 */
export type EntityBalanceTransferThreshold = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The destination where the available amount will be automatically transferred to according to the configured
 *
 * @remarks
 * transfer frequency.
 */
export type EntityBalanceTransferDestination = {
  /**
   * The default destination of automatic scheduled transfers. Currently only `bank-account` is supported.
   *
   * @remarks
   *
   * * `bank-account` â€” Transfer the balance amount to an external bank account
   */
  type?: BalanceTransferDestinationType | undefined;
  /**
   * The configured bank account number of the beneficiary the balance amount is to be transferred to.
   */
  bankAccount?: string | undefined;
  /**
   * The full name of the beneficiary the balance amount is to be transferred to.
   */
  beneficiaryName?: string | undefined;
};

/**
 * The amount directly available on the balance, e.g. `{"currency":"EUR", "value":"100.00"}`.
 */
export type EntityBalanceAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is queued to be transferred to your balance. For example, a credit card payment can take a
 *
 * @remarks
 * few days to clear.
 */
export type EntityBalancePendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntityBalanceLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
};

export type EntityBalance = {
  /**
   * Indicates the response contains a balance object. Will always contain the string `balance` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this balance.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The balance's ISO 4217 currency code.
   */
  currency: EntityBalanceCurrency;
  /**
   * The description or name of the balance. Can be used to denote the purpose of the balance.
   */
  description: string;
  status: EntityBalanceStatus;
  transferFrequency?: EntityBalanceTransferFrequency | undefined;
  /**
   * The minimum amount configured for scheduled automatic settlements. As soon as the amount on the balance exceeds
   *
   * @remarks
   * this threshold, the complete balance will be paid out to the transfer destination according to the configured
   * frequency.
   */
  transferThreshold?: EntityBalanceTransferThreshold | undefined;
  /**
   * The transfer reference set to be included in all the transfers for this balance.
   */
  transferReference?: string | null | undefined;
  /**
   * The destination where the available amount will be automatically transferred to according to the configured
   *
   * @remarks
   * transfer frequency.
   */
  transferDestination?: EntityBalanceTransferDestination | null | undefined;
  /**
   * The amount directly available on the balance, e.g. `{"currency":"EUR", "value":"100.00"}`.
   */
  availableAmount: EntityBalanceAvailableAmount;
  /**
   * The total amount that is queued to be transferred to your balance. For example, a credit card payment can take a
   *
   * @remarks
   * few days to clear.
   */
  pendingAmount: EntityBalancePendingAmount;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: EntityBalanceLinks;
};

/** @internal */
export const EntityBalanceCurrency$inboundSchema: z.ZodType<
  EntityBalanceCurrency,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(EntityBalanceCurrency);
/** @internal */
export const EntityBalanceCurrency$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EntityBalanceCurrency
> = openEnums.outboundSchema(EntityBalanceCurrency);

/** @internal */
export const EntityBalanceStatus$inboundSchema: z.ZodType<
  EntityBalanceStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(EntityBalanceStatus);
/** @internal */
export const EntityBalanceStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EntityBalanceStatus
> = openEnums.outboundSchema(EntityBalanceStatus);

/** @internal */
export const EntityBalanceTransferFrequency$inboundSchema: z.ZodType<
  EntityBalanceTransferFrequency,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(EntityBalanceTransferFrequency);
/** @internal */
export const EntityBalanceTransferFrequency$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EntityBalanceTransferFrequency
> = openEnums.outboundSchema(EntityBalanceTransferFrequency);

/** @internal */
export const EntityBalanceTransferThreshold$inboundSchema: z.ZodType<
  EntityBalanceTransferThreshold,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type EntityBalanceTransferThreshold$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const EntityBalanceTransferThreshold$outboundSchema: z.ZodType<
  EntityBalanceTransferThreshold$Outbound,
  z.ZodTypeDef,
  EntityBalanceTransferThreshold
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function entityBalanceTransferThresholdToJSON(
  entityBalanceTransferThreshold: EntityBalanceTransferThreshold,
): string {
  return JSON.stringify(
    EntityBalanceTransferThreshold$outboundSchema.parse(
      entityBalanceTransferThreshold,
    ),
  );
}
export function entityBalanceTransferThresholdFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceTransferThreshold, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceTransferThreshold$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceTransferThreshold' from JSON`,
  );
}

/** @internal */
export const EntityBalanceTransferDestination$inboundSchema: z.ZodType<
  EntityBalanceTransferDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: BalanceTransferDestinationType$inboundSchema.optional(),
  bankAccount: z.string().optional(),
  beneficiaryName: z.string().optional(),
});
/** @internal */
export type EntityBalanceTransferDestination$Outbound = {
  type?: string | undefined;
  bankAccount?: string | undefined;
  beneficiaryName?: string | undefined;
};

/** @internal */
export const EntityBalanceTransferDestination$outboundSchema: z.ZodType<
  EntityBalanceTransferDestination$Outbound,
  z.ZodTypeDef,
  EntityBalanceTransferDestination
> = z.object({
  type: BalanceTransferDestinationType$outboundSchema.optional(),
  bankAccount: z.string().optional(),
  beneficiaryName: z.string().optional(),
});

export function entityBalanceTransferDestinationToJSON(
  entityBalanceTransferDestination: EntityBalanceTransferDestination,
): string {
  return JSON.stringify(
    EntityBalanceTransferDestination$outboundSchema.parse(
      entityBalanceTransferDestination,
    ),
  );
}
export function entityBalanceTransferDestinationFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceTransferDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceTransferDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceTransferDestination' from JSON`,
  );
}

/** @internal */
export const EntityBalanceAvailableAmount$inboundSchema: z.ZodType<
  EntityBalanceAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type EntityBalanceAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const EntityBalanceAvailableAmount$outboundSchema: z.ZodType<
  EntityBalanceAvailableAmount$Outbound,
  z.ZodTypeDef,
  EntityBalanceAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function entityBalanceAvailableAmountToJSON(
  entityBalanceAvailableAmount: EntityBalanceAvailableAmount,
): string {
  return JSON.stringify(
    EntityBalanceAvailableAmount$outboundSchema.parse(
      entityBalanceAvailableAmount,
    ),
  );
}
export function entityBalanceAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceAvailableAmount' from JSON`,
  );
}

/** @internal */
export const EntityBalancePendingAmount$inboundSchema: z.ZodType<
  EntityBalancePendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type EntityBalancePendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const EntityBalancePendingAmount$outboundSchema: z.ZodType<
  EntityBalancePendingAmount$Outbound,
  z.ZodTypeDef,
  EntityBalancePendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function entityBalancePendingAmountToJSON(
  entityBalancePendingAmount: EntityBalancePendingAmount,
): string {
  return JSON.stringify(
    EntityBalancePendingAmount$outboundSchema.parse(entityBalancePendingAmount),
  );
}
export function entityBalancePendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalancePendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalancePendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalancePendingAmount' from JSON`,
  );
}

/** @internal */
export const EntityBalanceLinks$inboundSchema: z.ZodType<
  EntityBalanceLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
});
/** @internal */
export type EntityBalanceLinks$Outbound = {
  self?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
};

/** @internal */
export const EntityBalanceLinks$outboundSchema: z.ZodType<
  EntityBalanceLinks$Outbound,
  z.ZodTypeDef,
  EntityBalanceLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
});

export function entityBalanceLinksToJSON(
  entityBalanceLinks: EntityBalanceLinks,
): string {
  return JSON.stringify(
    EntityBalanceLinks$outboundSchema.parse(entityBalanceLinks),
  );
}
export function entityBalanceLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceLinks' from JSON`,
  );
}

/** @internal */
export const EntityBalance$inboundSchema: z.ZodType<
  EntityBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  createdAt: z.string(),
  currency: EntityBalanceCurrency$inboundSchema,
  description: z.string(),
  status: EntityBalanceStatus$inboundSchema,
  transferFrequency: EntityBalanceTransferFrequency$inboundSchema.optional(),
  transferThreshold: z.lazy(() => EntityBalanceTransferThreshold$inboundSchema)
    .optional(),
  transferReference: z.nullable(z.string()).optional(),
  transferDestination: z.nullable(
    z.lazy(() => EntityBalanceTransferDestination$inboundSchema),
  ).optional(),
  availableAmount: z.lazy(() => EntityBalanceAvailableAmount$inboundSchema),
  pendingAmount: z.lazy(() => EntityBalancePendingAmount$inboundSchema),
  _links: z.lazy(() => EntityBalanceLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type EntityBalance$Outbound = {
  resource: string;
  id: string;
  mode: string;
  createdAt: string;
  currency: string;
  description: string;
  status: string;
  transferFrequency?: string | undefined;
  transferThreshold?: EntityBalanceTransferThreshold$Outbound | undefined;
  transferReference?: string | null | undefined;
  transferDestination?:
    | EntityBalanceTransferDestination$Outbound
    | null
    | undefined;
  availableAmount: EntityBalanceAvailableAmount$Outbound;
  pendingAmount: EntityBalancePendingAmount$Outbound;
  _links: EntityBalanceLinks$Outbound;
};

/** @internal */
export const EntityBalance$outboundSchema: z.ZodType<
  EntityBalance$Outbound,
  z.ZodTypeDef,
  EntityBalance
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  createdAt: z.string(),
  currency: EntityBalanceCurrency$outboundSchema,
  description: z.string(),
  status: EntityBalanceStatus$outboundSchema,
  transferFrequency: EntityBalanceTransferFrequency$outboundSchema.optional(),
  transferThreshold: z.lazy(() => EntityBalanceTransferThreshold$outboundSchema)
    .optional(),
  transferReference: z.nullable(z.string()).optional(),
  transferDestination: z.nullable(
    z.lazy(() => EntityBalanceTransferDestination$outboundSchema),
  ).optional(),
  availableAmount: z.lazy(() => EntityBalanceAvailableAmount$outboundSchema),
  pendingAmount: z.lazy(() => EntityBalancePendingAmount$outboundSchema),
  links: z.lazy(() => EntityBalanceLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function entityBalanceToJSON(entityBalance: EntityBalance): string {
  return JSON.stringify(EntityBalance$outboundSchema.parse(entityBalance));
}
export function entityBalanceFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalance' from JSON`,
  );
}
