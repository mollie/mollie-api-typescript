/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MethodStatus,
  MethodStatus$inboundSchema,
  MethodStatus$outboundSchema,
} from "./methodstatus.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * The unique identifier of the payment method. When used during [payment creation](create-payment), the payment
 *
 * @remarks
 * method selection screen will be skipped.
 */
export const ListEntityMethodAllId = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Mobilepay: "mobilepay",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Vipps: "vipps",
  Voucher: "voucher",
} as const;
/**
 * The unique identifier of the payment method. When used during [payment creation](create-payment), the payment
 *
 * @remarks
 * method selection screen will be skipped.
 */
export type ListEntityMethodAllId = OpenEnum<typeof ListEntityMethodAllId>;

/**
 * The minimum payment amount required to use this payment method.
 */
export type ListEntityMethodAllMinimumAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The maximum payment amount allowed when using this payment method. If there is no method-specific maximum, `null`
 *
 * @remarks
 * is returned instead.
 */
export type ListEntityMethodAllMaximumAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * URLs of images representing the payment method.
 */
export type ListEntityMethodAllImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x: string;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x: string;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can
   *
   * @remarks
   * scale to any desired size without compromising visual quality.
   */
  svg: string;
};

/**
 * URLs of images representing the issuer.
 *
 * @remarks
 * required:
 *   - size1x
 *   - size2x
 *   - svg
 */
export type ListEntityMethodAllIssuerImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x?: string | undefined;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x?: string | undefined;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can
   *
   * @remarks
   * scale to any desired size without compromising visual quality.
   */
  svg?: string | undefined;
};

export type ListEntityMethodAllIssuer = {
  resource: string;
  id: string;
  /**
   * The full name of the issuer.
   */
  name: string;
  /**
   * URLs of images representing the issuer.
   *
   * @remarks
   * required:
   *   - size1x
   *   - size2x
   *   - svg
   */
  image: ListEntityMethodAllIssuerImage;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListEntityMethodAllLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
};

export type Pricing = {
  /**
   * A description of what the pricing applies to. For example, a specific country (`The Netherlands`) or a
   *
   * @remarks
   * category of cards (`American Express`). If a `locale` is provided, the description may be translated.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  fixed: Amount;
  /**
   * The variable price charged per payment, as a percentage string.
   */
  variable: string;
  /**
   * Only present for credit card pricing. It will correspond with the `feeRegion` of credit card payments as
   *
   * @remarks
   * returned in the [Payments API](get-payment).
   */
  feeRegion?: string | null | undefined;
};

export type ListEntityMethodAll = {
  /**
   * Indicates the response contains a payment method object. Will always contain the string `method` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The unique identifier of the payment method. When used during [payment creation](create-payment), the payment
   *
   * @remarks
   * method selection screen will be skipped.
   */
  id: ListEntityMethodAllId | null;
  /**
   * The full name of the payment method.
   *
   * @remarks
   *
   * If a `locale` parameter is provided, the name is translated to the given locale if possible.
   */
  description: string;
  /**
   * The minimum payment amount required to use this payment method.
   */
  minimumAmount: ListEntityMethodAllMinimumAmount;
  /**
   * The maximum payment amount allowed when using this payment method. If there is no method-specific maximum, `null`
   *
   * @remarks
   * is returned instead.
   */
  maximumAmount: ListEntityMethodAllMaximumAmount | null;
  /**
   * URLs of images representing the payment method.
   */
  image: ListEntityMethodAllImage;
  /**
   * The payment method's activation status for this profile.
   */
  status: MethodStatus | null;
  /**
   * **Optional include.** Array of objects for each 'issuer' that is available for this payment method. Only relevant
   *
   * @remarks
   * for iDEAL, KBC/CBC, gift cards, and vouchers.
   */
  issuers?: Array<ListEntityMethodAllIssuer> | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListEntityMethodAllLinks;
  /**
   * **Optional include.** Array of objects describing the pricing configuration applicable for this payment method on
   *
   * @remarks
   * your account.
   */
  pricing?: Array<Pricing> | undefined;
};

/** @internal */
export const ListEntityMethodAllId$inboundSchema: z.ZodType<
  ListEntityMethodAllId,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ListEntityMethodAllId);
/** @internal */
export const ListEntityMethodAllId$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ListEntityMethodAllId
> = openEnums.outboundSchema(ListEntityMethodAllId);

/** @internal */
export const ListEntityMethodAllMinimumAmount$inboundSchema: z.ZodType<
  ListEntityMethodAllMinimumAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListEntityMethodAllMinimumAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListEntityMethodAllMinimumAmount$outboundSchema: z.ZodType<
  ListEntityMethodAllMinimumAmount$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllMinimumAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listEntityMethodAllMinimumAmountToJSON(
  listEntityMethodAllMinimumAmount: ListEntityMethodAllMinimumAmount,
): string {
  return JSON.stringify(
    ListEntityMethodAllMinimumAmount$outboundSchema.parse(
      listEntityMethodAllMinimumAmount,
    ),
  );
}
export function listEntityMethodAllMinimumAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllMinimumAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllMinimumAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllMinimumAmount' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAllMaximumAmount$inboundSchema: z.ZodType<
  ListEntityMethodAllMaximumAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});
/** @internal */
export type ListEntityMethodAllMaximumAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListEntityMethodAllMaximumAmount$outboundSchema: z.ZodType<
  ListEntityMethodAllMaximumAmount$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllMaximumAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

export function listEntityMethodAllMaximumAmountToJSON(
  listEntityMethodAllMaximumAmount: ListEntityMethodAllMaximumAmount,
): string {
  return JSON.stringify(
    ListEntityMethodAllMaximumAmount$outboundSchema.parse(
      listEntityMethodAllMaximumAmount,
    ),
  );
}
export function listEntityMethodAllMaximumAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllMaximumAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllMaximumAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllMaximumAmount' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAllImage$inboundSchema: z.ZodType<
  ListEntityMethodAllImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});
/** @internal */
export type ListEntityMethodAllImage$Outbound = {
  size1x: string;
  size2x: string;
  svg: string;
};

/** @internal */
export const ListEntityMethodAllImage$outboundSchema: z.ZodType<
  ListEntityMethodAllImage$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllImage
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});

export function listEntityMethodAllImageToJSON(
  listEntityMethodAllImage: ListEntityMethodAllImage,
): string {
  return JSON.stringify(
    ListEntityMethodAllImage$outboundSchema.parse(listEntityMethodAllImage),
  );
}
export function listEntityMethodAllImageFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllImage' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAllIssuerImage$inboundSchema: z.ZodType<
  ListEntityMethodAllIssuerImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});
/** @internal */
export type ListEntityMethodAllIssuerImage$Outbound = {
  size1x?: string | undefined;
  size2x?: string | undefined;
  svg?: string | undefined;
};

/** @internal */
export const ListEntityMethodAllIssuerImage$outboundSchema: z.ZodType<
  ListEntityMethodAllIssuerImage$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllIssuerImage
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});

export function listEntityMethodAllIssuerImageToJSON(
  listEntityMethodAllIssuerImage: ListEntityMethodAllIssuerImage,
): string {
  return JSON.stringify(
    ListEntityMethodAllIssuerImage$outboundSchema.parse(
      listEntityMethodAllIssuerImage,
    ),
  );
}
export function listEntityMethodAllIssuerImageFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllIssuerImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllIssuerImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllIssuerImage' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAllIssuer$inboundSchema: z.ZodType<
  ListEntityMethodAllIssuer,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => ListEntityMethodAllIssuerImage$inboundSchema),
});
/** @internal */
export type ListEntityMethodAllIssuer$Outbound = {
  resource: string;
  id: string;
  name: string;
  image: ListEntityMethodAllIssuerImage$Outbound;
};

/** @internal */
export const ListEntityMethodAllIssuer$outboundSchema: z.ZodType<
  ListEntityMethodAllIssuer$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllIssuer
> = z.object({
  resource: z.string(),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => ListEntityMethodAllIssuerImage$outboundSchema),
});

export function listEntityMethodAllIssuerToJSON(
  listEntityMethodAllIssuer: ListEntityMethodAllIssuer,
): string {
  return JSON.stringify(
    ListEntityMethodAllIssuer$outboundSchema.parse(listEntityMethodAllIssuer),
  );
}
export function listEntityMethodAllIssuerFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllIssuer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllIssuer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllIssuer' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAllLinks$inboundSchema: z.ZodType<
  ListEntityMethodAllLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
});
/** @internal */
export type ListEntityMethodAllLinks$Outbound = {
  self: Url$Outbound;
};

/** @internal */
export const ListEntityMethodAllLinks$outboundSchema: z.ZodType<
  ListEntityMethodAllLinks$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAllLinks
> = z.object({
  self: Url$outboundSchema,
});

export function listEntityMethodAllLinksToJSON(
  listEntityMethodAllLinks: ListEntityMethodAllLinks,
): string {
  return JSON.stringify(
    ListEntityMethodAllLinks$outboundSchema.parse(listEntityMethodAllLinks),
  );
}
export function listEntityMethodAllLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAllLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAllLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAllLinks' from JSON`,
  );
}

/** @internal */
export const Pricing$inboundSchema: z.ZodType<Pricing, z.ZodTypeDef, unknown> =
  z.object({
    description: z.string(),
    fixed: Amount$inboundSchema,
    variable: z.string(),
    feeRegion: z.nullable(z.string()).optional(),
  });
/** @internal */
export type Pricing$Outbound = {
  description: string;
  fixed: Amount$Outbound;
  variable: string;
  feeRegion?: string | null | undefined;
};

/** @internal */
export const Pricing$outboundSchema: z.ZodType<
  Pricing$Outbound,
  z.ZodTypeDef,
  Pricing
> = z.object({
  description: z.string(),
  fixed: Amount$outboundSchema,
  variable: z.string(),
  feeRegion: z.nullable(z.string()).optional(),
});

export function pricingToJSON(pricing: Pricing): string {
  return JSON.stringify(Pricing$outboundSchema.parse(pricing));
}
export function pricingFromJSON(
  jsonString: string,
): SafeParseResult<Pricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pricing' from JSON`,
  );
}

/** @internal */
export const ListEntityMethodAll$inboundSchema: z.ZodType<
  ListEntityMethodAll,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.nullable(ListEntityMethodAllId$inboundSchema),
  description: z.string(),
  minimumAmount: z.lazy(() => ListEntityMethodAllMinimumAmount$inboundSchema),
  maximumAmount: z.nullable(
    z.lazy(() => ListEntityMethodAllMaximumAmount$inboundSchema),
  ),
  image: z.lazy(() => ListEntityMethodAllImage$inboundSchema),
  status: z.nullable(MethodStatus$inboundSchema),
  issuers: z.array(z.lazy(() => ListEntityMethodAllIssuer$inboundSchema))
    .optional(),
  _links: z.lazy(() => ListEntityMethodAllLinks$inboundSchema),
  pricing: z.array(z.lazy(() => Pricing$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListEntityMethodAll$Outbound = {
  resource: string;
  id: string | null;
  description: string;
  minimumAmount: ListEntityMethodAllMinimumAmount$Outbound;
  maximumAmount: ListEntityMethodAllMaximumAmount$Outbound | null;
  image: ListEntityMethodAllImage$Outbound;
  status: string | null;
  issuers?: Array<ListEntityMethodAllIssuer$Outbound> | undefined;
  _links: ListEntityMethodAllLinks$Outbound;
  pricing?: Array<Pricing$Outbound> | undefined;
};

/** @internal */
export const ListEntityMethodAll$outboundSchema: z.ZodType<
  ListEntityMethodAll$Outbound,
  z.ZodTypeDef,
  ListEntityMethodAll
> = z.object({
  resource: z.string(),
  id: z.nullable(ListEntityMethodAllId$outboundSchema),
  description: z.string(),
  minimumAmount: z.lazy(() => ListEntityMethodAllMinimumAmount$outboundSchema),
  maximumAmount: z.nullable(
    z.lazy(() => ListEntityMethodAllMaximumAmount$outboundSchema),
  ),
  image: z.lazy(() => ListEntityMethodAllImage$outboundSchema),
  status: z.nullable(MethodStatus$outboundSchema),
  issuers: z.array(z.lazy(() => ListEntityMethodAllIssuer$outboundSchema))
    .optional(),
  links: z.lazy(() => ListEntityMethodAllLinks$outboundSchema),
  pricing: z.array(z.lazy(() => Pricing$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listEntityMethodAllToJSON(
  listEntityMethodAll: ListEntityMethodAll,
): string {
  return JSON.stringify(
    ListEntityMethodAll$outboundSchema.parse(listEntityMethodAll),
  );
}
export function listEntityMethodAllFromJSON(
  jsonString: string,
): SafeParseResult<ListEntityMethodAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListEntityMethodAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListEntityMethodAll' from JSON`,
  );
}
