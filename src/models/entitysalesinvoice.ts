/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SalesInvoiceDiscount,
  SalesInvoiceDiscount$inboundSchema,
  SalesInvoiceDiscount$Outbound,
  SalesInvoiceDiscount$outboundSchema,
} from "./salesinvoicediscount.js";
import {
  SalesInvoiceEmailDetails,
  SalesInvoiceEmailDetails$inboundSchema,
  SalesInvoiceEmailDetails$Outbound,
  SalesInvoiceEmailDetails$outboundSchema,
} from "./salesinvoiceemaildetails.js";
import {
  SalesInvoiceLineItem,
  SalesInvoiceLineItem$inboundSchema,
  SalesInvoiceLineItem$Outbound,
  SalesInvoiceLineItem$outboundSchema,
} from "./salesinvoicelineitem.js";
import {
  SalesInvoicePaymentDetails,
  SalesInvoicePaymentDetails$inboundSchema,
  SalesInvoicePaymentDetails$Outbound,
  SalesInvoicePaymentDetails$outboundSchema,
} from "./salesinvoicepaymentdetails.js";
import {
  SalesInvoiceRecipient,
  SalesInvoiceRecipient$inboundSchema,
  SalesInvoiceRecipient$Outbound,
  SalesInvoiceRecipient$outboundSchema,
} from "./salesinvoicerecipient.js";

/**
 * The status for the invoice to end up in.
 *
 * @remarks
 *
 * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
 * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
 * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
 *
 * A status value that cannot be set but can be returned is `canceled`, for invoices which were
 * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
 *
 * Dependent parameters:
 *   - `paymentDetails` is required if invoice should be set directly to `paid`
 *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
 *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
 */
export const EntitySalesInvoiceStatus = {
  Draft: "draft",
  Issued: "issued",
  Paid: "paid",
} as const;
/**
 * The status for the invoice to end up in.
 *
 * @remarks
 *
 * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
 * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
 * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
 *
 * A status value that cannot be set but can be returned is `canceled`, for invoices which were
 * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
 *
 * Dependent parameters:
 *   - `paymentDetails` is required if invoice should be set directly to `paid`
 *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
 *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
 */
export type EntitySalesInvoiceStatus = ClosedEnum<
  typeof EntitySalesInvoiceStatus
>;

/**
 * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
 */
export const EntitySalesInvoiceVatScheme = {
  Standard: "standard",
  OneStopShop: "one-stop-shop",
} as const;
/**
 * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
 */
export type EntitySalesInvoiceVatScheme = ClosedEnum<
  typeof EntitySalesInvoiceVatScheme
>;

/**
 * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
 *
 * @remarks
 * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
 */
export const EntitySalesInvoiceVatMode = {
  Exclusive: "exclusive",
  Inclusive: "inclusive",
} as const;
/**
 * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
 *
 * @remarks
 * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
 */
export type EntitySalesInvoiceVatMode = ClosedEnum<
  typeof EntitySalesInvoiceVatMode
>;

/**
 * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type EntitySalesInvoiceMetadata = {};

/**
 * The payment term to be set on the invoice.
 */
export const EntitySalesInvoicePaymentTerm = {
  Sevendays: "7 days",
  Fourteendays: "14 days",
  Thirtydays: "30 days",
  FortyFivedays: "45 days",
  Sixtydays: "60 days",
  Ninetydays: "90 days",
  OneHundredAndTwentydays: "120 days",
} as const;
/**
 * The payment term to be set on the invoice.
 */
export type EntitySalesInvoicePaymentTerm = ClosedEnum<
  typeof EntitySalesInvoicePaymentTerm
>;

export type EntitySalesInvoice = {
  id?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | null | undefined;
  /**
   * The status for the invoice to end up in.
   *
   * @remarks
   *
   * A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
   * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
   * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
   *
   * A status value that cannot be set but can be returned is `canceled`, for invoices which were
   * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
   *
   * Dependent parameters:
   *   - `paymentDetails` is required if invoice should be set directly to `paid`
   *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
   *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
   */
  status?: EntitySalesInvoiceStatus | undefined;
  /**
   * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
   */
  vatScheme?: EntitySalesInvoiceVatScheme | undefined;
  /**
   * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
   *
   * @remarks
   * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
   */
  vatMode?: EntitySalesInvoiceVatMode | undefined;
  /**
   * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
   */
  memo?: string | null | undefined;
  /**
   * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: EntitySalesInvoiceMetadata | null | undefined;
  /**
   * The payment term to be set on the invoice.
   */
  paymentTerm?: EntitySalesInvoicePaymentTerm | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetails | null | undefined;
  emailDetails?: SalesInvoiceEmailDetails | null | undefined;
  /**
   * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
   *
   * @remarks
   * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  customerId?: string | undefined;
  /**
   * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
   *
   * @remarks
   * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
   */
  mandateId?: string | undefined;
  /**
   * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
   *
   * @remarks
   * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
   * is not required to send a first invoice to a recipient.
   */
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipient | null | undefined;
  /**
   * Provide the line items for the invoice. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the invoice.
   */
  lines?: Array<SalesInvoiceLineItem> | null | undefined;
  discount?: SalesInvoiceDiscount | null | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountDue?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  subtotalAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalVatAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountedSubtotalAmount?: Amount | undefined;
};

/** @internal */
export const EntitySalesInvoiceStatus$inboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceStatus
> = z.nativeEnum(EntitySalesInvoiceStatus);

/** @internal */
export const EntitySalesInvoiceStatus$outboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceStatus
> = EntitySalesInvoiceStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceStatus$ {
  /** @deprecated use `EntitySalesInvoiceStatus$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceStatus$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceStatus$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceStatus$outboundSchema;
}

/** @internal */
export const EntitySalesInvoiceVatScheme$inboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceVatScheme
> = z.nativeEnum(EntitySalesInvoiceVatScheme);

/** @internal */
export const EntitySalesInvoiceVatScheme$outboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceVatScheme
> = EntitySalesInvoiceVatScheme$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceVatScheme$ {
  /** @deprecated use `EntitySalesInvoiceVatScheme$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceVatScheme$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceVatScheme$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceVatScheme$outboundSchema;
}

/** @internal */
export const EntitySalesInvoiceVatMode$inboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceVatMode
> = z.nativeEnum(EntitySalesInvoiceVatMode);

/** @internal */
export const EntitySalesInvoiceVatMode$outboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoiceVatMode
> = EntitySalesInvoiceVatMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceVatMode$ {
  /** @deprecated use `EntitySalesInvoiceVatMode$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceVatMode$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceVatMode$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceVatMode$outboundSchema;
}

/** @internal */
export const EntitySalesInvoiceMetadata$inboundSchema: z.ZodType<
  EntitySalesInvoiceMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type EntitySalesInvoiceMetadata$Outbound = {};

/** @internal */
export const EntitySalesInvoiceMetadata$outboundSchema: z.ZodType<
  EntitySalesInvoiceMetadata$Outbound,
  z.ZodTypeDef,
  EntitySalesInvoiceMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoiceMetadata$ {
  /** @deprecated use `EntitySalesInvoiceMetadata$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoiceMetadata$inboundSchema;
  /** @deprecated use `EntitySalesInvoiceMetadata$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoiceMetadata$outboundSchema;
  /** @deprecated use `EntitySalesInvoiceMetadata$Outbound` instead. */
  export type Outbound = EntitySalesInvoiceMetadata$Outbound;
}

export function entitySalesInvoiceMetadataToJSON(
  entitySalesInvoiceMetadata: EntitySalesInvoiceMetadata,
): string {
  return JSON.stringify(
    EntitySalesInvoiceMetadata$outboundSchema.parse(entitySalesInvoiceMetadata),
  );
}

export function entitySalesInvoiceMetadataFromJSON(
  jsonString: string,
): SafeParseResult<EntitySalesInvoiceMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySalesInvoiceMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySalesInvoiceMetadata' from JSON`,
  );
}

/** @internal */
export const EntitySalesInvoicePaymentTerm$inboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoicePaymentTerm
> = z.nativeEnum(EntitySalesInvoicePaymentTerm);

/** @internal */
export const EntitySalesInvoicePaymentTerm$outboundSchema: z.ZodNativeEnum<
  typeof EntitySalesInvoicePaymentTerm
> = EntitySalesInvoicePaymentTerm$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoicePaymentTerm$ {
  /** @deprecated use `EntitySalesInvoicePaymentTerm$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoicePaymentTerm$inboundSchema;
  /** @deprecated use `EntitySalesInvoicePaymentTerm$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoicePaymentTerm$outboundSchema;
}

/** @internal */
export const EntitySalesInvoice$inboundSchema: z.ZodType<
  EntitySalesInvoice,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  profileId: z.nullable(z.string()).optional(),
  status: EntitySalesInvoiceStatus$inboundSchema.optional(),
  vatScheme: EntitySalesInvoiceVatScheme$inboundSchema.optional(),
  vatMode: EntitySalesInvoiceVatMode$inboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.lazy(() => EntitySalesInvoiceMetadata$inboundSchema))
    .optional(),
  paymentTerm: z.nullable(EntitySalesInvoicePaymentTerm$inboundSchema)
    .optional(),
  paymentDetails: z.nullable(SalesInvoicePaymentDetails$inboundSchema)
    .optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$inboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipient$inboundSchema).optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItem$inboundSchema)).optional(),
  discount: z.nullable(SalesInvoiceDiscount$inboundSchema).optional(),
  amountDue: Amount$inboundSchema.optional(),
  subtotalAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema.optional(),
  totalVatAmount: Amount$inboundSchema.optional(),
  discountedSubtotalAmount: Amount$inboundSchema.optional(),
});

/** @internal */
export type EntitySalesInvoice$Outbound = {
  id?: string | undefined;
  testmode?: boolean | null | undefined;
  profileId?: string | null | undefined;
  status?: string | undefined;
  vatScheme?: string | undefined;
  vatMode?: string | undefined;
  memo?: string | null | undefined;
  metadata?: EntitySalesInvoiceMetadata$Outbound | null | undefined;
  paymentTerm?: string | null | undefined;
  paymentDetails?: SalesInvoicePaymentDetails$Outbound | null | undefined;
  emailDetails?: SalesInvoiceEmailDetails$Outbound | null | undefined;
  customerId?: string | undefined;
  mandateId?: string | undefined;
  recipientIdentifier?: string | undefined;
  recipient?: SalesInvoiceRecipient$Outbound | null | undefined;
  lines?: Array<SalesInvoiceLineItem$Outbound> | null | undefined;
  discount?: SalesInvoiceDiscount$Outbound | null | undefined;
  amountDue?: Amount$Outbound | undefined;
  subtotalAmount?: Amount$Outbound | undefined;
  totalAmount?: Amount$Outbound | undefined;
  totalVatAmount?: Amount$Outbound | undefined;
  discountedSubtotalAmount?: Amount$Outbound | undefined;
};

/** @internal */
export const EntitySalesInvoice$outboundSchema: z.ZodType<
  EntitySalesInvoice$Outbound,
  z.ZodTypeDef,
  EntitySalesInvoice
> = z.object({
  id: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
  profileId: z.nullable(z.string()).optional(),
  status: EntitySalesInvoiceStatus$outboundSchema.optional(),
  vatScheme: EntitySalesInvoiceVatScheme$outboundSchema.optional(),
  vatMode: EntitySalesInvoiceVatMode$outboundSchema.optional(),
  memo: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.lazy(() => EntitySalesInvoiceMetadata$outboundSchema))
    .optional(),
  paymentTerm: z.nullable(EntitySalesInvoicePaymentTerm$outboundSchema)
    .optional(),
  paymentDetails: z.nullable(SalesInvoicePaymentDetails$outboundSchema)
    .optional(),
  emailDetails: z.nullable(SalesInvoiceEmailDetails$outboundSchema).optional(),
  customerId: z.string().optional(),
  mandateId: z.string().optional(),
  recipientIdentifier: z.string().optional(),
  recipient: z.nullable(SalesInvoiceRecipient$outboundSchema).optional(),
  lines: z.nullable(z.array(SalesInvoiceLineItem$outboundSchema)).optional(),
  discount: z.nullable(SalesInvoiceDiscount$outboundSchema).optional(),
  amountDue: Amount$outboundSchema.optional(),
  subtotalAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema.optional(),
  totalVatAmount: Amount$outboundSchema.optional(),
  discountedSubtotalAmount: Amount$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntitySalesInvoice$ {
  /** @deprecated use `EntitySalesInvoice$inboundSchema` instead. */
  export const inboundSchema = EntitySalesInvoice$inboundSchema;
  /** @deprecated use `EntitySalesInvoice$outboundSchema` instead. */
  export const outboundSchema = EntitySalesInvoice$outboundSchema;
  /** @deprecated use `EntitySalesInvoice$Outbound` instead. */
  export type Outbound = EntitySalesInvoice$Outbound;
}

export function entitySalesInvoiceToJSON(
  entitySalesInvoice: EntitySalesInvoice,
): string {
  return JSON.stringify(
    EntitySalesInvoice$outboundSchema.parse(entitySalesInvoice),
  );
}

export function entitySalesInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<EntitySalesInvoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntitySalesInvoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntitySalesInvoice' from JSON`,
  );
}
