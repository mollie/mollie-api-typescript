/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  BalanceReportGrouping,
  BalanceReportGrouping$inboundSchema,
  BalanceReportGrouping$outboundSchema,
} from "./balancereportgrouping.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SubGroup,
  SubGroup$inboundSchema,
  SubGroup$Outbound,
  SubGroup$outboundSchema,
} from "./subgroup.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * The pending balance. Only available if grouping is `status-balances`.
 */
export type PendingBalance = {
  open?: SubGroup | undefined;
  close?: SubGroup | undefined;
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
};

/**
 * The available balance. Only available if grouping is `status-balances`.
 */
export type AvailableBalance = {
  open?: SubGroup | undefined;
  movedFromPending?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
  close?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Open = {
  pending?: SubGroup | undefined;
  available?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Close = {
  pending?: SubGroup | undefined;
  available?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Payments = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Refunds = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Chargebacks = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Capital = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Transfers = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type FeePrepayments = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Corrections = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Topups = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
 *
 * @remarks
 * typical grouping looks like.
 *
 * If grouping `status-balances` is chosen, the main grouping is as follows:
 *
 * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
 * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
 *
 * If grouping `transaction-categories` is chosen, the main grouping is as follows:
 *
 * * `open` and `close` groups, each containing a `pending` and `available` sub-group
 * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
 * each containing a `pending`, `movedToAvailable`, and
 * `immediatelyAvailable` sub-group
 *
 * Each sub-group typically has:
 *
 * * An `amount` object containing the group's total amount
 * * A `count` integer if relevant (for example, counting the number of refunds)
 * * A `subtotals` array containing more sub-group objects if applicable
 */
export type Totals = {
  /**
   * The pending balance. Only available if grouping is `status-balances`.
   */
  pendingBalance?: PendingBalance | null | undefined;
  /**
   * The available balance. Only available if grouping is `status-balances`.
   */
  availableBalance?: AvailableBalance | null | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  open?: Open | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  close?: Close | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  payments?: Payments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  refunds?: Refunds | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  chargebacks?: Chargebacks | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  capital?: Capital | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  transfers?: Transfers | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  feePrepayments?: FeePrepayments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  corrections?: Corrections | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  topups?: Topups | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntityBalanceReportLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
};

export type EntityBalanceReport = {
  /**
   * Indicates the response contains a balance report object. Will always contain the string `balance-report` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  balanceId: string;
  /**
   * The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.
   */
  timeZone: string;
  /**
   * The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time.
   *
   * @remarks
   * This means a report with for example `from=2024-01-01` will include movements of 2024-01-01 00:00:00 CET and
   * onwards.
   */
  from: string;
  /**
   * The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time.
   *
   * @remarks
   * This means a report with for example `until=2024-02-01` will include movements up until 2024-01-31 23:59:59 CET.
   */
  until: string;
  grouping: BalanceReportGrouping;
  /**
   * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
   *
   * @remarks
   * typical grouping looks like.
   *
   * If grouping `status-balances` is chosen, the main grouping is as follows:
   *
   * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
   * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
   *
   * If grouping `transaction-categories` is chosen, the main grouping is as follows:
   *
   * * `open` and `close` groups, each containing a `pending` and `available` sub-group
   * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
   * each containing a `pending`, `movedToAvailable`, and
   * `immediatelyAvailable` sub-group
   *
   * Each sub-group typically has:
   *
   * * An `amount` object containing the group's total amount
   * * A `count` integer if relevant (for example, counting the number of refunds)
   * * A `subtotals` array containing more sub-group objects if applicable
   */
  totals: Totals;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: EntityBalanceReportLinks;
};

/** @internal */
export const PendingBalance$inboundSchema: z.ZodType<
  PendingBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: SubGroup$inboundSchema.optional(),
  close: SubGroup$inboundSchema.optional(),
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type PendingBalance$Outbound = {
  open?: SubGroup$Outbound | undefined;
  close?: SubGroup$Outbound | undefined;
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const PendingBalance$outboundSchema: z.ZodType<
  PendingBalance$Outbound,
  z.ZodTypeDef,
  PendingBalance
> = z.object({
  open: SubGroup$outboundSchema.optional(),
  close: SubGroup$outboundSchema.optional(),
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
});

export function pendingBalanceToJSON(pendingBalance: PendingBalance): string {
  return JSON.stringify(PendingBalance$outboundSchema.parse(pendingBalance));
}
export function pendingBalanceFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalance' from JSON`,
  );
}

/** @internal */
export const AvailableBalance$inboundSchema: z.ZodType<
  AvailableBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: SubGroup$inboundSchema.optional(),
  movedFromPending: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
  close: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type AvailableBalance$Outbound = {
  open?: SubGroup$Outbound | undefined;
  movedFromPending?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
  close?: SubGroup$Outbound | undefined;
};

/** @internal */
export const AvailableBalance$outboundSchema: z.ZodType<
  AvailableBalance$Outbound,
  z.ZodTypeDef,
  AvailableBalance
> = z.object({
  open: SubGroup$outboundSchema.optional(),
  movedFromPending: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
  close: SubGroup$outboundSchema.optional(),
});

export function availableBalanceToJSON(
  availableBalance: AvailableBalance,
): string {
  return JSON.stringify(
    AvailableBalance$outboundSchema.parse(availableBalance),
  );
}
export function availableBalanceFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalance' from JSON`,
  );
}

/** @internal */
export const Open$inboundSchema: z.ZodType<Open, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    available: SubGroup$inboundSchema.optional(),
  });
/** @internal */
export type Open$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  available?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Open$outboundSchema: z.ZodType<Open$Outbound, z.ZodTypeDef, Open> =
  z.object({
    pending: SubGroup$outboundSchema.optional(),
    available: SubGroup$outboundSchema.optional(),
  });

export function openToJSON(open: Open): string {
  return JSON.stringify(Open$outboundSchema.parse(open));
}
export function openFromJSON(
  jsonString: string,
): SafeParseResult<Open, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Open$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Open' from JSON`,
  );
}

/** @internal */
export const Close$inboundSchema: z.ZodType<Close, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    available: SubGroup$inboundSchema.optional(),
  });
/** @internal */
export type Close$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  available?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Close$outboundSchema: z.ZodType<
  Close$Outbound,
  z.ZodTypeDef,
  Close
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  available: SubGroup$outboundSchema.optional(),
});

export function closeToJSON(close: Close): string {
  return JSON.stringify(Close$outboundSchema.parse(close));
}
export function closeFromJSON(
  jsonString: string,
): SafeParseResult<Close, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Close$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Close' from JSON`,
  );
}

/** @internal */
export const Payments$inboundSchema: z.ZodType<
  Payments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type Payments$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Payments$outboundSchema: z.ZodType<
  Payments$Outbound,
  z.ZodTypeDef,
  Payments
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function paymentsToJSON(payments: Payments): string {
  return JSON.stringify(Payments$outboundSchema.parse(payments));
}
export function paymentsFromJSON(
  jsonString: string,
): SafeParseResult<Payments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payments' from JSON`,
  );
}

/** @internal */
export const Refunds$inboundSchema: z.ZodType<Refunds, z.ZodTypeDef, unknown> =
  z.object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });
/** @internal */
export type Refunds$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Refunds$outboundSchema: z.ZodType<
  Refunds$Outbound,
  z.ZodTypeDef,
  Refunds
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function refundsToJSON(refunds: Refunds): string {
  return JSON.stringify(Refunds$outboundSchema.parse(refunds));
}
export function refundsFromJSON(
  jsonString: string,
): SafeParseResult<Refunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refunds' from JSON`,
  );
}

/** @internal */
export const Chargebacks$inboundSchema: z.ZodType<
  Chargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type Chargebacks$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Chargebacks$outboundSchema: z.ZodType<
  Chargebacks$Outbound,
  z.ZodTypeDef,
  Chargebacks
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function chargebacksToJSON(chargebacks: Chargebacks): string {
  return JSON.stringify(Chargebacks$outboundSchema.parse(chargebacks));
}
export function chargebacksFromJSON(
  jsonString: string,
): SafeParseResult<Chargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Chargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Chargebacks' from JSON`,
  );
}

/** @internal */
export const Capital$inboundSchema: z.ZodType<Capital, z.ZodTypeDef, unknown> =
  z.object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });
/** @internal */
export type Capital$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Capital$outboundSchema: z.ZodType<
  Capital$Outbound,
  z.ZodTypeDef,
  Capital
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function capitalToJSON(capital: Capital): string {
  return JSON.stringify(Capital$outboundSchema.parse(capital));
}
export function capitalFromJSON(
  jsonString: string,
): SafeParseResult<Capital, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Capital$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Capital' from JSON`,
  );
}

/** @internal */
export const Transfers$inboundSchema: z.ZodType<
  Transfers,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type Transfers$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Transfers$outboundSchema: z.ZodType<
  Transfers$Outbound,
  z.ZodTypeDef,
  Transfers
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function transfersToJSON(transfers: Transfers): string {
  return JSON.stringify(Transfers$outboundSchema.parse(transfers));
}
export function transfersFromJSON(
  jsonString: string,
): SafeParseResult<Transfers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transfers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transfers' from JSON`,
  );
}

/** @internal */
export const FeePrepayments$inboundSchema: z.ZodType<
  FeePrepayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type FeePrepayments$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const FeePrepayments$outboundSchema: z.ZodType<
  FeePrepayments$Outbound,
  z.ZodTypeDef,
  FeePrepayments
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function feePrepaymentsToJSON(feePrepayments: FeePrepayments): string {
  return JSON.stringify(FeePrepayments$outboundSchema.parse(feePrepayments));
}
export function feePrepaymentsFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepayments' from JSON`,
  );
}

/** @internal */
export const Corrections$inboundSchema: z.ZodType<
  Corrections,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});
/** @internal */
export type Corrections$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Corrections$outboundSchema: z.ZodType<
  Corrections$Outbound,
  z.ZodTypeDef,
  Corrections
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function correctionsToJSON(corrections: Corrections): string {
  return JSON.stringify(Corrections$outboundSchema.parse(corrections));
}
export function correctionsFromJSON(
  jsonString: string,
): SafeParseResult<Corrections, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Corrections$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Corrections' from JSON`,
  );
}

/** @internal */
export const Topups$inboundSchema: z.ZodType<Topups, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });
/** @internal */
export type Topups$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Topups$outboundSchema: z.ZodType<
  Topups$Outbound,
  z.ZodTypeDef,
  Topups
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

export function topupsToJSON(topups: Topups): string {
  return JSON.stringify(Topups$outboundSchema.parse(topups));
}
export function topupsFromJSON(
  jsonString: string,
): SafeParseResult<Topups, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Topups$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Topups' from JSON`,
  );
}

/** @internal */
export const Totals$inboundSchema: z.ZodType<Totals, z.ZodTypeDef, unknown> = z
  .object({
    pendingBalance: z.nullable(z.lazy(() => PendingBalance$inboundSchema))
      .optional(),
    availableBalance: z.nullable(z.lazy(() => AvailableBalance$inboundSchema))
      .optional(),
    open: z.lazy(() => Open$inboundSchema).optional(),
    close: z.lazy(() => Close$inboundSchema).optional(),
    payments: z.lazy(() => Payments$inboundSchema).optional(),
    refunds: z.lazy(() => Refunds$inboundSchema).optional(),
    chargebacks: z.lazy(() => Chargebacks$inboundSchema).optional(),
    capital: z.lazy(() => Capital$inboundSchema).optional(),
    transfers: z.lazy(() => Transfers$inboundSchema).optional(),
    "fee-prepayments": z.lazy(() => FeePrepayments$inboundSchema).optional(),
    corrections: z.lazy(() => Corrections$inboundSchema).optional(),
    topups: z.lazy(() => Topups$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "fee-prepayments": "feePrepayments",
    });
  });
/** @internal */
export type Totals$Outbound = {
  pendingBalance?: PendingBalance$Outbound | null | undefined;
  availableBalance?: AvailableBalance$Outbound | null | undefined;
  open?: Open$Outbound | undefined;
  close?: Close$Outbound | undefined;
  payments?: Payments$Outbound | undefined;
  refunds?: Refunds$Outbound | undefined;
  chargebacks?: Chargebacks$Outbound | undefined;
  capital?: Capital$Outbound | undefined;
  transfers?: Transfers$Outbound | undefined;
  "fee-prepayments"?: FeePrepayments$Outbound | undefined;
  corrections?: Corrections$Outbound | undefined;
  topups?: Topups$Outbound | undefined;
};

/** @internal */
export const Totals$outboundSchema: z.ZodType<
  Totals$Outbound,
  z.ZodTypeDef,
  Totals
> = z.object({
  pendingBalance: z.nullable(z.lazy(() => PendingBalance$outboundSchema))
    .optional(),
  availableBalance: z.nullable(z.lazy(() => AvailableBalance$outboundSchema))
    .optional(),
  open: z.lazy(() => Open$outboundSchema).optional(),
  close: z.lazy(() => Close$outboundSchema).optional(),
  payments: z.lazy(() => Payments$outboundSchema).optional(),
  refunds: z.lazy(() => Refunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => Chargebacks$outboundSchema).optional(),
  capital: z.lazy(() => Capital$outboundSchema).optional(),
  transfers: z.lazy(() => Transfers$outboundSchema).optional(),
  feePrepayments: z.lazy(() => FeePrepayments$outboundSchema).optional(),
  corrections: z.lazy(() => Corrections$outboundSchema).optional(),
  topups: z.lazy(() => Topups$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    feePrepayments: "fee-prepayments",
  });
});

export function totalsToJSON(totals: Totals): string {
  return JSON.stringify(Totals$outboundSchema.parse(totals));
}
export function totalsFromJSON(
  jsonString: string,
): SafeParseResult<Totals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Totals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Totals' from JSON`,
  );
}

/** @internal */
export const EntityBalanceReportLinks$inboundSchema: z.ZodType<
  EntityBalanceReportLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
});
/** @internal */
export type EntityBalanceReportLinks$Outbound = {
  self?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
};

/** @internal */
export const EntityBalanceReportLinks$outboundSchema: z.ZodType<
  EntityBalanceReportLinks$Outbound,
  z.ZodTypeDef,
  EntityBalanceReportLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
});

export function entityBalanceReportLinksToJSON(
  entityBalanceReportLinks: EntityBalanceReportLinks,
): string {
  return JSON.stringify(
    EntityBalanceReportLinks$outboundSchema.parse(entityBalanceReportLinks),
  );
}
export function entityBalanceReportLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceReportLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceReportLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceReportLinks' from JSON`,
  );
}

/** @internal */
export const EntityBalanceReport$inboundSchema: z.ZodType<
  EntityBalanceReport,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  balanceId: z.string(),
  timeZone: z.string(),
  from: z.string(),
  until: z.string(),
  grouping: BalanceReportGrouping$inboundSchema,
  totals: z.lazy(() => Totals$inboundSchema),
  _links: z.lazy(() => EntityBalanceReportLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type EntityBalanceReport$Outbound = {
  resource: string;
  balanceId: string;
  timeZone: string;
  from: string;
  until: string;
  grouping: string;
  totals: Totals$Outbound;
  _links: EntityBalanceReportLinks$Outbound;
};

/** @internal */
export const EntityBalanceReport$outboundSchema: z.ZodType<
  EntityBalanceReport$Outbound,
  z.ZodTypeDef,
  EntityBalanceReport
> = z.object({
  resource: z.string(),
  balanceId: z.string(),
  timeZone: z.string(),
  from: z.string(),
  until: z.string(),
  grouping: BalanceReportGrouping$outboundSchema,
  totals: z.lazy(() => Totals$outboundSchema),
  links: z.lazy(() => EntityBalanceReportLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function entityBalanceReportToJSON(
  entityBalanceReport: EntityBalanceReport,
): string {
  return JSON.stringify(
    EntityBalanceReport$outboundSchema.parse(entityBalanceReport),
  );
}
export function entityBalanceReportFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceReport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceReport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceReport' from JSON`,
  );
}
