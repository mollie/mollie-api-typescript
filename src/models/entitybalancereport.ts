/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SubGroup,
  SubGroup$inboundSchema,
  SubGroup$Outbound,
  SubGroup$outboundSchema,
} from "./subgroup.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by
 *
 * @remarks
 * status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then
 * by transaction type, and then by other sub-groupings where available (e.g. payment method).
 *
 * With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of
 * movement, and then again by other sub-groupings where available.
 *
 * Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates
 * of the report.
 */
export const Grouping = {
  StatusBalances: "status-balances",
  TransactionCategories: "transaction-categories",
} as const;
/**
 * You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by
 *
 * @remarks
 * status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then
 * by transaction type, and then by other sub-groupings where available (e.g. payment method).
 *
 * With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of
 * movement, and then again by other sub-groupings where available.
 *
 * Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates
 * of the report.
 */
export type Grouping = ClosedEnum<typeof Grouping>;

/**
 * The pending balance. Only available if grouping is `status-balances`.
 */
export type PendingBalance = {
  open?: SubGroup | undefined;
  close?: SubGroup | undefined;
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
};

/**
 * The available balance. Only available if grouping is `status-balances`.
 */
export type AvailableBalance = {
  open?: SubGroup | undefined;
  movedFromPending?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
  close?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Open = {
  pending?: SubGroup | undefined;
  available?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Close = {
  pending?: SubGroup | undefined;
  available?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Payments = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Refunds = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Chargebacks = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Capital = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Transfers = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type FeePrepayments = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Corrections = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Topups = {
  pending?: SubGroup | undefined;
  movedToAvailable?: SubGroup | undefined;
  immediatelyAvailable?: SubGroup | undefined;
};

/**
 * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
 *
 * @remarks
 * typical grouping looks like.
 *
 * If grouping `status-balances` is chosen, the main grouping is as follows:
 *
 * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
 * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
 *
 * If grouping `transaction-categories` is chosen, the main grouping is as follows:
 *
 * * `open` and `close` groups, each containing a `pending` and `available` sub-group
 * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
 * each containing a `pending`, `movedToAvailable`, and
 * `immediatelyAvailable` sub-group
 *
 * Each sub-group typically has:
 *
 * * An `amount` object containing the group's total amount
 * * A `count` integer if relevant (for example, counting the number of refunds)
 * * A `subtotals` array containing more sub-group objects if applicable
 */
export type Totals = {
  /**
   * The pending balance. Only available if grouping is `status-balances`.
   */
  pendingBalance?: PendingBalance | null | undefined;
  /**
   * The available balance. Only available if grouping is `status-balances`.
   */
  availableBalance?: AvailableBalance | null | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  open?: Open | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  close?: Close | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  payments?: Payments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  refunds?: Refunds | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  chargebacks?: Chargebacks | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  capital?: Capital | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  transfers?: Transfers | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  feePrepayments?: FeePrepayments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  corrections?: Corrections | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  topups?: Topups | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntityBalanceReportLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
};

export type EntityBalanceReport = {
  /**
   * Indicates the response contains a balance report object. Will always contain the string `balance-report` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  balanceId?: string | undefined;
  /**
   * The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.
   */
  timeZone?: string | undefined;
  /**
   * The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time.
   *
   * @remarks
   * This means a report with for example `from=2024-01-01` will include movements of 2024-01-01 00:00:00 CET and
   * onwards.
   */
  from?: string | undefined;
  /**
   * The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time.
   *
   * @remarks
   * This means a report with for example `until=2024-02-01` will include movements up until 2024-01-31 23:59:59 CET.
   */
  until?: string | undefined;
  /**
   * You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by
   *
   * @remarks
   * status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then
   * by transaction type, and then by other sub-groupings where available (e.g. payment method).
   *
   * With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of
   * movement, and then again by other sub-groupings where available.
   *
   * Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates
   * of the report.
   */
  grouping?: Grouping | undefined;
  /**
   * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a
   *
   * @remarks
   * typical grouping looks like.
   *
   * If grouping `status-balances` is chosen, the main grouping is as follows:
   *
   * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
   * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
   *
   * If grouping `transaction-categories` is chosen, the main grouping is as follows:
   *
   * * `open` and `close` groups, each containing a `pending` and `available` sub-group
   * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups`
   * each containing a `pending`, `movedToAvailable`, and
   * `immediatelyAvailable` sub-group
   *
   * Each sub-group typically has:
   *
   * * An `amount` object containing the group's total amount
   * * A `count` integer if relevant (for example, counting the number of refunds)
   * * A `subtotals` array containing more sub-group objects if applicable
   */
  totals?: Totals | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: EntityBalanceReportLinks | undefined;
};

/** @internal */
export const Grouping$inboundSchema: z.ZodNativeEnum<typeof Grouping> = z
  .nativeEnum(Grouping);

/** @internal */
export const Grouping$outboundSchema: z.ZodNativeEnum<typeof Grouping> =
  Grouping$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Grouping$ {
  /** @deprecated use `Grouping$inboundSchema` instead. */
  export const inboundSchema = Grouping$inboundSchema;
  /** @deprecated use `Grouping$outboundSchema` instead. */
  export const outboundSchema = Grouping$outboundSchema;
}

/** @internal */
export const PendingBalance$inboundSchema: z.ZodType<
  PendingBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: SubGroup$inboundSchema.optional(),
  close: SubGroup$inboundSchema.optional(),
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type PendingBalance$Outbound = {
  open?: SubGroup$Outbound | undefined;
  close?: SubGroup$Outbound | undefined;
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const PendingBalance$outboundSchema: z.ZodType<
  PendingBalance$Outbound,
  z.ZodTypeDef,
  PendingBalance
> = z.object({
  open: SubGroup$outboundSchema.optional(),
  close: SubGroup$outboundSchema.optional(),
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalance$ {
  /** @deprecated use `PendingBalance$inboundSchema` instead. */
  export const inboundSchema = PendingBalance$inboundSchema;
  /** @deprecated use `PendingBalance$outboundSchema` instead. */
  export const outboundSchema = PendingBalance$outboundSchema;
  /** @deprecated use `PendingBalance$Outbound` instead. */
  export type Outbound = PendingBalance$Outbound;
}

export function pendingBalanceToJSON(pendingBalance: PendingBalance): string {
  return JSON.stringify(PendingBalance$outboundSchema.parse(pendingBalance));
}

export function pendingBalanceFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalance' from JSON`,
  );
}

/** @internal */
export const AvailableBalance$inboundSchema: z.ZodType<
  AvailableBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: SubGroup$inboundSchema.optional(),
  movedFromPending: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
  close: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type AvailableBalance$Outbound = {
  open?: SubGroup$Outbound | undefined;
  movedFromPending?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
  close?: SubGroup$Outbound | undefined;
};

/** @internal */
export const AvailableBalance$outboundSchema: z.ZodType<
  AvailableBalance$Outbound,
  z.ZodTypeDef,
  AvailableBalance
> = z.object({
  open: SubGroup$outboundSchema.optional(),
  movedFromPending: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
  close: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalance$ {
  /** @deprecated use `AvailableBalance$inboundSchema` instead. */
  export const inboundSchema = AvailableBalance$inboundSchema;
  /** @deprecated use `AvailableBalance$outboundSchema` instead. */
  export const outboundSchema = AvailableBalance$outboundSchema;
  /** @deprecated use `AvailableBalance$Outbound` instead. */
  export type Outbound = AvailableBalance$Outbound;
}

export function availableBalanceToJSON(
  availableBalance: AvailableBalance,
): string {
  return JSON.stringify(
    AvailableBalance$outboundSchema.parse(availableBalance),
  );
}

export function availableBalanceFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalance' from JSON`,
  );
}

/** @internal */
export const Open$inboundSchema: z.ZodType<Open, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    available: SubGroup$inboundSchema.optional(),
  });

/** @internal */
export type Open$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  available?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Open$outboundSchema: z.ZodType<Open$Outbound, z.ZodTypeDef, Open> =
  z.object({
    pending: SubGroup$outboundSchema.optional(),
    available: SubGroup$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Open$ {
  /** @deprecated use `Open$inboundSchema` instead. */
  export const inboundSchema = Open$inboundSchema;
  /** @deprecated use `Open$outboundSchema` instead. */
  export const outboundSchema = Open$outboundSchema;
  /** @deprecated use `Open$Outbound` instead. */
  export type Outbound = Open$Outbound;
}

export function openToJSON(open: Open): string {
  return JSON.stringify(Open$outboundSchema.parse(open));
}

export function openFromJSON(
  jsonString: string,
): SafeParseResult<Open, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Open$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Open' from JSON`,
  );
}

/** @internal */
export const Close$inboundSchema: z.ZodType<Close, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    available: SubGroup$inboundSchema.optional(),
  });

/** @internal */
export type Close$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  available?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Close$outboundSchema: z.ZodType<
  Close$Outbound,
  z.ZodTypeDef,
  Close
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  available: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Close$ {
  /** @deprecated use `Close$inboundSchema` instead. */
  export const inboundSchema = Close$inboundSchema;
  /** @deprecated use `Close$outboundSchema` instead. */
  export const outboundSchema = Close$outboundSchema;
  /** @deprecated use `Close$Outbound` instead. */
  export type Outbound = Close$Outbound;
}

export function closeToJSON(close: Close): string {
  return JSON.stringify(Close$outboundSchema.parse(close));
}

export function closeFromJSON(
  jsonString: string,
): SafeParseResult<Close, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Close$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Close' from JSON`,
  );
}

/** @internal */
export const Payments$inboundSchema: z.ZodType<
  Payments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type Payments$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Payments$outboundSchema: z.ZodType<
  Payments$Outbound,
  z.ZodTypeDef,
  Payments
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Payments$ {
  /** @deprecated use `Payments$inboundSchema` instead. */
  export const inboundSchema = Payments$inboundSchema;
  /** @deprecated use `Payments$outboundSchema` instead. */
  export const outboundSchema = Payments$outboundSchema;
  /** @deprecated use `Payments$Outbound` instead. */
  export type Outbound = Payments$Outbound;
}

export function paymentsToJSON(payments: Payments): string {
  return JSON.stringify(Payments$outboundSchema.parse(payments));
}

export function paymentsFromJSON(
  jsonString: string,
): SafeParseResult<Payments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payments' from JSON`,
  );
}

/** @internal */
export const Refunds$inboundSchema: z.ZodType<Refunds, z.ZodTypeDef, unknown> =
  z.object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });

/** @internal */
export type Refunds$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Refunds$outboundSchema: z.ZodType<
  Refunds$Outbound,
  z.ZodTypeDef,
  Refunds
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Refunds$ {
  /** @deprecated use `Refunds$inboundSchema` instead. */
  export const inboundSchema = Refunds$inboundSchema;
  /** @deprecated use `Refunds$outboundSchema` instead. */
  export const outboundSchema = Refunds$outboundSchema;
  /** @deprecated use `Refunds$Outbound` instead. */
  export type Outbound = Refunds$Outbound;
}

export function refundsToJSON(refunds: Refunds): string {
  return JSON.stringify(Refunds$outboundSchema.parse(refunds));
}

export function refundsFromJSON(
  jsonString: string,
): SafeParseResult<Refunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refunds' from JSON`,
  );
}

/** @internal */
export const Chargebacks$inboundSchema: z.ZodType<
  Chargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type Chargebacks$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Chargebacks$outboundSchema: z.ZodType<
  Chargebacks$Outbound,
  z.ZodTypeDef,
  Chargebacks
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Chargebacks$ {
  /** @deprecated use `Chargebacks$inboundSchema` instead. */
  export const inboundSchema = Chargebacks$inboundSchema;
  /** @deprecated use `Chargebacks$outboundSchema` instead. */
  export const outboundSchema = Chargebacks$outboundSchema;
  /** @deprecated use `Chargebacks$Outbound` instead. */
  export type Outbound = Chargebacks$Outbound;
}

export function chargebacksToJSON(chargebacks: Chargebacks): string {
  return JSON.stringify(Chargebacks$outboundSchema.parse(chargebacks));
}

export function chargebacksFromJSON(
  jsonString: string,
): SafeParseResult<Chargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Chargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Chargebacks' from JSON`,
  );
}

/** @internal */
export const Capital$inboundSchema: z.ZodType<Capital, z.ZodTypeDef, unknown> =
  z.object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });

/** @internal */
export type Capital$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Capital$outboundSchema: z.ZodType<
  Capital$Outbound,
  z.ZodTypeDef,
  Capital
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Capital$ {
  /** @deprecated use `Capital$inboundSchema` instead. */
  export const inboundSchema = Capital$inboundSchema;
  /** @deprecated use `Capital$outboundSchema` instead. */
  export const outboundSchema = Capital$outboundSchema;
  /** @deprecated use `Capital$Outbound` instead. */
  export type Outbound = Capital$Outbound;
}

export function capitalToJSON(capital: Capital): string {
  return JSON.stringify(Capital$outboundSchema.parse(capital));
}

export function capitalFromJSON(
  jsonString: string,
): SafeParseResult<Capital, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Capital$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Capital' from JSON`,
  );
}

/** @internal */
export const Transfers$inboundSchema: z.ZodType<
  Transfers,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type Transfers$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Transfers$outboundSchema: z.ZodType<
  Transfers$Outbound,
  z.ZodTypeDef,
  Transfers
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Transfers$ {
  /** @deprecated use `Transfers$inboundSchema` instead. */
  export const inboundSchema = Transfers$inboundSchema;
  /** @deprecated use `Transfers$outboundSchema` instead. */
  export const outboundSchema = Transfers$outboundSchema;
  /** @deprecated use `Transfers$Outbound` instead. */
  export type Outbound = Transfers$Outbound;
}

export function transfersToJSON(transfers: Transfers): string {
  return JSON.stringify(Transfers$outboundSchema.parse(transfers));
}

export function transfersFromJSON(
  jsonString: string,
): SafeParseResult<Transfers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transfers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transfers' from JSON`,
  );
}

/** @internal */
export const FeePrepayments$inboundSchema: z.ZodType<
  FeePrepayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type FeePrepayments$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const FeePrepayments$outboundSchema: z.ZodType<
  FeePrepayments$Outbound,
  z.ZodTypeDef,
  FeePrepayments
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepayments$ {
  /** @deprecated use `FeePrepayments$inboundSchema` instead. */
  export const inboundSchema = FeePrepayments$inboundSchema;
  /** @deprecated use `FeePrepayments$outboundSchema` instead. */
  export const outboundSchema = FeePrepayments$outboundSchema;
  /** @deprecated use `FeePrepayments$Outbound` instead. */
  export type Outbound = FeePrepayments$Outbound;
}

export function feePrepaymentsToJSON(feePrepayments: FeePrepayments): string {
  return JSON.stringify(FeePrepayments$outboundSchema.parse(feePrepayments));
}

export function feePrepaymentsFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepayments' from JSON`,
  );
}

/** @internal */
export const Corrections$inboundSchema: z.ZodType<
  Corrections,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: SubGroup$inboundSchema.optional(),
  movedToAvailable: SubGroup$inboundSchema.optional(),
  immediatelyAvailable: SubGroup$inboundSchema.optional(),
});

/** @internal */
export type Corrections$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Corrections$outboundSchema: z.ZodType<
  Corrections$Outbound,
  z.ZodTypeDef,
  Corrections
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Corrections$ {
  /** @deprecated use `Corrections$inboundSchema` instead. */
  export const inboundSchema = Corrections$inboundSchema;
  /** @deprecated use `Corrections$outboundSchema` instead. */
  export const outboundSchema = Corrections$outboundSchema;
  /** @deprecated use `Corrections$Outbound` instead. */
  export type Outbound = Corrections$Outbound;
}

export function correctionsToJSON(corrections: Corrections): string {
  return JSON.stringify(Corrections$outboundSchema.parse(corrections));
}

export function correctionsFromJSON(
  jsonString: string,
): SafeParseResult<Corrections, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Corrections$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Corrections' from JSON`,
  );
}

/** @internal */
export const Topups$inboundSchema: z.ZodType<Topups, z.ZodTypeDef, unknown> = z
  .object({
    pending: SubGroup$inboundSchema.optional(),
    movedToAvailable: SubGroup$inboundSchema.optional(),
    immediatelyAvailable: SubGroup$inboundSchema.optional(),
  });

/** @internal */
export type Topups$Outbound = {
  pending?: SubGroup$Outbound | undefined;
  movedToAvailable?: SubGroup$Outbound | undefined;
  immediatelyAvailable?: SubGroup$Outbound | undefined;
};

/** @internal */
export const Topups$outboundSchema: z.ZodType<
  Topups$Outbound,
  z.ZodTypeDef,
  Topups
> = z.object({
  pending: SubGroup$outboundSchema.optional(),
  movedToAvailable: SubGroup$outboundSchema.optional(),
  immediatelyAvailable: SubGroup$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Topups$ {
  /** @deprecated use `Topups$inboundSchema` instead. */
  export const inboundSchema = Topups$inboundSchema;
  /** @deprecated use `Topups$outboundSchema` instead. */
  export const outboundSchema = Topups$outboundSchema;
  /** @deprecated use `Topups$Outbound` instead. */
  export type Outbound = Topups$Outbound;
}

export function topupsToJSON(topups: Topups): string {
  return JSON.stringify(Topups$outboundSchema.parse(topups));
}

export function topupsFromJSON(
  jsonString: string,
): SafeParseResult<Topups, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Topups$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Topups' from JSON`,
  );
}

/** @internal */
export const Totals$inboundSchema: z.ZodType<Totals, z.ZodTypeDef, unknown> = z
  .object({
    pendingBalance: z.nullable(z.lazy(() => PendingBalance$inboundSchema))
      .optional(),
    availableBalance: z.nullable(z.lazy(() => AvailableBalance$inboundSchema))
      .optional(),
    open: z.lazy(() => Open$inboundSchema).optional(),
    close: z.lazy(() => Close$inboundSchema).optional(),
    payments: z.lazy(() => Payments$inboundSchema).optional(),
    refunds: z.lazy(() => Refunds$inboundSchema).optional(),
    chargebacks: z.lazy(() => Chargebacks$inboundSchema).optional(),
    capital: z.lazy(() => Capital$inboundSchema).optional(),
    transfers: z.lazy(() => Transfers$inboundSchema).optional(),
    "fee-prepayments": z.lazy(() => FeePrepayments$inboundSchema).optional(),
    corrections: z.lazy(() => Corrections$inboundSchema).optional(),
    topups: z.lazy(() => Topups$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "fee-prepayments": "feePrepayments",
    });
  });

/** @internal */
export type Totals$Outbound = {
  pendingBalance?: PendingBalance$Outbound | null | undefined;
  availableBalance?: AvailableBalance$Outbound | null | undefined;
  open?: Open$Outbound | undefined;
  close?: Close$Outbound | undefined;
  payments?: Payments$Outbound | undefined;
  refunds?: Refunds$Outbound | undefined;
  chargebacks?: Chargebacks$Outbound | undefined;
  capital?: Capital$Outbound | undefined;
  transfers?: Transfers$Outbound | undefined;
  "fee-prepayments"?: FeePrepayments$Outbound | undefined;
  corrections?: Corrections$Outbound | undefined;
  topups?: Topups$Outbound | undefined;
};

/** @internal */
export const Totals$outboundSchema: z.ZodType<
  Totals$Outbound,
  z.ZodTypeDef,
  Totals
> = z.object({
  pendingBalance: z.nullable(z.lazy(() => PendingBalance$outboundSchema))
    .optional(),
  availableBalance: z.nullable(z.lazy(() => AvailableBalance$outboundSchema))
    .optional(),
  open: z.lazy(() => Open$outboundSchema).optional(),
  close: z.lazy(() => Close$outboundSchema).optional(),
  payments: z.lazy(() => Payments$outboundSchema).optional(),
  refunds: z.lazy(() => Refunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => Chargebacks$outboundSchema).optional(),
  capital: z.lazy(() => Capital$outboundSchema).optional(),
  transfers: z.lazy(() => Transfers$outboundSchema).optional(),
  feePrepayments: z.lazy(() => FeePrepayments$outboundSchema).optional(),
  corrections: z.lazy(() => Corrections$outboundSchema).optional(),
  topups: z.lazy(() => Topups$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    feePrepayments: "fee-prepayments",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Totals$ {
  /** @deprecated use `Totals$inboundSchema` instead. */
  export const inboundSchema = Totals$inboundSchema;
  /** @deprecated use `Totals$outboundSchema` instead. */
  export const outboundSchema = Totals$outboundSchema;
  /** @deprecated use `Totals$Outbound` instead. */
  export type Outbound = Totals$Outbound;
}

export function totalsToJSON(totals: Totals): string {
  return JSON.stringify(Totals$outboundSchema.parse(totals));
}

export function totalsFromJSON(
  jsonString: string,
): SafeParseResult<Totals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Totals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Totals' from JSON`,
  );
}

/** @internal */
export const EntityBalanceReportLinks$inboundSchema: z.ZodType<
  EntityBalanceReportLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
});

/** @internal */
export type EntityBalanceReportLinks$Outbound = {
  self?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
};

/** @internal */
export const EntityBalanceReportLinks$outboundSchema: z.ZodType<
  EntityBalanceReportLinks$Outbound,
  z.ZodTypeDef,
  EntityBalanceReportLinks
> = z.object({
  self: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityBalanceReportLinks$ {
  /** @deprecated use `EntityBalanceReportLinks$inboundSchema` instead. */
  export const inboundSchema = EntityBalanceReportLinks$inboundSchema;
  /** @deprecated use `EntityBalanceReportLinks$outboundSchema` instead. */
  export const outboundSchema = EntityBalanceReportLinks$outboundSchema;
  /** @deprecated use `EntityBalanceReportLinks$Outbound` instead. */
  export type Outbound = EntityBalanceReportLinks$Outbound;
}

export function entityBalanceReportLinksToJSON(
  entityBalanceReportLinks: EntityBalanceReportLinks,
): string {
  return JSON.stringify(
    EntityBalanceReportLinks$outboundSchema.parse(entityBalanceReportLinks),
  );
}

export function entityBalanceReportLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceReportLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceReportLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceReportLinks' from JSON`,
  );
}

/** @internal */
export const EntityBalanceReport$inboundSchema: z.ZodType<
  EntityBalanceReport,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  balanceId: z.string().optional(),
  timeZone: z.string().optional(),
  from: z.string().optional(),
  until: z.string().optional(),
  grouping: Grouping$inboundSchema.optional(),
  totals: z.lazy(() => Totals$inboundSchema).optional(),
  _links: z.lazy(() => EntityBalanceReportLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type EntityBalanceReport$Outbound = {
  resource?: string | undefined;
  balanceId?: string | undefined;
  timeZone?: string | undefined;
  from?: string | undefined;
  until?: string | undefined;
  grouping?: string | undefined;
  totals?: Totals$Outbound | undefined;
  _links?: EntityBalanceReportLinks$Outbound | undefined;
};

/** @internal */
export const EntityBalanceReport$outboundSchema: z.ZodType<
  EntityBalanceReport$Outbound,
  z.ZodTypeDef,
  EntityBalanceReport
> = z.object({
  resource: z.string().optional(),
  balanceId: z.string().optional(),
  timeZone: z.string().optional(),
  from: z.string().optional(),
  until: z.string().optional(),
  grouping: Grouping$outboundSchema.optional(),
  totals: z.lazy(() => Totals$outboundSchema).optional(),
  links: z.lazy(() => EntityBalanceReportLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityBalanceReport$ {
  /** @deprecated use `EntityBalanceReport$inboundSchema` instead. */
  export const inboundSchema = EntityBalanceReport$inboundSchema;
  /** @deprecated use `EntityBalanceReport$outboundSchema` instead. */
  export const outboundSchema = EntityBalanceReport$outboundSchema;
  /** @deprecated use `EntityBalanceReport$Outbound` instead. */
  export type Outbound = EntityBalanceReport$Outbound;
}

export function entityBalanceReportToJSON(
  entityBalanceReport: EntityBalanceReport,
): string {
  return JSON.stringify(
    EntityBalanceReport$outboundSchema.parse(entityBalanceReport),
  );
}

export function entityBalanceReportFromJSON(
  jsonString: string,
): SafeParseResult<EntityBalanceReport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityBalanceReport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityBalanceReport' from JSON`,
  );
}
