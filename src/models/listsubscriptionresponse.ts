/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  SubscriptionMethodResponse,
  SubscriptionMethodResponse$inboundSchema,
  SubscriptionMethodResponse$outboundSchema,
} from "./subscriptionmethodresponse.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";
import {
  UrlNullable,
  UrlNullable$inboundSchema,
  UrlNullable$Outbound,
  UrlNullable$outboundSchema,
} from "./urlnullable.js";

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const ListSubscriptionResponseStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type ListSubscriptionResponseStatus = OpenEnum<
  typeof ListSubscriptionResponseStatus
>;

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type ListSubscriptionResponseApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  description: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer: UrlNullable | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mandate?: UrlNullable | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  profile: UrlNullable | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payments?: UrlNullable | null | undefined;
};

export type ListSubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: Mode;
  status: ListSubscriptionResponseStatus;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times: number | null;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining: number | null;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval: string;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate: string;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method: SubscriptionMethodResponse | null;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: ListSubscriptionResponseApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata: Metadata | null;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl: string | null;
  /**
   * The customer this subscription belongs to.
   */
  customerId: string;
  mandateId?: string | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListSubscriptionResponseLinks;
};

/** @internal */
export const ListSubscriptionResponseStatus$inboundSchema: z.ZodType<
  ListSubscriptionResponseStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ListSubscriptionResponseStatus);
/** @internal */
export const ListSubscriptionResponseStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ListSubscriptionResponseStatus
> = openEnums.outboundSchema(ListSubscriptionResponseStatus);

/** @internal */
export const ListSubscriptionResponseApplicationFee$inboundSchema: z.ZodType<
  ListSubscriptionResponseApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema,
  description: z.string(),
});
/** @internal */
export type ListSubscriptionResponseApplicationFee$Outbound = {
  amount: Amount$Outbound;
  description: string;
};

/** @internal */
export const ListSubscriptionResponseApplicationFee$outboundSchema: z.ZodType<
  ListSubscriptionResponseApplicationFee$Outbound,
  z.ZodTypeDef,
  ListSubscriptionResponseApplicationFee
> = z.object({
  amount: Amount$outboundSchema,
  description: z.string(),
});

export function listSubscriptionResponseApplicationFeeToJSON(
  listSubscriptionResponseApplicationFee:
    ListSubscriptionResponseApplicationFee,
): string {
  return JSON.stringify(
    ListSubscriptionResponseApplicationFee$outboundSchema.parse(
      listSubscriptionResponseApplicationFee,
    ),
  );
}
export function listSubscriptionResponseApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionResponseApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionResponseApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionResponseApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionResponseLinks$inboundSchema: z.ZodType<
  ListSubscriptionResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  customer: z.nullable(UrlNullable$inboundSchema),
  mandate: z.nullable(UrlNullable$inboundSchema).optional(),
  profile: z.nullable(UrlNullable$inboundSchema),
  payments: z.nullable(UrlNullable$inboundSchema).optional(),
});
/** @internal */
export type ListSubscriptionResponseLinks$Outbound = {
  self: Url$Outbound;
  customer: UrlNullable$Outbound | null;
  mandate?: UrlNullable$Outbound | null | undefined;
  profile: UrlNullable$Outbound | null;
  payments?: UrlNullable$Outbound | null | undefined;
};

/** @internal */
export const ListSubscriptionResponseLinks$outboundSchema: z.ZodType<
  ListSubscriptionResponseLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionResponseLinks
> = z.object({
  self: Url$outboundSchema,
  customer: z.nullable(UrlNullable$outboundSchema),
  mandate: z.nullable(UrlNullable$outboundSchema).optional(),
  profile: z.nullable(UrlNullable$outboundSchema),
  payments: z.nullable(UrlNullable$outboundSchema).optional(),
});

export function listSubscriptionResponseLinksToJSON(
  listSubscriptionResponseLinks: ListSubscriptionResponseLinks,
): string {
  return JSON.stringify(
    ListSubscriptionResponseLinks$outboundSchema.parse(
      listSubscriptionResponseLinks,
    ),
  );
}
export function listSubscriptionResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionResponse$inboundSchema: z.ZodType<
  ListSubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$inboundSchema,
  status: ListSubscriptionResponseStatus$inboundSchema,
  amount: Amount$inboundSchema,
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(SubscriptionMethodResponse$inboundSchema),
  applicationFee: z.lazy(() =>
    ListSubscriptionResponseApplicationFee$inboundSchema
  ).optional(),
  metadata: z.nullable(Metadata$inboundSchema),
  webhookUrl: z.nullable(z.string()),
  customerId: z.string(),
  mandateId: z.string().optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSubscriptionResponseLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});
/** @internal */
export type ListSubscriptionResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  status: string;
  amount: Amount$Outbound;
  times: number | null;
  timesRemaining: number | null;
  interval: string;
  startDate: string;
  nextPaymentDate?: string | null | undefined;
  description: string;
  method: string | null;
  applicationFee?: ListSubscriptionResponseApplicationFee$Outbound | undefined;
  metadata: Metadata$Outbound | null;
  webhookUrl: string | null;
  customerId: string;
  mandateId?: string | undefined;
  createdAt: string;
  canceledAt?: string | null | undefined;
  _links: ListSubscriptionResponseLinks$Outbound;
};

/** @internal */
export const ListSubscriptionResponse$outboundSchema: z.ZodType<
  ListSubscriptionResponse$Outbound,
  z.ZodTypeDef,
  ListSubscriptionResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: Mode$outboundSchema,
  status: ListSubscriptionResponseStatus$outboundSchema,
  amount: Amount$outboundSchema,
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(SubscriptionMethodResponse$outboundSchema),
  applicationFee: z.lazy(() =>
    ListSubscriptionResponseApplicationFee$outboundSchema
  ).optional(),
  metadata: z.nullable(Metadata$outboundSchema),
  webhookUrl: z.nullable(z.string()),
  customerId: z.string(),
  mandateId: z.string().optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSubscriptionResponseLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

export function listSubscriptionResponseToJSON(
  listSubscriptionResponse: ListSubscriptionResponse,
): string {
  return JSON.stringify(
    ListSubscriptionResponse$outboundSchema.parse(listSubscriptionResponse),
  );
}
export function listSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionResponse' from JSON`,
  );
}
