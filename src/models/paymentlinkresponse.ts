/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  PaymentAddress,
  PaymentAddress$inboundSchema,
  PaymentAddress$Outbound,
  PaymentAddress$outboundSchema,
} from "./paymentaddress.js";
import {
  PaymentLineItemResponse,
  PaymentLineItemResponse$inboundSchema,
  PaymentLineItemResponse$Outbound,
  PaymentLineItemResponse$outboundSchema,
} from "./paymentlineitemresponse.js";
import {
  PaymentLinkSequenceTypeResponse,
  PaymentLinkSequenceTypeResponse$inboundSchema,
  PaymentLinkSequenceTypeResponse$outboundSchema,
} from "./paymentlinksequencetyperesponse.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 */
export type PaymentLinkResponseApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type PaymentLinkResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  paymentLink: Url;
};

export type PaymentLinkResponse = {
  /**
   * Indicates the response contains a payment link object. Will always contain the string `payment-link` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: Mode | undefined;
  /**
   * A short description of the payment link. The description is visible in the Dashboard and will be shown on the
   *
   * @remarks
   * customer's bank or card statement when possible.
   */
  description?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: AmountNullable | null | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  minimumAmount?: AmountNullable | null | undefined;
  /**
   * Whether the payment link is archived. Customers will not be able to complete payments on archived payment links.
   */
  archived?: boolean | undefined;
  /**
   * The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,
   *
   * @remarks
   * the customer will be shown a generic message after completing the payment.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to any payments
   * resulting from the payment link.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<PaymentLineItemResponse> | null | undefined;
  billingAddress?: PaymentAddress | undefined;
  shippingAddress?: PaymentAddress | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | null | undefined;
  /**
   * Indicates whether the payment link is reusable. If this field is set to `true`, customers can make multiple
   *
   * @remarks
   * payments using the same link.
   *
   * If no value is specified, the field defaults to `false`, allowing only a single payment per link.
   */
  reusable?: boolean | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The date and time the payment link became paid, in ISO 8601 format.
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment link is set to expire, in ISO 8601 format. If no expiry date was provided up front,
   *
   * @remarks
   * the payment link will not expire automatically.
   */
  expiresAt?: string | null | undefined;
  /**
   * An array of payment methods that are allowed to be used for this payment link. When this parameter is
   *
   * @remarks
   * not provided or is an empty array, all enabled payment methods will be available.
   *
   * Enum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'blik', 'creditcard', 'eps', 'giftcard',
   * 'ideal', 'kbc', 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale', 'przelewy24', 'satispay', 'trustly', 'twint',
   * 'in3', 'riverty', 'klarna', 'billie'.
   */
  allowedMethods?: Array<string> | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   */
  applicationFee?: PaymentLinkResponseApplicationFee | undefined;
  sequenceType?: PaymentLinkSequenceTypeResponse | undefined;
  /**
   * **Only relevant when `sequenceType` is set to `first`**
   *
   * @remarks
   *
   * The ID of the [customer](get-customer) the payment link is being created for. If a value is not provided,
   * the customer will be required to input relevant information which will be used to establish a mandate after
   * the payment is made.
   */
  customerId?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: PaymentLinkResponseLinks | undefined;
};

/** @internal */
export const PaymentLinkResponseApplicationFee$inboundSchema: z.ZodType<
  PaymentLinkResponseApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema,
  description: z.string(),
});

/** @internal */
export type PaymentLinkResponseApplicationFee$Outbound = {
  amount: Amount$Outbound;
  description: string;
};

/** @internal */
export const PaymentLinkResponseApplicationFee$outboundSchema: z.ZodType<
  PaymentLinkResponseApplicationFee$Outbound,
  z.ZodTypeDef,
  PaymentLinkResponseApplicationFee
> = z.object({
  amount: Amount$outboundSchema,
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentLinkResponseApplicationFee$ {
  /** @deprecated use `PaymentLinkResponseApplicationFee$inboundSchema` instead. */
  export const inboundSchema = PaymentLinkResponseApplicationFee$inboundSchema;
  /** @deprecated use `PaymentLinkResponseApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    PaymentLinkResponseApplicationFee$outboundSchema;
  /** @deprecated use `PaymentLinkResponseApplicationFee$Outbound` instead. */
  export type Outbound = PaymentLinkResponseApplicationFee$Outbound;
}

export function paymentLinkResponseApplicationFeeToJSON(
  paymentLinkResponseApplicationFee: PaymentLinkResponseApplicationFee,
): string {
  return JSON.stringify(
    PaymentLinkResponseApplicationFee$outboundSchema.parse(
      paymentLinkResponseApplicationFee,
    ),
  );
}

export function paymentLinkResponseApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<PaymentLinkResponseApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentLinkResponseApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentLinkResponseApplicationFee' from JSON`,
  );
}

/** @internal */
export const PaymentLinkResponseLinks$inboundSchema: z.ZodType<
  PaymentLinkResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  paymentLink: Url$inboundSchema,
});

/** @internal */
export type PaymentLinkResponseLinks$Outbound = {
  self: Url$Outbound;
  paymentLink: Url$Outbound;
};

/** @internal */
export const PaymentLinkResponseLinks$outboundSchema: z.ZodType<
  PaymentLinkResponseLinks$Outbound,
  z.ZodTypeDef,
  PaymentLinkResponseLinks
> = z.object({
  self: Url$outboundSchema,
  paymentLink: Url$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentLinkResponseLinks$ {
  /** @deprecated use `PaymentLinkResponseLinks$inboundSchema` instead. */
  export const inboundSchema = PaymentLinkResponseLinks$inboundSchema;
  /** @deprecated use `PaymentLinkResponseLinks$outboundSchema` instead. */
  export const outboundSchema = PaymentLinkResponseLinks$outboundSchema;
  /** @deprecated use `PaymentLinkResponseLinks$Outbound` instead. */
  export type Outbound = PaymentLinkResponseLinks$Outbound;
}

export function paymentLinkResponseLinksToJSON(
  paymentLinkResponseLinks: PaymentLinkResponseLinks,
): string {
  return JSON.stringify(
    PaymentLinkResponseLinks$outboundSchema.parse(paymentLinkResponseLinks),
  );
}

export function paymentLinkResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<PaymentLinkResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentLinkResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentLinkResponseLinks' from JSON`,
  );
}

/** @internal */
export const PaymentLinkResponse$inboundSchema: z.ZodType<
  PaymentLinkResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$inboundSchema.optional(),
  description: z.string().optional(),
  amount: z.nullable(AmountNullable$inboundSchema).optional(),
  minimumAmount: z.nullable(AmountNullable$inboundSchema).optional(),
  archived: z.boolean().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(PaymentLineItemResponse$inboundSchema)).optional(),
  billingAddress: PaymentAddress$inboundSchema.optional(),
  shippingAddress: PaymentAddress$inboundSchema.optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean()).optional(),
  createdAt: z.string().optional(),
  paidAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() => PaymentLinkResponseApplicationFee$inboundSchema)
    .optional(),
  sequenceType: PaymentLinkSequenceTypeResponse$inboundSchema.optional(),
  customerId: z.nullable(z.string()).optional(),
  _links: z.lazy(() => PaymentLinkResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type PaymentLinkResponse$Outbound = {
  resource?: string | undefined;
  id?: string | undefined;
  mode?: string | undefined;
  description?: string | undefined;
  amount?: AmountNullable$Outbound | null | undefined;
  minimumAmount?: AmountNullable$Outbound | null | undefined;
  archived?: boolean | undefined;
  redirectUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<PaymentLineItemResponse$Outbound> | null | undefined;
  billingAddress?: PaymentAddress$Outbound | undefined;
  shippingAddress?: PaymentAddress$Outbound | undefined;
  profileId?: string | null | undefined;
  reusable?: boolean | null | undefined;
  createdAt?: string | undefined;
  paidAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  allowedMethods?: Array<string> | null | undefined;
  applicationFee?: PaymentLinkResponseApplicationFee$Outbound | undefined;
  sequenceType?: string | undefined;
  customerId?: string | null | undefined;
  _links?: PaymentLinkResponseLinks$Outbound | undefined;
};

/** @internal */
export const PaymentLinkResponse$outboundSchema: z.ZodType<
  PaymentLinkResponse$Outbound,
  z.ZodTypeDef,
  PaymentLinkResponse
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$outboundSchema.optional(),
  description: z.string().optional(),
  amount: z.nullable(AmountNullable$outboundSchema).optional(),
  minimumAmount: z.nullable(AmountNullable$outboundSchema).optional(),
  archived: z.boolean().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(PaymentLineItemResponse$outboundSchema)).optional(),
  billingAddress: PaymentAddress$outboundSchema.optional(),
  shippingAddress: PaymentAddress$outboundSchema.optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean()).optional(),
  createdAt: z.string().optional(),
  paidAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() => PaymentLinkResponseApplicationFee$outboundSchema)
    .optional(),
  sequenceType: PaymentLinkSequenceTypeResponse$outboundSchema.optional(),
  customerId: z.nullable(z.string()).optional(),
  links: z.lazy(() => PaymentLinkResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentLinkResponse$ {
  /** @deprecated use `PaymentLinkResponse$inboundSchema` instead. */
  export const inboundSchema = PaymentLinkResponse$inboundSchema;
  /** @deprecated use `PaymentLinkResponse$outboundSchema` instead. */
  export const outboundSchema = PaymentLinkResponse$outboundSchema;
  /** @deprecated use `PaymentLinkResponse$Outbound` instead. */
  export type Outbound = PaymentLinkResponse$Outbound;
}

export function paymentLinkResponseToJSON(
  paymentLinkResponse: PaymentLinkResponse,
): string {
  return JSON.stringify(
    PaymentLinkResponse$outboundSchema.parse(paymentLinkResponse),
  );
}

export function paymentLinkResponseFromJSON(
  jsonString: string,
): SafeParseResult<PaymentLinkResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentLinkResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentLinkResponse' from JSON`,
  );
}
