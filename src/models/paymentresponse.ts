/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { RFCDate } from "../types/rfcdate.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import {
  CaptureModeResponse,
  CaptureModeResponse$inboundSchema,
  CaptureModeResponse$outboundSchema,
} from "./capturemoderesponse.js";
import {
  EntityPaymentRouteResponse,
  EntityPaymentRouteResponse$inboundSchema,
  EntityPaymentRouteResponse$Outbound,
  EntityPaymentRouteResponse$outboundSchema,
} from "./entitypaymentrouteresponse.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LineCategoriesResponse,
  LineCategoriesResponse$inboundSchema,
  LineCategoriesResponse$outboundSchema,
} from "./linecategoriesresponse.js";
import {
  LocaleResponse,
  LocaleResponse$inboundSchema,
  LocaleResponse$outboundSchema,
} from "./localeresponse.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";
import {
  MethodResponse,
  MethodResponse$inboundSchema,
  MethodResponse$outboundSchema,
} from "./methodresponse.js";
import { Mode, Mode$inboundSchema, Mode$outboundSchema } from "./mode.js";
import {
  PaymentAddress,
  PaymentAddress$inboundSchema,
  PaymentAddress$Outbound,
  PaymentAddress$outboundSchema,
} from "./paymentaddress.js";
import {
  PaymentDetailsCardAuditionResponse,
  PaymentDetailsCardAuditionResponse$inboundSchema,
  PaymentDetailsCardAuditionResponse$outboundSchema,
} from "./paymentdetailscardauditionresponse.js";
import {
  PaymentDetailsCardFundingResponse,
  PaymentDetailsCardFundingResponse$inboundSchema,
  PaymentDetailsCardFundingResponse$outboundSchema,
} from "./paymentdetailscardfundingresponse.js";
import {
  PaymentDetailsCardLabelResponse,
  PaymentDetailsCardLabelResponse$inboundSchema,
  PaymentDetailsCardLabelResponse$outboundSchema,
} from "./paymentdetailscardlabelresponse.js";
import {
  PaymentDetailsCardSecurityResponse,
  PaymentDetailsCardSecurityResponse$inboundSchema,
  PaymentDetailsCardSecurityResponse$outboundSchema,
} from "./paymentdetailscardsecurityresponse.js";
import {
  PaymentDetailsFailureReasonResponse,
  PaymentDetailsFailureReasonResponse$inboundSchema,
  PaymentDetailsFailureReasonResponse$outboundSchema,
} from "./paymentdetailsfailurereasonresponse.js";
import {
  PaymentDetailsFeeRegionResponse,
  PaymentDetailsFeeRegionResponse$inboundSchema,
  PaymentDetailsFeeRegionResponse$outboundSchema,
} from "./paymentdetailsfeeregionresponse.js";
import {
  PaymentDetailsReceiptCardReadMethodResponse,
  PaymentDetailsReceiptCardReadMethodResponse$inboundSchema,
  PaymentDetailsReceiptCardReadMethodResponse$outboundSchema,
} from "./paymentdetailsreceiptcardreadmethodresponse.js";
import {
  PaymentDetailsReceiptCardVerificationMethodResponse,
  PaymentDetailsReceiptCardVerificationMethodResponse$inboundSchema,
  PaymentDetailsReceiptCardVerificationMethodResponse$outboundSchema,
} from "./paymentdetailsreceiptcardverificationmethodresponse.js";
import {
  PaymentDetailsSellerProtectionResponse,
  PaymentDetailsSellerProtectionResponse$inboundSchema,
  PaymentDetailsSellerProtectionResponse$outboundSchema,
} from "./paymentdetailssellerprotectionresponse.js";
import {
  PaymentDetailsWalletResponse,
  PaymentDetailsWalletResponse$inboundSchema,
  PaymentDetailsWalletResponse$outboundSchema,
} from "./paymentdetailswalletresponse.js";
import {
  PaymentLineTypeResponse,
  PaymentLineTypeResponse$inboundSchema,
  PaymentLineTypeResponse$outboundSchema,
} from "./paymentlinetyperesponse.js";
import {
  PaymentStatus,
  PaymentStatus$inboundSchema,
  PaymentStatus$outboundSchema,
} from "./paymentstatus.js";
import {
  RecurringLineItem,
  RecurringLineItem$inboundSchema,
  RecurringLineItem$Outbound,
  RecurringLineItem$outboundSchema,
} from "./recurringlineitem.js";
import {
  SequenceTypeResponse,
  SequenceTypeResponse$inboundSchema,
  SequenceTypeResponse$outboundSchema,
} from "./sequencetyperesponse.js";
import {
  StatusReason,
  StatusReason$inboundSchema,
  StatusReason$Outbound,
  StatusReason$outboundSchema,
} from "./statusreason.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

export type PaymentResponseLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: PaymentLineTypeResponse | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  unitPrice: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  discountAmount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  totalAmount: Amount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  vatAmount?: Amount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
   */
  categories?: Array<LineCategoriesResponse> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  recurring?: RecurringLineItem | undefined;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type PaymentResponseApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * The Point of sale receipt object.
 */
export type Receipt = {
  /**
   * A unique code provided by the cardholder’s bank to confirm that the transaction was successfully approved.
   */
  authorizationCode?: string | null | undefined;
  /**
   * The unique number that identifies a specific payment application on a chip card.
   */
  applicationIdentifier?: string | null | undefined;
  /**
   * The method by which the card was read by the terminal.
   */
  cardReadMethod?:
    | PaymentDetailsReceiptCardReadMethodResponse
    | null
    | undefined;
  /**
   * The method used to verify the cardholder's identity.
   */
  cardVerificationMethod?:
    | PaymentDetailsReceiptCardVerificationMethodResponse
    | null
    | undefined;
};

/**
 * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
 *
 * @remarks
 * the QR code details will be available in this object.
 *
 * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
 * Bancontact QR payments can be completed by the customer using the Bancontact app.
 */
export type QrCode = {
  /**
   * The height of the QR code image in pixels.
   */
  height?: number | undefined;
  /**
   * The width of the QR code image in pixels.
   */
  width?: number | undefined;
  /**
   * The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or
   *
   * @remarks
   * downloaded.
   */
  src?: string | undefined;
};

/**
 * An object containing payment details collected during the payment process. For example, details may include the
 *
 * @remarks
 * customer's card or bank details and a payment reference. For the full list of details, please refer to the
 * [method-specific parameters](extra-payment-parameters) guide.
 */
export type PaymentResponseDetails = {
  /**
   * The customer's name, if made available by the payment method. For card payments, refer to details.cardHolder.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's account reference.
   *
   * @remarks
   *
   * For banking-based payment methods — such as iDEAL — this is normally either an IBAN or a domestic bank account
   * number.
   *
   * For PayPal, the account reference is an email address.
   *
   * For card and Bancontact payments, refer to details.cardNumber.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank account, if applicable.
   */
  consumerBic?: string | null | undefined;
  /**
   * For wallet payment methods — such as Apple Pay and PayPal — the shipping address is often already known by the
   *
   * @remarks
   * wallet provider. In these cases the shipping address may be available as a payment detail.
   */
  shippingAddress?: { [k: string]: any } | null | undefined;
  /**
   * For bancontact, it will be the customer's masked card number. For cards, it will be the last 4-digit of the
   *
   * @remarks
   * PAN. For Point-of-sale, it will be the the last 4 digits of the customer's masked card number.
   */
  cardNumber?: string | null | undefined;
  /**
   * The name of the bank that the customer will need to make the bank transfer payment towards.
   */
  bankName?: string | undefined;
  /**
   * The bank account number the customer will need to make the bank transfer payment towards.
   */
  bankAccount?: string | undefined;
  /**
   * The BIC of the bank the customer will need to make the bank transfer payment towards.
   */
  bankBic?: string | undefined;
  /**
   * The Mollie-generated reference the customer needs to use when transfering the amount. Do not apply any
   *
   * @remarks
   * formatting here; show it to the customer as-is.
   */
  transferReference?: string | null | undefined;
  /**
   * A unique fingerprint for a specific card. Can be used to identify returning customers.
   *
   * @remarks
   *
   * In the case of Point-of-sale payments, it's a unique identifier assigned to a cardholder's payment account,
   * linking multiple transactions from wallets and physical card to a single account, also across payment methods
   * or when the card is reissued.
   */
  cardFingerprint?: string | null | undefined;
  /**
   * The customer's name as shown on their card.
   */
  cardHolder?: string | null | undefined;
  /**
   * The card's target audience, if known.
   */
  cardAudition?: PaymentDetailsCardAuditionResponse | null | undefined;
  /**
   * The card's label, if known.
   */
  cardLabel?: PaymentDetailsCardLabelResponse | null | undefined;
  /**
   * The ISO 3166-1 alpha-2 country code of the country the card was issued in.
   */
  cardCountryCode?: string | null | undefined;
  /**
   * The expiry date (MM/YY) of the card as displayed on the card.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card type.
   */
  cardFunding?: PaymentDetailsCardFundingResponse | null | undefined;
  /**
   * The level of security applied during card processing.
   */
  cardSecurity?: PaymentDetailsCardSecurityResponse | null | undefined;
  /**
   * The applicable card fee region.
   */
  feeRegion?: PaymentDetailsFeeRegionResponse | null | undefined;
  /**
   * The first 6 and last 4 digits of the card number.
   */
  cardMaskedNumber?: string | null | undefined;
  /**
   * The outcome of authentication attempted on transactions enforced by 3DS (ie valid only for oneoff and first).
   */
  card3dsEci?: string | null | undefined;
  /**
   * The first 6 digit of the card bank identification number.
   */
  cardBin?: string | null | undefined;
  /**
   * The issuer of the Card.
   */
  cardIssuer?: string | null | undefined;
  /**
   * A failure code to help understand why the payment failed.
   */
  failureReason?: PaymentDetailsFailureReasonResponse | null | undefined;
  /**
   * A human-friendly failure message that can be shown to the customer. The message is translated in accordance
   *
   * @remarks
   * with the payment's locale setting.
   */
  failureMessage?: string | null | undefined;
  /**
   * The wallet used when creating the payment.
   */
  wallet?: PaymentDetailsWalletResponse | null | undefined;
  /**
   * PayPal's reference for the payment.
   */
  paypalReference?: string | null | undefined;
  /**
   * ID of the customer's PayPal account.
   */
  paypalPayerId?: string | null | undefined;
  /**
   * Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
   *
   * @remarks
   * payments, and if the information is made available by PayPal.
   */
  sellerProtection?: PaymentDetailsSellerProtectionResponse | null | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  paypalFee?: AmountNullable | null | undefined;
  /**
   * The paysafecard customer reference either provided via the API or otherwise auto-generated by Mollie.
   */
  customerReference?: string | undefined;
  /**
   * The ID of the terminal device where the payment took place on.
   */
  terminalId?: string | undefined;
  /**
   * The first 6 digits & last 4 digits of the customer's masked card number.
   */
  maskedNumber?: string | null | undefined;
  /**
   * The Point of sale receipt object.
   */
  receipt?: Receipt | undefined;
  /**
   * The creditor identifier indicates who is authorized to execute the payment. In this case, it is a
   *
   * @remarks
   * reference to Mollie.
   */
  creditorIdentifier?: string | null | undefined;
  /**
   * Estimated date the payment is debited from the customer's bank account, in YYYY-MM-DD format.
   */
  dueDate?: RFCDate | null | undefined;
  /**
   * Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment
   *
   * @remarks
   * has been signed.
   */
  signatureDate?: RFCDate | null | undefined;
  /**
   * The official reason why this payment has failed. A detailed description of each reason is available on the
   *
   * @remarks
   * website of the European Payments Council.
   */
  bankReasonCode?: string | null | undefined;
  /**
   * A human-friendly description of the failure reason.
   */
  bankReason?: string | null | undefined;
  /**
   * The end-to-end identifier you provided in the batch file.
   */
  endToEndIdentifier?: string | null | undefined;
  /**
   * The mandate reference you provided in the batch file.
   */
  mandateReference?: string | null | undefined;
  /**
   * The batch reference you provided in the batch file.
   */
  batchReference?: string | null | undefined;
  /**
   * The file reference you provided in the batch file.
   */
  fileReference?: string | null | undefined;
  /**
   * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
   *
   * @remarks
   * the QR code details will be available in this object.
   *
   * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
   * Bancontact QR payments can be completed by the customer using the Bancontact app.
   */
  qrCode?: QrCode | undefined;
  /**
   * For payments with gift cards: the masked gift card number of the first gift card applied to the payment.
   */
  voucherNumber?: string | undefined;
  /**
   * An array of detail objects for each gift card that was used on this payment, if any.
   */
  giftcards?: Array<{ [k: string]: any }> | undefined;
  /**
   * For payments with vouchers: the brand name of the first voucher applied.
   */
  issuer?: string | undefined;
  /**
   * An array of detail objects for each voucher that was used on this payment, if any.
   */
  vouchers?: Array<{ [k: string]: any }> | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  remainderAmount?: Amount | undefined;
  /**
   * The payment method used to pay the remainder amount, after all gift cards or vouchers were applied.
   */
  remainderMethod?: string | undefined;
  /**
   * Optional include. The full payment method details of the remainder payment.
   */
  remainderDetails?: { [k: string]: any } | undefined;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type PaymentResponseLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  checkout?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mobileAppCheckout?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  changePaymentState?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  dashboard: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  refunds?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  chargebacks?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  captures?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  settlement?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  customer?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  mandate?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  subscription?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  order?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  terminal?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  status?: Url | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  payOnline?: Url | undefined;
};

export type PaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource?: string | undefined;
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: Mode | undefined;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description?: string | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountRefunded?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountRemaining?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountCaptured?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amountChargedBack?: Amount | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  settlementAmount?: Amount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<PaymentResponseLine> | null | undefined;
  billingAddress?: PaymentAddress | undefined;
  shippingAddress?: PaymentAddress | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: LocaleResponse | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: MethodResponse | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: Metadata | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CaptureModeResponse | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: PaymentResponseApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<EntityPaymentRouteResponse> | null | undefined;
  sequenceType?: SequenceTypeResponse | undefined;
  subscriptionId?: string | undefined;
  mandateId?: string | undefined;
  customerId?: string | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | undefined;
  settlementId?: string | undefined;
  orderId?: string | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status?: PaymentStatus | undefined;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: StatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: PaymentResponseDetails | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: PaymentResponseLinks | undefined;
};

/** @internal */
export const PaymentResponseLine$inboundSchema: z.ZodType<
  PaymentResponseLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaymentLineTypeResponse$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$inboundSchema,
  discountAmount: Amount$inboundSchema.optional(),
  totalAmount: Amount$inboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$inboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategoriesResponse$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$inboundSchema.optional(),
});

/** @internal */
export type PaymentResponseLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: Amount$Outbound;
  discountAmount?: Amount$Outbound | undefined;
  totalAmount: Amount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: Amount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: RecurringLineItem$Outbound | undefined;
};

/** @internal */
export const PaymentResponseLine$outboundSchema: z.ZodType<
  PaymentResponseLine$Outbound,
  z.ZodTypeDef,
  PaymentResponseLine
> = z.object({
  type: PaymentLineTypeResponse$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: Amount$outboundSchema,
  discountAmount: Amount$outboundSchema.optional(),
  totalAmount: Amount$outboundSchema,
  vatRate: z.string().optional(),
  vatAmount: Amount$outboundSchema.optional(),
  sku: z.string().optional(),
  categories: z.array(LineCategoriesResponse$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: RecurringLineItem$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentResponseLine$ {
  /** @deprecated use `PaymentResponseLine$inboundSchema` instead. */
  export const inboundSchema = PaymentResponseLine$inboundSchema;
  /** @deprecated use `PaymentResponseLine$outboundSchema` instead. */
  export const outboundSchema = PaymentResponseLine$outboundSchema;
  /** @deprecated use `PaymentResponseLine$Outbound` instead. */
  export type Outbound = PaymentResponseLine$Outbound;
}

export function paymentResponseLineToJSON(
  paymentResponseLine: PaymentResponseLine,
): string {
  return JSON.stringify(
    PaymentResponseLine$outboundSchema.parse(paymentResponseLine),
  );
}

export function paymentResponseLineFromJSON(
  jsonString: string,
): SafeParseResult<PaymentResponseLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentResponseLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentResponseLine' from JSON`,
  );
}

/** @internal */
export const PaymentResponseApplicationFee$inboundSchema: z.ZodType<
  PaymentResponseApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  description: z.string().optional(),
});

/** @internal */
export type PaymentResponseApplicationFee$Outbound = {
  amount?: Amount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const PaymentResponseApplicationFee$outboundSchema: z.ZodType<
  PaymentResponseApplicationFee$Outbound,
  z.ZodTypeDef,
  PaymentResponseApplicationFee
> = z.object({
  amount: Amount$outboundSchema.optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentResponseApplicationFee$ {
  /** @deprecated use `PaymentResponseApplicationFee$inboundSchema` instead. */
  export const inboundSchema = PaymentResponseApplicationFee$inboundSchema;
  /** @deprecated use `PaymentResponseApplicationFee$outboundSchema` instead. */
  export const outboundSchema = PaymentResponseApplicationFee$outboundSchema;
  /** @deprecated use `PaymentResponseApplicationFee$Outbound` instead. */
  export type Outbound = PaymentResponseApplicationFee$Outbound;
}

export function paymentResponseApplicationFeeToJSON(
  paymentResponseApplicationFee: PaymentResponseApplicationFee,
): string {
  return JSON.stringify(
    PaymentResponseApplicationFee$outboundSchema.parse(
      paymentResponseApplicationFee,
    ),
  );
}

export function paymentResponseApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<PaymentResponseApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentResponseApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentResponseApplicationFee' from JSON`,
  );
}

/** @internal */
export const Receipt$inboundSchema: z.ZodType<Receipt, z.ZodTypeDef, unknown> =
  z.object({
    authorizationCode: z.nullable(z.string()).optional(),
    applicationIdentifier: z.nullable(z.string()).optional(),
    cardReadMethod: z.nullable(
      PaymentDetailsReceiptCardReadMethodResponse$inboundSchema,
    ).optional(),
    cardVerificationMethod: z.nullable(
      PaymentDetailsReceiptCardVerificationMethodResponse$inboundSchema,
    ).optional(),
  });

/** @internal */
export type Receipt$Outbound = {
  authorizationCode?: string | null | undefined;
  applicationIdentifier?: string | null | undefined;
  cardReadMethod?: string | null | undefined;
  cardVerificationMethod?: string | null | undefined;
};

/** @internal */
export const Receipt$outboundSchema: z.ZodType<
  Receipt$Outbound,
  z.ZodTypeDef,
  Receipt
> = z.object({
  authorizationCode: z.nullable(z.string()).optional(),
  applicationIdentifier: z.nullable(z.string()).optional(),
  cardReadMethod: z.nullable(
    PaymentDetailsReceiptCardReadMethodResponse$outboundSchema,
  ).optional(),
  cardVerificationMethod: z.nullable(
    PaymentDetailsReceiptCardVerificationMethodResponse$outboundSchema,
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Receipt$ {
  /** @deprecated use `Receipt$inboundSchema` instead. */
  export const inboundSchema = Receipt$inboundSchema;
  /** @deprecated use `Receipt$outboundSchema` instead. */
  export const outboundSchema = Receipt$outboundSchema;
  /** @deprecated use `Receipt$Outbound` instead. */
  export type Outbound = Receipt$Outbound;
}

export function receiptToJSON(receipt: Receipt): string {
  return JSON.stringify(Receipt$outboundSchema.parse(receipt));
}

export function receiptFromJSON(
  jsonString: string,
): SafeParseResult<Receipt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Receipt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Receipt' from JSON`,
  );
}

/** @internal */
export const QrCode$inboundSchema: z.ZodType<QrCode, z.ZodTypeDef, unknown> = z
  .object({
    height: z.number().int().optional(),
    width: z.number().int().optional(),
    src: z.string().optional(),
  });

/** @internal */
export type QrCode$Outbound = {
  height?: number | undefined;
  width?: number | undefined;
  src?: string | undefined;
};

/** @internal */
export const QrCode$outboundSchema: z.ZodType<
  QrCode$Outbound,
  z.ZodTypeDef,
  QrCode
> = z.object({
  height: z.number().int().optional(),
  width: z.number().int().optional(),
  src: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QrCode$ {
  /** @deprecated use `QrCode$inboundSchema` instead. */
  export const inboundSchema = QrCode$inboundSchema;
  /** @deprecated use `QrCode$outboundSchema` instead. */
  export const outboundSchema = QrCode$outboundSchema;
  /** @deprecated use `QrCode$Outbound` instead. */
  export type Outbound = QrCode$Outbound;
}

export function qrCodeToJSON(qrCode: QrCode): string {
  return JSON.stringify(QrCode$outboundSchema.parse(qrCode));
}

export function qrCodeFromJSON(
  jsonString: string,
): SafeParseResult<QrCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QrCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QrCode' from JSON`,
  );
}

/** @internal */
export const PaymentResponseDetails$inboundSchema: z.ZodType<
  PaymentResponseDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(PaymentDetailsCardAuditionResponse$inboundSchema)
    .optional(),
  cardLabel: z.nullable(PaymentDetailsCardLabelResponse$inboundSchema)
    .optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(PaymentDetailsCardFundingResponse$inboundSchema)
    .optional(),
  cardSecurity: z.nullable(PaymentDetailsCardSecurityResponse$inboundSchema)
    .optional(),
  feeRegion: z.nullable(PaymentDetailsFeeRegionResponse$inboundSchema)
    .optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(PaymentDetailsFailureReasonResponse$inboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(PaymentDetailsWalletResponse$inboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    PaymentDetailsSellerProtectionResponse$inboundSchema,
  ).optional(),
  paypalFee: z.nullable(AmountNullable$inboundSchema).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => Receipt$inboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.string().transform(v => new RFCDate(v))).optional(),
  signatureDate: z.nullable(z.string().transform(v => new RFCDate(v)))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => QrCode$inboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: Amount$inboundSchema.optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
});

/** @internal */
export type PaymentResponseDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  shippingAddress?: { [k: string]: any } | null | undefined;
  cardNumber?: string | null | undefined;
  bankName?: string | undefined;
  bankAccount?: string | undefined;
  bankBic?: string | undefined;
  transferReference?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardAudition?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardCountryCode?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardFunding?: string | null | undefined;
  cardSecurity?: string | null | undefined;
  feeRegion?: string | null | undefined;
  cardMaskedNumber?: string | null | undefined;
  card3dsEci?: string | null | undefined;
  cardBin?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  failureReason?: string | null | undefined;
  failureMessage?: string | null | undefined;
  wallet?: string | null | undefined;
  paypalReference?: string | null | undefined;
  paypalPayerId?: string | null | undefined;
  sellerProtection?: string | null | undefined;
  paypalFee?: AmountNullable$Outbound | null | undefined;
  customerReference?: string | undefined;
  terminalId?: string | undefined;
  maskedNumber?: string | null | undefined;
  receipt?: Receipt$Outbound | undefined;
  creditorIdentifier?: string | null | undefined;
  dueDate?: string | null | undefined;
  signatureDate?: string | null | undefined;
  bankReasonCode?: string | null | undefined;
  bankReason?: string | null | undefined;
  endToEndIdentifier?: string | null | undefined;
  mandateReference?: string | null | undefined;
  batchReference?: string | null | undefined;
  fileReference?: string | null | undefined;
  qrCode?: QrCode$Outbound | undefined;
  voucherNumber?: string | undefined;
  giftcards?: Array<{ [k: string]: any }> | undefined;
  issuer?: string | undefined;
  vouchers?: Array<{ [k: string]: any }> | undefined;
  remainderAmount?: Amount$Outbound | undefined;
  remainderMethod?: string | undefined;
  remainderDetails?: { [k: string]: any } | undefined;
};

/** @internal */
export const PaymentResponseDetails$outboundSchema: z.ZodType<
  PaymentResponseDetails$Outbound,
  z.ZodTypeDef,
  PaymentResponseDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(PaymentDetailsCardAuditionResponse$outboundSchema)
    .optional(),
  cardLabel: z.nullable(PaymentDetailsCardLabelResponse$outboundSchema)
    .optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(PaymentDetailsCardFundingResponse$outboundSchema)
    .optional(),
  cardSecurity: z.nullable(PaymentDetailsCardSecurityResponse$outboundSchema)
    .optional(),
  feeRegion: z.nullable(PaymentDetailsFeeRegionResponse$outboundSchema)
    .optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(PaymentDetailsFailureReasonResponse$outboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(PaymentDetailsWalletResponse$outboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    PaymentDetailsSellerProtectionResponse$outboundSchema,
  ).optional(),
  paypalFee: z.nullable(AmountNullable$outboundSchema).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => Receipt$outboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  signatureDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => QrCode$outboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: Amount$outboundSchema.optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentResponseDetails$ {
  /** @deprecated use `PaymentResponseDetails$inboundSchema` instead. */
  export const inboundSchema = PaymentResponseDetails$inboundSchema;
  /** @deprecated use `PaymentResponseDetails$outboundSchema` instead. */
  export const outboundSchema = PaymentResponseDetails$outboundSchema;
  /** @deprecated use `PaymentResponseDetails$Outbound` instead. */
  export type Outbound = PaymentResponseDetails$Outbound;
}

export function paymentResponseDetailsToJSON(
  paymentResponseDetails: PaymentResponseDetails,
): string {
  return JSON.stringify(
    PaymentResponseDetails$outboundSchema.parse(paymentResponseDetails),
  );
}

export function paymentResponseDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PaymentResponseDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentResponseDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentResponseDetails' from JSON`,
  );
}

/** @internal */
export const PaymentResponseLinks$inboundSchema: z.ZodType<
  PaymentResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  checkout: Url$inboundSchema.optional(),
  mobileAppCheckout: Url$inboundSchema.optional(),
  changePaymentState: Url$inboundSchema.optional(),
  dashboard: Url$inboundSchema,
  refunds: Url$inboundSchema.optional(),
  chargebacks: Url$inboundSchema.optional(),
  captures: Url$inboundSchema.optional(),
  settlement: Url$inboundSchema.optional(),
  customer: Url$inboundSchema.optional(),
  mandate: Url$inboundSchema.optional(),
  subscription: Url$inboundSchema.optional(),
  order: Url$inboundSchema.optional(),
  terminal: Url$inboundSchema.optional(),
  documentation: Url$inboundSchema.optional(),
  status: Url$inboundSchema.optional(),
  payOnline: Url$inboundSchema.optional(),
});

/** @internal */
export type PaymentResponseLinks$Outbound = {
  self: Url$Outbound;
  checkout?: Url$Outbound | undefined;
  mobileAppCheckout?: Url$Outbound | undefined;
  changePaymentState?: Url$Outbound | undefined;
  dashboard: Url$Outbound;
  refunds?: Url$Outbound | undefined;
  chargebacks?: Url$Outbound | undefined;
  captures?: Url$Outbound | undefined;
  settlement?: Url$Outbound | undefined;
  customer?: Url$Outbound | undefined;
  mandate?: Url$Outbound | undefined;
  subscription?: Url$Outbound | undefined;
  order?: Url$Outbound | undefined;
  terminal?: Url$Outbound | undefined;
  documentation?: Url$Outbound | undefined;
  status?: Url$Outbound | undefined;
  payOnline?: Url$Outbound | undefined;
};

/** @internal */
export const PaymentResponseLinks$outboundSchema: z.ZodType<
  PaymentResponseLinks$Outbound,
  z.ZodTypeDef,
  PaymentResponseLinks
> = z.object({
  self: Url$outboundSchema,
  checkout: Url$outboundSchema.optional(),
  mobileAppCheckout: Url$outboundSchema.optional(),
  changePaymentState: Url$outboundSchema.optional(),
  dashboard: Url$outboundSchema,
  refunds: Url$outboundSchema.optional(),
  chargebacks: Url$outboundSchema.optional(),
  captures: Url$outboundSchema.optional(),
  settlement: Url$outboundSchema.optional(),
  customer: Url$outboundSchema.optional(),
  mandate: Url$outboundSchema.optional(),
  subscription: Url$outboundSchema.optional(),
  order: Url$outboundSchema.optional(),
  terminal: Url$outboundSchema.optional(),
  documentation: Url$outboundSchema.optional(),
  status: Url$outboundSchema.optional(),
  payOnline: Url$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentResponseLinks$ {
  /** @deprecated use `PaymentResponseLinks$inboundSchema` instead. */
  export const inboundSchema = PaymentResponseLinks$inboundSchema;
  /** @deprecated use `PaymentResponseLinks$outboundSchema` instead. */
  export const outboundSchema = PaymentResponseLinks$outboundSchema;
  /** @deprecated use `PaymentResponseLinks$Outbound` instead. */
  export type Outbound = PaymentResponseLinks$Outbound;
}

export function paymentResponseLinksToJSON(
  paymentResponseLinks: PaymentResponseLinks,
): string {
  return JSON.stringify(
    PaymentResponseLinks$outboundSchema.parse(paymentResponseLinks),
  );
}

export function paymentResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<PaymentResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentResponseLinks' from JSON`,
  );
}

/** @internal */
export const PaymentResponse$inboundSchema: z.ZodType<
  PaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$inboundSchema.optional(),
  description: z.string().optional(),
  amount: Amount$inboundSchema.optional(),
  amountRefunded: Amount$inboundSchema.optional(),
  amountRemaining: Amount$inboundSchema.optional(),
  amountCaptured: Amount$inboundSchema.optional(),
  amountChargedBack: Amount$inboundSchema.optional(),
  settlementAmount: Amount$inboundSchema.optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentResponseLine$inboundSchema)))
    .optional(),
  billingAddress: PaymentAddress$inboundSchema.optional(),
  shippingAddress: PaymentAddress$inboundSchema.optional(),
  locale: z.nullable(LocaleResponse$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(MethodResponse$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$inboundSchema).optional(),
  captureMode: z.nullable(CaptureModeResponse$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentResponseApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRouteResponse$inboundSchema))
    .optional(),
  sequenceType: SequenceTypeResponse$inboundSchema.optional(),
  subscriptionId: z.string().optional(),
  mandateId: z.string().optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  settlementId: z.string().optional(),
  orderId: z.string().optional(),
  status: PaymentStatus$inboundSchema.optional(),
  statusReason: z.nullable(StatusReason$inboundSchema).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => PaymentResponseDetails$inboundSchema))
    .optional(),
  createdAt: z.string().optional(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => PaymentResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type PaymentResponse$Outbound = {
  resource?: string | undefined;
  id?: string | undefined;
  mode?: string | undefined;
  description?: string | undefined;
  amount?: Amount$Outbound | undefined;
  amountRefunded?: Amount$Outbound | undefined;
  amountRemaining?: Amount$Outbound | undefined;
  amountCaptured?: Amount$Outbound | undefined;
  amountChargedBack?: Amount$Outbound | undefined;
  settlementAmount?: Amount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<PaymentResponseLine$Outbound> | null | undefined;
  billingAddress?: PaymentAddress$Outbound | undefined;
  shippingAddress?: PaymentAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?: PaymentResponseApplicationFee$Outbound | null | undefined;
  routing?: Array<EntityPaymentRouteResponse$Outbound> | null | undefined;
  sequenceType?: string | undefined;
  subscriptionId?: string | undefined;
  mandateId?: string | undefined;
  customerId?: string | undefined;
  profileId?: string | undefined;
  settlementId?: string | undefined;
  orderId?: string | undefined;
  status?: string | undefined;
  statusReason?: StatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: PaymentResponseDetails$Outbound | null | undefined;
  createdAt?: string | undefined;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links?: PaymentResponseLinks$Outbound | undefined;
};

/** @internal */
export const PaymentResponse$outboundSchema: z.ZodType<
  PaymentResponse$Outbound,
  z.ZodTypeDef,
  PaymentResponse
> = z.object({
  resource: z.string().optional(),
  id: z.string().optional(),
  mode: Mode$outboundSchema.optional(),
  description: z.string().optional(),
  amount: Amount$outboundSchema.optional(),
  amountRefunded: Amount$outboundSchema.optional(),
  amountRemaining: Amount$outboundSchema.optional(),
  amountCaptured: Amount$outboundSchema.optional(),
  amountChargedBack: Amount$outboundSchema.optional(),
  settlementAmount: Amount$outboundSchema.optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => PaymentResponseLine$outboundSchema)))
    .optional(),
  billingAddress: PaymentAddress$outboundSchema.optional(),
  shippingAddress: PaymentAddress$outboundSchema.optional(),
  locale: z.nullable(LocaleResponse$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(MethodResponse$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(Metadata$outboundSchema).optional(),
  captureMode: z.nullable(CaptureModeResponse$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => PaymentResponseApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(z.array(EntityPaymentRouteResponse$outboundSchema))
    .optional(),
  sequenceType: SequenceTypeResponse$outboundSchema.optional(),
  subscriptionId: z.string().optional(),
  mandateId: z.string().optional(),
  customerId: z.string().optional(),
  profileId: z.string().optional(),
  settlementId: z.string().optional(),
  orderId: z.string().optional(),
  status: PaymentStatus$outboundSchema.optional(),
  statusReason: z.nullable(StatusReason$outboundSchema).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => PaymentResponseDetails$outboundSchema))
    .optional(),
  createdAt: z.string().optional(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => PaymentResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentResponse$ {
  /** @deprecated use `PaymentResponse$inboundSchema` instead. */
  export const inboundSchema = PaymentResponse$inboundSchema;
  /** @deprecated use `PaymentResponse$outboundSchema` instead. */
  export const outboundSchema = PaymentResponse$outboundSchema;
  /** @deprecated use `PaymentResponse$Outbound` instead. */
  export type Outbound = PaymentResponse$Outbound;
}

export function paymentResponseToJSON(
  paymentResponse: PaymentResponse,
): string {
  return JSON.stringify(PaymentResponse$outboundSchema.parse(paymentResponse));
}

export function paymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<PaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentResponse' from JSON`,
  );
}
