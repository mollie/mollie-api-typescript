/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type CreateCustomerPaymentAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreateCustomerPaymentLineTypeRequest = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreateCustomerPaymentLineTypeRequest = ClosedEnum<
  typeof CreateCustomerPaymentLineTypeRequest
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreateCustomerPaymentUnitPriceRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreateCustomerPaymentDiscountAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreateCustomerPaymentTotalAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreateCustomerPaymentVatAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreateCustomerPaymentCategoryRequest = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreateCustomerPaymentCategoryRequest = ClosedEnum<
  typeof CreateCustomerPaymentCategoryRequest
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const CreateCustomerPaymentIntervalRequest = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type CreateCustomerPaymentIntervalRequest = ClosedEnum<
  typeof CreateCustomerPaymentIntervalRequest
>;

/**
 * Total amount and currency of the recurring item.
 */
export type CreateCustomerPaymentRecurringAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type CreateCustomerPaymentRecurringRequest = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: CreateCustomerPaymentIntervalRequest;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: CreateCustomerPaymentRecurringAmountRequest | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type CreateCustomerPaymentLineRequest = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreateCustomerPaymentLineTypeRequest | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreateCustomerPaymentUnitPriceRequest;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreateCustomerPaymentDiscountAmountRequest | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreateCustomerPaymentTotalAmountRequest;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreateCustomerPaymentVatAmountRequest | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreateCustomerPaymentCategoryRequest> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: CreateCustomerPaymentRecurringRequest | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreateCustomerPaymentBillingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreateCustomerPaymentShippingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const CreateCustomerPaymentLocaleRequest = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type CreateCustomerPaymentLocaleRequest = ClosedEnum<
  typeof CreateCustomerPaymentLocaleRequest
>;

/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export const CreateCustomerPaymentMethodRequest = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export type CreateCustomerPaymentMethodRequest = ClosedEnum<
  typeof CreateCustomerPaymentMethodRequest
>;

export type CreateCustomerPaymentMetadataRequest = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type CreateCustomerPaymentMetadataRequestUnion =
  | CreateCustomerPaymentMetadataRequest
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const CreateCustomerPaymentCaptureModeRequest = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type CreateCustomerPaymentCaptureModeRequest = ClosedEnum<
  typeof CreateCustomerPaymentCaptureModeRequest
>;

/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export const CreateCustomerPaymentCaptureDelayRequest = {
  DotDotDotHours: "... hours",
  DotDotDotDays: "... days",
} as const;
/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export type CreateCustomerPaymentCaptureDelayRequest = ClosedEnum<
  typeof CreateCustomerPaymentCaptureDelayRequest
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreateCustomerPaymentApplicationFeeAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type CreateCustomerPaymentApplicationFeeRequest = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: CreateCustomerPaymentApplicationFeeAmountRequest | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type CreateCustomerPaymentRoutingAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const CreateCustomerPaymentRoutingTypeRequest = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type CreateCustomerPaymentRoutingTypeRequest = ClosedEnum<
  typeof CreateCustomerPaymentRoutingTypeRequest
>;

/**
 * The destination of this portion of the payment.
 */
export type CreateCustomerPaymentDestinationRequest = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: CreateCustomerPaymentRoutingTypeRequest;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateCustomerPaymentSelfRequest = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type CreateCustomerPaymentPaymentRequest = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreateCustomerPaymentLinksRequest = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreateCustomerPaymentSelfRequest;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: CreateCustomerPaymentPaymentRequest;
};

export type CreateCustomerPaymentRoutingRequest = {
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: CreateCustomerPaymentRoutingAmountRequest;
  /**
   * The destination of this portion of the payment.
   */
  destination: CreateCustomerPaymentDestinationRequest;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreateCustomerPaymentLinksRequest;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const CreateCustomerPaymentSequenceTypeRequest = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type CreateCustomerPaymentSequenceTypeRequest = ClosedEnum<
  typeof CreateCustomerPaymentSequenceTypeRequest
>;

export type CreateCustomerPaymentRequestBody = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: CreateCustomerPaymentAmountRequest;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl: string | null;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreateCustomerPaymentLineRequest> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreateCustomerPaymentBillingAddressRequest | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreateCustomerPaymentShippingAddressRequest | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: CreateCustomerPaymentLocaleRequest | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: CreateCustomerPaymentMethodRequest | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | CreateCustomerPaymentMetadataRequest
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CreateCustomerPaymentCaptureModeRequest | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   */
  captureDelay?: CreateCustomerPaymentCaptureDelayRequest | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?:
    | CreateCustomerPaymentApplicationFeeRequest
    | null
    | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<CreateCustomerPaymentRoutingRequest> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: CreateCustomerPaymentSequenceTypeRequest | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId?: string | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

export type CreateCustomerPaymentRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  requestBody?: CreateCustomerPaymentRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreateCustomerPaymentServiceUnavailableDocumentation = {
  href: string;
  type: string;
};

export type CreateCustomerPaymentServiceUnavailableLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreateCustomerPaymentServiceUnavailableDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreateCustomerPaymentUnprocessableEntityDocumentation = {
  href: string;
  type: string;
};

export type CreateCustomerPaymentUnprocessableEntityLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreateCustomerPaymentUnprocessableEntityDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreateCustomerPaymentMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreateCustomerPaymentMode = ClosedEnum<
  typeof CreateCustomerPaymentMode
>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type CreateCustomerPaymentAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type CreateCustomerPaymentAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type CreateCustomerPaymentAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type CreateCustomerPaymentAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type CreateCustomerPaymentAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type CreateCustomerPaymentSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreateCustomerPaymentLineTypeResponse = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreateCustomerPaymentLineTypeResponse = ClosedEnum<
  typeof CreateCustomerPaymentLineTypeResponse
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreateCustomerPaymentUnitPriceResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreateCustomerPaymentDiscountAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreateCustomerPaymentTotalAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreateCustomerPaymentVatAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreateCustomerPaymentCategoryResponse = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreateCustomerPaymentCategoryResponse = ClosedEnum<
  typeof CreateCustomerPaymentCategoryResponse
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const CreateCustomerPaymentIntervalResponse = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type CreateCustomerPaymentIntervalResponse = ClosedEnum<
  typeof CreateCustomerPaymentIntervalResponse
>;

/**
 * Total amount and currency of the recurring item.
 */
export type CreateCustomerPaymentRecurringAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type CreateCustomerPaymentRecurringResponse = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: CreateCustomerPaymentIntervalResponse;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: CreateCustomerPaymentRecurringAmountResponse | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type CreateCustomerPaymentLineResponse = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreateCustomerPaymentLineTypeResponse | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreateCustomerPaymentUnitPriceResponse;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreateCustomerPaymentDiscountAmountResponse | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreateCustomerPaymentTotalAmountResponse;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreateCustomerPaymentVatAmountResponse | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreateCustomerPaymentCategoryResponse> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: CreateCustomerPaymentRecurringResponse | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreateCustomerPaymentBillingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreateCustomerPaymentShippingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const CreateCustomerPaymentLocaleResponse = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type CreateCustomerPaymentLocaleResponse = ClosedEnum<
  typeof CreateCustomerPaymentLocaleResponse
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const CreateCustomerPaymentMethodResponse = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type CreateCustomerPaymentMethodResponse = ClosedEnum<
  typeof CreateCustomerPaymentMethodResponse
>;

export type CreateCustomerPaymentMetadataResponse = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type CreateCustomerPaymentMetadataResponseUnion =
  | CreateCustomerPaymentMetadataResponse
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const CreateCustomerPaymentCaptureModeResponse = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type CreateCustomerPaymentCaptureModeResponse = ClosedEnum<
  typeof CreateCustomerPaymentCaptureModeResponse
>;

/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export const CreateCustomerPaymentCaptureDelayResponse = {
  DotDotDotHours: "... hours",
  DotDotDotDays: "... days",
} as const;
/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export type CreateCustomerPaymentCaptureDelayResponse = ClosedEnum<
  typeof CreateCustomerPaymentCaptureDelayResponse
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreateCustomerPaymentApplicationFeeAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type CreateCustomerPaymentApplicationFeeResponse = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: CreateCustomerPaymentApplicationFeeAmountResponse | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreateCustomerPaymentRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreateCustomerPaymentRoutingMode = ClosedEnum<
  typeof CreateCustomerPaymentRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type CreateCustomerPaymentRoutingAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const CreateCustomerPaymentRoutingTypeResponse = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type CreateCustomerPaymentRoutingTypeResponse = ClosedEnum<
  typeof CreateCustomerPaymentRoutingTypeResponse
>;

/**
 * The destination of this portion of the payment.
 */
export type CreateCustomerPaymentDestinationResponse = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: CreateCustomerPaymentRoutingTypeResponse;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateCustomerPaymentRoutingSelfResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type CreateCustomerPaymentPaymentResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreateCustomerPaymentRoutingLinksResponse = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreateCustomerPaymentRoutingSelfResponse;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: CreateCustomerPaymentPaymentResponse;
};

export type CreateCustomerPaymentRoutingResponse = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CreateCustomerPaymentRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: CreateCustomerPaymentRoutingAmountResponse;
  /**
   * The destination of this portion of the payment.
   */
  destination: CreateCustomerPaymentDestinationResponse;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreateCustomerPaymentRoutingLinksResponse;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const CreateCustomerPaymentSequenceTypeResponse = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type CreateCustomerPaymentSequenceTypeResponse = ClosedEnum<
  typeof CreateCustomerPaymentSequenceTypeResponse
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const CreateCustomerPaymentStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type CreateCustomerPaymentStatus = ClosedEnum<
  typeof CreateCustomerPaymentStatus
>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type CreateCustomerPaymentStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateCustomerPaymentSelfResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type CreateCustomerPaymentCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type CreateCustomerPaymentMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type CreateCustomerPaymentChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type CreateCustomerPaymentDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type CreateCustomerPaymentRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type CreateCustomerPaymentChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type CreateCustomerPaymentCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type CreateCustomerPaymentSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type CreateCustomerPaymentCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type CreateCustomerPaymentMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type CreateCustomerPaymentSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type CreateCustomerPaymentOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type CreateCustomerPaymentTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateCustomerPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreateCustomerPaymentLinksResponse = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreateCustomerPaymentSelfResponse;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: CreateCustomerPaymentCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: CreateCustomerPaymentMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: CreateCustomerPaymentChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: CreateCustomerPaymentDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: CreateCustomerPaymentRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: CreateCustomerPaymentChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: CreateCustomerPaymentCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: CreateCustomerPaymentSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: CreateCustomerPaymentCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: CreateCustomerPaymentMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: CreateCustomerPaymentSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: CreateCustomerPaymentOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: CreateCustomerPaymentTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: CreateCustomerPaymentDocumentation | undefined;
};

/**
 * The newly created payment object.
 */
export type CreateCustomerPaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CreateCustomerPaymentMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: CreateCustomerPaymentAmountResponse;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: CreateCustomerPaymentAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: CreateCustomerPaymentAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: CreateCustomerPaymentAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: CreateCustomerPaymentAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: CreateCustomerPaymentSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreateCustomerPaymentLineResponse> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreateCustomerPaymentBillingAddressResponse | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreateCustomerPaymentShippingAddressResponse | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: CreateCustomerPaymentLocaleResponse | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: CreateCustomerPaymentMethodResponse | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | CreateCustomerPaymentMetadataResponse
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CreateCustomerPaymentCaptureModeResponse | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   */
  captureDelay?: CreateCustomerPaymentCaptureDelayResponse | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?:
    | CreateCustomerPaymentApplicationFeeResponse
    | null
    | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<CreateCustomerPaymentRoutingResponse> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: CreateCustomerPaymentSequenceTypeResponse | null | undefined;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: CreateCustomerPaymentStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: CreateCustomerPaymentStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreateCustomerPaymentLinksResponse;
};

/** @internal */
export const CreateCustomerPaymentAmountRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountRequest$Outbound;
}

export function createCustomerPaymentAmountRequestToJSON(
  createCustomerPaymentAmountRequest: CreateCustomerPaymentAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountRequest$outboundSchema.parse(
      createCustomerPaymentAmountRequest,
    ),
  );
}

export function createCustomerPaymentAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLineTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentLineTypeRequest> = z.nativeEnum(
    CreateCustomerPaymentLineTypeRequest,
  );

/** @internal */
export const CreateCustomerPaymentLineTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentLineTypeRequest> =
    CreateCustomerPaymentLineTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLineTypeRequest$ {
  /** @deprecated use `CreateCustomerPaymentLineTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentLineTypeRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLineTypeRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentUnitPriceRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentUnitPriceRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentUnitPriceRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentUnitPriceRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentUnitPriceRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentUnitPriceRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentUnitPriceRequest$ {
  /** @deprecated use `CreateCustomerPaymentUnitPriceRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentUnitPriceRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnitPriceRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentUnitPriceRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnitPriceRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentUnitPriceRequest$Outbound;
}

export function createCustomerPaymentUnitPriceRequestToJSON(
  createCustomerPaymentUnitPriceRequest: CreateCustomerPaymentUnitPriceRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentUnitPriceRequest$outboundSchema.parse(
      createCustomerPaymentUnitPriceRequest,
    ),
  );
}

export function createCustomerPaymentUnitPriceRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentUnitPriceRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentUnitPriceRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentUnitPriceRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentDiscountAmountRequest$inboundSchema:
  z.ZodType<CreateCustomerPaymentDiscountAmountRequest, z.ZodTypeDef, unknown> =
    z.object({
      currency: z.string(),
      value: z.string(),
    });

/** @internal */
export type CreateCustomerPaymentDiscountAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentDiscountAmountRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentDiscountAmountRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentDiscountAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDiscountAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentDiscountAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentDiscountAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDiscountAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentDiscountAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDiscountAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDiscountAmountRequest$Outbound;
}

export function createCustomerPaymentDiscountAmountRequestToJSON(
  createCustomerPaymentDiscountAmountRequest:
    CreateCustomerPaymentDiscountAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDiscountAmountRequest$outboundSchema.parse(
      createCustomerPaymentDiscountAmountRequest,
    ),
  );
}

export function createCustomerPaymentDiscountAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentDiscountAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentDiscountAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentDiscountAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentTotalAmountRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentTotalAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentTotalAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentTotalAmountRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentTotalAmountRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentTotalAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentTotalAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentTotalAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentTotalAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentTotalAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentTotalAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentTotalAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentTotalAmountRequest$Outbound;
}

export function createCustomerPaymentTotalAmountRequestToJSON(
  createCustomerPaymentTotalAmountRequest:
    CreateCustomerPaymentTotalAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentTotalAmountRequest$outboundSchema.parse(
      createCustomerPaymentTotalAmountRequest,
    ),
  );
}

export function createCustomerPaymentTotalAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentTotalAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentTotalAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentTotalAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentVatAmountRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentVatAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentVatAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentVatAmountRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentVatAmountRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentVatAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentVatAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentVatAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentVatAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentVatAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentVatAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentVatAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentVatAmountRequest$Outbound;
}

export function createCustomerPaymentVatAmountRequestToJSON(
  createCustomerPaymentVatAmountRequest: CreateCustomerPaymentVatAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentVatAmountRequest$outboundSchema.parse(
      createCustomerPaymentVatAmountRequest,
    ),
  );
}

export function createCustomerPaymentVatAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentVatAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentVatAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentVatAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCategoryRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCategoryRequest> = z.nativeEnum(
    CreateCustomerPaymentCategoryRequest,
  );

/** @internal */
export const CreateCustomerPaymentCategoryRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCategoryRequest> =
    CreateCustomerPaymentCategoryRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCategoryRequest$ {
  /** @deprecated use `CreateCustomerPaymentCategoryRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCategoryRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCategoryRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCategoryRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentIntervalRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentIntervalRequest> = z.nativeEnum(
    CreateCustomerPaymentIntervalRequest,
  );

/** @internal */
export const CreateCustomerPaymentIntervalRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentIntervalRequest> =
    CreateCustomerPaymentIntervalRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentIntervalRequest$ {
  /** @deprecated use `CreateCustomerPaymentIntervalRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentIntervalRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentIntervalRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentIntervalRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentRecurringAmountRequest$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentRecurringAmountRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentRecurringAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentRecurringAmountRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentRecurringAmountRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentRecurringAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRecurringAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentRecurringAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRecurringAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRecurringAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRecurringAmountRequest$Outbound;
}

export function createCustomerPaymentRecurringAmountRequestToJSON(
  createCustomerPaymentRecurringAmountRequest:
    CreateCustomerPaymentRecurringAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRecurringAmountRequest$outboundSchema.parse(
      createCustomerPaymentRecurringAmountRequest,
    ),
  );
}

export function createCustomerPaymentRecurringAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRecurringAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRecurringAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRecurringAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRecurringRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentRecurringRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: CreateCustomerPaymentIntervalRequest$inboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRecurringAmountRequest$inboundSchema
  ).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type CreateCustomerPaymentRecurringRequest$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: CreateCustomerPaymentRecurringAmountRequest$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const CreateCustomerPaymentRecurringRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentRecurringRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRecurringRequest
> = z.object({
  description: z.string().optional(),
  interval: CreateCustomerPaymentIntervalRequest$outboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRecurringAmountRequest$outboundSchema
  ).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRecurringRequest$ {
  /** @deprecated use `CreateCustomerPaymentRecurringRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRecurringRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRecurringRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRecurringRequest$Outbound;
}

export function createCustomerPaymentRecurringRequestToJSON(
  createCustomerPaymentRecurringRequest: CreateCustomerPaymentRecurringRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRecurringRequest$outboundSchema.parse(
      createCustomerPaymentRecurringRequest,
    ),
  );
}

export function createCustomerPaymentRecurringRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRecurringRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRecurringRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRecurringRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLineRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentLineRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateCustomerPaymentLineTypeRequest$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreateCustomerPaymentUnitPriceRequest$inboundSchema),
  discountAmount: z.lazy(() =>
    CreateCustomerPaymentDiscountAmountRequest$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() =>
    CreateCustomerPaymentTotalAmountRequest$inboundSchema
  ),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreateCustomerPaymentVatAmountRequest$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreateCustomerPaymentCategoryRequest$inboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreateCustomerPaymentRecurringRequest$inboundSchema)
    .optional(),
});

/** @internal */
export type CreateCustomerPaymentLineRequest$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreateCustomerPaymentUnitPriceRequest$Outbound;
  discountAmount?:
    | CreateCustomerPaymentDiscountAmountRequest$Outbound
    | undefined;
  totalAmount: CreateCustomerPaymentTotalAmountRequest$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreateCustomerPaymentVatAmountRequest$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: CreateCustomerPaymentRecurringRequest$Outbound | undefined;
};

/** @internal */
export const CreateCustomerPaymentLineRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentLineRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentLineRequest
> = z.object({
  type: CreateCustomerPaymentLineTypeRequest$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreateCustomerPaymentUnitPriceRequest$outboundSchema),
  discountAmount: z.lazy(() =>
    CreateCustomerPaymentDiscountAmountRequest$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() =>
    CreateCustomerPaymentTotalAmountRequest$outboundSchema
  ),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreateCustomerPaymentVatAmountRequest$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreateCustomerPaymentCategoryRequest$outboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreateCustomerPaymentRecurringRequest$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLineRequest$ {
  /** @deprecated use `CreateCustomerPaymentLineRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentLineRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineRequest$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentLineRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentLineRequest$Outbound;
}

export function createCustomerPaymentLineRequestToJSON(
  createCustomerPaymentLineRequest: CreateCustomerPaymentLineRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentLineRequest$outboundSchema.parse(
      createCustomerPaymentLineRequest,
    ),
  );
}

export function createCustomerPaymentLineRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentLineRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentLineRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentLineRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentBillingAddressRequest$inboundSchema:
  z.ZodType<CreateCustomerPaymentBillingAddressRequest, z.ZodTypeDef, unknown> =
    z.object({
      title: z.string().optional(),
      givenName: z.string().optional(),
      familyName: z.string().optional(),
      organizationName: z.string().optional(),
      streetAndNumber: z.string().optional(),
      streetAdditional: z.string().optional(),
      postalCode: z.string().optional(),
      email: z.string().optional(),
      phone: z.string().optional(),
      city: z.string().optional(),
      region: z.string().optional(),
      country: z.string().optional(),
    });

/** @internal */
export type CreateCustomerPaymentBillingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentBillingAddressRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentBillingAddressRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentBillingAddressRequest
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentBillingAddressRequest$ {
  /** @deprecated use `CreateCustomerPaymentBillingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentBillingAddressRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentBillingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentBillingAddressRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentBillingAddressRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentBillingAddressRequest$Outbound;
}

export function createCustomerPaymentBillingAddressRequestToJSON(
  createCustomerPaymentBillingAddressRequest:
    CreateCustomerPaymentBillingAddressRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentBillingAddressRequest$outboundSchema.parse(
      createCustomerPaymentBillingAddressRequest,
    ),
  );
}

export function createCustomerPaymentBillingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentBillingAddressRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentBillingAddressRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentBillingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentShippingAddressRequest$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentShippingAddressRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/** @internal */
export type CreateCustomerPaymentShippingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentShippingAddressRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentShippingAddressRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentShippingAddressRequest
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentShippingAddressRequest$ {
  /** @deprecated use `CreateCustomerPaymentShippingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentShippingAddressRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentShippingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentShippingAddressRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentShippingAddressRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentShippingAddressRequest$Outbound;
}

export function createCustomerPaymentShippingAddressRequestToJSON(
  createCustomerPaymentShippingAddressRequest:
    CreateCustomerPaymentShippingAddressRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentShippingAddressRequest$outboundSchema.parse(
      createCustomerPaymentShippingAddressRequest,
    ),
  );
}

export function createCustomerPaymentShippingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentShippingAddressRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentShippingAddressRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentShippingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLocaleRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentLocaleRequest
> = z.nativeEnum(CreateCustomerPaymentLocaleRequest);

/** @internal */
export const CreateCustomerPaymentLocaleRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentLocaleRequest
> = CreateCustomerPaymentLocaleRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLocaleRequest$ {
  /** @deprecated use `CreateCustomerPaymentLocaleRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentLocaleRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLocaleRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLocaleRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentMethodRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentMethodRequest
> = z.nativeEnum(CreateCustomerPaymentMethodRequest);

/** @internal */
export const CreateCustomerPaymentMethodRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentMethodRequest
> = CreateCustomerPaymentMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMethodRequest$ {
  /** @deprecated use `CreateCustomerPaymentMethodRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentMethodRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMethodRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMethodRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentMetadataRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentMetadataRequest,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreateCustomerPaymentMetadataRequest$Outbound = {};

/** @internal */
export const CreateCustomerPaymentMetadataRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentMetadataRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentMetadataRequest
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMetadataRequest$ {
  /** @deprecated use `CreateCustomerPaymentMetadataRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMetadataRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMetadataRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMetadataRequest$Outbound;
}

export function createCustomerPaymentMetadataRequestToJSON(
  createCustomerPaymentMetadataRequest: CreateCustomerPaymentMetadataRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMetadataRequest$outboundSchema.parse(
      createCustomerPaymentMetadataRequest,
    ),
  );
}

export function createCustomerPaymentMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentMetadataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentMetadataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentMetadataRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentMetadataRequestUnion$inboundSchema: z.ZodType<
  CreateCustomerPaymentMetadataRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateCustomerPaymentMetadataRequest$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CreateCustomerPaymentMetadataRequestUnion$Outbound =
  | CreateCustomerPaymentMetadataRequest$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreateCustomerPaymentMetadataRequestUnion$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentMetadataRequestUnion$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentMetadataRequestUnion
  > = z.union([
    z.lazy(() => CreateCustomerPaymentMetadataRequest$outboundSchema),
    z.string(),
    z.array(z.string()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMetadataRequestUnion$ {
  /** @deprecated use `CreateCustomerPaymentMetadataRequestUnion$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMetadataRequestUnion$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataRequestUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMetadataRequestUnion$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataRequestUnion$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMetadataRequestUnion$Outbound;
}

export function createCustomerPaymentMetadataRequestUnionToJSON(
  createCustomerPaymentMetadataRequestUnion:
    CreateCustomerPaymentMetadataRequestUnion,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMetadataRequestUnion$outboundSchema.parse(
      createCustomerPaymentMetadataRequestUnion,
    ),
  );
}

export function createCustomerPaymentMetadataRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentMetadataRequestUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentMetadataRequestUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentMetadataRequestUnion' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCaptureModeRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureModeRequest> = z
    .nativeEnum(CreateCustomerPaymentCaptureModeRequest);

/** @internal */
export const CreateCustomerPaymentCaptureModeRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureModeRequest> =
    CreateCustomerPaymentCaptureModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCaptureModeRequest$ {
  /** @deprecated use `CreateCustomerPaymentCaptureModeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCaptureModeRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptureModeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCaptureModeRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentCaptureDelayRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureDelayRequest> = z
    .nativeEnum(CreateCustomerPaymentCaptureDelayRequest);

/** @internal */
export const CreateCustomerPaymentCaptureDelayRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureDelayRequest> =
    CreateCustomerPaymentCaptureDelayRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCaptureDelayRequest$ {
  /** @deprecated use `CreateCustomerPaymentCaptureDelayRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCaptureDelayRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptureDelayRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCaptureDelayRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentApplicationFeeAmountRequest$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeAmountRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentApplicationFeeAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentApplicationFeeAmountRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeAmountRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentApplicationFeeAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentApplicationFeeAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentApplicationFeeAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentApplicationFeeAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountRequest$Outbound` instead. */
  export type Outbound =
    CreateCustomerPaymentApplicationFeeAmountRequest$Outbound;
}

export function createCustomerPaymentApplicationFeeAmountRequestToJSON(
  createCustomerPaymentApplicationFeeAmountRequest:
    CreateCustomerPaymentApplicationFeeAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentApplicationFeeAmountRequest$outboundSchema.parse(
      createCustomerPaymentApplicationFeeAmountRequest,
    ),
  );
}

export function createCustomerPaymentApplicationFeeAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentApplicationFeeAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentApplicationFeeAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentApplicationFeeAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentApplicationFeeRequest$inboundSchema:
  z.ZodType<CreateCustomerPaymentApplicationFeeRequest, z.ZodTypeDef, unknown> =
    z.object({
      amount: z.lazy(() =>
        CreateCustomerPaymentApplicationFeeAmountRequest$inboundSchema
      ).optional(),
      description: z.string().optional(),
    });

/** @internal */
export type CreateCustomerPaymentApplicationFeeRequest$Outbound = {
  amount?:
    | CreateCustomerPaymentApplicationFeeAmountRequest$Outbound
    | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentApplicationFeeRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentApplicationFeeRequest
  > = z.object({
    amount: z.lazy(() =>
      CreateCustomerPaymentApplicationFeeAmountRequest$outboundSchema
    ).optional(),
    description: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentApplicationFeeRequest$ {
  /** @deprecated use `CreateCustomerPaymentApplicationFeeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentApplicationFeeRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentApplicationFeeRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentApplicationFeeRequest$Outbound;
}

export function createCustomerPaymentApplicationFeeRequestToJSON(
  createCustomerPaymentApplicationFeeRequest:
    CreateCustomerPaymentApplicationFeeRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentApplicationFeeRequest$outboundSchema.parse(
      createCustomerPaymentApplicationFeeRequest,
    ),
  );
}

export function createCustomerPaymentApplicationFeeRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentApplicationFeeRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentApplicationFeeRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentApplicationFeeRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingAmountRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentRoutingAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentRoutingAmountRequest$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentRoutingAmountRequest$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentRoutingAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingAmountRequest$ {
  /** @deprecated use `CreateCustomerPaymentRoutingAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingAmountRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingAmountRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingAmountRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingAmountRequest$Outbound;
}

export function createCustomerPaymentRoutingAmountRequestToJSON(
  createCustomerPaymentRoutingAmountRequest:
    CreateCustomerPaymentRoutingAmountRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingAmountRequest$outboundSchema.parse(
      createCustomerPaymentRoutingAmountRequest,
    ),
  );
}

export function createCustomerPaymentRoutingAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRoutingAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRoutingAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentRoutingTypeRequest> = z
    .nativeEnum(CreateCustomerPaymentRoutingTypeRequest);

/** @internal */
export const CreateCustomerPaymentRoutingTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentRoutingTypeRequest> =
    CreateCustomerPaymentRoutingTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingTypeRequest$ {
  /** @deprecated use `CreateCustomerPaymentRoutingTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingTypeRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingTypeRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentDestinationRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentDestinationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateCustomerPaymentRoutingTypeRequest$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type CreateCustomerPaymentDestinationRequest$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const CreateCustomerPaymentDestinationRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentDestinationRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentDestinationRequest
> = z.object({
  type: CreateCustomerPaymentRoutingTypeRequest$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDestinationRequest$ {
  /** @deprecated use `CreateCustomerPaymentDestinationRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentDestinationRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDestinationRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentDestinationRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDestinationRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDestinationRequest$Outbound;
}

export function createCustomerPaymentDestinationRequestToJSON(
  createCustomerPaymentDestinationRequest:
    CreateCustomerPaymentDestinationRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDestinationRequest$outboundSchema.parse(
      createCustomerPaymentDestinationRequest,
    ),
  );
}

export function createCustomerPaymentDestinationRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentDestinationRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentDestinationRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentDestinationRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSelfRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentSelfRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentSelfRequest$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentSelfRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentSelfRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentSelfRequest
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSelfRequest$ {
  /** @deprecated use `CreateCustomerPaymentSelfRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentSelfRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSelfRequest$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentSelfRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentSelfRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentSelfRequest$Outbound;
}

export function createCustomerPaymentSelfRequestToJSON(
  createCustomerPaymentSelfRequest: CreateCustomerPaymentSelfRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentSelfRequest$outboundSchema.parse(
      createCustomerPaymentSelfRequest,
    ),
  );
}

export function createCustomerPaymentSelfRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentSelfRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentSelfRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentSelfRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentPaymentRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentPaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentPaymentRequest$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentPaymentRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentPaymentRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentPaymentRequest
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentPaymentRequest$ {
  /** @deprecated use `CreateCustomerPaymentPaymentRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentPaymentRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentPaymentRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentPaymentRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentPaymentRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentPaymentRequest$Outbound;
}

export function createCustomerPaymentPaymentRequestToJSON(
  createCustomerPaymentPaymentRequest: CreateCustomerPaymentPaymentRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentPaymentRequest$outboundSchema.parse(
      createCustomerPaymentPaymentRequest,
    ),
  );
}

export function createCustomerPaymentPaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentPaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentPaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentPaymentRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLinksRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentLinksRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreateCustomerPaymentSelfRequest$inboundSchema),
  payment: z.lazy(() => CreateCustomerPaymentPaymentRequest$inboundSchema),
});

/** @internal */
export type CreateCustomerPaymentLinksRequest$Outbound = {
  self: CreateCustomerPaymentSelfRequest$Outbound;
  payment: CreateCustomerPaymentPaymentRequest$Outbound;
};

/** @internal */
export const CreateCustomerPaymentLinksRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentLinksRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentLinksRequest
> = z.object({
  self: z.lazy(() => CreateCustomerPaymentSelfRequest$outboundSchema),
  payment: z.lazy(() => CreateCustomerPaymentPaymentRequest$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLinksRequest$ {
  /** @deprecated use `CreateCustomerPaymentLinksRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentLinksRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLinksRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLinksRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentLinksRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentLinksRequest$Outbound;
}

export function createCustomerPaymentLinksRequestToJSON(
  createCustomerPaymentLinksRequest: CreateCustomerPaymentLinksRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentLinksRequest$outboundSchema.parse(
      createCustomerPaymentLinksRequest,
    ),
  );
}

export function createCustomerPaymentLinksRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentLinksRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentLinksRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentLinksRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreateCustomerPaymentRoutingAmountRequest$inboundSchema),
  destination: z.lazy(() =>
    CreateCustomerPaymentDestinationRequest$inboundSchema
  ),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreateCustomerPaymentLinksRequest$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreateCustomerPaymentRoutingRequest$Outbound = {
  amount: CreateCustomerPaymentRoutingAmountRequest$Outbound;
  destination: CreateCustomerPaymentDestinationRequest$Outbound;
  releaseDate?: string | null | undefined;
  _links: CreateCustomerPaymentLinksRequest$Outbound;
};

/** @internal */
export const CreateCustomerPaymentRoutingRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRoutingRequest
> = z.object({
  amount: z.lazy(() =>
    CreateCustomerPaymentRoutingAmountRequest$outboundSchema
  ),
  destination: z.lazy(() =>
    CreateCustomerPaymentDestinationRequest$outboundSchema
  ),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreateCustomerPaymentLinksRequest$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingRequest$ {
  /** @deprecated use `CreateCustomerPaymentRoutingRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingRequest$Outbound;
}

export function createCustomerPaymentRoutingRequestToJSON(
  createCustomerPaymentRoutingRequest: CreateCustomerPaymentRoutingRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingRequest$outboundSchema.parse(
      createCustomerPaymentRoutingRequest,
    ),
  );
}

export function createCustomerPaymentRoutingRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRoutingRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRoutingRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSequenceTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentSequenceTypeRequest> = z
    .nativeEnum(CreateCustomerPaymentSequenceTypeRequest);

/** @internal */
export const CreateCustomerPaymentSequenceTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentSequenceTypeRequest> =
    CreateCustomerPaymentSequenceTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSequenceTypeRequest$ {
  /** @deprecated use `CreateCustomerPaymentSequenceTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentSequenceTypeRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSequenceTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentSequenceTypeRequest$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentRequestBody$inboundSchema: z.ZodType<
  CreateCustomerPaymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: z.lazy(() => CreateCustomerPaymentAmountRequest$inboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentLineRequest$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreateCustomerPaymentBillingAddressRequest$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreateCustomerPaymentShippingAddressRequest$inboundSchema
  ).optional(),
  locale: z.nullable(CreateCustomerPaymentLocaleRequest$inboundSchema)
    .optional(),
  method: z.nullable(CreateCustomerPaymentMethodRequest$inboundSchema)
    .optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateCustomerPaymentMetadataRequest$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    CreateCustomerPaymentCaptureModeRequest$inboundSchema.default("automatic"),
  ),
  captureDelay: z.nullable(
    CreateCustomerPaymentCaptureDelayRequest$inboundSchema,
  ).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreateCustomerPaymentApplicationFeeRequest$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentRoutingRequest$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreateCustomerPaymentSequenceTypeRequest$inboundSchema.default("oneoff"),
  ),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CreateCustomerPaymentRequestBody$Outbound = {
  description: string;
  amount: CreateCustomerPaymentAmountRequest$Outbound;
  redirectUrl: string | null;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<CreateCustomerPaymentLineRequest$Outbound> | null | undefined;
  billingAddress?:
    | CreateCustomerPaymentBillingAddressRequest$Outbound
    | undefined;
  shippingAddress?:
    | CreateCustomerPaymentShippingAddressRequest$Outbound
    | undefined;
  locale?: string | null | undefined;
  method?: string | null | undefined;
  issuer?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | CreateCustomerPaymentMetadataRequest$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode: string | null;
  captureDelay?: string | null | undefined;
  applicationFee?:
    | CreateCustomerPaymentApplicationFeeRequest$Outbound
    | null
    | undefined;
  routing?:
    | Array<CreateCustomerPaymentRoutingRequest$Outbound>
    | null
    | undefined;
  sequenceType: string | null;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId?: string | undefined;
  dueDate?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CreateCustomerPaymentRequestBody$outboundSchema: z.ZodType<
  CreateCustomerPaymentRequestBody$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRequestBody
> = z.object({
  description: z.string(),
  amount: z.lazy(() => CreateCustomerPaymentAmountRequest$outboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentLineRequest$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreateCustomerPaymentBillingAddressRequest$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreateCustomerPaymentShippingAddressRequest$outboundSchema
  ).optional(),
  locale: z.nullable(CreateCustomerPaymentLocaleRequest$outboundSchema)
    .optional(),
  method: z.nullable(CreateCustomerPaymentMethodRequest$outboundSchema)
    .optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateCustomerPaymentMetadataRequest$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    CreateCustomerPaymentCaptureModeRequest$outboundSchema.default("automatic"),
  ),
  captureDelay: z.nullable(
    CreateCustomerPaymentCaptureDelayRequest$outboundSchema,
  ).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreateCustomerPaymentApplicationFeeRequest$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentRoutingRequest$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreateCustomerPaymentSequenceTypeRequest$outboundSchema.default("oneoff"),
  ),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRequestBody$ {
  /** @deprecated use `CreateCustomerPaymentRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentRequestBody$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentRequestBody$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRequestBody$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRequestBody$Outbound;
}

export function createCustomerPaymentRequestBodyToJSON(
  createCustomerPaymentRequestBody: CreateCustomerPaymentRequestBody,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRequestBody$outboundSchema.parse(
      createCustomerPaymentRequestBody,
    ),
  );
}

export function createCustomerPaymentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRequest$inboundSchema: z.ZodType<
  CreateCustomerPaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  RequestBody: z.lazy(() => CreateCustomerPaymentRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateCustomerPaymentRequest$Outbound = {
  customerId: string;
  RequestBody?: CreateCustomerPaymentRequestBody$Outbound | undefined;
};

/** @internal */
export const CreateCustomerPaymentRequest$outboundSchema: z.ZodType<
  CreateCustomerPaymentRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRequest
> = z.object({
  customerId: z.string(),
  requestBody: z.lazy(() => CreateCustomerPaymentRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRequest$ {
  /** @deprecated use `CreateCustomerPaymentRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentRequest$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRequest$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentRequest$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRequest$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRequest$Outbound;
}

export function createCustomerPaymentRequestToJSON(
  createCustomerPaymentRequest: CreateCustomerPaymentRequest,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRequest$outboundSchema.parse(
      createCustomerPaymentRequest,
    ),
  );
}

export function createCustomerPaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentServiceUnavailableDocumentation$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentServiceUnavailableDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentServiceUnavailableDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentServiceUnavailableDocumentation$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentServiceUnavailableDocumentation$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentServiceUnavailableDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentServiceUnavailableDocumentation$ {
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentServiceUnavailableDocumentation$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentServiceUnavailableDocumentation$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableDocumentation$Outbound` instead. */
  export type Outbound =
    CreateCustomerPaymentServiceUnavailableDocumentation$Outbound;
}

export function createCustomerPaymentServiceUnavailableDocumentationToJSON(
  createCustomerPaymentServiceUnavailableDocumentation:
    CreateCustomerPaymentServiceUnavailableDocumentation,
): string {
  return JSON.stringify(
    CreateCustomerPaymentServiceUnavailableDocumentation$outboundSchema.parse(
      createCustomerPaymentServiceUnavailableDocumentation,
    ),
  );
}

export function createCustomerPaymentServiceUnavailableDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentServiceUnavailableDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentServiceUnavailableDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentServiceUnavailableDocumentation' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentServiceUnavailableLinks$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentServiceUnavailableLinks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    documentation: z.lazy(() =>
      CreateCustomerPaymentServiceUnavailableDocumentation$inboundSchema
    ),
  });

/** @internal */
export type CreateCustomerPaymentServiceUnavailableLinks$Outbound = {
  documentation: CreateCustomerPaymentServiceUnavailableDocumentation$Outbound;
};

/** @internal */
export const CreateCustomerPaymentServiceUnavailableLinks$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentServiceUnavailableLinks$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentServiceUnavailableLinks
  > = z.object({
    documentation: z.lazy(() =>
      CreateCustomerPaymentServiceUnavailableDocumentation$outboundSchema
    ),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentServiceUnavailableLinks$ {
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableLinks$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentServiceUnavailableLinks$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableLinks$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentServiceUnavailableLinks$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentServiceUnavailableLinks$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentServiceUnavailableLinks$Outbound;
}

export function createCustomerPaymentServiceUnavailableLinksToJSON(
  createCustomerPaymentServiceUnavailableLinks:
    CreateCustomerPaymentServiceUnavailableLinks,
): string {
  return JSON.stringify(
    CreateCustomerPaymentServiceUnavailableLinks$outboundSchema.parse(
      createCustomerPaymentServiceUnavailableLinks,
    ),
  );
}

export function createCustomerPaymentServiceUnavailableLinksFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentServiceUnavailableLinks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentServiceUnavailableLinks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentServiceUnavailableLinks' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentUnprocessableEntityDocumentation$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentUnprocessableEntityDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentUnprocessableEntityDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentUnprocessableEntityDocumentation$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentUnprocessableEntityDocumentation$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentUnprocessableEntityDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentUnprocessableEntityDocumentation$ {
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentUnprocessableEntityDocumentation$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentUnprocessableEntityDocumentation$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityDocumentation$Outbound` instead. */
  export type Outbound =
    CreateCustomerPaymentUnprocessableEntityDocumentation$Outbound;
}

export function createCustomerPaymentUnprocessableEntityDocumentationToJSON(
  createCustomerPaymentUnprocessableEntityDocumentation:
    CreateCustomerPaymentUnprocessableEntityDocumentation,
): string {
  return JSON.stringify(
    CreateCustomerPaymentUnprocessableEntityDocumentation$outboundSchema.parse(
      createCustomerPaymentUnprocessableEntityDocumentation,
    ),
  );
}

export function createCustomerPaymentUnprocessableEntityDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentUnprocessableEntityDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentUnprocessableEntityDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentUnprocessableEntityDocumentation' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentUnprocessableEntityLinks$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentUnprocessableEntityLinks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    documentation: z.lazy(() =>
      CreateCustomerPaymentUnprocessableEntityDocumentation$inboundSchema
    ),
  });

/** @internal */
export type CreateCustomerPaymentUnprocessableEntityLinks$Outbound = {
  documentation: CreateCustomerPaymentUnprocessableEntityDocumentation$Outbound;
};

/** @internal */
export const CreateCustomerPaymentUnprocessableEntityLinks$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentUnprocessableEntityLinks$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentUnprocessableEntityLinks
  > = z.object({
    documentation: z.lazy(() =>
      CreateCustomerPaymentUnprocessableEntityDocumentation$outboundSchema
    ),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentUnprocessableEntityLinks$ {
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityLinks$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentUnprocessableEntityLinks$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityLinks$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentUnprocessableEntityLinks$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnprocessableEntityLinks$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentUnprocessableEntityLinks$Outbound;
}

export function createCustomerPaymentUnprocessableEntityLinksToJSON(
  createCustomerPaymentUnprocessableEntityLinks:
    CreateCustomerPaymentUnprocessableEntityLinks,
): string {
  return JSON.stringify(
    CreateCustomerPaymentUnprocessableEntityLinks$outboundSchema.parse(
      createCustomerPaymentUnprocessableEntityLinks,
    ),
  );
}

export function createCustomerPaymentUnprocessableEntityLinksFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentUnprocessableEntityLinks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentUnprocessableEntityLinks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentUnprocessableEntityLinks' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentMode$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentMode
> = z.nativeEnum(CreateCustomerPaymentMode);

/** @internal */
export const CreateCustomerPaymentMode$outboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentMode
> = CreateCustomerPaymentMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMode$ {
  /** @deprecated use `CreateCustomerPaymentMode$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentMode$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMode$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentMode$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentAmountResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountResponse$Outbound;
}

export function createCustomerPaymentAmountResponseToJSON(
  createCustomerPaymentAmountResponse: CreateCustomerPaymentAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountResponse$outboundSchema.parse(
      createCustomerPaymentAmountResponse,
    ),
  );
}

export function createCustomerPaymentAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentAmountRefunded$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountRefunded$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRefunded$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountRefunded$ {
  /** @deprecated use `CreateCustomerPaymentAmountRefunded$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentAmountRefunded$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRefunded$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountRefunded$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRefunded$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountRefunded$Outbound;
}

export function createCustomerPaymentAmountRefundedToJSON(
  createCustomerPaymentAmountRefunded: CreateCustomerPaymentAmountRefunded,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountRefunded$outboundSchema.parse(
      createCustomerPaymentAmountRefunded,
    ),
  );
}

export function createCustomerPaymentAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountRefunded' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentAmountRemaining$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountRemaining$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountRemaining$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountRemaining$ {
  /** @deprecated use `CreateCustomerPaymentAmountRemaining$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentAmountRemaining$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRemaining$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountRemaining$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountRemaining$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountRemaining$Outbound;
}

export function createCustomerPaymentAmountRemainingToJSON(
  createCustomerPaymentAmountRemaining: CreateCustomerPaymentAmountRemaining,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountRemaining$outboundSchema.parse(
      createCustomerPaymentAmountRemaining,
    ),
  );
}

export function createCustomerPaymentAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountRemaining' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentAmountCaptured$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountCaptured$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountCaptured$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountCaptured$ {
  /** @deprecated use `CreateCustomerPaymentAmountCaptured$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentAmountCaptured$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountCaptured$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountCaptured$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountCaptured$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountCaptured$Outbound;
}

export function createCustomerPaymentAmountCapturedToJSON(
  createCustomerPaymentAmountCaptured: CreateCustomerPaymentAmountCaptured,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountCaptured$outboundSchema.parse(
      createCustomerPaymentAmountCaptured,
    ),
  );
}

export function createCustomerPaymentAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountCaptured' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentAmountChargedBack$inboundSchema: z.ZodType<
  CreateCustomerPaymentAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentAmountChargedBack$outboundSchema: z.ZodType<
  CreateCustomerPaymentAmountChargedBack$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentAmountChargedBack$ {
  /** @deprecated use `CreateCustomerPaymentAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentAmountChargedBack$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentAmountChargedBack$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentAmountChargedBack$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentAmountChargedBack$Outbound;
}

export function createCustomerPaymentAmountChargedBackToJSON(
  createCustomerPaymentAmountChargedBack:
    CreateCustomerPaymentAmountChargedBack,
): string {
  return JSON.stringify(
    CreateCustomerPaymentAmountChargedBack$outboundSchema.parse(
      createCustomerPaymentAmountChargedBack,
    ),
  );
}

export function createCustomerPaymentAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSettlementAmount$inboundSchema: z.ZodType<
  CreateCustomerPaymentSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentSettlementAmount$outboundSchema: z.ZodType<
  CreateCustomerPaymentSettlementAmount$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSettlementAmount$ {
  /** @deprecated use `CreateCustomerPaymentSettlementAmount$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentSettlementAmount$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSettlementAmount$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentSettlementAmount$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentSettlementAmount$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentSettlementAmount$Outbound;
}

export function createCustomerPaymentSettlementAmountToJSON(
  createCustomerPaymentSettlementAmount: CreateCustomerPaymentSettlementAmount,
): string {
  return JSON.stringify(
    CreateCustomerPaymentSettlementAmount$outboundSchema.parse(
      createCustomerPaymentSettlementAmount,
    ),
  );
}

export function createCustomerPaymentSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentSettlementAmount' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLineTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentLineTypeResponse> = z.nativeEnum(
    CreateCustomerPaymentLineTypeResponse,
  );

/** @internal */
export const CreateCustomerPaymentLineTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentLineTypeResponse> =
    CreateCustomerPaymentLineTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLineTypeResponse$ {
  /** @deprecated use `CreateCustomerPaymentLineTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentLineTypeResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLineTypeResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentUnitPriceResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentUnitPriceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentUnitPriceResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentUnitPriceResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentUnitPriceResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentUnitPriceResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentUnitPriceResponse$ {
  /** @deprecated use `CreateCustomerPaymentUnitPriceResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentUnitPriceResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnitPriceResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentUnitPriceResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentUnitPriceResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentUnitPriceResponse$Outbound;
}

export function createCustomerPaymentUnitPriceResponseToJSON(
  createCustomerPaymentUnitPriceResponse:
    CreateCustomerPaymentUnitPriceResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentUnitPriceResponse$outboundSchema.parse(
      createCustomerPaymentUnitPriceResponse,
    ),
  );
}

export function createCustomerPaymentUnitPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentUnitPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentUnitPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentUnitPriceResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentDiscountAmountResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentDiscountAmountResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentDiscountAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentDiscountAmountResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentDiscountAmountResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentDiscountAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDiscountAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentDiscountAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentDiscountAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDiscountAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentDiscountAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDiscountAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDiscountAmountResponse$Outbound;
}

export function createCustomerPaymentDiscountAmountResponseToJSON(
  createCustomerPaymentDiscountAmountResponse:
    CreateCustomerPaymentDiscountAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDiscountAmountResponse$outboundSchema.parse(
      createCustomerPaymentDiscountAmountResponse,
    ),
  );
}

export function createCustomerPaymentDiscountAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentDiscountAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentDiscountAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentDiscountAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentTotalAmountResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentTotalAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentTotalAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentTotalAmountResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentTotalAmountResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentTotalAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentTotalAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentTotalAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentTotalAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentTotalAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentTotalAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentTotalAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentTotalAmountResponse$Outbound;
}

export function createCustomerPaymentTotalAmountResponseToJSON(
  createCustomerPaymentTotalAmountResponse:
    CreateCustomerPaymentTotalAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentTotalAmountResponse$outboundSchema.parse(
      createCustomerPaymentTotalAmountResponse,
    ),
  );
}

export function createCustomerPaymentTotalAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentTotalAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentTotalAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentTotalAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentVatAmountResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentVatAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateCustomerPaymentVatAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentVatAmountResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentVatAmountResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentVatAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentVatAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentVatAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentVatAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentVatAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentVatAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentVatAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentVatAmountResponse$Outbound;
}

export function createCustomerPaymentVatAmountResponseToJSON(
  createCustomerPaymentVatAmountResponse:
    CreateCustomerPaymentVatAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentVatAmountResponse$outboundSchema.parse(
      createCustomerPaymentVatAmountResponse,
    ),
  );
}

export function createCustomerPaymentVatAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentVatAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentVatAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentVatAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCategoryResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCategoryResponse> = z.nativeEnum(
    CreateCustomerPaymentCategoryResponse,
  );

/** @internal */
export const CreateCustomerPaymentCategoryResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCategoryResponse> =
    CreateCustomerPaymentCategoryResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCategoryResponse$ {
  /** @deprecated use `CreateCustomerPaymentCategoryResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCategoryResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCategoryResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCategoryResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentIntervalResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentIntervalResponse> = z.nativeEnum(
    CreateCustomerPaymentIntervalResponse,
  );

/** @internal */
export const CreateCustomerPaymentIntervalResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentIntervalResponse> =
    CreateCustomerPaymentIntervalResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentIntervalResponse$ {
  /** @deprecated use `CreateCustomerPaymentIntervalResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentIntervalResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentIntervalResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentIntervalResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentRecurringAmountResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentRecurringAmountResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentRecurringAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentRecurringAmountResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentRecurringAmountResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentRecurringAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRecurringAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentRecurringAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRecurringAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRecurringAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRecurringAmountResponse$Outbound;
}

export function createCustomerPaymentRecurringAmountResponseToJSON(
  createCustomerPaymentRecurringAmountResponse:
    CreateCustomerPaymentRecurringAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRecurringAmountResponse$outboundSchema.parse(
      createCustomerPaymentRecurringAmountResponse,
    ),
  );
}

export function createCustomerPaymentRecurringAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRecurringAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRecurringAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRecurringAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRecurringResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentRecurringResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: CreateCustomerPaymentIntervalResponse$inboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRecurringAmountResponse$inboundSchema
  ).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type CreateCustomerPaymentRecurringResponse$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: CreateCustomerPaymentRecurringAmountResponse$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const CreateCustomerPaymentRecurringResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentRecurringResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRecurringResponse
> = z.object({
  description: z.string().optional(),
  interval: CreateCustomerPaymentIntervalResponse$outboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRecurringAmountResponse$outboundSchema
  ).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRecurringResponse$ {
  /** @deprecated use `CreateCustomerPaymentRecurringResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRecurringResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRecurringResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRecurringResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRecurringResponse$Outbound;
}

export function createCustomerPaymentRecurringResponseToJSON(
  createCustomerPaymentRecurringResponse:
    CreateCustomerPaymentRecurringResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRecurringResponse$outboundSchema.parse(
      createCustomerPaymentRecurringResponse,
    ),
  );
}

export function createCustomerPaymentRecurringResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRecurringResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRecurringResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRecurringResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLineResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentLineResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateCustomerPaymentLineTypeResponse$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreateCustomerPaymentUnitPriceResponse$inboundSchema),
  discountAmount: z.lazy(() =>
    CreateCustomerPaymentDiscountAmountResponse$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() =>
    CreateCustomerPaymentTotalAmountResponse$inboundSchema
  ),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreateCustomerPaymentVatAmountResponse$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreateCustomerPaymentCategoryResponse$inboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreateCustomerPaymentRecurringResponse$inboundSchema)
    .optional(),
});

/** @internal */
export type CreateCustomerPaymentLineResponse$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreateCustomerPaymentUnitPriceResponse$Outbound;
  discountAmount?:
    | CreateCustomerPaymentDiscountAmountResponse$Outbound
    | undefined;
  totalAmount: CreateCustomerPaymentTotalAmountResponse$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreateCustomerPaymentVatAmountResponse$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: CreateCustomerPaymentRecurringResponse$Outbound | undefined;
};

/** @internal */
export const CreateCustomerPaymentLineResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentLineResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentLineResponse
> = z.object({
  type: CreateCustomerPaymentLineTypeResponse$outboundSchema.default(
    "physical",
  ),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() =>
    CreateCustomerPaymentUnitPriceResponse$outboundSchema
  ),
  discountAmount: z.lazy(() =>
    CreateCustomerPaymentDiscountAmountResponse$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() =>
    CreateCustomerPaymentTotalAmountResponse$outboundSchema
  ),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreateCustomerPaymentVatAmountResponse$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreateCustomerPaymentCategoryResponse$outboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreateCustomerPaymentRecurringResponse$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLineResponse$ {
  /** @deprecated use `CreateCustomerPaymentLineResponse$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentLineResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLineResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentLineResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentLineResponse$Outbound;
}

export function createCustomerPaymentLineResponseToJSON(
  createCustomerPaymentLineResponse: CreateCustomerPaymentLineResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentLineResponse$outboundSchema.parse(
      createCustomerPaymentLineResponse,
    ),
  );
}

export function createCustomerPaymentLineResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentLineResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentLineResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentLineResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentBillingAddressResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentBillingAddressResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/** @internal */
export type CreateCustomerPaymentBillingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentBillingAddressResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentBillingAddressResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentBillingAddressResponse
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentBillingAddressResponse$ {
  /** @deprecated use `CreateCustomerPaymentBillingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentBillingAddressResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentBillingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentBillingAddressResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentBillingAddressResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentBillingAddressResponse$Outbound;
}

export function createCustomerPaymentBillingAddressResponseToJSON(
  createCustomerPaymentBillingAddressResponse:
    CreateCustomerPaymentBillingAddressResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentBillingAddressResponse$outboundSchema.parse(
      createCustomerPaymentBillingAddressResponse,
    ),
  );
}

export function createCustomerPaymentBillingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentBillingAddressResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentBillingAddressResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentBillingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentShippingAddressResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentShippingAddressResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/** @internal */
export type CreateCustomerPaymentShippingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentShippingAddressResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentShippingAddressResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentShippingAddressResponse
  > = z.object({
    title: z.string().optional(),
    givenName: z.string().optional(),
    familyName: z.string().optional(),
    organizationName: z.string().optional(),
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentShippingAddressResponse$ {
  /** @deprecated use `CreateCustomerPaymentShippingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentShippingAddressResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentShippingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentShippingAddressResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentShippingAddressResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentShippingAddressResponse$Outbound;
}

export function createCustomerPaymentShippingAddressResponseToJSON(
  createCustomerPaymentShippingAddressResponse:
    CreateCustomerPaymentShippingAddressResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentShippingAddressResponse$outboundSchema.parse(
      createCustomerPaymentShippingAddressResponse,
    ),
  );
}

export function createCustomerPaymentShippingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentShippingAddressResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentShippingAddressResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentShippingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLocaleResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentLocaleResponse
> = z.nativeEnum(CreateCustomerPaymentLocaleResponse);

/** @internal */
export const CreateCustomerPaymentLocaleResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentLocaleResponse> =
    CreateCustomerPaymentLocaleResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLocaleResponse$ {
  /** @deprecated use `CreateCustomerPaymentLocaleResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentLocaleResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLocaleResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLocaleResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentMethodResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentMethodResponse
> = z.nativeEnum(CreateCustomerPaymentMethodResponse);

/** @internal */
export const CreateCustomerPaymentMethodResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentMethodResponse> =
    CreateCustomerPaymentMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMethodResponse$ {
  /** @deprecated use `CreateCustomerPaymentMethodResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMethodResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMethodResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMethodResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentMetadataResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentMetadataResponse,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreateCustomerPaymentMetadataResponse$Outbound = {};

/** @internal */
export const CreateCustomerPaymentMetadataResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentMetadataResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentMetadataResponse
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMetadataResponse$ {
  /** @deprecated use `CreateCustomerPaymentMetadataResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMetadataResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMetadataResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMetadataResponse$Outbound;
}

export function createCustomerPaymentMetadataResponseToJSON(
  createCustomerPaymentMetadataResponse: CreateCustomerPaymentMetadataResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMetadataResponse$outboundSchema.parse(
      createCustomerPaymentMetadataResponse,
    ),
  );
}

export function createCustomerPaymentMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentMetadataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentMetadataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentMetadataResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentMetadataResponseUnion$inboundSchema:
  z.ZodType<CreateCustomerPaymentMetadataResponseUnion, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => CreateCustomerPaymentMetadataResponse$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]);

/** @internal */
export type CreateCustomerPaymentMetadataResponseUnion$Outbound =
  | CreateCustomerPaymentMetadataResponse$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreateCustomerPaymentMetadataResponseUnion$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentMetadataResponseUnion$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentMetadataResponseUnion
  > = z.union([
    z.lazy(() => CreateCustomerPaymentMetadataResponse$outboundSchema),
    z.string(),
    z.array(z.string()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMetadataResponseUnion$ {
  /** @deprecated use `CreateCustomerPaymentMetadataResponseUnion$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMetadataResponseUnion$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataResponseUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMetadataResponseUnion$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMetadataResponseUnion$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMetadataResponseUnion$Outbound;
}

export function createCustomerPaymentMetadataResponseUnionToJSON(
  createCustomerPaymentMetadataResponseUnion:
    CreateCustomerPaymentMetadataResponseUnion,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMetadataResponseUnion$outboundSchema.parse(
      createCustomerPaymentMetadataResponseUnion,
    ),
  );
}

export function createCustomerPaymentMetadataResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentMetadataResponseUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentMetadataResponseUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentMetadataResponseUnion' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCaptureModeResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureModeResponse> = z
    .nativeEnum(CreateCustomerPaymentCaptureModeResponse);

/** @internal */
export const CreateCustomerPaymentCaptureModeResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureModeResponse> =
    CreateCustomerPaymentCaptureModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCaptureModeResponse$ {
  /** @deprecated use `CreateCustomerPaymentCaptureModeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCaptureModeResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptureModeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCaptureModeResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentCaptureDelayResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureDelayResponse> = z
    .nativeEnum(CreateCustomerPaymentCaptureDelayResponse);

/** @internal */
export const CreateCustomerPaymentCaptureDelayResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentCaptureDelayResponse> =
    CreateCustomerPaymentCaptureDelayResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCaptureDelayResponse$ {
  /** @deprecated use `CreateCustomerPaymentCaptureDelayResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentCaptureDelayResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptureDelayResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentCaptureDelayResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentApplicationFeeAmountResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeAmountResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateCustomerPaymentApplicationFeeAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentApplicationFeeAmountResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeAmountResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentApplicationFeeAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentApplicationFeeAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentApplicationFeeAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentApplicationFeeAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeAmountResponse$Outbound` instead. */
  export type Outbound =
    CreateCustomerPaymentApplicationFeeAmountResponse$Outbound;
}

export function createCustomerPaymentApplicationFeeAmountResponseToJSON(
  createCustomerPaymentApplicationFeeAmountResponse:
    CreateCustomerPaymentApplicationFeeAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentApplicationFeeAmountResponse$outboundSchema.parse(
      createCustomerPaymentApplicationFeeAmountResponse,
    ),
  );
}

export function createCustomerPaymentApplicationFeeAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentApplicationFeeAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentApplicationFeeAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentApplicationFeeAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentApplicationFeeResponse$inboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    amount: z.lazy(() =>
      CreateCustomerPaymentApplicationFeeAmountResponse$inboundSchema
    ).optional(),
    description: z.string().optional(),
  });

/** @internal */
export type CreateCustomerPaymentApplicationFeeResponse$Outbound = {
  amount?:
    | CreateCustomerPaymentApplicationFeeAmountResponse$Outbound
    | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreateCustomerPaymentApplicationFeeResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentApplicationFeeResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentApplicationFeeResponse
  > = z.object({
    amount: z.lazy(() =>
      CreateCustomerPaymentApplicationFeeAmountResponse$outboundSchema
    ).optional(),
    description: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentApplicationFeeResponse$ {
  /** @deprecated use `CreateCustomerPaymentApplicationFeeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentApplicationFeeResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentApplicationFeeResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentApplicationFeeResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentApplicationFeeResponse$Outbound;
}

export function createCustomerPaymentApplicationFeeResponseToJSON(
  createCustomerPaymentApplicationFeeResponse:
    CreateCustomerPaymentApplicationFeeResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentApplicationFeeResponse$outboundSchema.parse(
      createCustomerPaymentApplicationFeeResponse,
    ),
  );
}

export function createCustomerPaymentApplicationFeeResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentApplicationFeeResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentApplicationFeeResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentApplicationFeeResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentRoutingMode
> = z.nativeEnum(CreateCustomerPaymentRoutingMode);

/** @internal */
export const CreateCustomerPaymentRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentRoutingMode
> = CreateCustomerPaymentRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingMode$ {
  /** @deprecated use `CreateCustomerPaymentRoutingMode$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentRoutingMode$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingMode$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentRoutingMode$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentRoutingAmountResponse$inboundSchema:
  z.ZodType<CreateCustomerPaymentRoutingAmountResponse, z.ZodTypeDef, unknown> =
    z.object({
      currency: z.string(),
      value: z.string(),
    });

/** @internal */
export type CreateCustomerPaymentRoutingAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateCustomerPaymentRoutingAmountResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentRoutingAmountResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentRoutingAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingAmountResponse$ {
  /** @deprecated use `CreateCustomerPaymentRoutingAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingAmountResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingAmountResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingAmountResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingAmountResponse$Outbound;
}

export function createCustomerPaymentRoutingAmountResponseToJSON(
  createCustomerPaymentRoutingAmountResponse:
    CreateCustomerPaymentRoutingAmountResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingAmountResponse$outboundSchema.parse(
      createCustomerPaymentRoutingAmountResponse,
    ),
  );
}

export function createCustomerPaymentRoutingAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRoutingAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRoutingAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentRoutingTypeResponse> = z
    .nativeEnum(CreateCustomerPaymentRoutingTypeResponse);

/** @internal */
export const CreateCustomerPaymentRoutingTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentRoutingTypeResponse> =
    CreateCustomerPaymentRoutingTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingTypeResponse$ {
  /** @deprecated use `CreateCustomerPaymentRoutingTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingTypeResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingTypeResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentDestinationResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentDestinationResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateCustomerPaymentRoutingTypeResponse$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type CreateCustomerPaymentDestinationResponse$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const CreateCustomerPaymentDestinationResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentDestinationResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentDestinationResponse
> = z.object({
  type: CreateCustomerPaymentRoutingTypeResponse$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDestinationResponse$ {
  /** @deprecated use `CreateCustomerPaymentDestinationResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentDestinationResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDestinationResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentDestinationResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDestinationResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDestinationResponse$Outbound;
}

export function createCustomerPaymentDestinationResponseToJSON(
  createCustomerPaymentDestinationResponse:
    CreateCustomerPaymentDestinationResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDestinationResponse$outboundSchema.parse(
      createCustomerPaymentDestinationResponse,
    ),
  );
}

export function createCustomerPaymentDestinationResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentDestinationResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentDestinationResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentDestinationResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingSelfResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingSelfResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentRoutingSelfResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentRoutingSelfResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingSelfResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRoutingSelfResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingSelfResponse$ {
  /** @deprecated use `CreateCustomerPaymentRoutingSelfResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingSelfResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingSelfResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingSelfResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingSelfResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingSelfResponse$Outbound;
}

export function createCustomerPaymentRoutingSelfResponseToJSON(
  createCustomerPaymentRoutingSelfResponse:
    CreateCustomerPaymentRoutingSelfResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingSelfResponse$outboundSchema.parse(
      createCustomerPaymentRoutingSelfResponse,
    ),
  );
}

export function createCustomerPaymentRoutingSelfResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRoutingSelfResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingSelfResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRoutingSelfResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentPaymentResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentPaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentPaymentResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentPaymentResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentPaymentResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentPaymentResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentPaymentResponse$ {
  /** @deprecated use `CreateCustomerPaymentPaymentResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentPaymentResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentPaymentResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentPaymentResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentPaymentResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentPaymentResponse$Outbound;
}

export function createCustomerPaymentPaymentResponseToJSON(
  createCustomerPaymentPaymentResponse: CreateCustomerPaymentPaymentResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentPaymentResponse$outboundSchema.parse(
      createCustomerPaymentPaymentResponse,
    ),
  );
}

export function createCustomerPaymentPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentPaymentResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingLinksResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingLinksResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreateCustomerPaymentRoutingSelfResponse$inboundSchema),
  payment: z.lazy(() => CreateCustomerPaymentPaymentResponse$inboundSchema),
});

/** @internal */
export type CreateCustomerPaymentRoutingLinksResponse$Outbound = {
  self: CreateCustomerPaymentRoutingSelfResponse$Outbound;
  payment: CreateCustomerPaymentPaymentResponse$Outbound;
};

/** @internal */
export const CreateCustomerPaymentRoutingLinksResponse$outboundSchema:
  z.ZodType<
    CreateCustomerPaymentRoutingLinksResponse$Outbound,
    z.ZodTypeDef,
    CreateCustomerPaymentRoutingLinksResponse
  > = z.object({
    self: z.lazy(() => CreateCustomerPaymentRoutingSelfResponse$outboundSchema),
    payment: z.lazy(() => CreateCustomerPaymentPaymentResponse$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingLinksResponse$ {
  /** @deprecated use `CreateCustomerPaymentRoutingLinksResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingLinksResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingLinksResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingLinksResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingLinksResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingLinksResponse$Outbound;
}

export function createCustomerPaymentRoutingLinksResponseToJSON(
  createCustomerPaymentRoutingLinksResponse:
    CreateCustomerPaymentRoutingLinksResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingLinksResponse$outboundSchema.parse(
      createCustomerPaymentRoutingLinksResponse,
    ),
  );
}

export function createCustomerPaymentRoutingLinksResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentRoutingLinksResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingLinksResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentRoutingLinksResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRoutingResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreateCustomerPaymentRoutingMode$inboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRoutingAmountResponse$inboundSchema
  ),
  destination: z.lazy(() =>
    CreateCustomerPaymentDestinationResponse$inboundSchema
  ),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreateCustomerPaymentRoutingLinksResponse$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreateCustomerPaymentRoutingResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: CreateCustomerPaymentRoutingAmountResponse$Outbound;
  destination: CreateCustomerPaymentDestinationResponse$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: CreateCustomerPaymentRoutingLinksResponse$Outbound;
};

/** @internal */
export const CreateCustomerPaymentRoutingResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentRoutingResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRoutingResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreateCustomerPaymentRoutingMode$outboundSchema,
  amount: z.lazy(() =>
    CreateCustomerPaymentRoutingAmountResponse$outboundSchema
  ),
  destination: z.lazy(() =>
    CreateCustomerPaymentDestinationResponse$outboundSchema
  ),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreateCustomerPaymentRoutingLinksResponse$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRoutingResponse$ {
  /** @deprecated use `CreateCustomerPaymentRoutingResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentRoutingResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentRoutingResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRoutingResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRoutingResponse$Outbound;
}

export function createCustomerPaymentRoutingResponseToJSON(
  createCustomerPaymentRoutingResponse: CreateCustomerPaymentRoutingResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRoutingResponse$outboundSchema.parse(
      createCustomerPaymentRoutingResponse,
    ),
  );
}

export function createCustomerPaymentRoutingResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRoutingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentRoutingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRoutingResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSequenceTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentSequenceTypeResponse> = z
    .nativeEnum(CreateCustomerPaymentSequenceTypeResponse);

/** @internal */
export const CreateCustomerPaymentSequenceTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreateCustomerPaymentSequenceTypeResponse> =
    CreateCustomerPaymentSequenceTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSequenceTypeResponse$ {
  /** @deprecated use `CreateCustomerPaymentSequenceTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentSequenceTypeResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSequenceTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentSequenceTypeResponse$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentStatus
> = z.nativeEnum(CreateCustomerPaymentStatus);

/** @internal */
export const CreateCustomerPaymentStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateCustomerPaymentStatus
> = CreateCustomerPaymentStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentStatus$ {
  /** @deprecated use `CreateCustomerPaymentStatus$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentStatus$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentStatus$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentStatus$outboundSchema;
}

/** @internal */
export const CreateCustomerPaymentStatusReason$inboundSchema: z.ZodType<
  CreateCustomerPaymentStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type CreateCustomerPaymentStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const CreateCustomerPaymentStatusReason$outboundSchema: z.ZodType<
  CreateCustomerPaymentStatusReason$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentStatusReason$ {
  /** @deprecated use `CreateCustomerPaymentStatusReason$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentStatusReason$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentStatusReason$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentStatusReason$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentStatusReason$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentStatusReason$Outbound;
}

export function createCustomerPaymentStatusReasonToJSON(
  createCustomerPaymentStatusReason: CreateCustomerPaymentStatusReason,
): string {
  return JSON.stringify(
    CreateCustomerPaymentStatusReason$outboundSchema.parse(
      createCustomerPaymentStatusReason,
    ),
  );
}

export function createCustomerPaymentStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentStatusReason' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSelfResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentSelfResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentSelfResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentSelfResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentSelfResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentSelfResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSelfResponse$ {
  /** @deprecated use `CreateCustomerPaymentSelfResponse$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentSelfResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSelfResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentSelfResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentSelfResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentSelfResponse$Outbound;
}

export function createCustomerPaymentSelfResponseToJSON(
  createCustomerPaymentSelfResponse: CreateCustomerPaymentSelfResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentSelfResponse$outboundSchema.parse(
      createCustomerPaymentSelfResponse,
    ),
  );
}

export function createCustomerPaymentSelfResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentSelfResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentSelfResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentSelfResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCheckout$inboundSchema: z.ZodType<
  CreateCustomerPaymentCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentCheckout$outboundSchema: z.ZodType<
  CreateCustomerPaymentCheckout$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCheckout$ {
  /** @deprecated use `CreateCustomerPaymentCheckout$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentCheckout$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCheckout$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentCheckout$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentCheckout$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentCheckout$Outbound;
}

export function createCustomerPaymentCheckoutToJSON(
  createCustomerPaymentCheckout: CreateCustomerPaymentCheckout,
): string {
  return JSON.stringify(
    CreateCustomerPaymentCheckout$outboundSchema.parse(
      createCustomerPaymentCheckout,
    ),
  );
}

export function createCustomerPaymentCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentCheckout' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentMobileAppCheckout$inboundSchema: z.ZodType<
  CreateCustomerPaymentMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentMobileAppCheckout$outboundSchema: z.ZodType<
  CreateCustomerPaymentMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMobileAppCheckout$ {
  /** @deprecated use `CreateCustomerPaymentMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentMobileAppCheckout$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentMobileAppCheckout$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMobileAppCheckout$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMobileAppCheckout$Outbound;
}

export function createCustomerPaymentMobileAppCheckoutToJSON(
  createCustomerPaymentMobileAppCheckout:
    CreateCustomerPaymentMobileAppCheckout,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMobileAppCheckout$outboundSchema.parse(
      createCustomerPaymentMobileAppCheckout,
    ),
  );
}

export function createCustomerPaymentMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentChangePaymentState$inboundSchema: z.ZodType<
  CreateCustomerPaymentChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentChangePaymentState$outboundSchema: z.ZodType<
  CreateCustomerPaymentChangePaymentState$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentChangePaymentState$ {
  /** @deprecated use `CreateCustomerPaymentChangePaymentState$inboundSchema` instead. */
  export const inboundSchema =
    CreateCustomerPaymentChangePaymentState$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentChangePaymentState$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentChangePaymentState$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentChangePaymentState$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentChangePaymentState$Outbound;
}

export function createCustomerPaymentChangePaymentStateToJSON(
  createCustomerPaymentChangePaymentState:
    CreateCustomerPaymentChangePaymentState,
): string {
  return JSON.stringify(
    CreateCustomerPaymentChangePaymentState$outboundSchema.parse(
      createCustomerPaymentChangePaymentState,
    ),
  );
}

export function createCustomerPaymentChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCustomerPaymentChangePaymentState,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentChangePaymentState$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCustomerPaymentChangePaymentState' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentDashboard$inboundSchema: z.ZodType<
  CreateCustomerPaymentDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentDashboard$outboundSchema: z.ZodType<
  CreateCustomerPaymentDashboard$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDashboard$ {
  /** @deprecated use `CreateCustomerPaymentDashboard$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentDashboard$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDashboard$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentDashboard$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDashboard$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDashboard$Outbound;
}

export function createCustomerPaymentDashboardToJSON(
  createCustomerPaymentDashboard: CreateCustomerPaymentDashboard,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDashboard$outboundSchema.parse(
      createCustomerPaymentDashboard,
    ),
  );
}

export function createCustomerPaymentDashboardFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentDashboard' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentRefunds$inboundSchema: z.ZodType<
  CreateCustomerPaymentRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentRefunds$outboundSchema: z.ZodType<
  CreateCustomerPaymentRefunds$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentRefunds$ {
  /** @deprecated use `CreateCustomerPaymentRefunds$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentRefunds$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentRefunds$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentRefunds$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentRefunds$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentRefunds$Outbound;
}

export function createCustomerPaymentRefundsToJSON(
  createCustomerPaymentRefunds: CreateCustomerPaymentRefunds,
): string {
  return JSON.stringify(
    CreateCustomerPaymentRefunds$outboundSchema.parse(
      createCustomerPaymentRefunds,
    ),
  );
}

export function createCustomerPaymentRefundsFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentRefunds' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentChargebacks$inboundSchema: z.ZodType<
  CreateCustomerPaymentChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentChargebacks$outboundSchema: z.ZodType<
  CreateCustomerPaymentChargebacks$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentChargebacks$ {
  /** @deprecated use `CreateCustomerPaymentChargebacks$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentChargebacks$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentChargebacks$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentChargebacks$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentChargebacks$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentChargebacks$Outbound;
}

export function createCustomerPaymentChargebacksToJSON(
  createCustomerPaymentChargebacks: CreateCustomerPaymentChargebacks,
): string {
  return JSON.stringify(
    CreateCustomerPaymentChargebacks$outboundSchema.parse(
      createCustomerPaymentChargebacks,
    ),
  );
}

export function createCustomerPaymentChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentChargebacks' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCaptures$inboundSchema: z.ZodType<
  CreateCustomerPaymentCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentCaptures$outboundSchema: z.ZodType<
  CreateCustomerPaymentCaptures$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCaptures$ {
  /** @deprecated use `CreateCustomerPaymentCaptures$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentCaptures$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptures$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentCaptures$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentCaptures$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentCaptures$Outbound;
}

export function createCustomerPaymentCapturesToJSON(
  createCustomerPaymentCaptures: CreateCustomerPaymentCaptures,
): string {
  return JSON.stringify(
    CreateCustomerPaymentCaptures$outboundSchema.parse(
      createCustomerPaymentCaptures,
    ),
  );
}

export function createCustomerPaymentCapturesFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentCaptures' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSettlement$inboundSchema: z.ZodType<
  CreateCustomerPaymentSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentSettlement$outboundSchema: z.ZodType<
  CreateCustomerPaymentSettlement$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSettlement$ {
  /** @deprecated use `CreateCustomerPaymentSettlement$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentSettlement$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSettlement$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentSettlement$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentSettlement$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentSettlement$Outbound;
}

export function createCustomerPaymentSettlementToJSON(
  createCustomerPaymentSettlement: CreateCustomerPaymentSettlement,
): string {
  return JSON.stringify(
    CreateCustomerPaymentSettlement$outboundSchema.parse(
      createCustomerPaymentSettlement,
    ),
  );
}

export function createCustomerPaymentSettlementFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentSettlement' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentCustomer$inboundSchema: z.ZodType<
  CreateCustomerPaymentCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentCustomer$outboundSchema: z.ZodType<
  CreateCustomerPaymentCustomer$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentCustomer$ {
  /** @deprecated use `CreateCustomerPaymentCustomer$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentCustomer$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentCustomer$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentCustomer$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentCustomer$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentCustomer$Outbound;
}

export function createCustomerPaymentCustomerToJSON(
  createCustomerPaymentCustomer: CreateCustomerPaymentCustomer,
): string {
  return JSON.stringify(
    CreateCustomerPaymentCustomer$outboundSchema.parse(
      createCustomerPaymentCustomer,
    ),
  );
}

export function createCustomerPaymentCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentCustomer' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentMandate$inboundSchema: z.ZodType<
  CreateCustomerPaymentMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentMandate$outboundSchema: z.ZodType<
  CreateCustomerPaymentMandate$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentMandate$ {
  /** @deprecated use `CreateCustomerPaymentMandate$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentMandate$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentMandate$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentMandate$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentMandate$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentMandate$Outbound;
}

export function createCustomerPaymentMandateToJSON(
  createCustomerPaymentMandate: CreateCustomerPaymentMandate,
): string {
  return JSON.stringify(
    CreateCustomerPaymentMandate$outboundSchema.parse(
      createCustomerPaymentMandate,
    ),
  );
}

export function createCustomerPaymentMandateFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentMandate' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentSubscription$inboundSchema: z.ZodType<
  CreateCustomerPaymentSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentSubscription$outboundSchema: z.ZodType<
  CreateCustomerPaymentSubscription$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentSubscription$ {
  /** @deprecated use `CreateCustomerPaymentSubscription$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentSubscription$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentSubscription$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentSubscription$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentSubscription$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentSubscription$Outbound;
}

export function createCustomerPaymentSubscriptionToJSON(
  createCustomerPaymentSubscription: CreateCustomerPaymentSubscription,
): string {
  return JSON.stringify(
    CreateCustomerPaymentSubscription$outboundSchema.parse(
      createCustomerPaymentSubscription,
    ),
  );
}

export function createCustomerPaymentSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentSubscription' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentOrder$inboundSchema: z.ZodType<
  CreateCustomerPaymentOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentOrder$outboundSchema: z.ZodType<
  CreateCustomerPaymentOrder$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentOrder$ {
  /** @deprecated use `CreateCustomerPaymentOrder$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentOrder$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentOrder$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentOrder$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentOrder$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentOrder$Outbound;
}

export function createCustomerPaymentOrderToJSON(
  createCustomerPaymentOrder: CreateCustomerPaymentOrder,
): string {
  return JSON.stringify(
    CreateCustomerPaymentOrder$outboundSchema.parse(createCustomerPaymentOrder),
  );
}

export function createCustomerPaymentOrderFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentOrder' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentTerminal$inboundSchema: z.ZodType<
  CreateCustomerPaymentTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentTerminal$outboundSchema: z.ZodType<
  CreateCustomerPaymentTerminal$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentTerminal$ {
  /** @deprecated use `CreateCustomerPaymentTerminal$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentTerminal$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentTerminal$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentTerminal$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentTerminal$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentTerminal$Outbound;
}

export function createCustomerPaymentTerminalToJSON(
  createCustomerPaymentTerminal: CreateCustomerPaymentTerminal,
): string {
  return JSON.stringify(
    CreateCustomerPaymentTerminal$outboundSchema.parse(
      createCustomerPaymentTerminal,
    ),
  );
}

export function createCustomerPaymentTerminalFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentTerminal' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentDocumentation$inboundSchema: z.ZodType<
  CreateCustomerPaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateCustomerPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateCustomerPaymentDocumentation$outboundSchema: z.ZodType<
  CreateCustomerPaymentDocumentation$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentDocumentation$ {
  /** @deprecated use `CreateCustomerPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentDocumentation$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentDocumentation$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentDocumentation$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentDocumentation$Outbound;
}

export function createCustomerPaymentDocumentationToJSON(
  createCustomerPaymentDocumentation: CreateCustomerPaymentDocumentation,
): string {
  return JSON.stringify(
    CreateCustomerPaymentDocumentation$outboundSchema.parse(
      createCustomerPaymentDocumentation,
    ),
  );
}

export function createCustomerPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentLinksResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentLinksResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreateCustomerPaymentSelfResponse$inboundSchema),
  checkout: z.lazy(() => CreateCustomerPaymentCheckout$inboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    CreateCustomerPaymentMobileAppCheckout$inboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    CreateCustomerPaymentChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => CreateCustomerPaymentDashboard$inboundSchema),
  refunds: z.lazy(() => CreateCustomerPaymentRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => CreateCustomerPaymentChargebacks$inboundSchema)
    .optional(),
  captures: z.lazy(() => CreateCustomerPaymentCaptures$inboundSchema)
    .optional(),
  settlement: z.lazy(() => CreateCustomerPaymentSettlement$inboundSchema)
    .optional(),
  customer: z.lazy(() => CreateCustomerPaymentCustomer$inboundSchema)
    .optional(),
  mandate: z.lazy(() => CreateCustomerPaymentMandate$inboundSchema).optional(),
  subscription: z.lazy(() => CreateCustomerPaymentSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => CreateCustomerPaymentOrder$inboundSchema).optional(),
  terminal: z.lazy(() => CreateCustomerPaymentTerminal$inboundSchema)
    .optional(),
  documentation: z.lazy(() => CreateCustomerPaymentDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type CreateCustomerPaymentLinksResponse$Outbound = {
  self: CreateCustomerPaymentSelfResponse$Outbound;
  checkout?: CreateCustomerPaymentCheckout$Outbound | undefined;
  mobileAppCheckout?:
    | CreateCustomerPaymentMobileAppCheckout$Outbound
    | undefined;
  changePaymentState?:
    | CreateCustomerPaymentChangePaymentState$Outbound
    | undefined;
  dashboard: CreateCustomerPaymentDashboard$Outbound;
  refunds?: CreateCustomerPaymentRefunds$Outbound | undefined;
  chargebacks?: CreateCustomerPaymentChargebacks$Outbound | undefined;
  captures?: CreateCustomerPaymentCaptures$Outbound | undefined;
  settlement?: CreateCustomerPaymentSettlement$Outbound | undefined;
  customer?: CreateCustomerPaymentCustomer$Outbound | undefined;
  mandate?: CreateCustomerPaymentMandate$Outbound | undefined;
  subscription?: CreateCustomerPaymentSubscription$Outbound | undefined;
  order?: CreateCustomerPaymentOrder$Outbound | undefined;
  terminal?: CreateCustomerPaymentTerminal$Outbound | undefined;
  documentation?: CreateCustomerPaymentDocumentation$Outbound | undefined;
};

/** @internal */
export const CreateCustomerPaymentLinksResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentLinksResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentLinksResponse
> = z.object({
  self: z.lazy(() => CreateCustomerPaymentSelfResponse$outboundSchema),
  checkout: z.lazy(() => CreateCustomerPaymentCheckout$outboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    CreateCustomerPaymentMobileAppCheckout$outboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    CreateCustomerPaymentChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => CreateCustomerPaymentDashboard$outboundSchema),
  refunds: z.lazy(() => CreateCustomerPaymentRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => CreateCustomerPaymentChargebacks$outboundSchema)
    .optional(),
  captures: z.lazy(() => CreateCustomerPaymentCaptures$outboundSchema)
    .optional(),
  settlement: z.lazy(() => CreateCustomerPaymentSettlement$outboundSchema)
    .optional(),
  customer: z.lazy(() => CreateCustomerPaymentCustomer$outboundSchema)
    .optional(),
  mandate: z.lazy(() => CreateCustomerPaymentMandate$outboundSchema).optional(),
  subscription: z.lazy(() => CreateCustomerPaymentSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => CreateCustomerPaymentOrder$outboundSchema).optional(),
  terminal: z.lazy(() => CreateCustomerPaymentTerminal$outboundSchema)
    .optional(),
  documentation: z.lazy(() => CreateCustomerPaymentDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentLinksResponse$ {
  /** @deprecated use `CreateCustomerPaymentLinksResponse$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentLinksResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentLinksResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateCustomerPaymentLinksResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentLinksResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentLinksResponse$Outbound;
}

export function createCustomerPaymentLinksResponseToJSON(
  createCustomerPaymentLinksResponse: CreateCustomerPaymentLinksResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentLinksResponse$outboundSchema.parse(
      createCustomerPaymentLinksResponse,
    ),
  );
}

export function createCustomerPaymentLinksResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentLinksResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCustomerPaymentLinksResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentLinksResponse' from JSON`,
  );
}

/** @internal */
export const CreateCustomerPaymentResponse$inboundSchema: z.ZodType<
  CreateCustomerPaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreateCustomerPaymentMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => CreateCustomerPaymentAmountResponse$inboundSchema),
  amountRefunded: z.lazy(() =>
    CreateCustomerPaymentAmountRefunded$inboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    CreateCustomerPaymentAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    CreateCustomerPaymentAmountCaptured$inboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    CreateCustomerPaymentAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    CreateCustomerPaymentSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentLineResponse$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreateCustomerPaymentBillingAddressResponse$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreateCustomerPaymentShippingAddressResponse$inboundSchema
  ).optional(),
  locale: z.nullable(CreateCustomerPaymentLocaleResponse$inboundSchema)
    .optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(CreateCustomerPaymentMethodResponse$inboundSchema)
    .optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateCustomerPaymentMetadataResponse$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    CreateCustomerPaymentCaptureModeResponse$inboundSchema.default("automatic"),
  ),
  captureDelay: z.nullable(
    CreateCustomerPaymentCaptureDelayResponse$inboundSchema,
  ).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreateCustomerPaymentApplicationFeeResponse$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentRoutingResponse$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreateCustomerPaymentSequenceTypeResponse$inboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: CreateCustomerPaymentStatus$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => CreateCustomerPaymentStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreateCustomerPaymentLinksResponse$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreateCustomerPaymentResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: CreateCustomerPaymentAmountResponse$Outbound;
  amountRefunded?: CreateCustomerPaymentAmountRefunded$Outbound | undefined;
  amountRemaining?: CreateCustomerPaymentAmountRemaining$Outbound | undefined;
  amountCaptured?: CreateCustomerPaymentAmountCaptured$Outbound | undefined;
  amountChargedBack?:
    | CreateCustomerPaymentAmountChargedBack$Outbound
    | undefined;
  settlementAmount?: CreateCustomerPaymentSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<CreateCustomerPaymentLineResponse$Outbound> | null | undefined;
  billingAddress?:
    | CreateCustomerPaymentBillingAddressResponse$Outbound
    | undefined;
  shippingAddress?:
    | CreateCustomerPaymentShippingAddressResponse$Outbound
    | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | CreateCustomerPaymentMetadataResponse$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode: string | null;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | CreateCustomerPaymentApplicationFeeResponse$Outbound
    | null
    | undefined;
  routing?:
    | Array<CreateCustomerPaymentRoutingResponse$Outbound>
    | null
    | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: CreateCustomerPaymentStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: CreateCustomerPaymentLinksResponse$Outbound;
};

/** @internal */
export const CreateCustomerPaymentResponse$outboundSchema: z.ZodType<
  CreateCustomerPaymentResponse$Outbound,
  z.ZodTypeDef,
  CreateCustomerPaymentResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreateCustomerPaymentMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => CreateCustomerPaymentAmountResponse$outboundSchema),
  amountRefunded: z.lazy(() =>
    CreateCustomerPaymentAmountRefunded$outboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    CreateCustomerPaymentAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    CreateCustomerPaymentAmountCaptured$outboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    CreateCustomerPaymentAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    CreateCustomerPaymentSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentLineResponse$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreateCustomerPaymentBillingAddressResponse$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreateCustomerPaymentShippingAddressResponse$outboundSchema
  ).optional(),
  locale: z.nullable(CreateCustomerPaymentLocaleResponse$outboundSchema)
    .optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(CreateCustomerPaymentMethodResponse$outboundSchema)
    .optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateCustomerPaymentMetadataResponse$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    CreateCustomerPaymentCaptureModeResponse$outboundSchema.default(
      "automatic",
    ),
  ),
  captureDelay: z.nullable(
    CreateCustomerPaymentCaptureDelayResponse$outboundSchema,
  ).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreateCustomerPaymentApplicationFeeResponse$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreateCustomerPaymentRoutingResponse$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreateCustomerPaymentSequenceTypeResponse$outboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: CreateCustomerPaymentStatus$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => CreateCustomerPaymentStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreateCustomerPaymentLinksResponse$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerPaymentResponse$ {
  /** @deprecated use `CreateCustomerPaymentResponse$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerPaymentResponse$inboundSchema;
  /** @deprecated use `CreateCustomerPaymentResponse$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerPaymentResponse$outboundSchema;
  /** @deprecated use `CreateCustomerPaymentResponse$Outbound` instead. */
  export type Outbound = CreateCustomerPaymentResponse$Outbound;
}

export function createCustomerPaymentResponseToJSON(
  createCustomerPaymentResponse: CreateCustomerPaymentResponse,
): string {
  return JSON.stringify(
    CreateCustomerPaymentResponse$outboundSchema.parse(
      createCustomerPaymentResponse,
    ),
  );
}

export function createCustomerPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerPaymentResponse' from JSON`,
  );
}
