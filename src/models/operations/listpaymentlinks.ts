/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListPaymentLinksRequest = {
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
   *
   * @remarks
   * result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListPaymentLinksBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListPaymentLinksBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListPaymentLinksBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListPaymentLinksMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListPaymentLinksMode = ClosedEnum<typeof ListPaymentLinksMode>;

/**
 * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
 *
 * @remarks
 * amount.
 */
export type ListPaymentLinksAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
 *
 * @remarks
 * customer will be prompted to enter a value greater than or equal to the minimum amount.
 */
export type ListPaymentLinksMinimumAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const ListPaymentLinksType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type ListPaymentLinksType = ClosedEnum<typeof ListPaymentLinksType>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type ListPaymentLinksUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type ListPaymentLinksDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type ListPaymentLinksTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type ListPaymentLinksVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const ListPaymentLinksCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type ListPaymentLinksCategory = ClosedEnum<
  typeof ListPaymentLinksCategory
>;

export type ListPaymentLinksLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: ListPaymentLinksType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: ListPaymentLinksUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: ListPaymentLinksDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: ListPaymentLinksTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: ListPaymentLinksVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<ListPaymentLinksCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListPaymentLinksBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type ListPaymentLinksShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type ListPaymentLinksApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 */
export type ListPaymentLinksApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount: ListPaymentLinksApplicationFeeAmount;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description: string;
};

/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export const ListPaymentLinksSequenceType = {
  Oneoff: "oneoff",
  First: "first",
} as const;
/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export type ListPaymentLinksSequenceType = ClosedEnum<
  typeof ListPaymentLinksSequenceType
>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type PaymentLinkSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type ListPaymentLinksLinksPaymentLink = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type PaymentLinkLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: PaymentLinkSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  paymentLink: ListPaymentLinksLinksPaymentLink;
};

export type ListPaymentLinksPaymentLink = {
  /**
   * Indicates the response contains a payment link object. Will always contain the string `payment-link` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  /**
   * The identifier uniquely referring to this payment link. Example: `pl_4Y0eZitmBnQ6IDoMqZQKh`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListPaymentLinksMode;
  /**
   * A short description of the payment link. The description is visible in the Dashboard and will be shown on the
   *
   * @remarks
   * customer's bank or card statement when possible.
   */
  description: string;
  /**
   * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
   *
   * @remarks
   * amount.
   */
  amount: ListPaymentLinksAmount | null;
  /**
   * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
   *
   * @remarks
   * customer will be prompted to enter a value greater than or equal to the minimum amount.
   */
  minimumAmount?: ListPaymentLinksMinimumAmount | null | undefined;
  /**
   * Whether the payment link is archived. Customers will not be able to complete payments on archived payment links.
   */
  archived: boolean;
  /**
   * The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,
   *
   * @remarks
   * the customer will be shown a generic message after completing the payment.
   */
  redirectUrl: string | null;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to any payments
   * resulting from the payment link.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl: string | null;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListPaymentLinksLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListPaymentLinksBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: ListPaymentLinksShippingAddress | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId: string | null;
  /**
   * Indicates whether the payment link is reusable. If this field is set to `true`, customers can make multiple
   *
   * @remarks
   * payments using the same link.
   *
   * If no value is specified, the field defaults to `false`, allowing only a single payment per link.
   */
  reusable?: boolean | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment link became paid, in ISO 8601 format.
   */
  paidAt: string | null;
  /**
   * The date and time the payment link is set to expire, in ISO 8601 format. If no expiry date was provided up front,
   *
   * @remarks
   * the payment link will not expire automatically.
   */
  expiresAt: string | null;
  /**
   * An array of payment methods that are allowed to be used for this payment link. When this parameter is
   *
   * @remarks
   * not provided or is an empty array, all enabled payment methods will be available.
   *
   * Enum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'blik', 'creditcard', 'eps', 'giftcard',
   * 'ideal', 'kbc', 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale', 'przelewy24', 'satispay', 'trustly', 'twint',
   * 'in3', 'riverty', 'klarna', 'billie'.
   */
  allowedMethods: Array<string> | null;
  /**
   * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   */
  applicationFee?: ListPaymentLinksApplicationFee | undefined;
  /**
   * If set to `first`, a payment mandate is established right after a payment is made by the customer.
   *
   * @remarks
   *
   * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
   *
   * The mandate ID can be retrieved by making a call to the
   * [Payment Link Payments Endpoint](get-payment-link-payments).
   */
  sequenceType?: ListPaymentLinksSequenceType | null | undefined;
  /**
   * **Only relevant when `sequenceType` is set to `first`**
   *
   * @remarks
   *
   * The ID of the [customer](get-customer) the payment link is being created for. If a value is not provided,
   * the customer will be required to input relevant information which will be used to establish a mandate after
   * the payment is made.
   */
  customerId?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: PaymentLinkLinks;
};

export type ListPaymentLinksEmbedded = {
  /**
   * An array of payment link objects.
   */
  paymentLinks?: Array<ListPaymentLinksPaymentLink> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListPaymentLinksSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListPaymentLinksPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListPaymentLinksNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListPaymentLinksDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListPaymentLinksLinks = {
  /**
   * The URL to the current set of items.
   */
  self?: ListPaymentLinksSelf | undefined;
  /**
   * The previous set of items, if available.
   */
  previous?: ListPaymentLinksPrevious | null | undefined;
  /**
   * The next set of items, if available.
   */
  next?: ListPaymentLinksNext | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListPaymentLinksDocumentation | undefined;
};

/**
 * A list of payment link objects.
 */
export type ListPaymentLinksResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListPaymentLinksEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListPaymentLinksLinks | undefined;
};

/** @internal */
export const ListPaymentLinksRequest$inboundSchema: z.ZodType<
  ListPaymentLinksRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListPaymentLinksRequest$Outbound = {
  from?: string | undefined;
  limit: number | null;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListPaymentLinksRequest$outboundSchema: z.ZodType<
  ListPaymentLinksRequest$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksRequest
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksRequest$ {
  /** @deprecated use `ListPaymentLinksRequest$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksRequest$inboundSchema;
  /** @deprecated use `ListPaymentLinksRequest$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksRequest$outboundSchema;
  /** @deprecated use `ListPaymentLinksRequest$Outbound` instead. */
  export type Outbound = ListPaymentLinksRequest$Outbound;
}

export function listPaymentLinksRequestToJSON(
  listPaymentLinksRequest: ListPaymentLinksRequest,
): string {
  return JSON.stringify(
    ListPaymentLinksRequest$outboundSchema.parse(listPaymentLinksRequest),
  );
}

export function listPaymentLinksRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksRequest' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksBadRequestDocumentation$inboundSchema: z.ZodType<
  ListPaymentLinksBadRequestDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListPaymentLinksBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListPaymentLinksBadRequestDocumentation$outboundSchema: z.ZodType<
  ListPaymentLinksBadRequestDocumentation$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksBadRequestDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksBadRequestDocumentation$ {
  /** @deprecated use `ListPaymentLinksBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListPaymentLinksBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListPaymentLinksBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListPaymentLinksBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListPaymentLinksBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListPaymentLinksBadRequestDocumentation$Outbound;
}

export function listPaymentLinksBadRequestDocumentationToJSON(
  listPaymentLinksBadRequestDocumentation:
    ListPaymentLinksBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListPaymentLinksBadRequestDocumentation$outboundSchema.parse(
      listPaymentLinksBadRequestDocumentation,
    ),
  );
}

export function listPaymentLinksBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPaymentLinksBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPaymentLinksBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPaymentLinksBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksBadRequestLinks$inboundSchema: z.ZodType<
  ListPaymentLinksBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListPaymentLinksBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListPaymentLinksBadRequestLinks$Outbound = {
  documentation: ListPaymentLinksBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListPaymentLinksBadRequestLinks$outboundSchema: z.ZodType<
  ListPaymentLinksBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListPaymentLinksBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksBadRequestLinks$ {
  /** @deprecated use `ListPaymentLinksBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksBadRequestLinks$inboundSchema;
  /** @deprecated use `ListPaymentLinksBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksBadRequestLinks$outboundSchema;
  /** @deprecated use `ListPaymentLinksBadRequestLinks$Outbound` instead. */
  export type Outbound = ListPaymentLinksBadRequestLinks$Outbound;
}

export function listPaymentLinksBadRequestLinksToJSON(
  listPaymentLinksBadRequestLinks: ListPaymentLinksBadRequestLinks,
): string {
  return JSON.stringify(
    ListPaymentLinksBadRequestLinks$outboundSchema.parse(
      listPaymentLinksBadRequestLinks,
    ),
  );
}

export function listPaymentLinksBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksMode$inboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksMode
> = z.nativeEnum(ListPaymentLinksMode);

/** @internal */
export const ListPaymentLinksMode$outboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksMode
> = ListPaymentLinksMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksMode$ {
  /** @deprecated use `ListPaymentLinksMode$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksMode$inboundSchema;
  /** @deprecated use `ListPaymentLinksMode$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksMode$outboundSchema;
}

/** @internal */
export const ListPaymentLinksAmount$inboundSchema: z.ZodType<
  ListPaymentLinksAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksAmount$outboundSchema: z.ZodType<
  ListPaymentLinksAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksAmount$ {
  /** @deprecated use `ListPaymentLinksAmount$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksAmount$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksAmount$Outbound;
}

export function listPaymentLinksAmountToJSON(
  listPaymentLinksAmount: ListPaymentLinksAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksAmount$outboundSchema.parse(listPaymentLinksAmount),
  );
}

export function listPaymentLinksAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksMinimumAmount$inboundSchema: z.ZodType<
  ListPaymentLinksMinimumAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksMinimumAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksMinimumAmount$outboundSchema: z.ZodType<
  ListPaymentLinksMinimumAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksMinimumAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksMinimumAmount$ {
  /** @deprecated use `ListPaymentLinksMinimumAmount$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksMinimumAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksMinimumAmount$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksMinimumAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksMinimumAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksMinimumAmount$Outbound;
}

export function listPaymentLinksMinimumAmountToJSON(
  listPaymentLinksMinimumAmount: ListPaymentLinksMinimumAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksMinimumAmount$outboundSchema.parse(
      listPaymentLinksMinimumAmount,
    ),
  );
}

export function listPaymentLinksMinimumAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksMinimumAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksMinimumAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksMinimumAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksType$inboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksType
> = z.nativeEnum(ListPaymentLinksType);

/** @internal */
export const ListPaymentLinksType$outboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksType
> = ListPaymentLinksType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksType$ {
  /** @deprecated use `ListPaymentLinksType$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksType$inboundSchema;
  /** @deprecated use `ListPaymentLinksType$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksType$outboundSchema;
}

/** @internal */
export const ListPaymentLinksUnitPrice$inboundSchema: z.ZodType<
  ListPaymentLinksUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksUnitPrice$outboundSchema: z.ZodType<
  ListPaymentLinksUnitPrice$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksUnitPrice$ {
  /** @deprecated use `ListPaymentLinksUnitPrice$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksUnitPrice$inboundSchema;
  /** @deprecated use `ListPaymentLinksUnitPrice$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksUnitPrice$outboundSchema;
  /** @deprecated use `ListPaymentLinksUnitPrice$Outbound` instead. */
  export type Outbound = ListPaymentLinksUnitPrice$Outbound;
}

export function listPaymentLinksUnitPriceToJSON(
  listPaymentLinksUnitPrice: ListPaymentLinksUnitPrice,
): string {
  return JSON.stringify(
    ListPaymentLinksUnitPrice$outboundSchema.parse(listPaymentLinksUnitPrice),
  );
}

export function listPaymentLinksUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksUnitPrice' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksDiscountAmount$inboundSchema: z.ZodType<
  ListPaymentLinksDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksDiscountAmount$outboundSchema: z.ZodType<
  ListPaymentLinksDiscountAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksDiscountAmount$ {
  /** @deprecated use `ListPaymentLinksDiscountAmount$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksDiscountAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksDiscountAmount$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksDiscountAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksDiscountAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksDiscountAmount$Outbound;
}

export function listPaymentLinksDiscountAmountToJSON(
  listPaymentLinksDiscountAmount: ListPaymentLinksDiscountAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksDiscountAmount$outboundSchema.parse(
      listPaymentLinksDiscountAmount,
    ),
  );
}

export function listPaymentLinksDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksDiscountAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksTotalAmount$inboundSchema: z.ZodType<
  ListPaymentLinksTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksTotalAmount$outboundSchema: z.ZodType<
  ListPaymentLinksTotalAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksTotalAmount$ {
  /** @deprecated use `ListPaymentLinksTotalAmount$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksTotalAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksTotalAmount$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksTotalAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksTotalAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksTotalAmount$Outbound;
}

export function listPaymentLinksTotalAmountToJSON(
  listPaymentLinksTotalAmount: ListPaymentLinksTotalAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksTotalAmount$outboundSchema.parse(
      listPaymentLinksTotalAmount,
    ),
  );
}

export function listPaymentLinksTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksVatAmount$inboundSchema: z.ZodType<
  ListPaymentLinksVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksVatAmount$outboundSchema: z.ZodType<
  ListPaymentLinksVatAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksVatAmount$ {
  /** @deprecated use `ListPaymentLinksVatAmount$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksVatAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksVatAmount$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksVatAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksVatAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksVatAmount$Outbound;
}

export function listPaymentLinksVatAmountToJSON(
  listPaymentLinksVatAmount: ListPaymentLinksVatAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksVatAmount$outboundSchema.parse(listPaymentLinksVatAmount),
  );
}

export function listPaymentLinksVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksVatAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksCategory$inboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksCategory
> = z.nativeEnum(ListPaymentLinksCategory);

/** @internal */
export const ListPaymentLinksCategory$outboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksCategory
> = ListPaymentLinksCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksCategory$ {
  /** @deprecated use `ListPaymentLinksCategory$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksCategory$inboundSchema;
  /** @deprecated use `ListPaymentLinksCategory$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksCategory$outboundSchema;
}

/** @internal */
export const ListPaymentLinksLine$inboundSchema: z.ZodType<
  ListPaymentLinksLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPaymentLinksType$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListPaymentLinksUnitPrice$inboundSchema),
  discountAmount: z.lazy(() => ListPaymentLinksDiscountAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => ListPaymentLinksTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListPaymentLinksVatAmount$inboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(ListPaymentLinksCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/** @internal */
export type ListPaymentLinksLine$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: ListPaymentLinksUnitPrice$Outbound;
  discountAmount?: ListPaymentLinksDiscountAmount$Outbound | undefined;
  totalAmount: ListPaymentLinksTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: ListPaymentLinksVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
};

/** @internal */
export const ListPaymentLinksLine$outboundSchema: z.ZodType<
  ListPaymentLinksLine$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksLine
> = z.object({
  type: ListPaymentLinksType$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListPaymentLinksUnitPrice$outboundSchema),
  discountAmount: z.lazy(() => ListPaymentLinksDiscountAmount$outboundSchema)
    .optional(),
  totalAmount: z.lazy(() => ListPaymentLinksTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListPaymentLinksVatAmount$outboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(ListPaymentLinksCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksLine$ {
  /** @deprecated use `ListPaymentLinksLine$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksLine$inboundSchema;
  /** @deprecated use `ListPaymentLinksLine$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksLine$outboundSchema;
  /** @deprecated use `ListPaymentLinksLine$Outbound` instead. */
  export type Outbound = ListPaymentLinksLine$Outbound;
}

export function listPaymentLinksLineToJSON(
  listPaymentLinksLine: ListPaymentLinksLine,
): string {
  return JSON.stringify(
    ListPaymentLinksLine$outboundSchema.parse(listPaymentLinksLine),
  );
}

export function listPaymentLinksLineFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksLine' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksBillingAddress$inboundSchema: z.ZodType<
  ListPaymentLinksBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListPaymentLinksBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListPaymentLinksBillingAddress$outboundSchema: z.ZodType<
  ListPaymentLinksBillingAddress$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksBillingAddress$ {
  /** @deprecated use `ListPaymentLinksBillingAddress$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksBillingAddress$inboundSchema;
  /** @deprecated use `ListPaymentLinksBillingAddress$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksBillingAddress$outboundSchema;
  /** @deprecated use `ListPaymentLinksBillingAddress$Outbound` instead. */
  export type Outbound = ListPaymentLinksBillingAddress$Outbound;
}

export function listPaymentLinksBillingAddressToJSON(
  listPaymentLinksBillingAddress: ListPaymentLinksBillingAddress,
): string {
  return JSON.stringify(
    ListPaymentLinksBillingAddress$outboundSchema.parse(
      listPaymentLinksBillingAddress,
    ),
  );
}

export function listPaymentLinksBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksShippingAddress$inboundSchema: z.ZodType<
  ListPaymentLinksShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListPaymentLinksShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListPaymentLinksShippingAddress$outboundSchema: z.ZodType<
  ListPaymentLinksShippingAddress$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksShippingAddress$ {
  /** @deprecated use `ListPaymentLinksShippingAddress$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksShippingAddress$inboundSchema;
  /** @deprecated use `ListPaymentLinksShippingAddress$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksShippingAddress$outboundSchema;
  /** @deprecated use `ListPaymentLinksShippingAddress$Outbound` instead. */
  export type Outbound = ListPaymentLinksShippingAddress$Outbound;
}

export function listPaymentLinksShippingAddressToJSON(
  listPaymentLinksShippingAddress: ListPaymentLinksShippingAddress,
): string {
  return JSON.stringify(
    ListPaymentLinksShippingAddress$outboundSchema.parse(
      listPaymentLinksShippingAddress,
    ),
  );
}

export function listPaymentLinksShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksShippingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksShippingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksShippingAddress' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksApplicationFeeAmount$inboundSchema: z.ZodType<
  ListPaymentLinksApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListPaymentLinksApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListPaymentLinksApplicationFeeAmount$outboundSchema: z.ZodType<
  ListPaymentLinksApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksApplicationFeeAmount$ {
  /** @deprecated use `ListPaymentLinksApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListPaymentLinksApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListPaymentLinksApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListPaymentLinksApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListPaymentLinksApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListPaymentLinksApplicationFeeAmount$Outbound;
}

export function listPaymentLinksApplicationFeeAmountToJSON(
  listPaymentLinksApplicationFeeAmount: ListPaymentLinksApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListPaymentLinksApplicationFeeAmount$outboundSchema.parse(
      listPaymentLinksApplicationFeeAmount,
    ),
  );
}

export function listPaymentLinksApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPaymentLinksApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksApplicationFee$inboundSchema: z.ZodType<
  ListPaymentLinksApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListPaymentLinksApplicationFeeAmount$inboundSchema),
  description: z.string(),
});

/** @internal */
export type ListPaymentLinksApplicationFee$Outbound = {
  amount: ListPaymentLinksApplicationFeeAmount$Outbound;
  description: string;
};

/** @internal */
export const ListPaymentLinksApplicationFee$outboundSchema: z.ZodType<
  ListPaymentLinksApplicationFee$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksApplicationFee
> = z.object({
  amount: z.lazy(() => ListPaymentLinksApplicationFeeAmount$outboundSchema),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksApplicationFee$ {
  /** @deprecated use `ListPaymentLinksApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksApplicationFee$inboundSchema;
  /** @deprecated use `ListPaymentLinksApplicationFee$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksApplicationFee$outboundSchema;
  /** @deprecated use `ListPaymentLinksApplicationFee$Outbound` instead. */
  export type Outbound = ListPaymentLinksApplicationFee$Outbound;
}

export function listPaymentLinksApplicationFeeToJSON(
  listPaymentLinksApplicationFee: ListPaymentLinksApplicationFee,
): string {
  return JSON.stringify(
    ListPaymentLinksApplicationFee$outboundSchema.parse(
      listPaymentLinksApplicationFee,
    ),
  );
}

export function listPaymentLinksApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksSequenceType$inboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksSequenceType
> = z.nativeEnum(ListPaymentLinksSequenceType);

/** @internal */
export const ListPaymentLinksSequenceType$outboundSchema: z.ZodNativeEnum<
  typeof ListPaymentLinksSequenceType
> = ListPaymentLinksSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksSequenceType$ {
  /** @deprecated use `ListPaymentLinksSequenceType$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksSequenceType$inboundSchema;
  /** @deprecated use `ListPaymentLinksSequenceType$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksSequenceType$outboundSchema;
}

/** @internal */
export const PaymentLinkSelf$inboundSchema: z.ZodType<
  PaymentLinkSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type PaymentLinkSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const PaymentLinkSelf$outboundSchema: z.ZodType<
  PaymentLinkSelf$Outbound,
  z.ZodTypeDef,
  PaymentLinkSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentLinkSelf$ {
  /** @deprecated use `PaymentLinkSelf$inboundSchema` instead. */
  export const inboundSchema = PaymentLinkSelf$inboundSchema;
  /** @deprecated use `PaymentLinkSelf$outboundSchema` instead. */
  export const outboundSchema = PaymentLinkSelf$outboundSchema;
  /** @deprecated use `PaymentLinkSelf$Outbound` instead. */
  export type Outbound = PaymentLinkSelf$Outbound;
}

export function paymentLinkSelfToJSON(
  paymentLinkSelf: PaymentLinkSelf,
): string {
  return JSON.stringify(PaymentLinkSelf$outboundSchema.parse(paymentLinkSelf));
}

export function paymentLinkSelfFromJSON(
  jsonString: string,
): SafeParseResult<PaymentLinkSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentLinkSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentLinkSelf' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksLinksPaymentLink$inboundSchema: z.ZodType<
  ListPaymentLinksLinksPaymentLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListPaymentLinksLinksPaymentLink$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListPaymentLinksLinksPaymentLink$outboundSchema: z.ZodType<
  ListPaymentLinksLinksPaymentLink$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksLinksPaymentLink
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksLinksPaymentLink$ {
  /** @deprecated use `ListPaymentLinksLinksPaymentLink$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksLinksPaymentLink$inboundSchema;
  /** @deprecated use `ListPaymentLinksLinksPaymentLink$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksLinksPaymentLink$outboundSchema;
  /** @deprecated use `ListPaymentLinksLinksPaymentLink$Outbound` instead. */
  export type Outbound = ListPaymentLinksLinksPaymentLink$Outbound;
}

export function listPaymentLinksLinksPaymentLinkToJSON(
  listPaymentLinksLinksPaymentLink: ListPaymentLinksLinksPaymentLink,
): string {
  return JSON.stringify(
    ListPaymentLinksLinksPaymentLink$outboundSchema.parse(
      listPaymentLinksLinksPaymentLink,
    ),
  );
}

export function listPaymentLinksLinksPaymentLinkFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksLinksPaymentLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksLinksPaymentLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksLinksPaymentLink' from JSON`,
  );
}

/** @internal */
export const PaymentLinkLinks$inboundSchema: z.ZodType<
  PaymentLinkLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => PaymentLinkSelf$inboundSchema),
  paymentLink: z.lazy(() => ListPaymentLinksLinksPaymentLink$inboundSchema),
});

/** @internal */
export type PaymentLinkLinks$Outbound = {
  self: PaymentLinkSelf$Outbound;
  paymentLink: ListPaymentLinksLinksPaymentLink$Outbound;
};

/** @internal */
export const PaymentLinkLinks$outboundSchema: z.ZodType<
  PaymentLinkLinks$Outbound,
  z.ZodTypeDef,
  PaymentLinkLinks
> = z.object({
  self: z.lazy(() => PaymentLinkSelf$outboundSchema),
  paymentLink: z.lazy(() => ListPaymentLinksLinksPaymentLink$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentLinkLinks$ {
  /** @deprecated use `PaymentLinkLinks$inboundSchema` instead. */
  export const inboundSchema = PaymentLinkLinks$inboundSchema;
  /** @deprecated use `PaymentLinkLinks$outboundSchema` instead. */
  export const outboundSchema = PaymentLinkLinks$outboundSchema;
  /** @deprecated use `PaymentLinkLinks$Outbound` instead. */
  export type Outbound = PaymentLinkLinks$Outbound;
}

export function paymentLinkLinksToJSON(
  paymentLinkLinks: PaymentLinkLinks,
): string {
  return JSON.stringify(
    PaymentLinkLinks$outboundSchema.parse(paymentLinkLinks),
  );
}

export function paymentLinkLinksFromJSON(
  jsonString: string,
): SafeParseResult<PaymentLinkLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentLinkLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentLinkLinks' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksPaymentLink$inboundSchema: z.ZodType<
  ListPaymentLinksPaymentLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("payment-link"),
  id: z.string(),
  mode: ListPaymentLinksMode$inboundSchema,
  description: z.string(),
  amount: z.nullable(z.lazy(() => ListPaymentLinksAmount$inboundSchema)),
  minimumAmount: z.nullable(
    z.lazy(() => ListPaymentLinksMinimumAmount$inboundSchema),
  ).optional(),
  archived: z.boolean(),
  redirectUrl: z.nullable(z.string()),
  webhookUrl: z.nullable(z.string()),
  lines: z.nullable(z.array(z.lazy(() => ListPaymentLinksLine$inboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => ListPaymentLinksBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() => ListPaymentLinksShippingAddress$inboundSchema)
    .optional(),
  profileId: z.nullable(z.string()),
  reusable: z.nullable(z.boolean().default(false)),
  createdAt: z.string(),
  paidAt: z.nullable(z.string()),
  expiresAt: z.nullable(z.string()),
  allowedMethods: z.nullable(z.array(z.string())),
  applicationFee: z.lazy(() => ListPaymentLinksApplicationFee$inboundSchema)
    .optional(),
  sequenceType: z.nullable(ListPaymentLinksSequenceType$inboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
  _links: z.lazy(() => PaymentLinkLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListPaymentLinksPaymentLink$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: ListPaymentLinksAmount$Outbound | null;
  minimumAmount?: ListPaymentLinksMinimumAmount$Outbound | null | undefined;
  archived: boolean;
  redirectUrl: string | null;
  webhookUrl: string | null;
  lines?: Array<ListPaymentLinksLine$Outbound> | null | undefined;
  billingAddress?: ListPaymentLinksBillingAddress$Outbound | undefined;
  shippingAddress?: ListPaymentLinksShippingAddress$Outbound | undefined;
  profileId: string | null;
  reusable: boolean | null;
  createdAt: string;
  paidAt: string | null;
  expiresAt: string | null;
  allowedMethods: Array<string> | null;
  applicationFee?: ListPaymentLinksApplicationFee$Outbound | undefined;
  sequenceType?: string | null | undefined;
  customerId?: string | null | undefined;
  _links: PaymentLinkLinks$Outbound;
};

/** @internal */
export const ListPaymentLinksPaymentLink$outboundSchema: z.ZodType<
  ListPaymentLinksPaymentLink$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksPaymentLink
> = z.object({
  resource: z.string().default("payment-link"),
  id: z.string(),
  mode: ListPaymentLinksMode$outboundSchema,
  description: z.string(),
  amount: z.nullable(z.lazy(() => ListPaymentLinksAmount$outboundSchema)),
  minimumAmount: z.nullable(
    z.lazy(() => ListPaymentLinksMinimumAmount$outboundSchema),
  ).optional(),
  archived: z.boolean(),
  redirectUrl: z.nullable(z.string()),
  webhookUrl: z.nullable(z.string()),
  lines: z.nullable(z.array(z.lazy(() => ListPaymentLinksLine$outboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => ListPaymentLinksBillingAddress$outboundSchema)
    .optional(),
  shippingAddress: z.lazy(() => ListPaymentLinksShippingAddress$outboundSchema)
    .optional(),
  profileId: z.nullable(z.string()),
  reusable: z.nullable(z.boolean().default(false)),
  createdAt: z.string(),
  paidAt: z.nullable(z.string()),
  expiresAt: z.nullable(z.string()),
  allowedMethods: z.nullable(z.array(z.string())),
  applicationFee: z.lazy(() => ListPaymentLinksApplicationFee$outboundSchema)
    .optional(),
  sequenceType: z.nullable(ListPaymentLinksSequenceType$outboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
  links: z.lazy(() => PaymentLinkLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksPaymentLink$ {
  /** @deprecated use `ListPaymentLinksPaymentLink$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksPaymentLink$inboundSchema;
  /** @deprecated use `ListPaymentLinksPaymentLink$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksPaymentLink$outboundSchema;
  /** @deprecated use `ListPaymentLinksPaymentLink$Outbound` instead. */
  export type Outbound = ListPaymentLinksPaymentLink$Outbound;
}

export function listPaymentLinksPaymentLinkToJSON(
  listPaymentLinksPaymentLink: ListPaymentLinksPaymentLink,
): string {
  return JSON.stringify(
    ListPaymentLinksPaymentLink$outboundSchema.parse(
      listPaymentLinksPaymentLink,
    ),
  );
}

export function listPaymentLinksPaymentLinkFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksPaymentLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksPaymentLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksPaymentLink' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksEmbedded$inboundSchema: z.ZodType<
  ListPaymentLinksEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  payment_links: z.array(
    z.lazy(() => ListPaymentLinksPaymentLink$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "payment_links": "paymentLinks",
  });
});

/** @internal */
export type ListPaymentLinksEmbedded$Outbound = {
  payment_links?: Array<ListPaymentLinksPaymentLink$Outbound> | undefined;
};

/** @internal */
export const ListPaymentLinksEmbedded$outboundSchema: z.ZodType<
  ListPaymentLinksEmbedded$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksEmbedded
> = z.object({
  paymentLinks: z.array(
    z.lazy(() => ListPaymentLinksPaymentLink$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    paymentLinks: "payment_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksEmbedded$ {
  /** @deprecated use `ListPaymentLinksEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksEmbedded$inboundSchema;
  /** @deprecated use `ListPaymentLinksEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksEmbedded$outboundSchema;
  /** @deprecated use `ListPaymentLinksEmbedded$Outbound` instead. */
  export type Outbound = ListPaymentLinksEmbedded$Outbound;
}

export function listPaymentLinksEmbeddedToJSON(
  listPaymentLinksEmbedded: ListPaymentLinksEmbedded,
): string {
  return JSON.stringify(
    ListPaymentLinksEmbedded$outboundSchema.parse(listPaymentLinksEmbedded),
  );
}

export function listPaymentLinksEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksEmbedded' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksSelf$inboundSchema: z.ZodType<
  ListPaymentLinksSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListPaymentLinksSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListPaymentLinksSelf$outboundSchema: z.ZodType<
  ListPaymentLinksSelf$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksSelf$ {
  /** @deprecated use `ListPaymentLinksSelf$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksSelf$inboundSchema;
  /** @deprecated use `ListPaymentLinksSelf$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksSelf$outboundSchema;
  /** @deprecated use `ListPaymentLinksSelf$Outbound` instead. */
  export type Outbound = ListPaymentLinksSelf$Outbound;
}

export function listPaymentLinksSelfToJSON(
  listPaymentLinksSelf: ListPaymentLinksSelf,
): string {
  return JSON.stringify(
    ListPaymentLinksSelf$outboundSchema.parse(listPaymentLinksSelf),
  );
}

export function listPaymentLinksSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksSelf' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksPrevious$inboundSchema: z.ZodType<
  ListPaymentLinksPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListPaymentLinksPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListPaymentLinksPrevious$outboundSchema: z.ZodType<
  ListPaymentLinksPrevious$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksPrevious$ {
  /** @deprecated use `ListPaymentLinksPrevious$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksPrevious$inboundSchema;
  /** @deprecated use `ListPaymentLinksPrevious$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksPrevious$outboundSchema;
  /** @deprecated use `ListPaymentLinksPrevious$Outbound` instead. */
  export type Outbound = ListPaymentLinksPrevious$Outbound;
}

export function listPaymentLinksPreviousToJSON(
  listPaymentLinksPrevious: ListPaymentLinksPrevious,
): string {
  return JSON.stringify(
    ListPaymentLinksPrevious$outboundSchema.parse(listPaymentLinksPrevious),
  );
}

export function listPaymentLinksPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksPrevious' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksNext$inboundSchema: z.ZodType<
  ListPaymentLinksNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListPaymentLinksNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListPaymentLinksNext$outboundSchema: z.ZodType<
  ListPaymentLinksNext$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksNext$ {
  /** @deprecated use `ListPaymentLinksNext$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksNext$inboundSchema;
  /** @deprecated use `ListPaymentLinksNext$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksNext$outboundSchema;
  /** @deprecated use `ListPaymentLinksNext$Outbound` instead. */
  export type Outbound = ListPaymentLinksNext$Outbound;
}

export function listPaymentLinksNextToJSON(
  listPaymentLinksNext: ListPaymentLinksNext,
): string {
  return JSON.stringify(
    ListPaymentLinksNext$outboundSchema.parse(listPaymentLinksNext),
  );
}

export function listPaymentLinksNextFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksNext' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksDocumentation$inboundSchema: z.ZodType<
  ListPaymentLinksDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListPaymentLinksDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListPaymentLinksDocumentation$outboundSchema: z.ZodType<
  ListPaymentLinksDocumentation$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksDocumentation$ {
  /** @deprecated use `ListPaymentLinksDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksDocumentation$inboundSchema;
  /** @deprecated use `ListPaymentLinksDocumentation$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksDocumentation$outboundSchema;
  /** @deprecated use `ListPaymentLinksDocumentation$Outbound` instead. */
  export type Outbound = ListPaymentLinksDocumentation$Outbound;
}

export function listPaymentLinksDocumentationToJSON(
  listPaymentLinksDocumentation: ListPaymentLinksDocumentation,
): string {
  return JSON.stringify(
    ListPaymentLinksDocumentation$outboundSchema.parse(
      listPaymentLinksDocumentation,
    ),
  );
}

export function listPaymentLinksDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksDocumentation' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksLinks$inboundSchema: z.ZodType<
  ListPaymentLinksLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListPaymentLinksSelf$inboundSchema).optional(),
  previous: z.nullable(z.lazy(() => ListPaymentLinksPrevious$inboundSchema))
    .optional(),
  next: z.nullable(z.lazy(() => ListPaymentLinksNext$inboundSchema)).optional(),
  documentation: z.lazy(() => ListPaymentLinksDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type ListPaymentLinksLinks$Outbound = {
  self?: ListPaymentLinksSelf$Outbound | undefined;
  previous?: ListPaymentLinksPrevious$Outbound | null | undefined;
  next?: ListPaymentLinksNext$Outbound | null | undefined;
  documentation?: ListPaymentLinksDocumentation$Outbound | undefined;
};

/** @internal */
export const ListPaymentLinksLinks$outboundSchema: z.ZodType<
  ListPaymentLinksLinks$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksLinks
> = z.object({
  self: z.lazy(() => ListPaymentLinksSelf$outboundSchema).optional(),
  previous: z.nullable(z.lazy(() => ListPaymentLinksPrevious$outboundSchema))
    .optional(),
  next: z.nullable(z.lazy(() => ListPaymentLinksNext$outboundSchema))
    .optional(),
  documentation: z.lazy(() => ListPaymentLinksDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksLinks$ {
  /** @deprecated use `ListPaymentLinksLinks$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksLinks$inboundSchema;
  /** @deprecated use `ListPaymentLinksLinks$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksLinks$outboundSchema;
  /** @deprecated use `ListPaymentLinksLinks$Outbound` instead. */
  export type Outbound = ListPaymentLinksLinks$Outbound;
}

export function listPaymentLinksLinksToJSON(
  listPaymentLinksLinks: ListPaymentLinksLinks,
): string {
  return JSON.stringify(
    ListPaymentLinksLinks$outboundSchema.parse(listPaymentLinksLinks),
  );
}

export function listPaymentLinksLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksLinks' from JSON`,
  );
}

/** @internal */
export const ListPaymentLinksResponse$inboundSchema: z.ZodType<
  ListPaymentLinksResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListPaymentLinksEmbedded$inboundSchema).optional(),
  _links: z.lazy(() => ListPaymentLinksLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListPaymentLinksResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListPaymentLinksEmbedded$Outbound | undefined;
  _links?: ListPaymentLinksLinks$Outbound | undefined;
};

/** @internal */
export const ListPaymentLinksResponse$outboundSchema: z.ZodType<
  ListPaymentLinksResponse$Outbound,
  z.ZodTypeDef,
  ListPaymentLinksResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListPaymentLinksEmbedded$outboundSchema).optional(),
  links: z.lazy(() => ListPaymentLinksLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListPaymentLinksResponse$ {
  /** @deprecated use `ListPaymentLinksResponse$inboundSchema` instead. */
  export const inboundSchema = ListPaymentLinksResponse$inboundSchema;
  /** @deprecated use `ListPaymentLinksResponse$outboundSchema` instead. */
  export const outboundSchema = ListPaymentLinksResponse$outboundSchema;
  /** @deprecated use `ListPaymentLinksResponse$Outbound` instead. */
  export type Outbound = ListPaymentLinksResponse$Outbound;
}

export function listPaymentLinksResponseToJSON(
  listPaymentLinksResponse: ListPaymentLinksResponse,
): string {
  return JSON.stringify(
    ListPaymentLinksResponse$outboundSchema.parse(listPaymentLinksResponse),
  );
}

export function listPaymentLinksResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListPaymentLinksResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPaymentLinksResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPaymentLinksResponse' from JSON`,
  );
}
