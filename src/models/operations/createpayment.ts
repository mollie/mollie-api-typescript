/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export const CreatePaymentInclude = {
  DetailsQrCode: "details.qrCode",
} as const;
/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export type CreatePaymentInclude = ClosedEnum<typeof CreatePaymentInclude>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type CreatePaymentAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreatePaymentLineTypeRequest = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreatePaymentLineTypeRequest = ClosedEnum<
  typeof CreatePaymentLineTypeRequest
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreatePaymentUnitPriceRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreatePaymentDiscountAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreatePaymentTotalAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreatePaymentVatAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreatePaymentCategoryRequest = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreatePaymentCategoryRequest = ClosedEnum<
  typeof CreatePaymentCategoryRequest
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const CreatePaymentIntervalRequest = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type CreatePaymentIntervalRequest = ClosedEnum<
  typeof CreatePaymentIntervalRequest
>;

/**
 * Total amount and currency of the recurring item.
 */
export type CreatePaymentRecurringAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type CreatePaymentRecurringRequest = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: CreatePaymentIntervalRequest;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: CreatePaymentRecurringAmountRequest | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type CreatePaymentLineRequest = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreatePaymentLineTypeRequest | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreatePaymentUnitPriceRequest;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreatePaymentDiscountAmountRequest | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreatePaymentTotalAmountRequest;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreatePaymentVatAmountRequest | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreatePaymentCategoryRequest> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: CreatePaymentRecurringRequest | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreatePaymentBillingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreatePaymentShippingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const CreatePaymentLocaleRequest = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type CreatePaymentLocaleRequest = ClosedEnum<
  typeof CreatePaymentLocaleRequest
>;

/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export const CreatePaymentMethodRequest = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export type CreatePaymentMethodRequest = ClosedEnum<
  typeof CreatePaymentMethodRequest
>;

export type CreatePaymentMetadataRequest = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type CreatePaymentMetadataRequestUnion =
  | CreatePaymentMetadataRequest
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const CreatePaymentCaptureModeRequest = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type CreatePaymentCaptureModeRequest = ClosedEnum<
  typeof CreatePaymentCaptureModeRequest
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreatePaymentApplicationFeeAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type CreatePaymentApplicationFeeRequest = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: CreatePaymentApplicationFeeAmountRequest | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type CreatePaymentRoutingAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const CreatePaymentRoutingTypeRequest = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type CreatePaymentRoutingTypeRequest = ClosedEnum<
  typeof CreatePaymentRoutingTypeRequest
>;

/**
 * The destination of this portion of the payment.
 */
export type CreatePaymentDestinationRequest = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: CreatePaymentRoutingTypeRequest;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreatePaymentSelfRequest = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type CreatePaymentPaymentRequest = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreatePaymentLinksRequest = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreatePaymentSelfRequest;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: CreatePaymentPaymentRequest;
};

export type CreatePaymentRoutingRequest = {
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: CreatePaymentRoutingAmountRequest;
  /**
   * The destination of this portion of the payment.
   */
  destination: CreatePaymentDestinationRequest;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreatePaymentLinksRequest;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const CreatePaymentSequenceTypeRequest = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type CreatePaymentSequenceTypeRequest = ClosedEnum<
  typeof CreatePaymentSequenceTypeRequest
>;

export type CreatePaymentRequestBody = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: CreatePaymentAmountRequest;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl: string | null;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreatePaymentLineRequest> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreatePaymentBillingAddressRequest | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreatePaymentShippingAddressRequest | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: CreatePaymentLocaleRequest | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: CreatePaymentMethodRequest | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | CreatePaymentMetadataRequest
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CreatePaymentCaptureModeRequest | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: CreatePaymentApplicationFeeRequest | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<CreatePaymentRoutingRequest> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: CreatePaymentSequenceTypeRequest | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId?: string | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

export type CreatePaymentRequest = {
  /**
   * This endpoint allows you to include additional information via the `include` query string parameter.
   */
  include?: CreatePaymentInclude | null | undefined;
  requestBody?: CreatePaymentRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreatePaymentServiceUnavailableDocumentation = {
  href: string;
  type: string;
};

export type CreatePaymentServiceUnavailableLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreatePaymentServiceUnavailableDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreatePaymentUnprocessableEntityDocumentation = {
  href: string;
  type: string;
};

export type CreatePaymentUnprocessableEntityLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreatePaymentUnprocessableEntityDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreatePaymentMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreatePaymentMode = ClosedEnum<typeof CreatePaymentMode>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type CreatePaymentAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type CreatePaymentAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type CreatePaymentAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type CreatePaymentAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type CreatePaymentAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type CreatePaymentSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreatePaymentLineTypeResponse = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreatePaymentLineTypeResponse = ClosedEnum<
  typeof CreatePaymentLineTypeResponse
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreatePaymentUnitPriceResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreatePaymentDiscountAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreatePaymentTotalAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreatePaymentVatAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreatePaymentCategoryResponse = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreatePaymentCategoryResponse = ClosedEnum<
  typeof CreatePaymentCategoryResponse
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const CreatePaymentIntervalResponse = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type CreatePaymentIntervalResponse = ClosedEnum<
  typeof CreatePaymentIntervalResponse
>;

/**
 * Total amount and currency of the recurring item.
 */
export type CreatePaymentRecurringAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type CreatePaymentRecurringResponse = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: CreatePaymentIntervalResponse;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: CreatePaymentRecurringAmountResponse | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type CreatePaymentLineResponse = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreatePaymentLineTypeResponse | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreatePaymentUnitPriceResponse;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreatePaymentDiscountAmountResponse | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreatePaymentTotalAmountResponse;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreatePaymentVatAmountResponse | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreatePaymentCategoryResponse> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: CreatePaymentRecurringResponse | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreatePaymentBillingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreatePaymentShippingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const CreatePaymentLocaleResponse = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type CreatePaymentLocaleResponse = ClosedEnum<
  typeof CreatePaymentLocaleResponse
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const CreatePaymentMethodResponse = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type CreatePaymentMethodResponse = ClosedEnum<
  typeof CreatePaymentMethodResponse
>;

export type CreatePaymentMetadataResponse = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type CreatePaymentMetadataResponseUnion =
  | CreatePaymentMetadataResponse
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const CreatePaymentCaptureModeResponse = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type CreatePaymentCaptureModeResponse = ClosedEnum<
  typeof CreatePaymentCaptureModeResponse
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreatePaymentApplicationFeeAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type CreatePaymentApplicationFeeResponse = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: CreatePaymentApplicationFeeAmountResponse | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreatePaymentRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreatePaymentRoutingMode = ClosedEnum<
  typeof CreatePaymentRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type CreatePaymentRoutingAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const CreatePaymentRoutingTypeResponse = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type CreatePaymentRoutingTypeResponse = ClosedEnum<
  typeof CreatePaymentRoutingTypeResponse
>;

/**
 * The destination of this portion of the payment.
 */
export type CreatePaymentDestinationResponse = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: CreatePaymentRoutingTypeResponse;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreatePaymentRoutingSelfResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type CreatePaymentPaymentResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreatePaymentRoutingLinksResponse = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreatePaymentRoutingSelfResponse;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: CreatePaymentPaymentResponse;
};

export type CreatePaymentRoutingResponse = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CreatePaymentRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: CreatePaymentRoutingAmountResponse;
  /**
   * The destination of this portion of the payment.
   */
  destination: CreatePaymentDestinationResponse;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreatePaymentRoutingLinksResponse;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const CreatePaymentSequenceTypeResponse = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type CreatePaymentSequenceTypeResponse = ClosedEnum<
  typeof CreatePaymentSequenceTypeResponse
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const CreatePaymentStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type CreatePaymentStatus = ClosedEnum<typeof CreatePaymentStatus>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type CreatePaymentStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreatePaymentSelfResponse = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type CreatePaymentCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type CreatePaymentMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type CreatePaymentChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type CreatePaymentDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type CreatePaymentRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type CreatePaymentChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type CreatePaymentCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type CreatePaymentSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type CreatePaymentCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type CreatePaymentMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type CreatePaymentSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type CreatePaymentOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type CreatePaymentTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreatePaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreatePaymentLinksResponse = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreatePaymentSelfResponse;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: CreatePaymentCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: CreatePaymentMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: CreatePaymentChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: CreatePaymentDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: CreatePaymentRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: CreatePaymentChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: CreatePaymentCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: CreatePaymentSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: CreatePaymentCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: CreatePaymentMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: CreatePaymentSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: CreatePaymentOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: CreatePaymentTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: CreatePaymentDocumentation | undefined;
};

/**
 * The newly created payment object.
 */
export type CreatePaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CreatePaymentMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: CreatePaymentAmountResponse;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: CreatePaymentAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: CreatePaymentAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: CreatePaymentAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: CreatePaymentAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: CreatePaymentSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreatePaymentLineResponse> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreatePaymentBillingAddressResponse | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreatePaymentShippingAddressResponse | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: CreatePaymentLocaleResponse | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: CreatePaymentMethodResponse | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | CreatePaymentMetadataResponse
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: CreatePaymentCaptureModeResponse | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: CreatePaymentApplicationFeeResponse | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<CreatePaymentRoutingResponse> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: CreatePaymentSequenceTypeResponse | null | undefined;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: CreatePaymentStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: CreatePaymentStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreatePaymentLinksResponse;
};

/** @internal */
export const CreatePaymentInclude$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentInclude
> = z.nativeEnum(CreatePaymentInclude);

/** @internal */
export const CreatePaymentInclude$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentInclude
> = CreatePaymentInclude$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentInclude$ {
  /** @deprecated use `CreatePaymentInclude$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentInclude$inboundSchema;
  /** @deprecated use `CreatePaymentInclude$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentInclude$outboundSchema;
}

/** @internal */
export const CreatePaymentAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountRequest$ {
  /** @deprecated use `CreatePaymentAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentAmountRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentAmountRequest$Outbound;
}

export function createPaymentAmountRequestToJSON(
  createPaymentAmountRequest: CreatePaymentAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentAmountRequest$outboundSchema.parse(createPaymentAmountRequest),
  );
}

export function createPaymentAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLineTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLineTypeRequest
> = z.nativeEnum(CreatePaymentLineTypeRequest);

/** @internal */
export const CreatePaymentLineTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLineTypeRequest
> = CreatePaymentLineTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLineTypeRequest$ {
  /** @deprecated use `CreatePaymentLineTypeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLineTypeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLineTypeRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLineTypeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentUnitPriceRequest$inboundSchema: z.ZodType<
  CreatePaymentUnitPriceRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentUnitPriceRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentUnitPriceRequest$outboundSchema: z.ZodType<
  CreatePaymentUnitPriceRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentUnitPriceRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentUnitPriceRequest$ {
  /** @deprecated use `CreatePaymentUnitPriceRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentUnitPriceRequest$inboundSchema;
  /** @deprecated use `CreatePaymentUnitPriceRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentUnitPriceRequest$outboundSchema;
  /** @deprecated use `CreatePaymentUnitPriceRequest$Outbound` instead. */
  export type Outbound = CreatePaymentUnitPriceRequest$Outbound;
}

export function createPaymentUnitPriceRequestToJSON(
  createPaymentUnitPriceRequest: CreatePaymentUnitPriceRequest,
): string {
  return JSON.stringify(
    CreatePaymentUnitPriceRequest$outboundSchema.parse(
      createPaymentUnitPriceRequest,
    ),
  );
}

export function createPaymentUnitPriceRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentUnitPriceRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentUnitPriceRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentUnitPriceRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentDiscountAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentDiscountAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentDiscountAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentDiscountAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentDiscountAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentDiscountAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDiscountAmountRequest$ {
  /** @deprecated use `CreatePaymentDiscountAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentDiscountAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentDiscountAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentDiscountAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentDiscountAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentDiscountAmountRequest$Outbound;
}

export function createPaymentDiscountAmountRequestToJSON(
  createPaymentDiscountAmountRequest: CreatePaymentDiscountAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentDiscountAmountRequest$outboundSchema.parse(
      createPaymentDiscountAmountRequest,
    ),
  );
}

export function createPaymentDiscountAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDiscountAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentDiscountAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDiscountAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentTotalAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentTotalAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentTotalAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentTotalAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentTotalAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentTotalAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentTotalAmountRequest$ {
  /** @deprecated use `CreatePaymentTotalAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentTotalAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentTotalAmountRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentTotalAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentTotalAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentTotalAmountRequest$Outbound;
}

export function createPaymentTotalAmountRequestToJSON(
  createPaymentTotalAmountRequest: CreatePaymentTotalAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentTotalAmountRequest$outboundSchema.parse(
      createPaymentTotalAmountRequest,
    ),
  );
}

export function createPaymentTotalAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentTotalAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentTotalAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentTotalAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentVatAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentVatAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentVatAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentVatAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentVatAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentVatAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentVatAmountRequest$ {
  /** @deprecated use `CreatePaymentVatAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentVatAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentVatAmountRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentVatAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentVatAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentVatAmountRequest$Outbound;
}

export function createPaymentVatAmountRequestToJSON(
  createPaymentVatAmountRequest: CreatePaymentVatAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentVatAmountRequest$outboundSchema.parse(
      createPaymentVatAmountRequest,
    ),
  );
}

export function createPaymentVatAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentVatAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentVatAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentVatAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCategoryRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCategoryRequest
> = z.nativeEnum(CreatePaymentCategoryRequest);

/** @internal */
export const CreatePaymentCategoryRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCategoryRequest
> = CreatePaymentCategoryRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCategoryRequest$ {
  /** @deprecated use `CreatePaymentCategoryRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCategoryRequest$inboundSchema;
  /** @deprecated use `CreatePaymentCategoryRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCategoryRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentIntervalRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentIntervalRequest
> = z.nativeEnum(CreatePaymentIntervalRequest);

/** @internal */
export const CreatePaymentIntervalRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentIntervalRequest
> = CreatePaymentIntervalRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentIntervalRequest$ {
  /** @deprecated use `CreatePaymentIntervalRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentIntervalRequest$inboundSchema;
  /** @deprecated use `CreatePaymentIntervalRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentIntervalRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentRecurringAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentRecurringAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentRecurringAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentRecurringAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentRecurringAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRecurringAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRecurringAmountRequest$ {
  /** @deprecated use `CreatePaymentRecurringAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentRecurringAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRecurringAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentRecurringAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRecurringAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRecurringAmountRequest$Outbound;
}

export function createPaymentRecurringAmountRequestToJSON(
  createPaymentRecurringAmountRequest: CreatePaymentRecurringAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentRecurringAmountRequest$outboundSchema.parse(
      createPaymentRecurringAmountRequest,
    ),
  );
}

export function createPaymentRecurringAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRecurringAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentRecurringAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRecurringAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRecurringRequest$inboundSchema: z.ZodType<
  CreatePaymentRecurringRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: CreatePaymentIntervalRequest$inboundSchema,
  amount: z.lazy(() => CreatePaymentRecurringAmountRequest$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type CreatePaymentRecurringRequest$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: CreatePaymentRecurringAmountRequest$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const CreatePaymentRecurringRequest$outboundSchema: z.ZodType<
  CreatePaymentRecurringRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRecurringRequest
> = z.object({
  description: z.string().optional(),
  interval: CreatePaymentIntervalRequest$outboundSchema,
  amount: z.lazy(() => CreatePaymentRecurringAmountRequest$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRecurringRequest$ {
  /** @deprecated use `CreatePaymentRecurringRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRecurringRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRecurringRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRecurringRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRecurringRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRecurringRequest$Outbound;
}

export function createPaymentRecurringRequestToJSON(
  createPaymentRecurringRequest: CreatePaymentRecurringRequest,
): string {
  return JSON.stringify(
    CreatePaymentRecurringRequest$outboundSchema.parse(
      createPaymentRecurringRequest,
    ),
  );
}

export function createPaymentRecurringRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRecurringRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRecurringRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRecurringRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLineRequest$inboundSchema: z.ZodType<
  CreatePaymentLineRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentLineTypeRequest$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentUnitPriceRequest$inboundSchema),
  discountAmount: z.lazy(() => CreatePaymentDiscountAmountRequest$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => CreatePaymentTotalAmountRequest$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentVatAmountRequest$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentCategoryRequest$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreatePaymentRecurringRequest$inboundSchema)
    .optional(),
});

/** @internal */
export type CreatePaymentLineRequest$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreatePaymentUnitPriceRequest$Outbound;
  discountAmount?: CreatePaymentDiscountAmountRequest$Outbound | undefined;
  totalAmount: CreatePaymentTotalAmountRequest$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreatePaymentVatAmountRequest$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: CreatePaymentRecurringRequest$Outbound | undefined;
};

/** @internal */
export const CreatePaymentLineRequest$outboundSchema: z.ZodType<
  CreatePaymentLineRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLineRequest
> = z.object({
  type: CreatePaymentLineTypeRequest$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentUnitPriceRequest$outboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentDiscountAmountRequest$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentTotalAmountRequest$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentVatAmountRequest$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentCategoryRequest$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreatePaymentRecurringRequest$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLineRequest$ {
  /** @deprecated use `CreatePaymentLineRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLineRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLineRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLineRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLineRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLineRequest$Outbound;
}

export function createPaymentLineRequestToJSON(
  createPaymentLineRequest: CreatePaymentLineRequest,
): string {
  return JSON.stringify(
    CreatePaymentLineRequest$outboundSchema.parse(createPaymentLineRequest),
  );
}

export function createPaymentLineRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLineRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLineRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLineRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentBillingAddressRequest$inboundSchema: z.ZodType<
  CreatePaymentBillingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentBillingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentBillingAddressRequest$outboundSchema: z.ZodType<
  CreatePaymentBillingAddressRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentBillingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentBillingAddressRequest$ {
  /** @deprecated use `CreatePaymentBillingAddressRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentBillingAddressRequest$inboundSchema;
  /** @deprecated use `CreatePaymentBillingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentBillingAddressRequest$outboundSchema;
  /** @deprecated use `CreatePaymentBillingAddressRequest$Outbound` instead. */
  export type Outbound = CreatePaymentBillingAddressRequest$Outbound;
}

export function createPaymentBillingAddressRequestToJSON(
  createPaymentBillingAddressRequest: CreatePaymentBillingAddressRequest,
): string {
  return JSON.stringify(
    CreatePaymentBillingAddressRequest$outboundSchema.parse(
      createPaymentBillingAddressRequest,
    ),
  );
}

export function createPaymentBillingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentBillingAddressRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentBillingAddressRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentBillingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentShippingAddressRequest$inboundSchema: z.ZodType<
  CreatePaymentShippingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentShippingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentShippingAddressRequest$outboundSchema: z.ZodType<
  CreatePaymentShippingAddressRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentShippingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentShippingAddressRequest$ {
  /** @deprecated use `CreatePaymentShippingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentShippingAddressRequest$inboundSchema;
  /** @deprecated use `CreatePaymentShippingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentShippingAddressRequest$outboundSchema;
  /** @deprecated use `CreatePaymentShippingAddressRequest$Outbound` instead. */
  export type Outbound = CreatePaymentShippingAddressRequest$Outbound;
}

export function createPaymentShippingAddressRequestToJSON(
  createPaymentShippingAddressRequest: CreatePaymentShippingAddressRequest,
): string {
  return JSON.stringify(
    CreatePaymentShippingAddressRequest$outboundSchema.parse(
      createPaymentShippingAddressRequest,
    ),
  );
}

export function createPaymentShippingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentShippingAddressRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentShippingAddressRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentShippingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLocaleRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLocaleRequest
> = z.nativeEnum(CreatePaymentLocaleRequest);

/** @internal */
export const CreatePaymentLocaleRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLocaleRequest
> = CreatePaymentLocaleRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLocaleRequest$ {
  /** @deprecated use `CreatePaymentLocaleRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLocaleRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLocaleRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLocaleRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentMethodRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMethodRequest
> = z.nativeEnum(CreatePaymentMethodRequest);

/** @internal */
export const CreatePaymentMethodRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMethodRequest
> = CreatePaymentMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMethodRequest$ {
  /** @deprecated use `CreatePaymentMethodRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMethodRequest$inboundSchema;
  /** @deprecated use `CreatePaymentMethodRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMethodRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentMetadataRequest$inboundSchema: z.ZodType<
  CreatePaymentMetadataRequest,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreatePaymentMetadataRequest$Outbound = {};

/** @internal */
export const CreatePaymentMetadataRequest$outboundSchema: z.ZodType<
  CreatePaymentMetadataRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentMetadataRequest
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMetadataRequest$ {
  /** @deprecated use `CreatePaymentMetadataRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMetadataRequest$inboundSchema;
  /** @deprecated use `CreatePaymentMetadataRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMetadataRequest$outboundSchema;
  /** @deprecated use `CreatePaymentMetadataRequest$Outbound` instead. */
  export type Outbound = CreatePaymentMetadataRequest$Outbound;
}

export function createPaymentMetadataRequestToJSON(
  createPaymentMetadataRequest: CreatePaymentMetadataRequest,
): string {
  return JSON.stringify(
    CreatePaymentMetadataRequest$outboundSchema.parse(
      createPaymentMetadataRequest,
    ),
  );
}

export function createPaymentMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMetadataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentMetadataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMetadataRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentMetadataRequestUnion$inboundSchema: z.ZodType<
  CreatePaymentMetadataRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePaymentMetadataRequest$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CreatePaymentMetadataRequestUnion$Outbound =
  | CreatePaymentMetadataRequest$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreatePaymentMetadataRequestUnion$outboundSchema: z.ZodType<
  CreatePaymentMetadataRequestUnion$Outbound,
  z.ZodTypeDef,
  CreatePaymentMetadataRequestUnion
> = z.union([
  z.lazy(() => CreatePaymentMetadataRequest$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMetadataRequestUnion$ {
  /** @deprecated use `CreatePaymentMetadataRequestUnion$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMetadataRequestUnion$inboundSchema;
  /** @deprecated use `CreatePaymentMetadataRequestUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentMetadataRequestUnion$outboundSchema;
  /** @deprecated use `CreatePaymentMetadataRequestUnion$Outbound` instead. */
  export type Outbound = CreatePaymentMetadataRequestUnion$Outbound;
}

export function createPaymentMetadataRequestUnionToJSON(
  createPaymentMetadataRequestUnion: CreatePaymentMetadataRequestUnion,
): string {
  return JSON.stringify(
    CreatePaymentMetadataRequestUnion$outboundSchema.parse(
      createPaymentMetadataRequestUnion,
    ),
  );
}

export function createPaymentMetadataRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMetadataRequestUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentMetadataRequestUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMetadataRequestUnion' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCaptureModeRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCaptureModeRequest
> = z.nativeEnum(CreatePaymentCaptureModeRequest);

/** @internal */
export const CreatePaymentCaptureModeRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCaptureModeRequest
> = CreatePaymentCaptureModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCaptureModeRequest$ {
  /** @deprecated use `CreatePaymentCaptureModeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCaptureModeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentCaptureModeRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCaptureModeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentApplicationFeeAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentApplicationFeeAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentApplicationFeeAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentApplicationFeeAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentApplicationFeeAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentApplicationFeeAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentApplicationFeeAmountRequest$ {
  /** @deprecated use `CreatePaymentApplicationFeeAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentApplicationFeeAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentApplicationFeeAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentApplicationFeeAmountRequest$Outbound;
}

export function createPaymentApplicationFeeAmountRequestToJSON(
  createPaymentApplicationFeeAmountRequest:
    CreatePaymentApplicationFeeAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentApplicationFeeAmountRequest$outboundSchema.parse(
      createPaymentApplicationFeeAmountRequest,
    ),
  );
}

export function createPaymentApplicationFeeAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentApplicationFeeAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentApplicationFeeAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentApplicationFeeAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentApplicationFeeRequest$inboundSchema: z.ZodType<
  CreatePaymentApplicationFeeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreatePaymentApplicationFeeAmountRequest$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type CreatePaymentApplicationFeeRequest$Outbound = {
  amount?: CreatePaymentApplicationFeeAmountRequest$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreatePaymentApplicationFeeRequest$outboundSchema: z.ZodType<
  CreatePaymentApplicationFeeRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentApplicationFeeRequest
> = z.object({
  amount: z.lazy(() => CreatePaymentApplicationFeeAmountRequest$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentApplicationFeeRequest$ {
  /** @deprecated use `CreatePaymentApplicationFeeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentApplicationFeeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentApplicationFeeRequest$outboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeRequest$Outbound` instead. */
  export type Outbound = CreatePaymentApplicationFeeRequest$Outbound;
}

export function createPaymentApplicationFeeRequestToJSON(
  createPaymentApplicationFeeRequest: CreatePaymentApplicationFeeRequest,
): string {
  return JSON.stringify(
    CreatePaymentApplicationFeeRequest$outboundSchema.parse(
      createPaymentApplicationFeeRequest,
    ),
  );
}

export function createPaymentApplicationFeeRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentApplicationFeeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentApplicationFeeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentApplicationFeeRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentRoutingAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentRoutingAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentRoutingAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentRoutingAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingAmountRequest$ {
  /** @deprecated use `CreatePaymentRoutingAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentRoutingAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingAmountRequest$Outbound;
}

export function createPaymentRoutingAmountRequestToJSON(
  createPaymentRoutingAmountRequest: CreatePaymentRoutingAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentRoutingAmountRequest$outboundSchema.parse(
      createPaymentRoutingAmountRequest,
    ),
  );
}

export function createPaymentRoutingAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRoutingAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingTypeRequest
> = z.nativeEnum(CreatePaymentRoutingTypeRequest);

/** @internal */
export const CreatePaymentRoutingTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingTypeRequest
> = CreatePaymentRoutingTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingTypeRequest$ {
  /** @deprecated use `CreatePaymentRoutingTypeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingTypeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingTypeRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingTypeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentDestinationRequest$inboundSchema: z.ZodType<
  CreatePaymentDestinationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentRoutingTypeRequest$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type CreatePaymentDestinationRequest$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const CreatePaymentDestinationRequest$outboundSchema: z.ZodType<
  CreatePaymentDestinationRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentDestinationRequest
> = z.object({
  type: CreatePaymentRoutingTypeRequest$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDestinationRequest$ {
  /** @deprecated use `CreatePaymentDestinationRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentDestinationRequest$inboundSchema;
  /** @deprecated use `CreatePaymentDestinationRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentDestinationRequest$outboundSchema;
  /** @deprecated use `CreatePaymentDestinationRequest$Outbound` instead. */
  export type Outbound = CreatePaymentDestinationRequest$Outbound;
}

export function createPaymentDestinationRequestToJSON(
  createPaymentDestinationRequest: CreatePaymentDestinationRequest,
): string {
  return JSON.stringify(
    CreatePaymentDestinationRequest$outboundSchema.parse(
      createPaymentDestinationRequest,
    ),
  );
}

export function createPaymentDestinationRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDestinationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentDestinationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDestinationRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSelfRequest$inboundSchema: z.ZodType<
  CreatePaymentSelfRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentSelfRequest$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentSelfRequest$outboundSchema: z.ZodType<
  CreatePaymentSelfRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentSelfRequest
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSelfRequest$ {
  /** @deprecated use `CreatePaymentSelfRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSelfRequest$inboundSchema;
  /** @deprecated use `CreatePaymentSelfRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSelfRequest$outboundSchema;
  /** @deprecated use `CreatePaymentSelfRequest$Outbound` instead. */
  export type Outbound = CreatePaymentSelfRequest$Outbound;
}

export function createPaymentSelfRequestToJSON(
  createPaymentSelfRequest: CreatePaymentSelfRequest,
): string {
  return JSON.stringify(
    CreatePaymentSelfRequest$outboundSchema.parse(createPaymentSelfRequest),
  );
}

export function createPaymentSelfRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentSelfRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentSelfRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentSelfRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentPaymentRequest$inboundSchema: z.ZodType<
  CreatePaymentPaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentPaymentRequest$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentPaymentRequest$outboundSchema: z.ZodType<
  CreatePaymentPaymentRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentPaymentRequest
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentPaymentRequest$ {
  /** @deprecated use `CreatePaymentPaymentRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentPaymentRequest$inboundSchema;
  /** @deprecated use `CreatePaymentPaymentRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentPaymentRequest$outboundSchema;
  /** @deprecated use `CreatePaymentPaymentRequest$Outbound` instead. */
  export type Outbound = CreatePaymentPaymentRequest$Outbound;
}

export function createPaymentPaymentRequestToJSON(
  createPaymentPaymentRequest: CreatePaymentPaymentRequest,
): string {
  return JSON.stringify(
    CreatePaymentPaymentRequest$outboundSchema.parse(
      createPaymentPaymentRequest,
    ),
  );
}

export function createPaymentPaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentPaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentPaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentPaymentRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinksRequest$inboundSchema: z.ZodType<
  CreatePaymentLinksRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreatePaymentSelfRequest$inboundSchema),
  payment: z.lazy(() => CreatePaymentPaymentRequest$inboundSchema),
});

/** @internal */
export type CreatePaymentLinksRequest$Outbound = {
  self: CreatePaymentSelfRequest$Outbound;
  payment: CreatePaymentPaymentRequest$Outbound;
};

/** @internal */
export const CreatePaymentLinksRequest$outboundSchema: z.ZodType<
  CreatePaymentLinksRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinksRequest
> = z.object({
  self: z.lazy(() => CreatePaymentSelfRequest$outboundSchema),
  payment: z.lazy(() => CreatePaymentPaymentRequest$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinksRequest$ {
  /** @deprecated use `CreatePaymentLinksRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinksRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinksRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinksRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinksRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinksRequest$Outbound;
}

export function createPaymentLinksRequestToJSON(
  createPaymentLinksRequest: CreatePaymentLinksRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinksRequest$outboundSchema.parse(createPaymentLinksRequest),
  );
}

export function createPaymentLinksRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinksRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinksRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinksRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingRequest$inboundSchema: z.ZodType<
  CreatePaymentRoutingRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreatePaymentRoutingAmountRequest$inboundSchema),
  destination: z.lazy(() => CreatePaymentDestinationRequest$inboundSchema),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreatePaymentLinksRequest$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreatePaymentRoutingRequest$Outbound = {
  amount: CreatePaymentRoutingAmountRequest$Outbound;
  destination: CreatePaymentDestinationRequest$Outbound;
  releaseDate?: string | null | undefined;
  _links: CreatePaymentLinksRequest$Outbound;
};

/** @internal */
export const CreatePaymentRoutingRequest$outboundSchema: z.ZodType<
  CreatePaymentRoutingRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingRequest
> = z.object({
  amount: z.lazy(() => CreatePaymentRoutingAmountRequest$outboundSchema),
  destination: z.lazy(() => CreatePaymentDestinationRequest$outboundSchema),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreatePaymentLinksRequest$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingRequest$ {
  /** @deprecated use `CreatePaymentRoutingRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingRequest$Outbound;
}

export function createPaymentRoutingRequestToJSON(
  createPaymentRoutingRequest: CreatePaymentRoutingRequest,
): string {
  return JSON.stringify(
    CreatePaymentRoutingRequest$outboundSchema.parse(
      createPaymentRoutingRequest,
    ),
  );
}

export function createPaymentRoutingRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRoutingRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSequenceTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentSequenceTypeRequest
> = z.nativeEnum(CreatePaymentSequenceTypeRequest);

/** @internal */
export const CreatePaymentSequenceTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentSequenceTypeRequest
> = CreatePaymentSequenceTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSequenceTypeRequest$ {
  /** @deprecated use `CreatePaymentSequenceTypeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSequenceTypeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentSequenceTypeRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSequenceTypeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentRequestBody$inboundSchema: z.ZodType<
  CreatePaymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: z.lazy(() => CreatePaymentAmountRequest$inboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLineRequest$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() => CreatePaymentBillingAddressRequest$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentShippingAddressRequest$inboundSchema
  ).optional(),
  locale: z.nullable(CreatePaymentLocaleRequest$inboundSchema).optional(),
  method: z.nullable(CreatePaymentMethodRequest$inboundSchema).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreatePaymentMetadataRequest$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(CreatePaymentCaptureModeRequest$inboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreatePaymentApplicationFeeRequest$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreatePaymentRoutingRequest$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreatePaymentSequenceTypeRequest$inboundSchema.default("oneoff"),
  ),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CreatePaymentRequestBody$Outbound = {
  description: string;
  amount: CreatePaymentAmountRequest$Outbound;
  redirectUrl: string | null;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<CreatePaymentLineRequest$Outbound> | null | undefined;
  billingAddress?: CreatePaymentBillingAddressRequest$Outbound | undefined;
  shippingAddress?: CreatePaymentShippingAddressRequest$Outbound | undefined;
  locale?: string | null | undefined;
  method?: string | null | undefined;
  issuer?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | CreatePaymentMetadataRequest$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  applicationFee?:
    | CreatePaymentApplicationFeeRequest$Outbound
    | null
    | undefined;
  routing?: Array<CreatePaymentRoutingRequest$Outbound> | null | undefined;
  sequenceType: string | null;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId?: string | undefined;
  dueDate?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CreatePaymentRequestBody$outboundSchema: z.ZodType<
  CreatePaymentRequestBody$Outbound,
  z.ZodTypeDef,
  CreatePaymentRequestBody
> = z.object({
  description: z.string(),
  amount: z.lazy(() => CreatePaymentAmountRequest$outboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLineRequest$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentBillingAddressRequest$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentShippingAddressRequest$outboundSchema
  ).optional(),
  locale: z.nullable(CreatePaymentLocaleRequest$outboundSchema).optional(),
  method: z.nullable(CreatePaymentMethodRequest$outboundSchema).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreatePaymentMetadataRequest$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(CreatePaymentCaptureModeRequest$outboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreatePaymentApplicationFeeRequest$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreatePaymentRoutingRequest$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreatePaymentSequenceTypeRequest$outboundSchema.default("oneoff"),
  ),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  dueDate: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRequestBody$ {
  /** @deprecated use `CreatePaymentRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRequestBody$inboundSchema;
  /** @deprecated use `CreatePaymentRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRequestBody$outboundSchema;
  /** @deprecated use `CreatePaymentRequestBody$Outbound` instead. */
  export type Outbound = CreatePaymentRequestBody$Outbound;
}

export function createPaymentRequestBodyToJSON(
  createPaymentRequestBody: CreatePaymentRequestBody,
): string {
  return JSON.stringify(
    CreatePaymentRequestBody$outboundSchema.parse(createPaymentRequestBody),
  );
}

export function createPaymentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRequest$inboundSchema: z.ZodType<
  CreatePaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  include: z.nullable(CreatePaymentInclude$inboundSchema).optional(),
  RequestBody: z.lazy(() => CreatePaymentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreatePaymentRequest$Outbound = {
  include?: string | null | undefined;
  RequestBody?: CreatePaymentRequestBody$Outbound | undefined;
};

/** @internal */
export const CreatePaymentRequest$outboundSchema: z.ZodType<
  CreatePaymentRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRequest
> = z.object({
  include: z.nullable(CreatePaymentInclude$outboundSchema).optional(),
  requestBody: z.lazy(() => CreatePaymentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRequest$ {
  /** @deprecated use `CreatePaymentRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRequest$Outbound;
}

export function createPaymentRequestToJSON(
  createPaymentRequest: CreatePaymentRequest,
): string {
  return JSON.stringify(
    CreatePaymentRequest$outboundSchema.parse(createPaymentRequest),
  );
}

export function createPaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentServiceUnavailableDocumentation$inboundSchema:
  z.ZodType<
    CreatePaymentServiceUnavailableDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type CreatePaymentServiceUnavailableDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentServiceUnavailableDocumentation$outboundSchema:
  z.ZodType<
    CreatePaymentServiceUnavailableDocumentation$Outbound,
    z.ZodTypeDef,
    CreatePaymentServiceUnavailableDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentServiceUnavailableDocumentation$ {
  /** @deprecated use `CreatePaymentServiceUnavailableDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentServiceUnavailableDocumentation$inboundSchema;
  /** @deprecated use `CreatePaymentServiceUnavailableDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentServiceUnavailableDocumentation$outboundSchema;
  /** @deprecated use `CreatePaymentServiceUnavailableDocumentation$Outbound` instead. */
  export type Outbound = CreatePaymentServiceUnavailableDocumentation$Outbound;
}

export function createPaymentServiceUnavailableDocumentationToJSON(
  createPaymentServiceUnavailableDocumentation:
    CreatePaymentServiceUnavailableDocumentation,
): string {
  return JSON.stringify(
    CreatePaymentServiceUnavailableDocumentation$outboundSchema.parse(
      createPaymentServiceUnavailableDocumentation,
    ),
  );
}

export function createPaymentServiceUnavailableDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentServiceUnavailableDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentServiceUnavailableDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentServiceUnavailableDocumentation' from JSON`,
  );
}

/** @internal */
export const CreatePaymentServiceUnavailableLinks$inboundSchema: z.ZodType<
  CreatePaymentServiceUnavailableLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentServiceUnavailableDocumentation$inboundSchema
  ),
});

/** @internal */
export type CreatePaymentServiceUnavailableLinks$Outbound = {
  documentation: CreatePaymentServiceUnavailableDocumentation$Outbound;
};

/** @internal */
export const CreatePaymentServiceUnavailableLinks$outboundSchema: z.ZodType<
  CreatePaymentServiceUnavailableLinks$Outbound,
  z.ZodTypeDef,
  CreatePaymentServiceUnavailableLinks
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentServiceUnavailableDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentServiceUnavailableLinks$ {
  /** @deprecated use `CreatePaymentServiceUnavailableLinks$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentServiceUnavailableLinks$inboundSchema;
  /** @deprecated use `CreatePaymentServiceUnavailableLinks$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentServiceUnavailableLinks$outboundSchema;
  /** @deprecated use `CreatePaymentServiceUnavailableLinks$Outbound` instead. */
  export type Outbound = CreatePaymentServiceUnavailableLinks$Outbound;
}

export function createPaymentServiceUnavailableLinksToJSON(
  createPaymentServiceUnavailableLinks: CreatePaymentServiceUnavailableLinks,
): string {
  return JSON.stringify(
    CreatePaymentServiceUnavailableLinks$outboundSchema.parse(
      createPaymentServiceUnavailableLinks,
    ),
  );
}

export function createPaymentServiceUnavailableLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentServiceUnavailableLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentServiceUnavailableLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentServiceUnavailableLinks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentUnprocessableEntityDocumentation$inboundSchema:
  z.ZodType<
    CreatePaymentUnprocessableEntityDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type CreatePaymentUnprocessableEntityDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentUnprocessableEntityDocumentation$outboundSchema:
  z.ZodType<
    CreatePaymentUnprocessableEntityDocumentation$Outbound,
    z.ZodTypeDef,
    CreatePaymentUnprocessableEntityDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentUnprocessableEntityDocumentation$ {
  /** @deprecated use `CreatePaymentUnprocessableEntityDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentUnprocessableEntityDocumentation$inboundSchema;
  /** @deprecated use `CreatePaymentUnprocessableEntityDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentUnprocessableEntityDocumentation$outboundSchema;
  /** @deprecated use `CreatePaymentUnprocessableEntityDocumentation$Outbound` instead. */
  export type Outbound = CreatePaymentUnprocessableEntityDocumentation$Outbound;
}

export function createPaymentUnprocessableEntityDocumentationToJSON(
  createPaymentUnprocessableEntityDocumentation:
    CreatePaymentUnprocessableEntityDocumentation,
): string {
  return JSON.stringify(
    CreatePaymentUnprocessableEntityDocumentation$outboundSchema.parse(
      createPaymentUnprocessableEntityDocumentation,
    ),
  );
}

export function createPaymentUnprocessableEntityDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentUnprocessableEntityDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentUnprocessableEntityDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentUnprocessableEntityDocumentation' from JSON`,
  );
}

/** @internal */
export const CreatePaymentUnprocessableEntityLinks$inboundSchema: z.ZodType<
  CreatePaymentUnprocessableEntityLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentUnprocessableEntityDocumentation$inboundSchema
  ),
});

/** @internal */
export type CreatePaymentUnprocessableEntityLinks$Outbound = {
  documentation: CreatePaymentUnprocessableEntityDocumentation$Outbound;
};

/** @internal */
export const CreatePaymentUnprocessableEntityLinks$outboundSchema: z.ZodType<
  CreatePaymentUnprocessableEntityLinks$Outbound,
  z.ZodTypeDef,
  CreatePaymentUnprocessableEntityLinks
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentUnprocessableEntityDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentUnprocessableEntityLinks$ {
  /** @deprecated use `CreatePaymentUnprocessableEntityLinks$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentUnprocessableEntityLinks$inboundSchema;
  /** @deprecated use `CreatePaymentUnprocessableEntityLinks$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentUnprocessableEntityLinks$outboundSchema;
  /** @deprecated use `CreatePaymentUnprocessableEntityLinks$Outbound` instead. */
  export type Outbound = CreatePaymentUnprocessableEntityLinks$Outbound;
}

export function createPaymentUnprocessableEntityLinksToJSON(
  createPaymentUnprocessableEntityLinks: CreatePaymentUnprocessableEntityLinks,
): string {
  return JSON.stringify(
    CreatePaymentUnprocessableEntityLinks$outboundSchema.parse(
      createPaymentUnprocessableEntityLinks,
    ),
  );
}

export function createPaymentUnprocessableEntityLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentUnprocessableEntityLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentUnprocessableEntityLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentUnprocessableEntityLinks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentMode$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMode
> = z.nativeEnum(CreatePaymentMode);

/** @internal */
export const CreatePaymentMode$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMode
> = CreatePaymentMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMode$ {
  /** @deprecated use `CreatePaymentMode$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMode$inboundSchema;
  /** @deprecated use `CreatePaymentMode$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMode$outboundSchema;
}

/** @internal */
export const CreatePaymentAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountResponse$ {
  /** @deprecated use `CreatePaymentAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentAmountResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentAmountResponse$Outbound;
}

export function createPaymentAmountResponseToJSON(
  createPaymentAmountResponse: CreatePaymentAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentAmountResponse$outboundSchema.parse(
      createPaymentAmountResponse,
    ),
  );
}

export function createPaymentAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentAmountRefunded$inboundSchema: z.ZodType<
  CreatePaymentAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountRefunded$outboundSchema: z.ZodType<
  CreatePaymentAmountRefunded$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountRefunded$ {
  /** @deprecated use `CreatePaymentAmountRefunded$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountRefunded$inboundSchema;
  /** @deprecated use `CreatePaymentAmountRefunded$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountRefunded$outboundSchema;
  /** @deprecated use `CreatePaymentAmountRefunded$Outbound` instead. */
  export type Outbound = CreatePaymentAmountRefunded$Outbound;
}

export function createPaymentAmountRefundedToJSON(
  createPaymentAmountRefunded: CreatePaymentAmountRefunded,
): string {
  return JSON.stringify(
    CreatePaymentAmountRefunded$outboundSchema.parse(
      createPaymentAmountRefunded,
    ),
  );
}

export function createPaymentAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountRefunded' from JSON`,
  );
}

/** @internal */
export const CreatePaymentAmountRemaining$inboundSchema: z.ZodType<
  CreatePaymentAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountRemaining$outboundSchema: z.ZodType<
  CreatePaymentAmountRemaining$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountRemaining$ {
  /** @deprecated use `CreatePaymentAmountRemaining$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountRemaining$inboundSchema;
  /** @deprecated use `CreatePaymentAmountRemaining$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountRemaining$outboundSchema;
  /** @deprecated use `CreatePaymentAmountRemaining$Outbound` instead. */
  export type Outbound = CreatePaymentAmountRemaining$Outbound;
}

export function createPaymentAmountRemainingToJSON(
  createPaymentAmountRemaining: CreatePaymentAmountRemaining,
): string {
  return JSON.stringify(
    CreatePaymentAmountRemaining$outboundSchema.parse(
      createPaymentAmountRemaining,
    ),
  );
}

export function createPaymentAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountRemaining' from JSON`,
  );
}

/** @internal */
export const CreatePaymentAmountCaptured$inboundSchema: z.ZodType<
  CreatePaymentAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountCaptured$outboundSchema: z.ZodType<
  CreatePaymentAmountCaptured$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountCaptured$ {
  /** @deprecated use `CreatePaymentAmountCaptured$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountCaptured$inboundSchema;
  /** @deprecated use `CreatePaymentAmountCaptured$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountCaptured$outboundSchema;
  /** @deprecated use `CreatePaymentAmountCaptured$Outbound` instead. */
  export type Outbound = CreatePaymentAmountCaptured$Outbound;
}

export function createPaymentAmountCapturedToJSON(
  createPaymentAmountCaptured: CreatePaymentAmountCaptured,
): string {
  return JSON.stringify(
    CreatePaymentAmountCaptured$outboundSchema.parse(
      createPaymentAmountCaptured,
    ),
  );
}

export function createPaymentAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountCaptured' from JSON`,
  );
}

/** @internal */
export const CreatePaymentAmountChargedBack$inboundSchema: z.ZodType<
  CreatePaymentAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmountChargedBack$outboundSchema: z.ZodType<
  CreatePaymentAmountChargedBack$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmountChargedBack$ {
  /** @deprecated use `CreatePaymentAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmountChargedBack$inboundSchema;
  /** @deprecated use `CreatePaymentAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmountChargedBack$outboundSchema;
  /** @deprecated use `CreatePaymentAmountChargedBack$Outbound` instead. */
  export type Outbound = CreatePaymentAmountChargedBack$Outbound;
}

export function createPaymentAmountChargedBackToJSON(
  createPaymentAmountChargedBack: CreatePaymentAmountChargedBack,
): string {
  return JSON.stringify(
    CreatePaymentAmountChargedBack$outboundSchema.parse(
      createPaymentAmountChargedBack,
    ),
  );
}

export function createPaymentAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSettlementAmount$inboundSchema: z.ZodType<
  CreatePaymentSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentSettlementAmount$outboundSchema: z.ZodType<
  CreatePaymentSettlementAmount$Outbound,
  z.ZodTypeDef,
  CreatePaymentSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSettlementAmount$ {
  /** @deprecated use `CreatePaymentSettlementAmount$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSettlementAmount$inboundSchema;
  /** @deprecated use `CreatePaymentSettlementAmount$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSettlementAmount$outboundSchema;
  /** @deprecated use `CreatePaymentSettlementAmount$Outbound` instead. */
  export type Outbound = CreatePaymentSettlementAmount$Outbound;
}

export function createPaymentSettlementAmountToJSON(
  createPaymentSettlementAmount: CreatePaymentSettlementAmount,
): string {
  return JSON.stringify(
    CreatePaymentSettlementAmount$outboundSchema.parse(
      createPaymentSettlementAmount,
    ),
  );
}

export function createPaymentSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentSettlementAmount' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLineTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLineTypeResponse
> = z.nativeEnum(CreatePaymentLineTypeResponse);

/** @internal */
export const CreatePaymentLineTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLineTypeResponse
> = CreatePaymentLineTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLineTypeResponse$ {
  /** @deprecated use `CreatePaymentLineTypeResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLineTypeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLineTypeResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLineTypeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentUnitPriceResponse$inboundSchema: z.ZodType<
  CreatePaymentUnitPriceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentUnitPriceResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentUnitPriceResponse$outboundSchema: z.ZodType<
  CreatePaymentUnitPriceResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentUnitPriceResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentUnitPriceResponse$ {
  /** @deprecated use `CreatePaymentUnitPriceResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentUnitPriceResponse$inboundSchema;
  /** @deprecated use `CreatePaymentUnitPriceResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentUnitPriceResponse$outboundSchema;
  /** @deprecated use `CreatePaymentUnitPriceResponse$Outbound` instead. */
  export type Outbound = CreatePaymentUnitPriceResponse$Outbound;
}

export function createPaymentUnitPriceResponseToJSON(
  createPaymentUnitPriceResponse: CreatePaymentUnitPriceResponse,
): string {
  return JSON.stringify(
    CreatePaymentUnitPriceResponse$outboundSchema.parse(
      createPaymentUnitPriceResponse,
    ),
  );
}

export function createPaymentUnitPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentUnitPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentUnitPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentUnitPriceResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentDiscountAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentDiscountAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentDiscountAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentDiscountAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentDiscountAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentDiscountAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDiscountAmountResponse$ {
  /** @deprecated use `CreatePaymentDiscountAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentDiscountAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentDiscountAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentDiscountAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentDiscountAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentDiscountAmountResponse$Outbound;
}

export function createPaymentDiscountAmountResponseToJSON(
  createPaymentDiscountAmountResponse: CreatePaymentDiscountAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentDiscountAmountResponse$outboundSchema.parse(
      createPaymentDiscountAmountResponse,
    ),
  );
}

export function createPaymentDiscountAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDiscountAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentDiscountAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDiscountAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentTotalAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentTotalAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentTotalAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentTotalAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentTotalAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentTotalAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentTotalAmountResponse$ {
  /** @deprecated use `CreatePaymentTotalAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentTotalAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentTotalAmountResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentTotalAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentTotalAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentTotalAmountResponse$Outbound;
}

export function createPaymentTotalAmountResponseToJSON(
  createPaymentTotalAmountResponse: CreatePaymentTotalAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentTotalAmountResponse$outboundSchema.parse(
      createPaymentTotalAmountResponse,
    ),
  );
}

export function createPaymentTotalAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentTotalAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentTotalAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentTotalAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentVatAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentVatAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentVatAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentVatAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentVatAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentVatAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentVatAmountResponse$ {
  /** @deprecated use `CreatePaymentVatAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentVatAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentVatAmountResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentVatAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentVatAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentVatAmountResponse$Outbound;
}

export function createPaymentVatAmountResponseToJSON(
  createPaymentVatAmountResponse: CreatePaymentVatAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentVatAmountResponse$outboundSchema.parse(
      createPaymentVatAmountResponse,
    ),
  );
}

export function createPaymentVatAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentVatAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentVatAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentVatAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCategoryResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCategoryResponse
> = z.nativeEnum(CreatePaymentCategoryResponse);

/** @internal */
export const CreatePaymentCategoryResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCategoryResponse
> = CreatePaymentCategoryResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCategoryResponse$ {
  /** @deprecated use `CreatePaymentCategoryResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCategoryResponse$inboundSchema;
  /** @deprecated use `CreatePaymentCategoryResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCategoryResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentIntervalResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentIntervalResponse
> = z.nativeEnum(CreatePaymentIntervalResponse);

/** @internal */
export const CreatePaymentIntervalResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentIntervalResponse
> = CreatePaymentIntervalResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentIntervalResponse$ {
  /** @deprecated use `CreatePaymentIntervalResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentIntervalResponse$inboundSchema;
  /** @deprecated use `CreatePaymentIntervalResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentIntervalResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentRecurringAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentRecurringAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentRecurringAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentRecurringAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentRecurringAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRecurringAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRecurringAmountResponse$ {
  /** @deprecated use `CreatePaymentRecurringAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentRecurringAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRecurringAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentRecurringAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRecurringAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRecurringAmountResponse$Outbound;
}

export function createPaymentRecurringAmountResponseToJSON(
  createPaymentRecurringAmountResponse: CreatePaymentRecurringAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentRecurringAmountResponse$outboundSchema.parse(
      createPaymentRecurringAmountResponse,
    ),
  );
}

export function createPaymentRecurringAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRecurringAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentRecurringAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRecurringAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRecurringResponse$inboundSchema: z.ZodType<
  CreatePaymentRecurringResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: CreatePaymentIntervalResponse$inboundSchema,
  amount: z.lazy(() => CreatePaymentRecurringAmountResponse$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type CreatePaymentRecurringResponse$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: CreatePaymentRecurringAmountResponse$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const CreatePaymentRecurringResponse$outboundSchema: z.ZodType<
  CreatePaymentRecurringResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRecurringResponse
> = z.object({
  description: z.string().optional(),
  interval: CreatePaymentIntervalResponse$outboundSchema,
  amount: z.lazy(() => CreatePaymentRecurringAmountResponse$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRecurringResponse$ {
  /** @deprecated use `CreatePaymentRecurringResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRecurringResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRecurringResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRecurringResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRecurringResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRecurringResponse$Outbound;
}

export function createPaymentRecurringResponseToJSON(
  createPaymentRecurringResponse: CreatePaymentRecurringResponse,
): string {
  return JSON.stringify(
    CreatePaymentRecurringResponse$outboundSchema.parse(
      createPaymentRecurringResponse,
    ),
  );
}

export function createPaymentRecurringResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRecurringResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRecurringResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRecurringResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLineResponse$inboundSchema: z.ZodType<
  CreatePaymentLineResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentLineTypeResponse$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentUnitPriceResponse$inboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentDiscountAmountResponse$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentTotalAmountResponse$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentVatAmountResponse$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentCategoryResponse$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreatePaymentRecurringResponse$inboundSchema)
    .optional(),
});

/** @internal */
export type CreatePaymentLineResponse$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreatePaymentUnitPriceResponse$Outbound;
  discountAmount?: CreatePaymentDiscountAmountResponse$Outbound | undefined;
  totalAmount: CreatePaymentTotalAmountResponse$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreatePaymentVatAmountResponse$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: CreatePaymentRecurringResponse$Outbound | undefined;
};

/** @internal */
export const CreatePaymentLineResponse$outboundSchema: z.ZodType<
  CreatePaymentLineResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLineResponse
> = z.object({
  type: CreatePaymentLineTypeResponse$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentUnitPriceResponse$outboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentDiscountAmountResponse$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentTotalAmountResponse$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentVatAmountResponse$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentCategoryResponse$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => CreatePaymentRecurringResponse$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLineResponse$ {
  /** @deprecated use `CreatePaymentLineResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLineResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLineResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLineResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLineResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLineResponse$Outbound;
}

export function createPaymentLineResponseToJSON(
  createPaymentLineResponse: CreatePaymentLineResponse,
): string {
  return JSON.stringify(
    CreatePaymentLineResponse$outboundSchema.parse(createPaymentLineResponse),
  );
}

export function createPaymentLineResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLineResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLineResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLineResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentBillingAddressResponse$inboundSchema: z.ZodType<
  CreatePaymentBillingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentBillingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentBillingAddressResponse$outboundSchema: z.ZodType<
  CreatePaymentBillingAddressResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentBillingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentBillingAddressResponse$ {
  /** @deprecated use `CreatePaymentBillingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentBillingAddressResponse$inboundSchema;
  /** @deprecated use `CreatePaymentBillingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentBillingAddressResponse$outboundSchema;
  /** @deprecated use `CreatePaymentBillingAddressResponse$Outbound` instead. */
  export type Outbound = CreatePaymentBillingAddressResponse$Outbound;
}

export function createPaymentBillingAddressResponseToJSON(
  createPaymentBillingAddressResponse: CreatePaymentBillingAddressResponse,
): string {
  return JSON.stringify(
    CreatePaymentBillingAddressResponse$outboundSchema.parse(
      createPaymentBillingAddressResponse,
    ),
  );
}

export function createPaymentBillingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentBillingAddressResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentBillingAddressResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentBillingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentShippingAddressResponse$inboundSchema: z.ZodType<
  CreatePaymentShippingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentShippingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentShippingAddressResponse$outboundSchema: z.ZodType<
  CreatePaymentShippingAddressResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentShippingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentShippingAddressResponse$ {
  /** @deprecated use `CreatePaymentShippingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentShippingAddressResponse$inboundSchema;
  /** @deprecated use `CreatePaymentShippingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentShippingAddressResponse$outboundSchema;
  /** @deprecated use `CreatePaymentShippingAddressResponse$Outbound` instead. */
  export type Outbound = CreatePaymentShippingAddressResponse$Outbound;
}

export function createPaymentShippingAddressResponseToJSON(
  createPaymentShippingAddressResponse: CreatePaymentShippingAddressResponse,
): string {
  return JSON.stringify(
    CreatePaymentShippingAddressResponse$outboundSchema.parse(
      createPaymentShippingAddressResponse,
    ),
  );
}

export function createPaymentShippingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentShippingAddressResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentShippingAddressResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentShippingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLocaleResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLocaleResponse
> = z.nativeEnum(CreatePaymentLocaleResponse);

/** @internal */
export const CreatePaymentLocaleResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLocaleResponse
> = CreatePaymentLocaleResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLocaleResponse$ {
  /** @deprecated use `CreatePaymentLocaleResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLocaleResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLocaleResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLocaleResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentMethodResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMethodResponse
> = z.nativeEnum(CreatePaymentMethodResponse);

/** @internal */
export const CreatePaymentMethodResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentMethodResponse
> = CreatePaymentMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMethodResponse$ {
  /** @deprecated use `CreatePaymentMethodResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMethodResponse$inboundSchema;
  /** @deprecated use `CreatePaymentMethodResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMethodResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentMetadataResponse$inboundSchema: z.ZodType<
  CreatePaymentMetadataResponse,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreatePaymentMetadataResponse$Outbound = {};

/** @internal */
export const CreatePaymentMetadataResponse$outboundSchema: z.ZodType<
  CreatePaymentMetadataResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentMetadataResponse
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMetadataResponse$ {
  /** @deprecated use `CreatePaymentMetadataResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMetadataResponse$inboundSchema;
  /** @deprecated use `CreatePaymentMetadataResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMetadataResponse$outboundSchema;
  /** @deprecated use `CreatePaymentMetadataResponse$Outbound` instead. */
  export type Outbound = CreatePaymentMetadataResponse$Outbound;
}

export function createPaymentMetadataResponseToJSON(
  createPaymentMetadataResponse: CreatePaymentMetadataResponse,
): string {
  return JSON.stringify(
    CreatePaymentMetadataResponse$outboundSchema.parse(
      createPaymentMetadataResponse,
    ),
  );
}

export function createPaymentMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMetadataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentMetadataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMetadataResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentMetadataResponseUnion$inboundSchema: z.ZodType<
  CreatePaymentMetadataResponseUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePaymentMetadataResponse$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CreatePaymentMetadataResponseUnion$Outbound =
  | CreatePaymentMetadataResponse$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreatePaymentMetadataResponseUnion$outboundSchema: z.ZodType<
  CreatePaymentMetadataResponseUnion$Outbound,
  z.ZodTypeDef,
  CreatePaymentMetadataResponseUnion
> = z.union([
  z.lazy(() => CreatePaymentMetadataResponse$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMetadataResponseUnion$ {
  /** @deprecated use `CreatePaymentMetadataResponseUnion$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMetadataResponseUnion$inboundSchema;
  /** @deprecated use `CreatePaymentMetadataResponseUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentMetadataResponseUnion$outboundSchema;
  /** @deprecated use `CreatePaymentMetadataResponseUnion$Outbound` instead. */
  export type Outbound = CreatePaymentMetadataResponseUnion$Outbound;
}

export function createPaymentMetadataResponseUnionToJSON(
  createPaymentMetadataResponseUnion: CreatePaymentMetadataResponseUnion,
): string {
  return JSON.stringify(
    CreatePaymentMetadataResponseUnion$outboundSchema.parse(
      createPaymentMetadataResponseUnion,
    ),
  );
}

export function createPaymentMetadataResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMetadataResponseUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentMetadataResponseUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMetadataResponseUnion' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCaptureModeResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCaptureModeResponse
> = z.nativeEnum(CreatePaymentCaptureModeResponse);

/** @internal */
export const CreatePaymentCaptureModeResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentCaptureModeResponse
> = CreatePaymentCaptureModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCaptureModeResponse$ {
  /** @deprecated use `CreatePaymentCaptureModeResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCaptureModeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentCaptureModeResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCaptureModeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentApplicationFeeAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentApplicationFeeAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentApplicationFeeAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentApplicationFeeAmountResponse$outboundSchema:
  z.ZodType<
    CreatePaymentApplicationFeeAmountResponse$Outbound,
    z.ZodTypeDef,
    CreatePaymentApplicationFeeAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentApplicationFeeAmountResponse$ {
  /** @deprecated use `CreatePaymentApplicationFeeAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentApplicationFeeAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentApplicationFeeAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentApplicationFeeAmountResponse$Outbound;
}

export function createPaymentApplicationFeeAmountResponseToJSON(
  createPaymentApplicationFeeAmountResponse:
    CreatePaymentApplicationFeeAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentApplicationFeeAmountResponse$outboundSchema.parse(
      createPaymentApplicationFeeAmountResponse,
    ),
  );
}

export function createPaymentApplicationFeeAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentApplicationFeeAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentApplicationFeeAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentApplicationFeeAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentApplicationFeeResponse$inboundSchema: z.ZodType<
  CreatePaymentApplicationFeeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreatePaymentApplicationFeeAmountResponse$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type CreatePaymentApplicationFeeResponse$Outbound = {
  amount?: CreatePaymentApplicationFeeAmountResponse$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreatePaymentApplicationFeeResponse$outboundSchema: z.ZodType<
  CreatePaymentApplicationFeeResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentApplicationFeeResponse
> = z.object({
  amount: z.lazy(() => CreatePaymentApplicationFeeAmountResponse$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentApplicationFeeResponse$ {
  /** @deprecated use `CreatePaymentApplicationFeeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentApplicationFeeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentApplicationFeeResponse$outboundSchema;
  /** @deprecated use `CreatePaymentApplicationFeeResponse$Outbound` instead. */
  export type Outbound = CreatePaymentApplicationFeeResponse$Outbound;
}

export function createPaymentApplicationFeeResponseToJSON(
  createPaymentApplicationFeeResponse: CreatePaymentApplicationFeeResponse,
): string {
  return JSON.stringify(
    CreatePaymentApplicationFeeResponse$outboundSchema.parse(
      createPaymentApplicationFeeResponse,
    ),
  );
}

export function createPaymentApplicationFeeResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentApplicationFeeResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentApplicationFeeResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentApplicationFeeResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingMode
> = z.nativeEnum(CreatePaymentRoutingMode);

/** @internal */
export const CreatePaymentRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingMode
> = CreatePaymentRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingMode$ {
  /** @deprecated use `CreatePaymentRoutingMode$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingMode$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingMode$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingMode$outboundSchema;
}

/** @internal */
export const CreatePaymentRoutingAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentRoutingAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentRoutingAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentRoutingAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentRoutingAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingAmountResponse$ {
  /** @deprecated use `CreatePaymentRoutingAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentRoutingAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingAmountResponse$Outbound;
}

export function createPaymentRoutingAmountResponseToJSON(
  createPaymentRoutingAmountResponse: CreatePaymentRoutingAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentRoutingAmountResponse$outboundSchema.parse(
      createPaymentRoutingAmountResponse,
    ),
  );
}

export function createPaymentRoutingAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentRoutingAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingTypeResponse
> = z.nativeEnum(CreatePaymentRoutingTypeResponse);

/** @internal */
export const CreatePaymentRoutingTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentRoutingTypeResponse
> = CreatePaymentRoutingTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingTypeResponse$ {
  /** @deprecated use `CreatePaymentRoutingTypeResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingTypeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingTypeResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingTypeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentDestinationResponse$inboundSchema: z.ZodType<
  CreatePaymentDestinationResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentRoutingTypeResponse$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type CreatePaymentDestinationResponse$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const CreatePaymentDestinationResponse$outboundSchema: z.ZodType<
  CreatePaymentDestinationResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentDestinationResponse
> = z.object({
  type: CreatePaymentRoutingTypeResponse$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDestinationResponse$ {
  /** @deprecated use `CreatePaymentDestinationResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentDestinationResponse$inboundSchema;
  /** @deprecated use `CreatePaymentDestinationResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentDestinationResponse$outboundSchema;
  /** @deprecated use `CreatePaymentDestinationResponse$Outbound` instead. */
  export type Outbound = CreatePaymentDestinationResponse$Outbound;
}

export function createPaymentDestinationResponseToJSON(
  createPaymentDestinationResponse: CreatePaymentDestinationResponse,
): string {
  return JSON.stringify(
    CreatePaymentDestinationResponse$outboundSchema.parse(
      createPaymentDestinationResponse,
    ),
  );
}

export function createPaymentDestinationResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDestinationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentDestinationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDestinationResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingSelfResponse$inboundSchema: z.ZodType<
  CreatePaymentRoutingSelfResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentRoutingSelfResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentRoutingSelfResponse$outboundSchema: z.ZodType<
  CreatePaymentRoutingSelfResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingSelfResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingSelfResponse$ {
  /** @deprecated use `CreatePaymentRoutingSelfResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingSelfResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingSelfResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingSelfResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingSelfResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingSelfResponse$Outbound;
}

export function createPaymentRoutingSelfResponseToJSON(
  createPaymentRoutingSelfResponse: CreatePaymentRoutingSelfResponse,
): string {
  return JSON.stringify(
    CreatePaymentRoutingSelfResponse$outboundSchema.parse(
      createPaymentRoutingSelfResponse,
    ),
  );
}

export function createPaymentRoutingSelfResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingSelfResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRoutingSelfResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingSelfResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentPaymentResponse$inboundSchema: z.ZodType<
  CreatePaymentPaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentPaymentResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentPaymentResponse$outboundSchema: z.ZodType<
  CreatePaymentPaymentResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentPaymentResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentPaymentResponse$ {
  /** @deprecated use `CreatePaymentPaymentResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentPaymentResponse$inboundSchema;
  /** @deprecated use `CreatePaymentPaymentResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentPaymentResponse$outboundSchema;
  /** @deprecated use `CreatePaymentPaymentResponse$Outbound` instead. */
  export type Outbound = CreatePaymentPaymentResponse$Outbound;
}

export function createPaymentPaymentResponseToJSON(
  createPaymentPaymentResponse: CreatePaymentPaymentResponse,
): string {
  return JSON.stringify(
    CreatePaymentPaymentResponse$outboundSchema.parse(
      createPaymentPaymentResponse,
    ),
  );
}

export function createPaymentPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentPaymentResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingLinksResponse$inboundSchema: z.ZodType<
  CreatePaymentRoutingLinksResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreatePaymentRoutingSelfResponse$inboundSchema),
  payment: z.lazy(() => CreatePaymentPaymentResponse$inboundSchema),
});

/** @internal */
export type CreatePaymentRoutingLinksResponse$Outbound = {
  self: CreatePaymentRoutingSelfResponse$Outbound;
  payment: CreatePaymentPaymentResponse$Outbound;
};

/** @internal */
export const CreatePaymentRoutingLinksResponse$outboundSchema: z.ZodType<
  CreatePaymentRoutingLinksResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingLinksResponse
> = z.object({
  self: z.lazy(() => CreatePaymentRoutingSelfResponse$outboundSchema),
  payment: z.lazy(() => CreatePaymentPaymentResponse$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingLinksResponse$ {
  /** @deprecated use `CreatePaymentRoutingLinksResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingLinksResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingLinksResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentRoutingLinksResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingLinksResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingLinksResponse$Outbound;
}

export function createPaymentRoutingLinksResponseToJSON(
  createPaymentRoutingLinksResponse: CreatePaymentRoutingLinksResponse,
): string {
  return JSON.stringify(
    CreatePaymentRoutingLinksResponse$outboundSchema.parse(
      createPaymentRoutingLinksResponse,
    ),
  );
}

export function createPaymentRoutingLinksResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingLinksResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRoutingLinksResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingLinksResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRoutingResponse$inboundSchema: z.ZodType<
  CreatePaymentRoutingResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreatePaymentRoutingMode$inboundSchema,
  amount: z.lazy(() => CreatePaymentRoutingAmountResponse$inboundSchema),
  destination: z.lazy(() => CreatePaymentDestinationResponse$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreatePaymentRoutingLinksResponse$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreatePaymentRoutingResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: CreatePaymentRoutingAmountResponse$Outbound;
  destination: CreatePaymentDestinationResponse$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: CreatePaymentRoutingLinksResponse$Outbound;
};

/** @internal */
export const CreatePaymentRoutingResponse$outboundSchema: z.ZodType<
  CreatePaymentRoutingResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentRoutingResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreatePaymentRoutingMode$outboundSchema,
  amount: z.lazy(() => CreatePaymentRoutingAmountResponse$outboundSchema),
  destination: z.lazy(() => CreatePaymentDestinationResponse$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreatePaymentRoutingLinksResponse$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRoutingResponse$ {
  /** @deprecated use `CreatePaymentRoutingResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRoutingResponse$inboundSchema;
  /** @deprecated use `CreatePaymentRoutingResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRoutingResponse$outboundSchema;
  /** @deprecated use `CreatePaymentRoutingResponse$Outbound` instead. */
  export type Outbound = CreatePaymentRoutingResponse$Outbound;
}

export function createPaymentRoutingResponseToJSON(
  createPaymentRoutingResponse: CreatePaymentRoutingResponse,
): string {
  return JSON.stringify(
    CreatePaymentRoutingResponse$outboundSchema.parse(
      createPaymentRoutingResponse,
    ),
  );
}

export function createPaymentRoutingResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRoutingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRoutingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRoutingResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSequenceTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentSequenceTypeResponse
> = z.nativeEnum(CreatePaymentSequenceTypeResponse);

/** @internal */
export const CreatePaymentSequenceTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentSequenceTypeResponse
> = CreatePaymentSequenceTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSequenceTypeResponse$ {
  /** @deprecated use `CreatePaymentSequenceTypeResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSequenceTypeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentSequenceTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentSequenceTypeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentStatus
> = z.nativeEnum(CreatePaymentStatus);

/** @internal */
export const CreatePaymentStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentStatus
> = CreatePaymentStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentStatus$ {
  /** @deprecated use `CreatePaymentStatus$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentStatus$inboundSchema;
  /** @deprecated use `CreatePaymentStatus$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentStatus$outboundSchema;
}

/** @internal */
export const CreatePaymentStatusReason$inboundSchema: z.ZodType<
  CreatePaymentStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type CreatePaymentStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const CreatePaymentStatusReason$outboundSchema: z.ZodType<
  CreatePaymentStatusReason$Outbound,
  z.ZodTypeDef,
  CreatePaymentStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentStatusReason$ {
  /** @deprecated use `CreatePaymentStatusReason$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentStatusReason$inboundSchema;
  /** @deprecated use `CreatePaymentStatusReason$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentStatusReason$outboundSchema;
  /** @deprecated use `CreatePaymentStatusReason$Outbound` instead. */
  export type Outbound = CreatePaymentStatusReason$Outbound;
}

export function createPaymentStatusReasonToJSON(
  createPaymentStatusReason: CreatePaymentStatusReason,
): string {
  return JSON.stringify(
    CreatePaymentStatusReason$outboundSchema.parse(createPaymentStatusReason),
  );
}

export function createPaymentStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentStatusReason' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSelfResponse$inboundSchema: z.ZodType<
  CreatePaymentSelfResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentSelfResponse$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentSelfResponse$outboundSchema: z.ZodType<
  CreatePaymentSelfResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentSelfResponse
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSelfResponse$ {
  /** @deprecated use `CreatePaymentSelfResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSelfResponse$inboundSchema;
  /** @deprecated use `CreatePaymentSelfResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSelfResponse$outboundSchema;
  /** @deprecated use `CreatePaymentSelfResponse$Outbound` instead. */
  export type Outbound = CreatePaymentSelfResponse$Outbound;
}

export function createPaymentSelfResponseToJSON(
  createPaymentSelfResponse: CreatePaymentSelfResponse,
): string {
  return JSON.stringify(
    CreatePaymentSelfResponse$outboundSchema.parse(createPaymentSelfResponse),
  );
}

export function createPaymentSelfResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentSelfResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentSelfResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentSelfResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCheckout$inboundSchema: z.ZodType<
  CreatePaymentCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentCheckout$outboundSchema: z.ZodType<
  CreatePaymentCheckout$Outbound,
  z.ZodTypeDef,
  CreatePaymentCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCheckout$ {
  /** @deprecated use `CreatePaymentCheckout$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCheckout$inboundSchema;
  /** @deprecated use `CreatePaymentCheckout$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCheckout$outboundSchema;
  /** @deprecated use `CreatePaymentCheckout$Outbound` instead. */
  export type Outbound = CreatePaymentCheckout$Outbound;
}

export function createPaymentCheckoutToJSON(
  createPaymentCheckout: CreatePaymentCheckout,
): string {
  return JSON.stringify(
    CreatePaymentCheckout$outboundSchema.parse(createPaymentCheckout),
  );
}

export function createPaymentCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentCheckout' from JSON`,
  );
}

/** @internal */
export const CreatePaymentMobileAppCheckout$inboundSchema: z.ZodType<
  CreatePaymentMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentMobileAppCheckout$outboundSchema: z.ZodType<
  CreatePaymentMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  CreatePaymentMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMobileAppCheckout$ {
  /** @deprecated use `CreatePaymentMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMobileAppCheckout$inboundSchema;
  /** @deprecated use `CreatePaymentMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMobileAppCheckout$outboundSchema;
  /** @deprecated use `CreatePaymentMobileAppCheckout$Outbound` instead. */
  export type Outbound = CreatePaymentMobileAppCheckout$Outbound;
}

export function createPaymentMobileAppCheckoutToJSON(
  createPaymentMobileAppCheckout: CreatePaymentMobileAppCheckout,
): string {
  return JSON.stringify(
    CreatePaymentMobileAppCheckout$outboundSchema.parse(
      createPaymentMobileAppCheckout,
    ),
  );
}

export function createPaymentMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const CreatePaymentChangePaymentState$inboundSchema: z.ZodType<
  CreatePaymentChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentChangePaymentState$outboundSchema: z.ZodType<
  CreatePaymentChangePaymentState$Outbound,
  z.ZodTypeDef,
  CreatePaymentChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentChangePaymentState$ {
  /** @deprecated use `CreatePaymentChangePaymentState$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentChangePaymentState$inboundSchema;
  /** @deprecated use `CreatePaymentChangePaymentState$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentChangePaymentState$outboundSchema;
  /** @deprecated use `CreatePaymentChangePaymentState$Outbound` instead. */
  export type Outbound = CreatePaymentChangePaymentState$Outbound;
}

export function createPaymentChangePaymentStateToJSON(
  createPaymentChangePaymentState: CreatePaymentChangePaymentState,
): string {
  return JSON.stringify(
    CreatePaymentChangePaymentState$outboundSchema.parse(
      createPaymentChangePaymentState,
    ),
  );
}

export function createPaymentChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentChangePaymentState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentChangePaymentState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentChangePaymentState' from JSON`,
  );
}

/** @internal */
export const CreatePaymentDashboard$inboundSchema: z.ZodType<
  CreatePaymentDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentDashboard$outboundSchema: z.ZodType<
  CreatePaymentDashboard$Outbound,
  z.ZodTypeDef,
  CreatePaymentDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDashboard$ {
  /** @deprecated use `CreatePaymentDashboard$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentDashboard$inboundSchema;
  /** @deprecated use `CreatePaymentDashboard$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentDashboard$outboundSchema;
  /** @deprecated use `CreatePaymentDashboard$Outbound` instead. */
  export type Outbound = CreatePaymentDashboard$Outbound;
}

export function createPaymentDashboardToJSON(
  createPaymentDashboard: CreatePaymentDashboard,
): string {
  return JSON.stringify(
    CreatePaymentDashboard$outboundSchema.parse(createPaymentDashboard),
  );
}

export function createPaymentDashboardFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDashboard' from JSON`,
  );
}

/** @internal */
export const CreatePaymentRefunds$inboundSchema: z.ZodType<
  CreatePaymentRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentRefunds$outboundSchema: z.ZodType<
  CreatePaymentRefunds$Outbound,
  z.ZodTypeDef,
  CreatePaymentRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRefunds$ {
  /** @deprecated use `CreatePaymentRefunds$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRefunds$inboundSchema;
  /** @deprecated use `CreatePaymentRefunds$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRefunds$outboundSchema;
  /** @deprecated use `CreatePaymentRefunds$Outbound` instead. */
  export type Outbound = CreatePaymentRefunds$Outbound;
}

export function createPaymentRefundsToJSON(
  createPaymentRefunds: CreatePaymentRefunds,
): string {
  return JSON.stringify(
    CreatePaymentRefunds$outboundSchema.parse(createPaymentRefunds),
  );
}

export function createPaymentRefundsFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentRefunds' from JSON`,
  );
}

/** @internal */
export const CreatePaymentChargebacks$inboundSchema: z.ZodType<
  CreatePaymentChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentChargebacks$outboundSchema: z.ZodType<
  CreatePaymentChargebacks$Outbound,
  z.ZodTypeDef,
  CreatePaymentChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentChargebacks$ {
  /** @deprecated use `CreatePaymentChargebacks$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentChargebacks$inboundSchema;
  /** @deprecated use `CreatePaymentChargebacks$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentChargebacks$outboundSchema;
  /** @deprecated use `CreatePaymentChargebacks$Outbound` instead. */
  export type Outbound = CreatePaymentChargebacks$Outbound;
}

export function createPaymentChargebacksToJSON(
  createPaymentChargebacks: CreatePaymentChargebacks,
): string {
  return JSON.stringify(
    CreatePaymentChargebacks$outboundSchema.parse(createPaymentChargebacks),
  );
}

export function createPaymentChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentChargebacks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCaptures$inboundSchema: z.ZodType<
  CreatePaymentCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentCaptures$outboundSchema: z.ZodType<
  CreatePaymentCaptures$Outbound,
  z.ZodTypeDef,
  CreatePaymentCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCaptures$ {
  /** @deprecated use `CreatePaymentCaptures$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCaptures$inboundSchema;
  /** @deprecated use `CreatePaymentCaptures$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCaptures$outboundSchema;
  /** @deprecated use `CreatePaymentCaptures$Outbound` instead. */
  export type Outbound = CreatePaymentCaptures$Outbound;
}

export function createPaymentCapturesToJSON(
  createPaymentCaptures: CreatePaymentCaptures,
): string {
  return JSON.stringify(
    CreatePaymentCaptures$outboundSchema.parse(createPaymentCaptures),
  );
}

export function createPaymentCapturesFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentCaptures' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSettlement$inboundSchema: z.ZodType<
  CreatePaymentSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentSettlement$outboundSchema: z.ZodType<
  CreatePaymentSettlement$Outbound,
  z.ZodTypeDef,
  CreatePaymentSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSettlement$ {
  /** @deprecated use `CreatePaymentSettlement$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSettlement$inboundSchema;
  /** @deprecated use `CreatePaymentSettlement$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSettlement$outboundSchema;
  /** @deprecated use `CreatePaymentSettlement$Outbound` instead. */
  export type Outbound = CreatePaymentSettlement$Outbound;
}

export function createPaymentSettlementToJSON(
  createPaymentSettlement: CreatePaymentSettlement,
): string {
  return JSON.stringify(
    CreatePaymentSettlement$outboundSchema.parse(createPaymentSettlement),
  );
}

export function createPaymentSettlementFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentSettlement' from JSON`,
  );
}

/** @internal */
export const CreatePaymentCustomer$inboundSchema: z.ZodType<
  CreatePaymentCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentCustomer$outboundSchema: z.ZodType<
  CreatePaymentCustomer$Outbound,
  z.ZodTypeDef,
  CreatePaymentCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentCustomer$ {
  /** @deprecated use `CreatePaymentCustomer$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentCustomer$inboundSchema;
  /** @deprecated use `CreatePaymentCustomer$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentCustomer$outboundSchema;
  /** @deprecated use `CreatePaymentCustomer$Outbound` instead. */
  export type Outbound = CreatePaymentCustomer$Outbound;
}

export function createPaymentCustomerToJSON(
  createPaymentCustomer: CreatePaymentCustomer,
): string {
  return JSON.stringify(
    CreatePaymentCustomer$outboundSchema.parse(createPaymentCustomer),
  );
}

export function createPaymentCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentCustomer' from JSON`,
  );
}

/** @internal */
export const CreatePaymentMandate$inboundSchema: z.ZodType<
  CreatePaymentMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentMandate$outboundSchema: z.ZodType<
  CreatePaymentMandate$Outbound,
  z.ZodTypeDef,
  CreatePaymentMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentMandate$ {
  /** @deprecated use `CreatePaymentMandate$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentMandate$inboundSchema;
  /** @deprecated use `CreatePaymentMandate$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentMandate$outboundSchema;
  /** @deprecated use `CreatePaymentMandate$Outbound` instead. */
  export type Outbound = CreatePaymentMandate$Outbound;
}

export function createPaymentMandateToJSON(
  createPaymentMandate: CreatePaymentMandate,
): string {
  return JSON.stringify(
    CreatePaymentMandate$outboundSchema.parse(createPaymentMandate),
  );
}

export function createPaymentMandateFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentMandate' from JSON`,
  );
}

/** @internal */
export const CreatePaymentSubscription$inboundSchema: z.ZodType<
  CreatePaymentSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentSubscription$outboundSchema: z.ZodType<
  CreatePaymentSubscription$Outbound,
  z.ZodTypeDef,
  CreatePaymentSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentSubscription$ {
  /** @deprecated use `CreatePaymentSubscription$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentSubscription$inboundSchema;
  /** @deprecated use `CreatePaymentSubscription$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentSubscription$outboundSchema;
  /** @deprecated use `CreatePaymentSubscription$Outbound` instead. */
  export type Outbound = CreatePaymentSubscription$Outbound;
}

export function createPaymentSubscriptionToJSON(
  createPaymentSubscription: CreatePaymentSubscription,
): string {
  return JSON.stringify(
    CreatePaymentSubscription$outboundSchema.parse(createPaymentSubscription),
  );
}

export function createPaymentSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentSubscription' from JSON`,
  );
}

/** @internal */
export const CreatePaymentOrder$inboundSchema: z.ZodType<
  CreatePaymentOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentOrder$outboundSchema: z.ZodType<
  CreatePaymentOrder$Outbound,
  z.ZodTypeDef,
  CreatePaymentOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentOrder$ {
  /** @deprecated use `CreatePaymentOrder$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentOrder$inboundSchema;
  /** @deprecated use `CreatePaymentOrder$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentOrder$outboundSchema;
  /** @deprecated use `CreatePaymentOrder$Outbound` instead. */
  export type Outbound = CreatePaymentOrder$Outbound;
}

export function createPaymentOrderToJSON(
  createPaymentOrder: CreatePaymentOrder,
): string {
  return JSON.stringify(
    CreatePaymentOrder$outboundSchema.parse(createPaymentOrder),
  );
}

export function createPaymentOrderFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentOrder' from JSON`,
  );
}

/** @internal */
export const CreatePaymentTerminal$inboundSchema: z.ZodType<
  CreatePaymentTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentTerminal$outboundSchema: z.ZodType<
  CreatePaymentTerminal$Outbound,
  z.ZodTypeDef,
  CreatePaymentTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentTerminal$ {
  /** @deprecated use `CreatePaymentTerminal$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentTerminal$inboundSchema;
  /** @deprecated use `CreatePaymentTerminal$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentTerminal$outboundSchema;
  /** @deprecated use `CreatePaymentTerminal$Outbound` instead. */
  export type Outbound = CreatePaymentTerminal$Outbound;
}

export function createPaymentTerminalToJSON(
  createPaymentTerminal: CreatePaymentTerminal,
): string {
  return JSON.stringify(
    CreatePaymentTerminal$outboundSchema.parse(createPaymentTerminal),
  );
}

export function createPaymentTerminalFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentTerminal' from JSON`,
  );
}

/** @internal */
export const CreatePaymentDocumentation$inboundSchema: z.ZodType<
  CreatePaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentDocumentation$outboundSchema: z.ZodType<
  CreatePaymentDocumentation$Outbound,
  z.ZodTypeDef,
  CreatePaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentDocumentation$ {
  /** @deprecated use `CreatePaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentDocumentation$inboundSchema;
  /** @deprecated use `CreatePaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentDocumentation$outboundSchema;
  /** @deprecated use `CreatePaymentDocumentation$Outbound` instead. */
  export type Outbound = CreatePaymentDocumentation$Outbound;
}

export function createPaymentDocumentationToJSON(
  createPaymentDocumentation: CreatePaymentDocumentation,
): string {
  return JSON.stringify(
    CreatePaymentDocumentation$outboundSchema.parse(createPaymentDocumentation),
  );
}

export function createPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinksResponse$inboundSchema: z.ZodType<
  CreatePaymentLinksResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreatePaymentSelfResponse$inboundSchema),
  checkout: z.lazy(() => CreatePaymentCheckout$inboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => CreatePaymentMobileAppCheckout$inboundSchema)
    .optional(),
  changePaymentState: z.lazy(() =>
    CreatePaymentChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => CreatePaymentDashboard$inboundSchema),
  refunds: z.lazy(() => CreatePaymentRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => CreatePaymentChargebacks$inboundSchema).optional(),
  captures: z.lazy(() => CreatePaymentCaptures$inboundSchema).optional(),
  settlement: z.lazy(() => CreatePaymentSettlement$inboundSchema).optional(),
  customer: z.lazy(() => CreatePaymentCustomer$inboundSchema).optional(),
  mandate: z.lazy(() => CreatePaymentMandate$inboundSchema).optional(),
  subscription: z.lazy(() => CreatePaymentSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => CreatePaymentOrder$inboundSchema).optional(),
  terminal: z.lazy(() => CreatePaymentTerminal$inboundSchema).optional(),
  documentation: z.lazy(() => CreatePaymentDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type CreatePaymentLinksResponse$Outbound = {
  self: CreatePaymentSelfResponse$Outbound;
  checkout?: CreatePaymentCheckout$Outbound | undefined;
  mobileAppCheckout?: CreatePaymentMobileAppCheckout$Outbound | undefined;
  changePaymentState?: CreatePaymentChangePaymentState$Outbound | undefined;
  dashboard: CreatePaymentDashboard$Outbound;
  refunds?: CreatePaymentRefunds$Outbound | undefined;
  chargebacks?: CreatePaymentChargebacks$Outbound | undefined;
  captures?: CreatePaymentCaptures$Outbound | undefined;
  settlement?: CreatePaymentSettlement$Outbound | undefined;
  customer?: CreatePaymentCustomer$Outbound | undefined;
  mandate?: CreatePaymentMandate$Outbound | undefined;
  subscription?: CreatePaymentSubscription$Outbound | undefined;
  order?: CreatePaymentOrder$Outbound | undefined;
  terminal?: CreatePaymentTerminal$Outbound | undefined;
  documentation?: CreatePaymentDocumentation$Outbound | undefined;
};

/** @internal */
export const CreatePaymentLinksResponse$outboundSchema: z.ZodType<
  CreatePaymentLinksResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinksResponse
> = z.object({
  self: z.lazy(() => CreatePaymentSelfResponse$outboundSchema),
  checkout: z.lazy(() => CreatePaymentCheckout$outboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => CreatePaymentMobileAppCheckout$outboundSchema)
    .optional(),
  changePaymentState: z.lazy(() =>
    CreatePaymentChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => CreatePaymentDashboard$outboundSchema),
  refunds: z.lazy(() => CreatePaymentRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => CreatePaymentChargebacks$outboundSchema).optional(),
  captures: z.lazy(() => CreatePaymentCaptures$outboundSchema).optional(),
  settlement: z.lazy(() => CreatePaymentSettlement$outboundSchema).optional(),
  customer: z.lazy(() => CreatePaymentCustomer$outboundSchema).optional(),
  mandate: z.lazy(() => CreatePaymentMandate$outboundSchema).optional(),
  subscription: z.lazy(() => CreatePaymentSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => CreatePaymentOrder$outboundSchema).optional(),
  terminal: z.lazy(() => CreatePaymentTerminal$outboundSchema).optional(),
  documentation: z.lazy(() => CreatePaymentDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinksResponse$ {
  /** @deprecated use `CreatePaymentLinksResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinksResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinksResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinksResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinksResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinksResponse$Outbound;
}

export function createPaymentLinksResponseToJSON(
  createPaymentLinksResponse: CreatePaymentLinksResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinksResponse$outboundSchema.parse(createPaymentLinksResponse),
  );
}

export function createPaymentLinksResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinksResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinksResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinksResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentResponse$inboundSchema: z.ZodType<
  CreatePaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreatePaymentMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => CreatePaymentAmountResponse$inboundSchema),
  amountRefunded: z.lazy(() => CreatePaymentAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => CreatePaymentAmountRemaining$inboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => CreatePaymentAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => CreatePaymentAmountChargedBack$inboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => CreatePaymentSettlementAmount$inboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLineResponse$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentBillingAddressResponse$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentShippingAddressResponse$inboundSchema
  ).optional(),
  locale: z.nullable(CreatePaymentLocaleResponse$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(CreatePaymentMethodResponse$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreatePaymentMetadataResponse$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(CreatePaymentCaptureModeResponse$inboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreatePaymentApplicationFeeResponse$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreatePaymentRoutingResponse$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreatePaymentSequenceTypeResponse$inboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: CreatePaymentStatus$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => CreatePaymentStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreatePaymentLinksResponse$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreatePaymentResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: CreatePaymentAmountResponse$Outbound;
  amountRefunded?: CreatePaymentAmountRefunded$Outbound | undefined;
  amountRemaining?: CreatePaymentAmountRemaining$Outbound | undefined;
  amountCaptured?: CreatePaymentAmountCaptured$Outbound | undefined;
  amountChargedBack?: CreatePaymentAmountChargedBack$Outbound | undefined;
  settlementAmount?: CreatePaymentSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<CreatePaymentLineResponse$Outbound> | null | undefined;
  billingAddress?: CreatePaymentBillingAddressResponse$Outbound | undefined;
  shippingAddress?: CreatePaymentShippingAddressResponse$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | CreatePaymentMetadataResponse$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | CreatePaymentApplicationFeeResponse$Outbound
    | null
    | undefined;
  routing?: Array<CreatePaymentRoutingResponse$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: CreatePaymentStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: CreatePaymentLinksResponse$Outbound;
};

/** @internal */
export const CreatePaymentResponse$outboundSchema: z.ZodType<
  CreatePaymentResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CreatePaymentMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => CreatePaymentAmountResponse$outboundSchema),
  amountRefunded: z.lazy(() => CreatePaymentAmountRefunded$outboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => CreatePaymentAmountRemaining$outboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => CreatePaymentAmountCaptured$outboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => CreatePaymentAmountChargedBack$outboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => CreatePaymentSettlementAmount$outboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLineResponse$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentBillingAddressResponse$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentShippingAddressResponse$outboundSchema
  ).optional(),
  locale: z.nullable(CreatePaymentLocaleResponse$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(CreatePaymentMethodResponse$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreatePaymentMetadataResponse$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(CreatePaymentCaptureModeResponse$outboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => CreatePaymentApplicationFeeResponse$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => CreatePaymentRoutingResponse$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    CreatePaymentSequenceTypeResponse$outboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: CreatePaymentStatus$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => CreatePaymentStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreatePaymentLinksResponse$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentResponse$ {
  /** @deprecated use `CreatePaymentResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentResponse$inboundSchema;
  /** @deprecated use `CreatePaymentResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentResponse$outboundSchema;
  /** @deprecated use `CreatePaymentResponse$Outbound` instead. */
  export type Outbound = CreatePaymentResponse$Outbound;
}

export function createPaymentResponseToJSON(
  createPaymentResponse: CreatePaymentResponse,
): string {
  return JSON.stringify(
    CreatePaymentResponse$outboundSchema.parse(createPaymentResponse),
  );
}

export function createPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentResponse' from JSON`,
  );
}
