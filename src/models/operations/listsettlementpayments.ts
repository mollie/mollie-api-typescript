/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export const ListSettlementPaymentsSort = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export type ListSettlementPaymentsSort = ClosedEnum<
  typeof ListSettlementPaymentsSort
>;

export type ListSettlementPaymentsRequest = {
  /**
   * Provide the ID of the related settlement.
   */
  settlementId: string;
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate
   *
   * @remarks
   * the result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
   *
   * @remarks
   * newest to oldest.
   */
  sort?: ListSettlementPaymentsSort | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to
   *
   * @remarks
   * retrieve the resources for.
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For
   * organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListSettlementPaymentsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListSettlementPaymentsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListSettlementPaymentsBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListSettlementPaymentsMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListSettlementPaymentsMode = ClosedEnum<
  typeof ListSettlementPaymentsMode
>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type ListSettlementPaymentsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type ListSettlementPaymentsAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type ListSettlementPaymentsAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type ListSettlementPaymentsAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type ListSettlementPaymentsAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type ListSettlementPaymentsSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const ListSettlementPaymentsLineType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type ListSettlementPaymentsLineType = ClosedEnum<
  typeof ListSettlementPaymentsLineType
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type ListSettlementPaymentsUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type ListSettlementPaymentsDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type ListSettlementPaymentsTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type ListSettlementPaymentsVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const ListSettlementPaymentsCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type ListSettlementPaymentsCategory = ClosedEnum<
  typeof ListSettlementPaymentsCategory
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const ListSettlementPaymentsInterval = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type ListSettlementPaymentsInterval = ClosedEnum<
  typeof ListSettlementPaymentsInterval
>;

/**
 * Total amount and currency of the recurring item.
 */
export type ListSettlementPaymentsRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type ListSettlementPaymentsRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: ListSettlementPaymentsInterval;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: ListSettlementPaymentsRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type ListSettlementPaymentsLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: ListSettlementPaymentsLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: ListSettlementPaymentsUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: ListSettlementPaymentsDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: ListSettlementPaymentsTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: ListSettlementPaymentsVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<ListSettlementPaymentsCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: ListSettlementPaymentsRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListSettlementPaymentsBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type ListSettlementPaymentsShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const ListSettlementPaymentsLocale = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type ListSettlementPaymentsLocale = ClosedEnum<
  typeof ListSettlementPaymentsLocale
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const ListSettlementPaymentsMethod = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Klarnapaylater: "klarnapaylater",
  Klarnapaynow: "klarnapaynow",
  Klarnasliceit: "klarnasliceit",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type ListSettlementPaymentsMethod = ClosedEnum<
  typeof ListSettlementPaymentsMethod
>;

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListSettlementPaymentsMetadata =
  | string
  | { [k: string]: any }
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const ListSettlementPaymentsCaptureMode = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type ListSettlementPaymentsCaptureMode = ClosedEnum<
  typeof ListSettlementPaymentsCaptureMode
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type ListSettlementPaymentsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type ListSettlementPaymentsApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: ListSettlementPaymentsApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListSettlementPaymentsRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListSettlementPaymentsRoutingMode = ClosedEnum<
  typeof ListSettlementPaymentsRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type ListSettlementPaymentsRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const ListSettlementPaymentsRoutingType = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type ListSettlementPaymentsRoutingType = ClosedEnum<
  typeof ListSettlementPaymentsRoutingType
>;

/**
 * The destination of this portion of the payment.
 */
export type ListSettlementPaymentsDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: ListSettlementPaymentsRoutingType;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSettlementPaymentsRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type ListSettlementPaymentsRoutingPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSettlementPaymentsRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListSettlementPaymentsRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: ListSettlementPaymentsRoutingPayment;
};

export type ListSettlementPaymentsRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListSettlementPaymentsRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: ListSettlementPaymentsRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: ListSettlementPaymentsDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListSettlementPaymentsRoutingLinks;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const ListSettlementPaymentsSequenceType = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type ListSettlementPaymentsSequenceType = ClosedEnum<
  typeof ListSettlementPaymentsSequenceType
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const ListSettlementPaymentsStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type ListSettlementPaymentsStatus = ClosedEnum<
  typeof ListSettlementPaymentsStatus
>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type ListSettlementPaymentsStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSettlementPaymentsPaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type ListSettlementPaymentsCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type ListSettlementPaymentsMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type ListSettlementPaymentsChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type ListSettlementPaymentsDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type ListSettlementPaymentsRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type ListSettlementPaymentsChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type ListSettlementPaymentsCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type ListSettlementPaymentsSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type ListSettlementPaymentsCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type ListSettlementPaymentsMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type ListSettlementPaymentsSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type ListSettlementPaymentsOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type ListSettlementPaymentsTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSettlementPaymentsPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSettlementPaymentsPaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListSettlementPaymentsPaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: ListSettlementPaymentsCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: ListSettlementPaymentsMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: ListSettlementPaymentsChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: ListSettlementPaymentsDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: ListSettlementPaymentsRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: ListSettlementPaymentsChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: ListSettlementPaymentsCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: ListSettlementPaymentsSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: ListSettlementPaymentsCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: ListSettlementPaymentsMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: ListSettlementPaymentsSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: ListSettlementPaymentsOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: ListSettlementPaymentsTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListSettlementPaymentsPaymentDocumentation | undefined;
};

export type ListSettlementPaymentsPaymentOutput = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListSettlementPaymentsMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: ListSettlementPaymentsAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: ListSettlementPaymentsAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: ListSettlementPaymentsAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: ListSettlementPaymentsAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: ListSettlementPaymentsAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: ListSettlementPaymentsSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListSettlementPaymentsLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListSettlementPaymentsBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: ListSettlementPaymentsShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: ListSettlementPaymentsLocale | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: ListSettlementPaymentsMethod | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: ListSettlementPaymentsCaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: ListSettlementPaymentsApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<ListSettlementPaymentsRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType: ListSettlementPaymentsSequenceType | null;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: ListSettlementPaymentsStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: ListSettlementPaymentsStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListSettlementPaymentsPaymentLinks;
};

export type ListSettlementPaymentsEmbedded = {
  /**
   * An array of payment objects.
   */
  payments?: Array<ListSettlementPaymentsPaymentOutput> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListSettlementPaymentsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListSettlementPaymentsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListSettlementPaymentsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSettlementPaymentsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListSettlementPaymentsLinks = {
  /**
   * The URL to the current set of items.
   */
  self?: ListSettlementPaymentsSelf | undefined;
  /**
   * The previous set of items, if available.
   */
  previous?: ListSettlementPaymentsPrevious | null | undefined;
  /**
   * The next set of items, if available.
   */
  next?: ListSettlementPaymentsNext | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListSettlementPaymentsDocumentation | undefined;
};

/**
 * A list of payment objects.
 */
export type ListSettlementPaymentsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListSettlementPaymentsEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListSettlementPaymentsLinks | undefined;
};

/** @internal */
export const ListSettlementPaymentsSort$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsSort
> = z.nativeEnum(ListSettlementPaymentsSort);

/** @internal */
export const ListSettlementPaymentsSort$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsSort
> = ListSettlementPaymentsSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSort$ {
  /** @deprecated use `ListSettlementPaymentsSort$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsSort$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSort$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsSort$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsRequest$inboundSchema: z.ZodType<
  ListSettlementPaymentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  settlementId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListSettlementPaymentsSort$inboundSchema).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListSettlementPaymentsRequest$Outbound = {
  settlementId: string;
  from?: string | undefined;
  limit?: number | null | undefined;
  sort?: string | null | undefined;
  profileId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListSettlementPaymentsRequest$outboundSchema: z.ZodType<
  ListSettlementPaymentsRequest$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRequest
> = z.object({
  settlementId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListSettlementPaymentsSort$outboundSchema).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRequest$ {
  /** @deprecated use `ListSettlementPaymentsRequest$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRequest$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRequest$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsRequest$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRequest$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRequest$Outbound;
}

export function listSettlementPaymentsRequestToJSON(
  listSettlementPaymentsRequest: ListSettlementPaymentsRequest,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRequest$outboundSchema.parse(
      listSettlementPaymentsRequest,
    ),
  );
}

export function listSettlementPaymentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRequest' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsBadRequestDocumentation$inboundSchema:
  z.ZodType<
    ListSettlementPaymentsBadRequestDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListSettlementPaymentsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsBadRequestDocumentation$outboundSchema:
  z.ZodType<
    ListSettlementPaymentsBadRequestDocumentation$Outbound,
    z.ZodTypeDef,
    ListSettlementPaymentsBadRequestDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsBadRequestDocumentation$ {
  /** @deprecated use `ListSettlementPaymentsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsBadRequestDocumentation$Outbound;
}

export function listSettlementPaymentsBadRequestDocumentationToJSON(
  listSettlementPaymentsBadRequestDocumentation:
    ListSettlementPaymentsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListSettlementPaymentsBadRequestDocumentation$outboundSchema.parse(
      listSettlementPaymentsBadRequestDocumentation,
    ),
  );
}

export function listSettlementPaymentsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsBadRequestLinks$inboundSchema: z.ZodType<
  ListSettlementPaymentsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListSettlementPaymentsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListSettlementPaymentsBadRequestLinks$Outbound = {
  documentation: ListSettlementPaymentsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListSettlementPaymentsBadRequestLinks$outboundSchema: z.ZodType<
  ListSettlementPaymentsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListSettlementPaymentsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsBadRequestLinks$ {
  /** @deprecated use `ListSettlementPaymentsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsBadRequestLinks$Outbound;
}

export function listSettlementPaymentsBadRequestLinksToJSON(
  listSettlementPaymentsBadRequestLinks: ListSettlementPaymentsBadRequestLinks,
): string {
  return JSON.stringify(
    ListSettlementPaymentsBadRequestLinks$outboundSchema.parse(
      listSettlementPaymentsBadRequestLinks,
    ),
  );
}

export function listSettlementPaymentsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsMode
> = z.nativeEnum(ListSettlementPaymentsMode);

/** @internal */
export const ListSettlementPaymentsMode$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsMode
> = ListSettlementPaymentsMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsMode$ {
  /** @deprecated use `ListSettlementPaymentsMode$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsMode$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsMode$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsMode$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsAmount$ {
  /** @deprecated use `ListSettlementPaymentsAmount$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmount$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsAmount$Outbound;
}

export function listSettlementPaymentsAmountToJSON(
  listSettlementPaymentsAmount: ListSettlementPaymentsAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsAmount$outboundSchema.parse(
      listSettlementPaymentsAmount,
    ),
  );
}

export function listSettlementPaymentsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsAmountRefunded$inboundSchema: z.ZodType<
  ListSettlementPaymentsAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsAmountRefunded$outboundSchema: z.ZodType<
  ListSettlementPaymentsAmountRefunded$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsAmountRefunded$ {
  /** @deprecated use `ListSettlementPaymentsAmountRefunded$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsAmountRefunded$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountRefunded$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsAmountRefunded$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountRefunded$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsAmountRefunded$Outbound;
}

export function listSettlementPaymentsAmountRefundedToJSON(
  listSettlementPaymentsAmountRefunded: ListSettlementPaymentsAmountRefunded,
): string {
  return JSON.stringify(
    ListSettlementPaymentsAmountRefunded$outboundSchema.parse(
      listSettlementPaymentsAmountRefunded,
    ),
  );
}

export function listSettlementPaymentsAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsAmountRefunded' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsAmountRemaining$inboundSchema: z.ZodType<
  ListSettlementPaymentsAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsAmountRemaining$outboundSchema: z.ZodType<
  ListSettlementPaymentsAmountRemaining$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsAmountRemaining$ {
  /** @deprecated use `ListSettlementPaymentsAmountRemaining$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsAmountRemaining$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountRemaining$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsAmountRemaining$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountRemaining$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsAmountRemaining$Outbound;
}

export function listSettlementPaymentsAmountRemainingToJSON(
  listSettlementPaymentsAmountRemaining: ListSettlementPaymentsAmountRemaining,
): string {
  return JSON.stringify(
    ListSettlementPaymentsAmountRemaining$outboundSchema.parse(
      listSettlementPaymentsAmountRemaining,
    ),
  );
}

export function listSettlementPaymentsAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsAmountRemaining' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsAmountCaptured$inboundSchema: z.ZodType<
  ListSettlementPaymentsAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsAmountCaptured$outboundSchema: z.ZodType<
  ListSettlementPaymentsAmountCaptured$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsAmountCaptured$ {
  /** @deprecated use `ListSettlementPaymentsAmountCaptured$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsAmountCaptured$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountCaptured$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsAmountCaptured$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountCaptured$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsAmountCaptured$Outbound;
}

export function listSettlementPaymentsAmountCapturedToJSON(
  listSettlementPaymentsAmountCaptured: ListSettlementPaymentsAmountCaptured,
): string {
  return JSON.stringify(
    ListSettlementPaymentsAmountCaptured$outboundSchema.parse(
      listSettlementPaymentsAmountCaptured,
    ),
  );
}

export function listSettlementPaymentsAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsAmountCaptured' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsAmountChargedBack$inboundSchema: z.ZodType<
  ListSettlementPaymentsAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsAmountChargedBack$outboundSchema: z.ZodType<
  ListSettlementPaymentsAmountChargedBack$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsAmountChargedBack$ {
  /** @deprecated use `ListSettlementPaymentsAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsAmountChargedBack$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsAmountChargedBack$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsAmountChargedBack$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsAmountChargedBack$Outbound;
}

export function listSettlementPaymentsAmountChargedBackToJSON(
  listSettlementPaymentsAmountChargedBack:
    ListSettlementPaymentsAmountChargedBack,
): string {
  return JSON.stringify(
    ListSettlementPaymentsAmountChargedBack$outboundSchema.parse(
      listSettlementPaymentsAmountChargedBack,
    ),
  );
}

export function listSettlementPaymentsAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsAmountChargedBack,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsAmountChargedBack$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsSettlementAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsSettlementAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsSettlementAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSettlementAmount$ {
  /** @deprecated use `ListSettlementPaymentsSettlementAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsSettlementAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSettlementAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsSettlementAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsSettlementAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsSettlementAmount$Outbound;
}

export function listSettlementPaymentsSettlementAmountToJSON(
  listSettlementPaymentsSettlementAmount:
    ListSettlementPaymentsSettlementAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsSettlementAmount$outboundSchema.parse(
      listSettlementPaymentsSettlementAmount,
    ),
  );
}

export function listSettlementPaymentsSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsSettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsLineType$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsLineType
> = z.nativeEnum(ListSettlementPaymentsLineType);

/** @internal */
export const ListSettlementPaymentsLineType$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsLineType
> = ListSettlementPaymentsLineType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsLineType$ {
  /** @deprecated use `ListSettlementPaymentsLineType$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsLineType$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsLineType$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsLineType$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsUnitPrice$inboundSchema: z.ZodType<
  ListSettlementPaymentsUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsUnitPrice$outboundSchema: z.ZodType<
  ListSettlementPaymentsUnitPrice$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsUnitPrice$ {
  /** @deprecated use `ListSettlementPaymentsUnitPrice$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsUnitPrice$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsUnitPrice$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsUnitPrice$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsUnitPrice$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsUnitPrice$Outbound;
}

export function listSettlementPaymentsUnitPriceToJSON(
  listSettlementPaymentsUnitPrice: ListSettlementPaymentsUnitPrice,
): string {
  return JSON.stringify(
    ListSettlementPaymentsUnitPrice$outboundSchema.parse(
      listSettlementPaymentsUnitPrice,
    ),
  );
}

export function listSettlementPaymentsUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsUnitPrice' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsDiscountAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsDiscountAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsDiscountAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsDiscountAmount$ {
  /** @deprecated use `ListSettlementPaymentsDiscountAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsDiscountAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsDiscountAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsDiscountAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsDiscountAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsDiscountAmount$Outbound;
}

export function listSettlementPaymentsDiscountAmountToJSON(
  listSettlementPaymentsDiscountAmount: ListSettlementPaymentsDiscountAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsDiscountAmount$outboundSchema.parse(
      listSettlementPaymentsDiscountAmount,
    ),
  );
}

export function listSettlementPaymentsDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsDiscountAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsTotalAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsTotalAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsTotalAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsTotalAmount$ {
  /** @deprecated use `ListSettlementPaymentsTotalAmount$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsTotalAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsTotalAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsTotalAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsTotalAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsTotalAmount$Outbound;
}

export function listSettlementPaymentsTotalAmountToJSON(
  listSettlementPaymentsTotalAmount: ListSettlementPaymentsTotalAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsTotalAmount$outboundSchema.parse(
      listSettlementPaymentsTotalAmount,
    ),
  );
}

export function listSettlementPaymentsTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsVatAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsVatAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsVatAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsVatAmount$ {
  /** @deprecated use `ListSettlementPaymentsVatAmount$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsVatAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsVatAmount$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsVatAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsVatAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsVatAmount$Outbound;
}

export function listSettlementPaymentsVatAmountToJSON(
  listSettlementPaymentsVatAmount: ListSettlementPaymentsVatAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsVatAmount$outboundSchema.parse(
      listSettlementPaymentsVatAmount,
    ),
  );
}

export function listSettlementPaymentsVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsVatAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsCategory$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsCategory
> = z.nativeEnum(ListSettlementPaymentsCategory);

/** @internal */
export const ListSettlementPaymentsCategory$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsCategory
> = ListSettlementPaymentsCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsCategory$ {
  /** @deprecated use `ListSettlementPaymentsCategory$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsCategory$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsCategory$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsCategory$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsInterval$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsInterval
> = z.nativeEnum(ListSettlementPaymentsInterval);

/** @internal */
export const ListSettlementPaymentsInterval$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsInterval
> = ListSettlementPaymentsInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsInterval$ {
  /** @deprecated use `ListSettlementPaymentsInterval$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsInterval$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsInterval$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsInterval$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsRecurringAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsRecurringAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsRecurringAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRecurringAmount$ {
  /** @deprecated use `ListSettlementPaymentsRecurringAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsRecurringAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRecurringAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRecurringAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRecurringAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRecurringAmount$Outbound;
}

export function listSettlementPaymentsRecurringAmountToJSON(
  listSettlementPaymentsRecurringAmount: ListSettlementPaymentsRecurringAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRecurringAmount$outboundSchema.parse(
      listSettlementPaymentsRecurringAmount,
    ),
  );
}

export function listSettlementPaymentsRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRecurringAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsRecurringAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRecurringAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRecurring$inboundSchema: z.ZodType<
  ListSettlementPaymentsRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: ListSettlementPaymentsInterval$inboundSchema,
  amount: z.lazy(() => ListSettlementPaymentsRecurringAmount$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListSettlementPaymentsRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: ListSettlementPaymentsRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const ListSettlementPaymentsRecurring$outboundSchema: z.ZodType<
  ListSettlementPaymentsRecurring$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRecurring
> = z.object({
  description: z.string().optional(),
  interval: ListSettlementPaymentsInterval$outboundSchema,
  amount: z.lazy(() => ListSettlementPaymentsRecurringAmount$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRecurring$ {
  /** @deprecated use `ListSettlementPaymentsRecurring$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRecurring$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRecurring$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsRecurring$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRecurring$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRecurring$Outbound;
}

export function listSettlementPaymentsRecurringToJSON(
  listSettlementPaymentsRecurring: ListSettlementPaymentsRecurring,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRecurring$outboundSchema.parse(
      listSettlementPaymentsRecurring,
    ),
  );
}

export function listSettlementPaymentsRecurringFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRecurring' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsLine$inboundSchema: z.ZodType<
  ListSettlementPaymentsLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListSettlementPaymentsLineType$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListSettlementPaymentsUnitPrice$inboundSchema),
  discountAmount: z.lazy(() =>
    ListSettlementPaymentsDiscountAmount$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSettlementPaymentsTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListSettlementPaymentsVatAmount$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListSettlementPaymentsCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListSettlementPaymentsRecurring$inboundSchema)
    .optional(),
});

/** @internal */
export type ListSettlementPaymentsLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: ListSettlementPaymentsUnitPrice$Outbound;
  discountAmount?: ListSettlementPaymentsDiscountAmount$Outbound | undefined;
  totalAmount: ListSettlementPaymentsTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: ListSettlementPaymentsVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: ListSettlementPaymentsRecurring$Outbound | undefined;
};

/** @internal */
export const ListSettlementPaymentsLine$outboundSchema: z.ZodType<
  ListSettlementPaymentsLine$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsLine
> = z.object({
  type: ListSettlementPaymentsLineType$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListSettlementPaymentsUnitPrice$outboundSchema),
  discountAmount: z.lazy(() =>
    ListSettlementPaymentsDiscountAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSettlementPaymentsTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListSettlementPaymentsVatAmount$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListSettlementPaymentsCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListSettlementPaymentsRecurring$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsLine$ {
  /** @deprecated use `ListSettlementPaymentsLine$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsLine$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsLine$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsLine$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsLine$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsLine$Outbound;
}

export function listSettlementPaymentsLineToJSON(
  listSettlementPaymentsLine: ListSettlementPaymentsLine,
): string {
  return JSON.stringify(
    ListSettlementPaymentsLine$outboundSchema.parse(listSettlementPaymentsLine),
  );
}

export function listSettlementPaymentsLineFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsLine' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsBillingAddress$inboundSchema: z.ZodType<
  ListSettlementPaymentsBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListSettlementPaymentsBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListSettlementPaymentsBillingAddress$outboundSchema: z.ZodType<
  ListSettlementPaymentsBillingAddress$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsBillingAddress$ {
  /** @deprecated use `ListSettlementPaymentsBillingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsBillingAddress$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsBillingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsBillingAddress$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsBillingAddress$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsBillingAddress$Outbound;
}

export function listSettlementPaymentsBillingAddressToJSON(
  listSettlementPaymentsBillingAddress: ListSettlementPaymentsBillingAddress,
): string {
  return JSON.stringify(
    ListSettlementPaymentsBillingAddress$outboundSchema.parse(
      listSettlementPaymentsBillingAddress,
    ),
  );
}

export function listSettlementPaymentsBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsShippingAddress$inboundSchema: z.ZodType<
  ListSettlementPaymentsShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListSettlementPaymentsShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListSettlementPaymentsShippingAddress$outboundSchema: z.ZodType<
  ListSettlementPaymentsShippingAddress$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsShippingAddress$ {
  /** @deprecated use `ListSettlementPaymentsShippingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsShippingAddress$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsShippingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsShippingAddress$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsShippingAddress$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsShippingAddress$Outbound;
}

export function listSettlementPaymentsShippingAddressToJSON(
  listSettlementPaymentsShippingAddress: ListSettlementPaymentsShippingAddress,
): string {
  return JSON.stringify(
    ListSettlementPaymentsShippingAddress$outboundSchema.parse(
      listSettlementPaymentsShippingAddress,
    ),
  );
}

export function listSettlementPaymentsShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsShippingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsShippingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsShippingAddress' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsLocale$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsLocale
> = z.nativeEnum(ListSettlementPaymentsLocale);

/** @internal */
export const ListSettlementPaymentsLocale$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsLocale
> = ListSettlementPaymentsLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsLocale$ {
  /** @deprecated use `ListSettlementPaymentsLocale$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsLocale$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsLocale$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsLocale$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsMethod
> = z.nativeEnum(ListSettlementPaymentsMethod);

/** @internal */
export const ListSettlementPaymentsMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsMethod
> = ListSettlementPaymentsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsMethod$ {
  /** @deprecated use `ListSettlementPaymentsMethod$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsMethod$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsMethod$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsMethod$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsMetadata$inboundSchema: z.ZodType<
  ListSettlementPaymentsMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type ListSettlementPaymentsMetadata$Outbound = string | {
  [k: string]: any;
} | Array<string>;

/** @internal */
export const ListSettlementPaymentsMetadata$outboundSchema: z.ZodType<
  ListSettlementPaymentsMetadata$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsMetadata
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsMetadata$ {
  /** @deprecated use `ListSettlementPaymentsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsMetadata$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsMetadata$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsMetadata$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsMetadata$Outbound;
}

export function listSettlementPaymentsMetadataToJSON(
  listSettlementPaymentsMetadata: ListSettlementPaymentsMetadata,
): string {
  return JSON.stringify(
    ListSettlementPaymentsMetadata$outboundSchema.parse(
      listSettlementPaymentsMetadata,
    ),
  );
}

export function listSettlementPaymentsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsMetadata' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsCaptureMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsCaptureMode
> = z.nativeEnum(ListSettlementPaymentsCaptureMode);

/** @internal */
export const ListSettlementPaymentsCaptureMode$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsCaptureMode
> = ListSettlementPaymentsCaptureMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsCaptureMode$ {
  /** @deprecated use `ListSettlementPaymentsCaptureMode$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsCaptureMode$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsCaptureMode$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsCaptureMode$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsApplicationFeeAmount$inboundSchema:
  z.ZodType<ListSettlementPaymentsApplicationFeeAmount, z.ZodTypeDef, unknown> =
    z.object({
      currency: z.string(),
      value: z.string(),
    });

/** @internal */
export type ListSettlementPaymentsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsApplicationFeeAmount$outboundSchema:
  z.ZodType<
    ListSettlementPaymentsApplicationFeeAmount$Outbound,
    z.ZodTypeDef,
    ListSettlementPaymentsApplicationFeeAmount
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsApplicationFeeAmount$ {
  /** @deprecated use `ListSettlementPaymentsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsApplicationFeeAmount$Outbound;
}

export function listSettlementPaymentsApplicationFeeAmountToJSON(
  listSettlementPaymentsApplicationFeeAmount:
    ListSettlementPaymentsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsApplicationFeeAmount$outboundSchema.parse(
      listSettlementPaymentsApplicationFeeAmount,
    ),
  );
}

export function listSettlementPaymentsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsApplicationFeeAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsApplicationFeeAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsApplicationFee$inboundSchema: z.ZodType<
  ListSettlementPaymentsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListSettlementPaymentsApplicationFeeAmount$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type ListSettlementPaymentsApplicationFee$Outbound = {
  amount?: ListSettlementPaymentsApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ListSettlementPaymentsApplicationFee$outboundSchema: z.ZodType<
  ListSettlementPaymentsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsApplicationFee
> = z.object({
  amount: z.lazy(() =>
    ListSettlementPaymentsApplicationFeeAmount$outboundSchema
  ).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsApplicationFee$ {
  /** @deprecated use `ListSettlementPaymentsApplicationFee$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsApplicationFee$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsApplicationFee$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsApplicationFee$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsApplicationFee$Outbound;
}

export function listSettlementPaymentsApplicationFeeToJSON(
  listSettlementPaymentsApplicationFee: ListSettlementPaymentsApplicationFee,
): string {
  return JSON.stringify(
    ListSettlementPaymentsApplicationFee$outboundSchema.parse(
      listSettlementPaymentsApplicationFee,
    ),
  );
}

export function listSettlementPaymentsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsRoutingMode
> = z.nativeEnum(ListSettlementPaymentsRoutingMode);

/** @internal */
export const ListSettlementPaymentsRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsRoutingMode
> = ListSettlementPaymentsRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingMode$ {
  /** @deprecated use `ListSettlementPaymentsRoutingMode$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRoutingMode$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingMode$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingMode$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsRoutingAmount$inboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSettlementPaymentsRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSettlementPaymentsRoutingAmount$outboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingAmount$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingAmount$ {
  /** @deprecated use `ListSettlementPaymentsRoutingAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsRoutingAmount$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingAmount$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingAmount$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRoutingAmount$Outbound;
}

export function listSettlementPaymentsRoutingAmountToJSON(
  listSettlementPaymentsRoutingAmount: ListSettlementPaymentsRoutingAmount,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRoutingAmount$outboundSchema.parse(
      listSettlementPaymentsRoutingAmount,
    ),
  );
}

export function listSettlementPaymentsRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRoutingAmount' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsRoutingType
> = z.nativeEnum(ListSettlementPaymentsRoutingType);

/** @internal */
export const ListSettlementPaymentsRoutingType$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsRoutingType
> = ListSettlementPaymentsRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingType$ {
  /** @deprecated use `ListSettlementPaymentsRoutingType$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRoutingType$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingType$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingType$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsDestination$inboundSchema: z.ZodType<
  ListSettlementPaymentsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListSettlementPaymentsRoutingType$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type ListSettlementPaymentsDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const ListSettlementPaymentsDestination$outboundSchema: z.ZodType<
  ListSettlementPaymentsDestination$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsDestination
> = z.object({
  type: ListSettlementPaymentsRoutingType$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsDestination$ {
  /** @deprecated use `ListSettlementPaymentsDestination$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsDestination$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsDestination$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsDestination$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsDestination$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsDestination$Outbound;
}

export function listSettlementPaymentsDestinationToJSON(
  listSettlementPaymentsDestination: ListSettlementPaymentsDestination,
): string {
  return JSON.stringify(
    ListSettlementPaymentsDestination$outboundSchema.parse(
      listSettlementPaymentsDestination,
    ),
  );
}

export function listSettlementPaymentsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsDestination' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRoutingSelf$inboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsRoutingSelf$outboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingSelf$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingSelf$ {
  /** @deprecated use `ListSettlementPaymentsRoutingSelf$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRoutingSelf$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingSelf$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingSelf$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRoutingSelf$Outbound;
}

export function listSettlementPaymentsRoutingSelfToJSON(
  listSettlementPaymentsRoutingSelf: ListSettlementPaymentsRoutingSelf,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRoutingSelf$outboundSchema.parse(
      listSettlementPaymentsRoutingSelf,
    ),
  );
}

export function listSettlementPaymentsRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRoutingSelf' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRoutingPayment$inboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsRoutingPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsRoutingPayment$outboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingPayment$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRoutingPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingPayment$ {
  /** @deprecated use `ListSettlementPaymentsRoutingPayment$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsRoutingPayment$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingPayment$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingPayment$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingPayment$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRoutingPayment$Outbound;
}

export function listSettlementPaymentsRoutingPaymentToJSON(
  listSettlementPaymentsRoutingPayment: ListSettlementPaymentsRoutingPayment,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRoutingPayment$outboundSchema.parse(
      listSettlementPaymentsRoutingPayment,
    ),
  );
}

export function listSettlementPaymentsRoutingPaymentFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRoutingPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsRoutingPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRoutingPayment' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRoutingLinks$inboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsRoutingSelf$inboundSchema),
  payment: z.lazy(() => ListSettlementPaymentsRoutingPayment$inboundSchema),
});

/** @internal */
export type ListSettlementPaymentsRoutingLinks$Outbound = {
  self: ListSettlementPaymentsRoutingSelf$Outbound;
  payment: ListSettlementPaymentsRoutingPayment$Outbound;
};

/** @internal */
export const ListSettlementPaymentsRoutingLinks$outboundSchema: z.ZodType<
  ListSettlementPaymentsRoutingLinks$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRoutingLinks
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsRoutingSelf$outboundSchema),
  payment: z.lazy(() => ListSettlementPaymentsRoutingPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRoutingLinks$ {
  /** @deprecated use `ListSettlementPaymentsRoutingLinks$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRoutingLinks$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsRoutingLinks$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRoutingLinks$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRoutingLinks$Outbound;
}

export function listSettlementPaymentsRoutingLinksToJSON(
  listSettlementPaymentsRoutingLinks: ListSettlementPaymentsRoutingLinks,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRoutingLinks$outboundSchema.parse(
      listSettlementPaymentsRoutingLinks,
    ),
  );
}

export function listSettlementPaymentsRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRoutingLinks' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRouting$inboundSchema: z.ZodType<
  ListSettlementPaymentsRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSettlementPaymentsRoutingMode$inboundSchema,
  amount: z.lazy(() => ListSettlementPaymentsRoutingAmount$inboundSchema),
  destination: z.lazy(() => ListSettlementPaymentsDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSettlementPaymentsRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListSettlementPaymentsRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: ListSettlementPaymentsRoutingAmount$Outbound;
  destination: ListSettlementPaymentsDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: ListSettlementPaymentsRoutingLinks$Outbound;
};

/** @internal */
export const ListSettlementPaymentsRouting$outboundSchema: z.ZodType<
  ListSettlementPaymentsRouting$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSettlementPaymentsRoutingMode$outboundSchema,
  amount: z.lazy(() => ListSettlementPaymentsRoutingAmount$outboundSchema),
  destination: z.lazy(() => ListSettlementPaymentsDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSettlementPaymentsRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRouting$ {
  /** @deprecated use `ListSettlementPaymentsRouting$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRouting$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRouting$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsRouting$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRouting$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRouting$Outbound;
}

export function listSettlementPaymentsRoutingToJSON(
  listSettlementPaymentsRouting: ListSettlementPaymentsRouting,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRouting$outboundSchema.parse(
      listSettlementPaymentsRouting,
    ),
  );
}

export function listSettlementPaymentsRoutingFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRouting' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsSequenceType$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsSequenceType
> = z.nativeEnum(ListSettlementPaymentsSequenceType);

/** @internal */
export const ListSettlementPaymentsSequenceType$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsSequenceType
> = ListSettlementPaymentsSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSequenceType$ {
  /** @deprecated use `ListSettlementPaymentsSequenceType$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsSequenceType$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSequenceType$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsSequenceType$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsStatus
> = z.nativeEnum(ListSettlementPaymentsStatus);

/** @internal */
export const ListSettlementPaymentsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListSettlementPaymentsStatus
> = ListSettlementPaymentsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsStatus$ {
  /** @deprecated use `ListSettlementPaymentsStatus$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsStatus$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsStatus$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsStatus$outboundSchema;
}

/** @internal */
export const ListSettlementPaymentsStatusReason$inboundSchema: z.ZodType<
  ListSettlementPaymentsStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type ListSettlementPaymentsStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const ListSettlementPaymentsStatusReason$outboundSchema: z.ZodType<
  ListSettlementPaymentsStatusReason$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsStatusReason$ {
  /** @deprecated use `ListSettlementPaymentsStatusReason$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsStatusReason$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsStatusReason$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsStatusReason$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsStatusReason$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsStatusReason$Outbound;
}

export function listSettlementPaymentsStatusReasonToJSON(
  listSettlementPaymentsStatusReason: ListSettlementPaymentsStatusReason,
): string {
  return JSON.stringify(
    ListSettlementPaymentsStatusReason$outboundSchema.parse(
      listSettlementPaymentsStatusReason,
    ),
  );
}

export function listSettlementPaymentsStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsStatusReason' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsPaymentSelf$inboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsPaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsPaymentSelf$outboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentSelf$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsPaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsPaymentSelf$ {
  /** @deprecated use `ListSettlementPaymentsPaymentSelf$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsPaymentSelf$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsPaymentSelf$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentSelf$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsPaymentSelf$Outbound;
}

export function listSettlementPaymentsPaymentSelfToJSON(
  listSettlementPaymentsPaymentSelf: ListSettlementPaymentsPaymentSelf,
): string {
  return JSON.stringify(
    ListSettlementPaymentsPaymentSelf$outboundSchema.parse(
      listSettlementPaymentsPaymentSelf,
    ),
  );
}

export function listSettlementPaymentsPaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsPaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsPaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsPaymentSelf' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsCheckout$inboundSchema: z.ZodType<
  ListSettlementPaymentsCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsCheckout$outboundSchema: z.ZodType<
  ListSettlementPaymentsCheckout$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsCheckout$ {
  /** @deprecated use `ListSettlementPaymentsCheckout$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsCheckout$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsCheckout$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsCheckout$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsCheckout$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsCheckout$Outbound;
}

export function listSettlementPaymentsCheckoutToJSON(
  listSettlementPaymentsCheckout: ListSettlementPaymentsCheckout,
): string {
  return JSON.stringify(
    ListSettlementPaymentsCheckout$outboundSchema.parse(
      listSettlementPaymentsCheckout,
    ),
  );
}

export function listSettlementPaymentsCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsCheckout' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsMobileAppCheckout$inboundSchema: z.ZodType<
  ListSettlementPaymentsMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsMobileAppCheckout$outboundSchema: z.ZodType<
  ListSettlementPaymentsMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsMobileAppCheckout$ {
  /** @deprecated use `ListSettlementPaymentsMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsMobileAppCheckout$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsMobileAppCheckout$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsMobileAppCheckout$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsMobileAppCheckout$Outbound;
}

export function listSettlementPaymentsMobileAppCheckoutToJSON(
  listSettlementPaymentsMobileAppCheckout:
    ListSettlementPaymentsMobileAppCheckout,
): string {
  return JSON.stringify(
    ListSettlementPaymentsMobileAppCheckout$outboundSchema.parse(
      listSettlementPaymentsMobileAppCheckout,
    ),
  );
}

export function listSettlementPaymentsMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsMobileAppCheckout,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsMobileAppCheckout$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsChangePaymentState$inboundSchema: z.ZodType<
  ListSettlementPaymentsChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsChangePaymentState$outboundSchema: z.ZodType<
  ListSettlementPaymentsChangePaymentState$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsChangePaymentState$ {
  /** @deprecated use `ListSettlementPaymentsChangePaymentState$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsChangePaymentState$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsChangePaymentState$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsChangePaymentState$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsChangePaymentState$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsChangePaymentState$Outbound;
}

export function listSettlementPaymentsChangePaymentStateToJSON(
  listSettlementPaymentsChangePaymentState:
    ListSettlementPaymentsChangePaymentState,
): string {
  return JSON.stringify(
    ListSettlementPaymentsChangePaymentState$outboundSchema.parse(
      listSettlementPaymentsChangePaymentState,
    ),
  );
}

export function listSettlementPaymentsChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsChangePaymentState,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsChangePaymentState$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsChangePaymentState' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsDashboard$inboundSchema: z.ZodType<
  ListSettlementPaymentsDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsDashboard$outboundSchema: z.ZodType<
  ListSettlementPaymentsDashboard$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsDashboard$ {
  /** @deprecated use `ListSettlementPaymentsDashboard$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsDashboard$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsDashboard$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsDashboard$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsDashboard$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsDashboard$Outbound;
}

export function listSettlementPaymentsDashboardToJSON(
  listSettlementPaymentsDashboard: ListSettlementPaymentsDashboard,
): string {
  return JSON.stringify(
    ListSettlementPaymentsDashboard$outboundSchema.parse(
      listSettlementPaymentsDashboard,
    ),
  );
}

export function listSettlementPaymentsDashboardFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsDashboard' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsRefunds$inboundSchema: z.ZodType<
  ListSettlementPaymentsRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsRefunds$outboundSchema: z.ZodType<
  ListSettlementPaymentsRefunds$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsRefunds$ {
  /** @deprecated use `ListSettlementPaymentsRefunds$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsRefunds$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsRefunds$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsRefunds$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsRefunds$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsRefunds$Outbound;
}

export function listSettlementPaymentsRefundsToJSON(
  listSettlementPaymentsRefunds: ListSettlementPaymentsRefunds,
): string {
  return JSON.stringify(
    ListSettlementPaymentsRefunds$outboundSchema.parse(
      listSettlementPaymentsRefunds,
    ),
  );
}

export function listSettlementPaymentsRefundsFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsRefunds' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsChargebacks$inboundSchema: z.ZodType<
  ListSettlementPaymentsChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsChargebacks$outboundSchema: z.ZodType<
  ListSettlementPaymentsChargebacks$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsChargebacks$ {
  /** @deprecated use `ListSettlementPaymentsChargebacks$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsChargebacks$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsChargebacks$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsChargebacks$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsChargebacks$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsChargebacks$Outbound;
}

export function listSettlementPaymentsChargebacksToJSON(
  listSettlementPaymentsChargebacks: ListSettlementPaymentsChargebacks,
): string {
  return JSON.stringify(
    ListSettlementPaymentsChargebacks$outboundSchema.parse(
      listSettlementPaymentsChargebacks,
    ),
  );
}

export function listSettlementPaymentsChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsChargebacks' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsCaptures$inboundSchema: z.ZodType<
  ListSettlementPaymentsCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsCaptures$outboundSchema: z.ZodType<
  ListSettlementPaymentsCaptures$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsCaptures$ {
  /** @deprecated use `ListSettlementPaymentsCaptures$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsCaptures$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsCaptures$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsCaptures$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsCaptures$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsCaptures$Outbound;
}

export function listSettlementPaymentsCapturesToJSON(
  listSettlementPaymentsCaptures: ListSettlementPaymentsCaptures,
): string {
  return JSON.stringify(
    ListSettlementPaymentsCaptures$outboundSchema.parse(
      listSettlementPaymentsCaptures,
    ),
  );
}

export function listSettlementPaymentsCapturesFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsCaptures' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsSettlement$inboundSchema: z.ZodType<
  ListSettlementPaymentsSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsSettlement$outboundSchema: z.ZodType<
  ListSettlementPaymentsSettlement$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSettlement$ {
  /** @deprecated use `ListSettlementPaymentsSettlement$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsSettlement$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSettlement$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsSettlement$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsSettlement$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsSettlement$Outbound;
}

export function listSettlementPaymentsSettlementToJSON(
  listSettlementPaymentsSettlement: ListSettlementPaymentsSettlement,
): string {
  return JSON.stringify(
    ListSettlementPaymentsSettlement$outboundSchema.parse(
      listSettlementPaymentsSettlement,
    ),
  );
}

export function listSettlementPaymentsSettlementFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsSettlement' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsCustomer$inboundSchema: z.ZodType<
  ListSettlementPaymentsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsCustomer$outboundSchema: z.ZodType<
  ListSettlementPaymentsCustomer$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsCustomer$ {
  /** @deprecated use `ListSettlementPaymentsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsCustomer$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsCustomer$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsCustomer$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsCustomer$Outbound;
}

export function listSettlementPaymentsCustomerToJSON(
  listSettlementPaymentsCustomer: ListSettlementPaymentsCustomer,
): string {
  return JSON.stringify(
    ListSettlementPaymentsCustomer$outboundSchema.parse(
      listSettlementPaymentsCustomer,
    ),
  );
}

export function listSettlementPaymentsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsCustomer' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsMandate$inboundSchema: z.ZodType<
  ListSettlementPaymentsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsMandate$outboundSchema: z.ZodType<
  ListSettlementPaymentsMandate$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsMandate$ {
  /** @deprecated use `ListSettlementPaymentsMandate$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsMandate$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsMandate$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsMandate$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsMandate$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsMandate$Outbound;
}

export function listSettlementPaymentsMandateToJSON(
  listSettlementPaymentsMandate: ListSettlementPaymentsMandate,
): string {
  return JSON.stringify(
    ListSettlementPaymentsMandate$outboundSchema.parse(
      listSettlementPaymentsMandate,
    ),
  );
}

export function listSettlementPaymentsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsMandate' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsSubscription$inboundSchema: z.ZodType<
  ListSettlementPaymentsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsSubscription$outboundSchema: z.ZodType<
  ListSettlementPaymentsSubscription$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSubscription$ {
  /** @deprecated use `ListSettlementPaymentsSubscription$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsSubscription$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSubscription$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsSubscription$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsSubscription$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsSubscription$Outbound;
}

export function listSettlementPaymentsSubscriptionToJSON(
  listSettlementPaymentsSubscription: ListSettlementPaymentsSubscription,
): string {
  return JSON.stringify(
    ListSettlementPaymentsSubscription$outboundSchema.parse(
      listSettlementPaymentsSubscription,
    ),
  );
}

export function listSettlementPaymentsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsSubscription' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsOrder$inboundSchema: z.ZodType<
  ListSettlementPaymentsOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsOrder$outboundSchema: z.ZodType<
  ListSettlementPaymentsOrder$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsOrder$ {
  /** @deprecated use `ListSettlementPaymentsOrder$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsOrder$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsOrder$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsOrder$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsOrder$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsOrder$Outbound;
}

export function listSettlementPaymentsOrderToJSON(
  listSettlementPaymentsOrder: ListSettlementPaymentsOrder,
): string {
  return JSON.stringify(
    ListSettlementPaymentsOrder$outboundSchema.parse(
      listSettlementPaymentsOrder,
    ),
  );
}

export function listSettlementPaymentsOrderFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsOrder' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsTerminal$inboundSchema: z.ZodType<
  ListSettlementPaymentsTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsTerminal$outboundSchema: z.ZodType<
  ListSettlementPaymentsTerminal$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsTerminal$ {
  /** @deprecated use `ListSettlementPaymentsTerminal$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsTerminal$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsTerminal$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsTerminal$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsTerminal$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsTerminal$Outbound;
}

export function listSettlementPaymentsTerminalToJSON(
  listSettlementPaymentsTerminal: ListSettlementPaymentsTerminal,
): string {
  return JSON.stringify(
    ListSettlementPaymentsTerminal$outboundSchema.parse(
      listSettlementPaymentsTerminal,
    ),
  );
}

export function listSettlementPaymentsTerminalFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsTerminal' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsPaymentDocumentation$inboundSchema:
  z.ZodType<ListSettlementPaymentsPaymentDocumentation, z.ZodTypeDef, unknown> =
    z.object({
      href: z.string(),
      type: z.string(),
    });

/** @internal */
export type ListSettlementPaymentsPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsPaymentDocumentation$outboundSchema:
  z.ZodType<
    ListSettlementPaymentsPaymentDocumentation$Outbound,
    z.ZodTypeDef,
    ListSettlementPaymentsPaymentDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsPaymentDocumentation$ {
  /** @deprecated use `ListSettlementPaymentsPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsPaymentDocumentation$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsPaymentDocumentation$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentDocumentation$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsPaymentDocumentation$Outbound;
}

export function listSettlementPaymentsPaymentDocumentationToJSON(
  listSettlementPaymentsPaymentDocumentation:
    ListSettlementPaymentsPaymentDocumentation,
): string {
  return JSON.stringify(
    ListSettlementPaymentsPaymentDocumentation$outboundSchema.parse(
      listSettlementPaymentsPaymentDocumentation,
    ),
  );
}

export function listSettlementPaymentsPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSettlementPaymentsPaymentDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsPaymentDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSettlementPaymentsPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsPaymentLinks$inboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsPaymentSelf$inboundSchema),
  checkout: z.lazy(() => ListSettlementPaymentsCheckout$inboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListSettlementPaymentsMobileAppCheckout$inboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListSettlementPaymentsChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListSettlementPaymentsDashboard$inboundSchema),
  refunds: z.lazy(() => ListSettlementPaymentsRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => ListSettlementPaymentsChargebacks$inboundSchema)
    .optional(),
  captures: z.lazy(() => ListSettlementPaymentsCaptures$inboundSchema)
    .optional(),
  settlement: z.lazy(() => ListSettlementPaymentsSettlement$inboundSchema)
    .optional(),
  customer: z.lazy(() => ListSettlementPaymentsCustomer$inboundSchema)
    .optional(),
  mandate: z.lazy(() => ListSettlementPaymentsMandate$inboundSchema).optional(),
  subscription: z.lazy(() => ListSettlementPaymentsSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => ListSettlementPaymentsOrder$inboundSchema).optional(),
  terminal: z.lazy(() => ListSettlementPaymentsTerminal$inboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListSettlementPaymentsPaymentDocumentation$inboundSchema
  ).optional(),
});

/** @internal */
export type ListSettlementPaymentsPaymentLinks$Outbound = {
  self: ListSettlementPaymentsPaymentSelf$Outbound;
  checkout?: ListSettlementPaymentsCheckout$Outbound | undefined;
  mobileAppCheckout?:
    | ListSettlementPaymentsMobileAppCheckout$Outbound
    | undefined;
  changePaymentState?:
    | ListSettlementPaymentsChangePaymentState$Outbound
    | undefined;
  dashboard: ListSettlementPaymentsDashboard$Outbound;
  refunds?: ListSettlementPaymentsRefunds$Outbound | undefined;
  chargebacks?: ListSettlementPaymentsChargebacks$Outbound | undefined;
  captures?: ListSettlementPaymentsCaptures$Outbound | undefined;
  settlement?: ListSettlementPaymentsSettlement$Outbound | undefined;
  customer?: ListSettlementPaymentsCustomer$Outbound | undefined;
  mandate?: ListSettlementPaymentsMandate$Outbound | undefined;
  subscription?: ListSettlementPaymentsSubscription$Outbound | undefined;
  order?: ListSettlementPaymentsOrder$Outbound | undefined;
  terminal?: ListSettlementPaymentsTerminal$Outbound | undefined;
  documentation?:
    | ListSettlementPaymentsPaymentDocumentation$Outbound
    | undefined;
};

/** @internal */
export const ListSettlementPaymentsPaymentLinks$outboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentLinks$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsPaymentLinks
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsPaymentSelf$outboundSchema),
  checkout: z.lazy(() => ListSettlementPaymentsCheckout$outboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListSettlementPaymentsMobileAppCheckout$outboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListSettlementPaymentsChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListSettlementPaymentsDashboard$outboundSchema),
  refunds: z.lazy(() => ListSettlementPaymentsRefunds$outboundSchema)
    .optional(),
  chargebacks: z.lazy(() => ListSettlementPaymentsChargebacks$outboundSchema)
    .optional(),
  captures: z.lazy(() => ListSettlementPaymentsCaptures$outboundSchema)
    .optional(),
  settlement: z.lazy(() => ListSettlementPaymentsSettlement$outboundSchema)
    .optional(),
  customer: z.lazy(() => ListSettlementPaymentsCustomer$outboundSchema)
    .optional(),
  mandate: z.lazy(() => ListSettlementPaymentsMandate$outboundSchema)
    .optional(),
  subscription: z.lazy(() => ListSettlementPaymentsSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => ListSettlementPaymentsOrder$outboundSchema).optional(),
  terminal: z.lazy(() => ListSettlementPaymentsTerminal$outboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListSettlementPaymentsPaymentDocumentation$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsPaymentLinks$ {
  /** @deprecated use `ListSettlementPaymentsPaymentLinks$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsPaymentLinks$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsPaymentLinks$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentLinks$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsPaymentLinks$Outbound;
}

export function listSettlementPaymentsPaymentLinksToJSON(
  listSettlementPaymentsPaymentLinks: ListSettlementPaymentsPaymentLinks,
): string {
  return JSON.stringify(
    ListSettlementPaymentsPaymentLinks$outboundSchema.parse(
      listSettlementPaymentsPaymentLinks,
    ),
  );
}

export function listSettlementPaymentsPaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsPaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsPaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsPaymentLinks' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsPaymentOutput$inboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSettlementPaymentsMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListSettlementPaymentsAmount$inboundSchema),
  amountRefunded: z.lazy(() =>
    ListSettlementPaymentsAmountRefunded$inboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListSettlementPaymentsAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListSettlementPaymentsAmountCaptured$inboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListSettlementPaymentsAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListSettlementPaymentsSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListSettlementPaymentsLine$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListSettlementPaymentsBillingAddress$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListSettlementPaymentsShippingAddress$inboundSchema
  ).optional(),
  locale: z.nullable(ListSettlementPaymentsLocale$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListSettlementPaymentsMethod$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  captureMode: z.nullable(ListSettlementPaymentsCaptureMode$inboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListSettlementPaymentsApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListSettlementPaymentsRouting$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(ListSettlementPaymentsSequenceType$inboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListSettlementPaymentsStatus$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListSettlementPaymentsStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSettlementPaymentsPaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListSettlementPaymentsPaymentOutput$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: ListSettlementPaymentsAmount$Outbound;
  amountRefunded?: ListSettlementPaymentsAmountRefunded$Outbound | undefined;
  amountRemaining?: ListSettlementPaymentsAmountRemaining$Outbound | undefined;
  amountCaptured?: ListSettlementPaymentsAmountCaptured$Outbound | undefined;
  amountChargedBack?:
    | ListSettlementPaymentsAmountChargedBack$Outbound
    | undefined;
  settlementAmount?:
    | ListSettlementPaymentsSettlementAmount$Outbound
    | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<ListSettlementPaymentsLine$Outbound> | null | undefined;
  billingAddress?: ListSettlementPaymentsBillingAddress$Outbound | undefined;
  shippingAddress?: ListSettlementPaymentsShippingAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | ListSettlementPaymentsApplicationFee$Outbound
    | null
    | undefined;
  routing?: Array<ListSettlementPaymentsRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: ListSettlementPaymentsStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: ListSettlementPaymentsPaymentLinks$Outbound;
};

/** @internal */
export const ListSettlementPaymentsPaymentOutput$outboundSchema: z.ZodType<
  ListSettlementPaymentsPaymentOutput$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsPaymentOutput
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSettlementPaymentsMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListSettlementPaymentsAmount$outboundSchema),
  amountRefunded: z.lazy(() =>
    ListSettlementPaymentsAmountRefunded$outboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListSettlementPaymentsAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListSettlementPaymentsAmountCaptured$outboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListSettlementPaymentsAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListSettlementPaymentsSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListSettlementPaymentsLine$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListSettlementPaymentsBillingAddress$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListSettlementPaymentsShippingAddress$outboundSchema
  ).optional(),
  locale: z.nullable(ListSettlementPaymentsLocale$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListSettlementPaymentsMethod$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  captureMode: z.nullable(ListSettlementPaymentsCaptureMode$outboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListSettlementPaymentsApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListSettlementPaymentsRouting$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(ListSettlementPaymentsSequenceType$outboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListSettlementPaymentsStatus$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListSettlementPaymentsStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSettlementPaymentsPaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsPaymentOutput$ {
  /** @deprecated use `ListSettlementPaymentsPaymentOutput$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsPaymentOutput$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentOutput$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsPaymentOutput$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsPaymentOutput$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsPaymentOutput$Outbound;
}

export function listSettlementPaymentsPaymentOutputToJSON(
  listSettlementPaymentsPaymentOutput: ListSettlementPaymentsPaymentOutput,
): string {
  return JSON.stringify(
    ListSettlementPaymentsPaymentOutput$outboundSchema.parse(
      listSettlementPaymentsPaymentOutput,
    ),
  );
}

export function listSettlementPaymentsPaymentOutputFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsPaymentOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsPaymentOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsPaymentOutput' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsEmbedded$inboundSchema: z.ZodType<
  ListSettlementPaymentsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  payments: z.array(
    z.lazy(() => ListSettlementPaymentsPaymentOutput$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListSettlementPaymentsEmbedded$Outbound = {
  payments?: Array<ListSettlementPaymentsPaymentOutput$Outbound> | undefined;
};

/** @internal */
export const ListSettlementPaymentsEmbedded$outboundSchema: z.ZodType<
  ListSettlementPaymentsEmbedded$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsEmbedded
> = z.object({
  payments: z.array(
    z.lazy(() => ListSettlementPaymentsPaymentOutput$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsEmbedded$ {
  /** @deprecated use `ListSettlementPaymentsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsEmbedded$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsEmbedded$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsEmbedded$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsEmbedded$Outbound;
}

export function listSettlementPaymentsEmbeddedToJSON(
  listSettlementPaymentsEmbedded: ListSettlementPaymentsEmbedded,
): string {
  return JSON.stringify(
    ListSettlementPaymentsEmbedded$outboundSchema.parse(
      listSettlementPaymentsEmbedded,
    ),
  );
}

export function listSettlementPaymentsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsSelf$inboundSchema: z.ZodType<
  ListSettlementPaymentsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsSelf$outboundSchema: z.ZodType<
  ListSettlementPaymentsSelf$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsSelf$ {
  /** @deprecated use `ListSettlementPaymentsSelf$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsSelf$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsSelf$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsSelf$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsSelf$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsSelf$Outbound;
}

export function listSettlementPaymentsSelfToJSON(
  listSettlementPaymentsSelf: ListSettlementPaymentsSelf,
): string {
  return JSON.stringify(
    ListSettlementPaymentsSelf$outboundSchema.parse(listSettlementPaymentsSelf),
  );
}

export function listSettlementPaymentsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsSelf' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsPrevious$inboundSchema: z.ZodType<
  ListSettlementPaymentsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSettlementPaymentsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSettlementPaymentsPrevious$outboundSchema: z.ZodType<
  ListSettlementPaymentsPrevious$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsPrevious$ {
  /** @deprecated use `ListSettlementPaymentsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsPrevious$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsPrevious$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsPrevious$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsPrevious$Outbound;
}

export function listSettlementPaymentsPreviousToJSON(
  listSettlementPaymentsPrevious: ListSettlementPaymentsPrevious,
): string {
  return JSON.stringify(
    ListSettlementPaymentsPrevious$outboundSchema.parse(
      listSettlementPaymentsPrevious,
    ),
  );
}

export function listSettlementPaymentsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsPrevious' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsNext$inboundSchema: z.ZodType<
  ListSettlementPaymentsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSettlementPaymentsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSettlementPaymentsNext$outboundSchema: z.ZodType<
  ListSettlementPaymentsNext$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsNext$ {
  /** @deprecated use `ListSettlementPaymentsNext$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsNext$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsNext$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsNext$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsNext$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsNext$Outbound;
}

export function listSettlementPaymentsNextToJSON(
  listSettlementPaymentsNext: ListSettlementPaymentsNext,
): string {
  return JSON.stringify(
    ListSettlementPaymentsNext$outboundSchema.parse(listSettlementPaymentsNext),
  );
}

export function listSettlementPaymentsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsNext' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsDocumentation$inboundSchema: z.ZodType<
  ListSettlementPaymentsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSettlementPaymentsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSettlementPaymentsDocumentation$outboundSchema: z.ZodType<
  ListSettlementPaymentsDocumentation$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsDocumentation$ {
  /** @deprecated use `ListSettlementPaymentsDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSettlementPaymentsDocumentation$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSettlementPaymentsDocumentation$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsDocumentation$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsDocumentation$Outbound;
}

export function listSettlementPaymentsDocumentationToJSON(
  listSettlementPaymentsDocumentation: ListSettlementPaymentsDocumentation,
): string {
  return JSON.stringify(
    ListSettlementPaymentsDocumentation$outboundSchema.parse(
      listSettlementPaymentsDocumentation,
    ),
  );
}

export function listSettlementPaymentsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSettlementPaymentsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsLinks$inboundSchema: z.ZodType<
  ListSettlementPaymentsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsSelf$inboundSchema).optional(),
  previous: z.nullable(
    z.lazy(() => ListSettlementPaymentsPrevious$inboundSchema),
  ).optional(),
  next: z.nullable(z.lazy(() => ListSettlementPaymentsNext$inboundSchema))
    .optional(),
  documentation: z.lazy(() => ListSettlementPaymentsDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type ListSettlementPaymentsLinks$Outbound = {
  self?: ListSettlementPaymentsSelf$Outbound | undefined;
  previous?: ListSettlementPaymentsPrevious$Outbound | null | undefined;
  next?: ListSettlementPaymentsNext$Outbound | null | undefined;
  documentation?: ListSettlementPaymentsDocumentation$Outbound | undefined;
};

/** @internal */
export const ListSettlementPaymentsLinks$outboundSchema: z.ZodType<
  ListSettlementPaymentsLinks$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsLinks
> = z.object({
  self: z.lazy(() => ListSettlementPaymentsSelf$outboundSchema).optional(),
  previous: z.nullable(
    z.lazy(() => ListSettlementPaymentsPrevious$outboundSchema),
  ).optional(),
  next: z.nullable(z.lazy(() => ListSettlementPaymentsNext$outboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListSettlementPaymentsDocumentation$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsLinks$ {
  /** @deprecated use `ListSettlementPaymentsLinks$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsLinks$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsLinks$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsLinks$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsLinks$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsLinks$Outbound;
}

export function listSettlementPaymentsLinksToJSON(
  listSettlementPaymentsLinks: ListSettlementPaymentsLinks,
): string {
  return JSON.stringify(
    ListSettlementPaymentsLinks$outboundSchema.parse(
      listSettlementPaymentsLinks,
    ),
  );
}

export function listSettlementPaymentsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsLinks' from JSON`,
  );
}

/** @internal */
export const ListSettlementPaymentsResponse$inboundSchema: z.ZodType<
  ListSettlementPaymentsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListSettlementPaymentsEmbedded$inboundSchema)
    .optional(),
  _links: z.lazy(() => ListSettlementPaymentsLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListSettlementPaymentsResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListSettlementPaymentsEmbedded$Outbound | undefined;
  _links?: ListSettlementPaymentsLinks$Outbound | undefined;
};

/** @internal */
export const ListSettlementPaymentsResponse$outboundSchema: z.ZodType<
  ListSettlementPaymentsResponse$Outbound,
  z.ZodTypeDef,
  ListSettlementPaymentsResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListSettlementPaymentsEmbedded$outboundSchema)
    .optional(),
  links: z.lazy(() => ListSettlementPaymentsLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSettlementPaymentsResponse$ {
  /** @deprecated use `ListSettlementPaymentsResponse$inboundSchema` instead. */
  export const inboundSchema = ListSettlementPaymentsResponse$inboundSchema;
  /** @deprecated use `ListSettlementPaymentsResponse$outboundSchema` instead. */
  export const outboundSchema = ListSettlementPaymentsResponse$outboundSchema;
  /** @deprecated use `ListSettlementPaymentsResponse$Outbound` instead. */
  export type Outbound = ListSettlementPaymentsResponse$Outbound;
}

export function listSettlementPaymentsResponseToJSON(
  listSettlementPaymentsResponse: ListSettlementPaymentsResponse,
): string {
  return JSON.stringify(
    ListSettlementPaymentsResponse$outboundSchema.parse(
      listSettlementPaymentsResponse,
    ),
  );
}

export function listSettlementPaymentsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListSettlementPaymentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSettlementPaymentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSettlementPaymentsResponse' from JSON`,
  );
}
