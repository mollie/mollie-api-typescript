/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type UpdatePaymentMetadataRequest = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type UpdatePaymentMetadataRequestUnion =
  | UpdatePaymentMetadataRequest
  | string
  | Array<string>;

/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export const UpdatePaymentMethodRequest = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
 *
 * @remarks
 * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
 * parameter enables you to fully integrate the payment method selection into your website.
 *
 * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
 * but will only show the methods specified in the array. For example, you can use this functionality to only show
 * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
 */
export type UpdatePaymentMethodRequest = ClosedEnum<
  typeof UpdatePaymentMethodRequest
>;

/**
 * Allows you to preset the language to be used.
 */
export const UpdatePaymentLocaleRequest = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used.
 */
export type UpdatePaymentLocaleRequest = ClosedEnum<
  typeof UpdatePaymentLocaleRequest
>;

export type UpdatePaymentBillingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

export type UpdatePaymentShippingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

export type UpdatePaymentRequestBody = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description?: string | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | UpdatePaymentMetadataRequest
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: UpdatePaymentMethodRequest | null | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: UpdatePaymentLocaleRequest | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  billingAddress?: UpdatePaymentBillingAddressRequest | undefined;
  shippingAddress?: UpdatePaymentShippingAddressRequest | undefined;
  billingEmail?: string | undefined;
};

export type UpdatePaymentRequest = {
  /**
   * Provide the ID of the related payment.
   */
  paymentId: string;
  requestBody?: UpdatePaymentRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type UpdatePaymentUnprocessableEntityDocumentation = {
  href: string;
  type: string;
};

export type UpdatePaymentUnprocessableEntityLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: UpdatePaymentUnprocessableEntityDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type UpdatePaymentNotFoundDocumentation = {
  href: string;
  type: string;
};

export type UpdatePaymentNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: UpdatePaymentNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const UpdatePaymentMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type UpdatePaymentMode = ClosedEnum<typeof UpdatePaymentMode>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type UpdatePaymentAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type UpdatePaymentAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type UpdatePaymentAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type UpdatePaymentAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type UpdatePaymentAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type UpdatePaymentSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const UpdatePaymentLineType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type UpdatePaymentLineType = ClosedEnum<typeof UpdatePaymentLineType>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type UpdatePaymentUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type UpdatePaymentDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type UpdatePaymentTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type UpdatePaymentVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const UpdatePaymentCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type UpdatePaymentCategory = ClosedEnum<typeof UpdatePaymentCategory>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const UpdatePaymentInterval = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type UpdatePaymentInterval = ClosedEnum<typeof UpdatePaymentInterval>;

/**
 * Total amount and currency of the recurring item.
 */
export type UpdatePaymentRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type UpdatePaymentRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: UpdatePaymentInterval;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: UpdatePaymentRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type UpdatePaymentLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: UpdatePaymentLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: UpdatePaymentUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: UpdatePaymentDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: UpdatePaymentTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: UpdatePaymentVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<UpdatePaymentCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: UpdatePaymentRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type UpdatePaymentBillingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type UpdatePaymentShippingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const UpdatePaymentLocaleResponse = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type UpdatePaymentLocaleResponse = ClosedEnum<
  typeof UpdatePaymentLocaleResponse
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const UpdatePaymentMethodResponse = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type UpdatePaymentMethodResponse = ClosedEnum<
  typeof UpdatePaymentMethodResponse
>;

export type UpdatePaymentMetadataResponse = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type UpdatePaymentMetadataResponseUnion =
  | UpdatePaymentMetadataResponse
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const UpdatePaymentCaptureMode = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type UpdatePaymentCaptureMode = ClosedEnum<
  typeof UpdatePaymentCaptureMode
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type UpdatePaymentApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type UpdatePaymentApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: UpdatePaymentApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const UpdatePaymentRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type UpdatePaymentRoutingMode = ClosedEnum<
  typeof UpdatePaymentRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type UpdatePaymentRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const UpdatePaymentRoutingType = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type UpdatePaymentRoutingType = ClosedEnum<
  typeof UpdatePaymentRoutingType
>;

/**
 * The destination of this portion of the payment.
 */
export type UpdatePaymentDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: UpdatePaymentRoutingType;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type UpdatePaymentRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type UpdatePaymentPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type UpdatePaymentRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: UpdatePaymentRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: UpdatePaymentPayment;
};

export type UpdatePaymentRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: UpdatePaymentRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: UpdatePaymentRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: UpdatePaymentDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: UpdatePaymentRoutingLinks;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const UpdatePaymentSequenceType = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type UpdatePaymentSequenceType = ClosedEnum<
  typeof UpdatePaymentSequenceType
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const UpdatePaymentStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type UpdatePaymentStatus = ClosedEnum<typeof UpdatePaymentStatus>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type UpdatePaymentStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type UpdatePaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type UpdatePaymentCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type UpdatePaymentMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type UpdatePaymentChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type UpdatePaymentDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type UpdatePaymentRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type UpdatePaymentChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type UpdatePaymentCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type UpdatePaymentSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type UpdatePaymentCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type UpdatePaymentMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type UpdatePaymentSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type UpdatePaymentOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type UpdatePaymentTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type UpdatePaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type UpdatePaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: UpdatePaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: UpdatePaymentCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: UpdatePaymentMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: UpdatePaymentChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: UpdatePaymentDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: UpdatePaymentRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: UpdatePaymentChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: UpdatePaymentCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: UpdatePaymentSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: UpdatePaymentCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: UpdatePaymentMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: UpdatePaymentSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: UpdatePaymentOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: UpdatePaymentTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: UpdatePaymentDocumentation | undefined;
};

/**
 * The updated payment object.
 */
export type UpdatePaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: UpdatePaymentMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: UpdatePaymentAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: UpdatePaymentAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: UpdatePaymentAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: UpdatePaymentAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: UpdatePaymentAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: UpdatePaymentSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<UpdatePaymentLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: UpdatePaymentBillingAddressResponse | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: UpdatePaymentShippingAddressResponse | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: UpdatePaymentLocaleResponse | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: UpdatePaymentMethodResponse | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | UpdatePaymentMetadataResponse
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: UpdatePaymentCaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: UpdatePaymentApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<UpdatePaymentRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: UpdatePaymentSequenceType | null | undefined;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: UpdatePaymentStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: UpdatePaymentStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: UpdatePaymentLinks;
};

/** @internal */
export const UpdatePaymentMetadataRequest$inboundSchema: z.ZodType<
  UpdatePaymentMetadataRequest,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UpdatePaymentMetadataRequest$Outbound = {};

/** @internal */
export const UpdatePaymentMetadataRequest$outboundSchema: z.ZodType<
  UpdatePaymentMetadataRequest$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMetadataRequest
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMetadataRequest$ {
  /** @deprecated use `UpdatePaymentMetadataRequest$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMetadataRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentMetadataRequest$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMetadataRequest$outboundSchema;
  /** @deprecated use `UpdatePaymentMetadataRequest$Outbound` instead. */
  export type Outbound = UpdatePaymentMetadataRequest$Outbound;
}

export function updatePaymentMetadataRequestToJSON(
  updatePaymentMetadataRequest: UpdatePaymentMetadataRequest,
): string {
  return JSON.stringify(
    UpdatePaymentMetadataRequest$outboundSchema.parse(
      updatePaymentMetadataRequest,
    ),
  );
}

export function updatePaymentMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMetadataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentMetadataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMetadataRequest' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMetadataRequestUnion$inboundSchema: z.ZodType<
  UpdatePaymentMetadataRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePaymentMetadataRequest$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type UpdatePaymentMetadataRequestUnion$Outbound =
  | UpdatePaymentMetadataRequest$Outbound
  | string
  | Array<string>;

/** @internal */
export const UpdatePaymentMetadataRequestUnion$outboundSchema: z.ZodType<
  UpdatePaymentMetadataRequestUnion$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMetadataRequestUnion
> = z.union([
  z.lazy(() => UpdatePaymentMetadataRequest$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMetadataRequestUnion$ {
  /** @deprecated use `UpdatePaymentMetadataRequestUnion$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMetadataRequestUnion$inboundSchema;
  /** @deprecated use `UpdatePaymentMetadataRequestUnion$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentMetadataRequestUnion$outboundSchema;
  /** @deprecated use `UpdatePaymentMetadataRequestUnion$Outbound` instead. */
  export type Outbound = UpdatePaymentMetadataRequestUnion$Outbound;
}

export function updatePaymentMetadataRequestUnionToJSON(
  updatePaymentMetadataRequestUnion: UpdatePaymentMetadataRequestUnion,
): string {
  return JSON.stringify(
    UpdatePaymentMetadataRequestUnion$outboundSchema.parse(
      updatePaymentMetadataRequestUnion,
    ),
  );
}

export function updatePaymentMetadataRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMetadataRequestUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentMetadataRequestUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMetadataRequestUnion' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMethodRequest$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMethodRequest
> = z.nativeEnum(UpdatePaymentMethodRequest);

/** @internal */
export const UpdatePaymentMethodRequest$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMethodRequest
> = UpdatePaymentMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMethodRequest$ {
  /** @deprecated use `UpdatePaymentMethodRequest$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMethodRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentMethodRequest$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMethodRequest$outboundSchema;
}

/** @internal */
export const UpdatePaymentLocaleRequest$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLocaleRequest
> = z.nativeEnum(UpdatePaymentLocaleRequest);

/** @internal */
export const UpdatePaymentLocaleRequest$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLocaleRequest
> = UpdatePaymentLocaleRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentLocaleRequest$ {
  /** @deprecated use `UpdatePaymentLocaleRequest$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentLocaleRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentLocaleRequest$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentLocaleRequest$outboundSchema;
}

/** @internal */
export const UpdatePaymentBillingAddressRequest$inboundSchema: z.ZodType<
  UpdatePaymentBillingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type UpdatePaymentBillingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const UpdatePaymentBillingAddressRequest$outboundSchema: z.ZodType<
  UpdatePaymentBillingAddressRequest$Outbound,
  z.ZodTypeDef,
  UpdatePaymentBillingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentBillingAddressRequest$ {
  /** @deprecated use `UpdatePaymentBillingAddressRequest$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentBillingAddressRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentBillingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentBillingAddressRequest$outboundSchema;
  /** @deprecated use `UpdatePaymentBillingAddressRequest$Outbound` instead. */
  export type Outbound = UpdatePaymentBillingAddressRequest$Outbound;
}

export function updatePaymentBillingAddressRequestToJSON(
  updatePaymentBillingAddressRequest: UpdatePaymentBillingAddressRequest,
): string {
  return JSON.stringify(
    UpdatePaymentBillingAddressRequest$outboundSchema.parse(
      updatePaymentBillingAddressRequest,
    ),
  );
}

export function updatePaymentBillingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentBillingAddressRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentBillingAddressRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentBillingAddressRequest' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentShippingAddressRequest$inboundSchema: z.ZodType<
  UpdatePaymentShippingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type UpdatePaymentShippingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const UpdatePaymentShippingAddressRequest$outboundSchema: z.ZodType<
  UpdatePaymentShippingAddressRequest$Outbound,
  z.ZodTypeDef,
  UpdatePaymentShippingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentShippingAddressRequest$ {
  /** @deprecated use `UpdatePaymentShippingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    UpdatePaymentShippingAddressRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentShippingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentShippingAddressRequest$outboundSchema;
  /** @deprecated use `UpdatePaymentShippingAddressRequest$Outbound` instead. */
  export type Outbound = UpdatePaymentShippingAddressRequest$Outbound;
}

export function updatePaymentShippingAddressRequestToJSON(
  updatePaymentShippingAddressRequest: UpdatePaymentShippingAddressRequest,
): string {
  return JSON.stringify(
    UpdatePaymentShippingAddressRequest$outboundSchema.parse(
      updatePaymentShippingAddressRequest,
    ),
  );
}

export function updatePaymentShippingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentShippingAddressRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentShippingAddressRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentShippingAddressRequest' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRequestBody$inboundSchema: z.ZodType<
  UpdatePaymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => UpdatePaymentMetadataRequest$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  method: z.nullable(UpdatePaymentMethodRequest$inboundSchema).optional(),
  locale: UpdatePaymentLocaleRequest$inboundSchema.optional(),
  dueDate: z.string().optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
  issuer: z.nullable(z.string()).optional(),
  billingAddress: z.lazy(() => UpdatePaymentBillingAddressRequest$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() =>
    UpdatePaymentShippingAddressRequest$inboundSchema
  ).optional(),
  billingEmail: z.string().optional(),
});

/** @internal */
export type UpdatePaymentRequestBody$Outbound = {
  description?: string | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  metadata?:
    | UpdatePaymentMetadataRequest$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  method?: string | null | undefined;
  locale?: string | undefined;
  dueDate?: string | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  testmode?: boolean | null | undefined;
  issuer?: string | null | undefined;
  billingAddress?: UpdatePaymentBillingAddressRequest$Outbound | undefined;
  shippingAddress?: UpdatePaymentShippingAddressRequest$Outbound | undefined;
  billingEmail?: string | undefined;
};

/** @internal */
export const UpdatePaymentRequestBody$outboundSchema: z.ZodType<
  UpdatePaymentRequestBody$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRequestBody
> = z.object({
  description: z.string().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => UpdatePaymentMetadataRequest$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  method: z.nullable(UpdatePaymentMethodRequest$outboundSchema).optional(),
  locale: UpdatePaymentLocaleRequest$outboundSchema.optional(),
  dueDate: z.string().optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
  issuer: z.nullable(z.string()).optional(),
  billingAddress: z.lazy(() =>
    UpdatePaymentBillingAddressRequest$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    UpdatePaymentShippingAddressRequest$outboundSchema
  ).optional(),
  billingEmail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRequestBody$ {
  /** @deprecated use `UpdatePaymentRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRequestBody$inboundSchema;
  /** @deprecated use `UpdatePaymentRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRequestBody$outboundSchema;
  /** @deprecated use `UpdatePaymentRequestBody$Outbound` instead. */
  export type Outbound = UpdatePaymentRequestBody$Outbound;
}

export function updatePaymentRequestBodyToJSON(
  updatePaymentRequestBody: UpdatePaymentRequestBody,
): string {
  return JSON.stringify(
    UpdatePaymentRequestBody$outboundSchema.parse(updatePaymentRequestBody),
  );
}

export function updatePaymentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRequest$inboundSchema: z.ZodType<
  UpdatePaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string(),
  RequestBody: z.lazy(() => UpdatePaymentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdatePaymentRequest$Outbound = {
  paymentId: string;
  RequestBody?: UpdatePaymentRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdatePaymentRequest$outboundSchema: z.ZodType<
  UpdatePaymentRequest$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRequest
> = z.object({
  paymentId: z.string(),
  requestBody: z.lazy(() => UpdatePaymentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRequest$ {
  /** @deprecated use `UpdatePaymentRequest$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRequest$inboundSchema;
  /** @deprecated use `UpdatePaymentRequest$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRequest$outboundSchema;
  /** @deprecated use `UpdatePaymentRequest$Outbound` instead. */
  export type Outbound = UpdatePaymentRequest$Outbound;
}

export function updatePaymentRequestToJSON(
  updatePaymentRequest: UpdatePaymentRequest,
): string {
  return JSON.stringify(
    UpdatePaymentRequest$outboundSchema.parse(updatePaymentRequest),
  );
}

export function updatePaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRequest' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentUnprocessableEntityDocumentation$inboundSchema:
  z.ZodType<
    UpdatePaymentUnprocessableEntityDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type UpdatePaymentUnprocessableEntityDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentUnprocessableEntityDocumentation$outboundSchema:
  z.ZodType<
    UpdatePaymentUnprocessableEntityDocumentation$Outbound,
    z.ZodTypeDef,
    UpdatePaymentUnprocessableEntityDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentUnprocessableEntityDocumentation$ {
  /** @deprecated use `UpdatePaymentUnprocessableEntityDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    UpdatePaymentUnprocessableEntityDocumentation$inboundSchema;
  /** @deprecated use `UpdatePaymentUnprocessableEntityDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentUnprocessableEntityDocumentation$outboundSchema;
  /** @deprecated use `UpdatePaymentUnprocessableEntityDocumentation$Outbound` instead. */
  export type Outbound = UpdatePaymentUnprocessableEntityDocumentation$Outbound;
}

export function updatePaymentUnprocessableEntityDocumentationToJSON(
  updatePaymentUnprocessableEntityDocumentation:
    UpdatePaymentUnprocessableEntityDocumentation,
): string {
  return JSON.stringify(
    UpdatePaymentUnprocessableEntityDocumentation$outboundSchema.parse(
      updatePaymentUnprocessableEntityDocumentation,
    ),
  );
}

export function updatePaymentUnprocessableEntityDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePaymentUnprocessableEntityDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentUnprocessableEntityDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePaymentUnprocessableEntityDocumentation' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentUnprocessableEntityLinks$inboundSchema: z.ZodType<
  UpdatePaymentUnprocessableEntityLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    UpdatePaymentUnprocessableEntityDocumentation$inboundSchema
  ),
});

/** @internal */
export type UpdatePaymentUnprocessableEntityLinks$Outbound = {
  documentation: UpdatePaymentUnprocessableEntityDocumentation$Outbound;
};

/** @internal */
export const UpdatePaymentUnprocessableEntityLinks$outboundSchema: z.ZodType<
  UpdatePaymentUnprocessableEntityLinks$Outbound,
  z.ZodTypeDef,
  UpdatePaymentUnprocessableEntityLinks
> = z.object({
  documentation: z.lazy(() =>
    UpdatePaymentUnprocessableEntityDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentUnprocessableEntityLinks$ {
  /** @deprecated use `UpdatePaymentUnprocessableEntityLinks$inboundSchema` instead. */
  export const inboundSchema =
    UpdatePaymentUnprocessableEntityLinks$inboundSchema;
  /** @deprecated use `UpdatePaymentUnprocessableEntityLinks$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentUnprocessableEntityLinks$outboundSchema;
  /** @deprecated use `UpdatePaymentUnprocessableEntityLinks$Outbound` instead. */
  export type Outbound = UpdatePaymentUnprocessableEntityLinks$Outbound;
}

export function updatePaymentUnprocessableEntityLinksToJSON(
  updatePaymentUnprocessableEntityLinks: UpdatePaymentUnprocessableEntityLinks,
): string {
  return JSON.stringify(
    UpdatePaymentUnprocessableEntityLinks$outboundSchema.parse(
      updatePaymentUnprocessableEntityLinks,
    ),
  );
}

export function updatePaymentUnprocessableEntityLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentUnprocessableEntityLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentUnprocessableEntityLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentUnprocessableEntityLinks' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentNotFoundDocumentation$inboundSchema: z.ZodType<
  UpdatePaymentNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentNotFoundDocumentation$outboundSchema: z.ZodType<
  UpdatePaymentNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  UpdatePaymentNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentNotFoundDocumentation$ {
  /** @deprecated use `UpdatePaymentNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentNotFoundDocumentation$inboundSchema;
  /** @deprecated use `UpdatePaymentNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentNotFoundDocumentation$outboundSchema;
  /** @deprecated use `UpdatePaymentNotFoundDocumentation$Outbound` instead. */
  export type Outbound = UpdatePaymentNotFoundDocumentation$Outbound;
}

export function updatePaymentNotFoundDocumentationToJSON(
  updatePaymentNotFoundDocumentation: UpdatePaymentNotFoundDocumentation,
): string {
  return JSON.stringify(
    UpdatePaymentNotFoundDocumentation$outboundSchema.parse(
      updatePaymentNotFoundDocumentation,
    ),
  );
}

export function updatePaymentNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentNotFoundLinks$inboundSchema: z.ZodType<
  UpdatePaymentNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() => UpdatePaymentNotFoundDocumentation$inboundSchema),
});

/** @internal */
export type UpdatePaymentNotFoundLinks$Outbound = {
  documentation: UpdatePaymentNotFoundDocumentation$Outbound;
};

/** @internal */
export const UpdatePaymentNotFoundLinks$outboundSchema: z.ZodType<
  UpdatePaymentNotFoundLinks$Outbound,
  z.ZodTypeDef,
  UpdatePaymentNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    UpdatePaymentNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentNotFoundLinks$ {
  /** @deprecated use `UpdatePaymentNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentNotFoundLinks$inboundSchema;
  /** @deprecated use `UpdatePaymentNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentNotFoundLinks$outboundSchema;
  /** @deprecated use `UpdatePaymentNotFoundLinks$Outbound` instead. */
  export type Outbound = UpdatePaymentNotFoundLinks$Outbound;
}

export function updatePaymentNotFoundLinksToJSON(
  updatePaymentNotFoundLinks: UpdatePaymentNotFoundLinks,
): string {
  return JSON.stringify(
    UpdatePaymentNotFoundLinks$outboundSchema.parse(updatePaymentNotFoundLinks),
  );
}

export function updatePaymentNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMode
> = z.nativeEnum(UpdatePaymentMode);

/** @internal */
export const UpdatePaymentMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMode
> = UpdatePaymentMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMode$ {
  /** @deprecated use `UpdatePaymentMode$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMode$inboundSchema;
  /** @deprecated use `UpdatePaymentMode$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMode$outboundSchema;
}

/** @internal */
export const UpdatePaymentAmount$inboundSchema: z.ZodType<
  UpdatePaymentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentAmount$outboundSchema: z.ZodType<
  UpdatePaymentAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentAmount$ {
  /** @deprecated use `UpdatePaymentAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentAmount$Outbound;
}

export function updatePaymentAmountToJSON(
  updatePaymentAmount: UpdatePaymentAmount,
): string {
  return JSON.stringify(
    UpdatePaymentAmount$outboundSchema.parse(updatePaymentAmount),
  );
}

export function updatePaymentAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentAmountRefunded$inboundSchema: z.ZodType<
  UpdatePaymentAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentAmountRefunded$outboundSchema: z.ZodType<
  UpdatePaymentAmountRefunded$Outbound,
  z.ZodTypeDef,
  UpdatePaymentAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentAmountRefunded$ {
  /** @deprecated use `UpdatePaymentAmountRefunded$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentAmountRefunded$inboundSchema;
  /** @deprecated use `UpdatePaymentAmountRefunded$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentAmountRefunded$outboundSchema;
  /** @deprecated use `UpdatePaymentAmountRefunded$Outbound` instead. */
  export type Outbound = UpdatePaymentAmountRefunded$Outbound;
}

export function updatePaymentAmountRefundedToJSON(
  updatePaymentAmountRefunded: UpdatePaymentAmountRefunded,
): string {
  return JSON.stringify(
    UpdatePaymentAmountRefunded$outboundSchema.parse(
      updatePaymentAmountRefunded,
    ),
  );
}

export function updatePaymentAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentAmountRefunded' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentAmountRemaining$inboundSchema: z.ZodType<
  UpdatePaymentAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentAmountRemaining$outboundSchema: z.ZodType<
  UpdatePaymentAmountRemaining$Outbound,
  z.ZodTypeDef,
  UpdatePaymentAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentAmountRemaining$ {
  /** @deprecated use `UpdatePaymentAmountRemaining$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentAmountRemaining$inboundSchema;
  /** @deprecated use `UpdatePaymentAmountRemaining$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentAmountRemaining$outboundSchema;
  /** @deprecated use `UpdatePaymentAmountRemaining$Outbound` instead. */
  export type Outbound = UpdatePaymentAmountRemaining$Outbound;
}

export function updatePaymentAmountRemainingToJSON(
  updatePaymentAmountRemaining: UpdatePaymentAmountRemaining,
): string {
  return JSON.stringify(
    UpdatePaymentAmountRemaining$outboundSchema.parse(
      updatePaymentAmountRemaining,
    ),
  );
}

export function updatePaymentAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentAmountRemaining' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentAmountCaptured$inboundSchema: z.ZodType<
  UpdatePaymentAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentAmountCaptured$outboundSchema: z.ZodType<
  UpdatePaymentAmountCaptured$Outbound,
  z.ZodTypeDef,
  UpdatePaymentAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentAmountCaptured$ {
  /** @deprecated use `UpdatePaymentAmountCaptured$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentAmountCaptured$inboundSchema;
  /** @deprecated use `UpdatePaymentAmountCaptured$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentAmountCaptured$outboundSchema;
  /** @deprecated use `UpdatePaymentAmountCaptured$Outbound` instead. */
  export type Outbound = UpdatePaymentAmountCaptured$Outbound;
}

export function updatePaymentAmountCapturedToJSON(
  updatePaymentAmountCaptured: UpdatePaymentAmountCaptured,
): string {
  return JSON.stringify(
    UpdatePaymentAmountCaptured$outboundSchema.parse(
      updatePaymentAmountCaptured,
    ),
  );
}

export function updatePaymentAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentAmountCaptured' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentAmountChargedBack$inboundSchema: z.ZodType<
  UpdatePaymentAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentAmountChargedBack$outboundSchema: z.ZodType<
  UpdatePaymentAmountChargedBack$Outbound,
  z.ZodTypeDef,
  UpdatePaymentAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentAmountChargedBack$ {
  /** @deprecated use `UpdatePaymentAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentAmountChargedBack$inboundSchema;
  /** @deprecated use `UpdatePaymentAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentAmountChargedBack$outboundSchema;
  /** @deprecated use `UpdatePaymentAmountChargedBack$Outbound` instead. */
  export type Outbound = UpdatePaymentAmountChargedBack$Outbound;
}

export function updatePaymentAmountChargedBackToJSON(
  updatePaymentAmountChargedBack: UpdatePaymentAmountChargedBack,
): string {
  return JSON.stringify(
    UpdatePaymentAmountChargedBack$outboundSchema.parse(
      updatePaymentAmountChargedBack,
    ),
  );
}

export function updatePaymentAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentSettlementAmount$inboundSchema: z.ZodType<
  UpdatePaymentSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentSettlementAmount$outboundSchema: z.ZodType<
  UpdatePaymentSettlementAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentSettlementAmount$ {
  /** @deprecated use `UpdatePaymentSettlementAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentSettlementAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentSettlementAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentSettlementAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentSettlementAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentSettlementAmount$Outbound;
}

export function updatePaymentSettlementAmountToJSON(
  updatePaymentSettlementAmount: UpdatePaymentSettlementAmount,
): string {
  return JSON.stringify(
    UpdatePaymentSettlementAmount$outboundSchema.parse(
      updatePaymentSettlementAmount,
    ),
  );
}

export function updatePaymentSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentSettlementAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentLineType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLineType
> = z.nativeEnum(UpdatePaymentLineType);

/** @internal */
export const UpdatePaymentLineType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLineType
> = UpdatePaymentLineType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentLineType$ {
  /** @deprecated use `UpdatePaymentLineType$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentLineType$inboundSchema;
  /** @deprecated use `UpdatePaymentLineType$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentLineType$outboundSchema;
}

/** @internal */
export const UpdatePaymentUnitPrice$inboundSchema: z.ZodType<
  UpdatePaymentUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentUnitPrice$outboundSchema: z.ZodType<
  UpdatePaymentUnitPrice$Outbound,
  z.ZodTypeDef,
  UpdatePaymentUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentUnitPrice$ {
  /** @deprecated use `UpdatePaymentUnitPrice$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentUnitPrice$inboundSchema;
  /** @deprecated use `UpdatePaymentUnitPrice$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentUnitPrice$outboundSchema;
  /** @deprecated use `UpdatePaymentUnitPrice$Outbound` instead. */
  export type Outbound = UpdatePaymentUnitPrice$Outbound;
}

export function updatePaymentUnitPriceToJSON(
  updatePaymentUnitPrice: UpdatePaymentUnitPrice,
): string {
  return JSON.stringify(
    UpdatePaymentUnitPrice$outboundSchema.parse(updatePaymentUnitPrice),
  );
}

export function updatePaymentUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentUnitPrice' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentDiscountAmount$inboundSchema: z.ZodType<
  UpdatePaymentDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentDiscountAmount$outboundSchema: z.ZodType<
  UpdatePaymentDiscountAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentDiscountAmount$ {
  /** @deprecated use `UpdatePaymentDiscountAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentDiscountAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentDiscountAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentDiscountAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentDiscountAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentDiscountAmount$Outbound;
}

export function updatePaymentDiscountAmountToJSON(
  updatePaymentDiscountAmount: UpdatePaymentDiscountAmount,
): string {
  return JSON.stringify(
    UpdatePaymentDiscountAmount$outboundSchema.parse(
      updatePaymentDiscountAmount,
    ),
  );
}

export function updatePaymentDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentDiscountAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentTotalAmount$inboundSchema: z.ZodType<
  UpdatePaymentTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentTotalAmount$outboundSchema: z.ZodType<
  UpdatePaymentTotalAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentTotalAmount$ {
  /** @deprecated use `UpdatePaymentTotalAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentTotalAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentTotalAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentTotalAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentTotalAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentTotalAmount$Outbound;
}

export function updatePaymentTotalAmountToJSON(
  updatePaymentTotalAmount: UpdatePaymentTotalAmount,
): string {
  return JSON.stringify(
    UpdatePaymentTotalAmount$outboundSchema.parse(updatePaymentTotalAmount),
  );
}

export function updatePaymentTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentTotalAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentVatAmount$inboundSchema: z.ZodType<
  UpdatePaymentVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentVatAmount$outboundSchema: z.ZodType<
  UpdatePaymentVatAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentVatAmount$ {
  /** @deprecated use `UpdatePaymentVatAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentVatAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentVatAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentVatAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentVatAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentVatAmount$Outbound;
}

export function updatePaymentVatAmountToJSON(
  updatePaymentVatAmount: UpdatePaymentVatAmount,
): string {
  return JSON.stringify(
    UpdatePaymentVatAmount$outboundSchema.parse(updatePaymentVatAmount),
  );
}

export function updatePaymentVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentVatAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentCategory$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentCategory
> = z.nativeEnum(UpdatePaymentCategory);

/** @internal */
export const UpdatePaymentCategory$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentCategory
> = UpdatePaymentCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentCategory$ {
  /** @deprecated use `UpdatePaymentCategory$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentCategory$inboundSchema;
  /** @deprecated use `UpdatePaymentCategory$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentCategory$outboundSchema;
}

/** @internal */
export const UpdatePaymentInterval$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentInterval
> = z.nativeEnum(UpdatePaymentInterval);

/** @internal */
export const UpdatePaymentInterval$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentInterval
> = UpdatePaymentInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentInterval$ {
  /** @deprecated use `UpdatePaymentInterval$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentInterval$inboundSchema;
  /** @deprecated use `UpdatePaymentInterval$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentInterval$outboundSchema;
}

/** @internal */
export const UpdatePaymentRecurringAmount$inboundSchema: z.ZodType<
  UpdatePaymentRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentRecurringAmount$outboundSchema: z.ZodType<
  UpdatePaymentRecurringAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRecurringAmount$ {
  /** @deprecated use `UpdatePaymentRecurringAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRecurringAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentRecurringAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRecurringAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentRecurringAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentRecurringAmount$Outbound;
}

export function updatePaymentRecurringAmountToJSON(
  updatePaymentRecurringAmount: UpdatePaymentRecurringAmount,
): string {
  return JSON.stringify(
    UpdatePaymentRecurringAmount$outboundSchema.parse(
      updatePaymentRecurringAmount,
    ),
  );
}

export function updatePaymentRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRecurringAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRecurringAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRecurringAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRecurring$inboundSchema: z.ZodType<
  UpdatePaymentRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: UpdatePaymentInterval$inboundSchema,
  amount: z.lazy(() => UpdatePaymentRecurringAmount$inboundSchema).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type UpdatePaymentRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: UpdatePaymentRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const UpdatePaymentRecurring$outboundSchema: z.ZodType<
  UpdatePaymentRecurring$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRecurring
> = z.object({
  description: z.string().optional(),
  interval: UpdatePaymentInterval$outboundSchema,
  amount: z.lazy(() => UpdatePaymentRecurringAmount$outboundSchema).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRecurring$ {
  /** @deprecated use `UpdatePaymentRecurring$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRecurring$inboundSchema;
  /** @deprecated use `UpdatePaymentRecurring$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRecurring$outboundSchema;
  /** @deprecated use `UpdatePaymentRecurring$Outbound` instead. */
  export type Outbound = UpdatePaymentRecurring$Outbound;
}

export function updatePaymentRecurringToJSON(
  updatePaymentRecurring: UpdatePaymentRecurring,
): string {
  return JSON.stringify(
    UpdatePaymentRecurring$outboundSchema.parse(updatePaymentRecurring),
  );
}

export function updatePaymentRecurringFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRecurring' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentLine$inboundSchema: z.ZodType<
  UpdatePaymentLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdatePaymentLineType$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => UpdatePaymentUnitPrice$inboundSchema),
  discountAmount: z.lazy(() => UpdatePaymentDiscountAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => UpdatePaymentTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => UpdatePaymentVatAmount$inboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(UpdatePaymentCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => UpdatePaymentRecurring$inboundSchema).optional(),
});

/** @internal */
export type UpdatePaymentLine$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: UpdatePaymentUnitPrice$Outbound;
  discountAmount?: UpdatePaymentDiscountAmount$Outbound | undefined;
  totalAmount: UpdatePaymentTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: UpdatePaymentVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: UpdatePaymentRecurring$Outbound | undefined;
};

/** @internal */
export const UpdatePaymentLine$outboundSchema: z.ZodType<
  UpdatePaymentLine$Outbound,
  z.ZodTypeDef,
  UpdatePaymentLine
> = z.object({
  type: UpdatePaymentLineType$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => UpdatePaymentUnitPrice$outboundSchema),
  discountAmount: z.lazy(() => UpdatePaymentDiscountAmount$outboundSchema)
    .optional(),
  totalAmount: z.lazy(() => UpdatePaymentTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => UpdatePaymentVatAmount$outboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(UpdatePaymentCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => UpdatePaymentRecurring$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentLine$ {
  /** @deprecated use `UpdatePaymentLine$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentLine$inboundSchema;
  /** @deprecated use `UpdatePaymentLine$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentLine$outboundSchema;
  /** @deprecated use `UpdatePaymentLine$Outbound` instead. */
  export type Outbound = UpdatePaymentLine$Outbound;
}

export function updatePaymentLineToJSON(
  updatePaymentLine: UpdatePaymentLine,
): string {
  return JSON.stringify(
    UpdatePaymentLine$outboundSchema.parse(updatePaymentLine),
  );
}

export function updatePaymentLineFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentLine' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentBillingAddressResponse$inboundSchema: z.ZodType<
  UpdatePaymentBillingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type UpdatePaymentBillingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const UpdatePaymentBillingAddressResponse$outboundSchema: z.ZodType<
  UpdatePaymentBillingAddressResponse$Outbound,
  z.ZodTypeDef,
  UpdatePaymentBillingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentBillingAddressResponse$ {
  /** @deprecated use `UpdatePaymentBillingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    UpdatePaymentBillingAddressResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentBillingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentBillingAddressResponse$outboundSchema;
  /** @deprecated use `UpdatePaymentBillingAddressResponse$Outbound` instead. */
  export type Outbound = UpdatePaymentBillingAddressResponse$Outbound;
}

export function updatePaymentBillingAddressResponseToJSON(
  updatePaymentBillingAddressResponse: UpdatePaymentBillingAddressResponse,
): string {
  return JSON.stringify(
    UpdatePaymentBillingAddressResponse$outboundSchema.parse(
      updatePaymentBillingAddressResponse,
    ),
  );
}

export function updatePaymentBillingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentBillingAddressResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentBillingAddressResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentBillingAddressResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentShippingAddressResponse$inboundSchema: z.ZodType<
  UpdatePaymentShippingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type UpdatePaymentShippingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const UpdatePaymentShippingAddressResponse$outboundSchema: z.ZodType<
  UpdatePaymentShippingAddressResponse$Outbound,
  z.ZodTypeDef,
  UpdatePaymentShippingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentShippingAddressResponse$ {
  /** @deprecated use `UpdatePaymentShippingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    UpdatePaymentShippingAddressResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentShippingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentShippingAddressResponse$outboundSchema;
  /** @deprecated use `UpdatePaymentShippingAddressResponse$Outbound` instead. */
  export type Outbound = UpdatePaymentShippingAddressResponse$Outbound;
}

export function updatePaymentShippingAddressResponseToJSON(
  updatePaymentShippingAddressResponse: UpdatePaymentShippingAddressResponse,
): string {
  return JSON.stringify(
    UpdatePaymentShippingAddressResponse$outboundSchema.parse(
      updatePaymentShippingAddressResponse,
    ),
  );
}

export function updatePaymentShippingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentShippingAddressResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentShippingAddressResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentShippingAddressResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentLocaleResponse$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLocaleResponse
> = z.nativeEnum(UpdatePaymentLocaleResponse);

/** @internal */
export const UpdatePaymentLocaleResponse$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentLocaleResponse
> = UpdatePaymentLocaleResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentLocaleResponse$ {
  /** @deprecated use `UpdatePaymentLocaleResponse$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentLocaleResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentLocaleResponse$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentLocaleResponse$outboundSchema;
}

/** @internal */
export const UpdatePaymentMethodResponse$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMethodResponse
> = z.nativeEnum(UpdatePaymentMethodResponse);

/** @internal */
export const UpdatePaymentMethodResponse$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentMethodResponse
> = UpdatePaymentMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMethodResponse$ {
  /** @deprecated use `UpdatePaymentMethodResponse$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMethodResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentMethodResponse$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMethodResponse$outboundSchema;
}

/** @internal */
export const UpdatePaymentMetadataResponse$inboundSchema: z.ZodType<
  UpdatePaymentMetadataResponse,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UpdatePaymentMetadataResponse$Outbound = {};

/** @internal */
export const UpdatePaymentMetadataResponse$outboundSchema: z.ZodType<
  UpdatePaymentMetadataResponse$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMetadataResponse
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMetadataResponse$ {
  /** @deprecated use `UpdatePaymentMetadataResponse$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMetadataResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentMetadataResponse$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMetadataResponse$outboundSchema;
  /** @deprecated use `UpdatePaymentMetadataResponse$Outbound` instead. */
  export type Outbound = UpdatePaymentMetadataResponse$Outbound;
}

export function updatePaymentMetadataResponseToJSON(
  updatePaymentMetadataResponse: UpdatePaymentMetadataResponse,
): string {
  return JSON.stringify(
    UpdatePaymentMetadataResponse$outboundSchema.parse(
      updatePaymentMetadataResponse,
    ),
  );
}

export function updatePaymentMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMetadataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentMetadataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMetadataResponse' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMetadataResponseUnion$inboundSchema: z.ZodType<
  UpdatePaymentMetadataResponseUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePaymentMetadataResponse$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type UpdatePaymentMetadataResponseUnion$Outbound =
  | UpdatePaymentMetadataResponse$Outbound
  | string
  | Array<string>;

/** @internal */
export const UpdatePaymentMetadataResponseUnion$outboundSchema: z.ZodType<
  UpdatePaymentMetadataResponseUnion$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMetadataResponseUnion
> = z.union([
  z.lazy(() => UpdatePaymentMetadataResponse$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMetadataResponseUnion$ {
  /** @deprecated use `UpdatePaymentMetadataResponseUnion$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMetadataResponseUnion$inboundSchema;
  /** @deprecated use `UpdatePaymentMetadataResponseUnion$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentMetadataResponseUnion$outboundSchema;
  /** @deprecated use `UpdatePaymentMetadataResponseUnion$Outbound` instead. */
  export type Outbound = UpdatePaymentMetadataResponseUnion$Outbound;
}

export function updatePaymentMetadataResponseUnionToJSON(
  updatePaymentMetadataResponseUnion: UpdatePaymentMetadataResponseUnion,
): string {
  return JSON.stringify(
    UpdatePaymentMetadataResponseUnion$outboundSchema.parse(
      updatePaymentMetadataResponseUnion,
    ),
  );
}

export function updatePaymentMetadataResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMetadataResponseUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePaymentMetadataResponseUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMetadataResponseUnion' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentCaptureMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentCaptureMode
> = z.nativeEnum(UpdatePaymentCaptureMode);

/** @internal */
export const UpdatePaymentCaptureMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentCaptureMode
> = UpdatePaymentCaptureMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentCaptureMode$ {
  /** @deprecated use `UpdatePaymentCaptureMode$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentCaptureMode$inboundSchema;
  /** @deprecated use `UpdatePaymentCaptureMode$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentCaptureMode$outboundSchema;
}

/** @internal */
export const UpdatePaymentApplicationFeeAmount$inboundSchema: z.ZodType<
  UpdatePaymentApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentApplicationFeeAmount$outboundSchema: z.ZodType<
  UpdatePaymentApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentApplicationFeeAmount$ {
  /** @deprecated use `UpdatePaymentApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentApplicationFeeAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    UpdatePaymentApplicationFeeAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentApplicationFeeAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentApplicationFeeAmount$Outbound;
}

export function updatePaymentApplicationFeeAmountToJSON(
  updatePaymentApplicationFeeAmount: UpdatePaymentApplicationFeeAmount,
): string {
  return JSON.stringify(
    UpdatePaymentApplicationFeeAmount$outboundSchema.parse(
      updatePaymentApplicationFeeAmount,
    ),
  );
}

export function updatePaymentApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentApplicationFee$inboundSchema: z.ZodType<
  UpdatePaymentApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => UpdatePaymentApplicationFeeAmount$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type UpdatePaymentApplicationFee$Outbound = {
  amount?: UpdatePaymentApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const UpdatePaymentApplicationFee$outboundSchema: z.ZodType<
  UpdatePaymentApplicationFee$Outbound,
  z.ZodTypeDef,
  UpdatePaymentApplicationFee
> = z.object({
  amount: z.lazy(() => UpdatePaymentApplicationFeeAmount$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentApplicationFee$ {
  /** @deprecated use `UpdatePaymentApplicationFee$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentApplicationFee$inboundSchema;
  /** @deprecated use `UpdatePaymentApplicationFee$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentApplicationFee$outboundSchema;
  /** @deprecated use `UpdatePaymentApplicationFee$Outbound` instead. */
  export type Outbound = UpdatePaymentApplicationFee$Outbound;
}

export function updatePaymentApplicationFeeToJSON(
  updatePaymentApplicationFee: UpdatePaymentApplicationFee,
): string {
  return JSON.stringify(
    UpdatePaymentApplicationFee$outboundSchema.parse(
      updatePaymentApplicationFee,
    ),
  );
}

export function updatePaymentApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentApplicationFee' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentRoutingMode
> = z.nativeEnum(UpdatePaymentRoutingMode);

/** @internal */
export const UpdatePaymentRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentRoutingMode
> = UpdatePaymentRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRoutingMode$ {
  /** @deprecated use `UpdatePaymentRoutingMode$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRoutingMode$inboundSchema;
  /** @deprecated use `UpdatePaymentRoutingMode$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRoutingMode$outboundSchema;
}

/** @internal */
export const UpdatePaymentRoutingAmount$inboundSchema: z.ZodType<
  UpdatePaymentRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdatePaymentRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdatePaymentRoutingAmount$outboundSchema: z.ZodType<
  UpdatePaymentRoutingAmount$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRoutingAmount$ {
  /** @deprecated use `UpdatePaymentRoutingAmount$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRoutingAmount$inboundSchema;
  /** @deprecated use `UpdatePaymentRoutingAmount$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRoutingAmount$outboundSchema;
  /** @deprecated use `UpdatePaymentRoutingAmount$Outbound` instead. */
  export type Outbound = UpdatePaymentRoutingAmount$Outbound;
}

export function updatePaymentRoutingAmountToJSON(
  updatePaymentRoutingAmount: UpdatePaymentRoutingAmount,
): string {
  return JSON.stringify(
    UpdatePaymentRoutingAmount$outboundSchema.parse(updatePaymentRoutingAmount),
  );
}

export function updatePaymentRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRoutingAmount' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentRoutingType
> = z.nativeEnum(UpdatePaymentRoutingType);

/** @internal */
export const UpdatePaymentRoutingType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentRoutingType
> = UpdatePaymentRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRoutingType$ {
  /** @deprecated use `UpdatePaymentRoutingType$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRoutingType$inboundSchema;
  /** @deprecated use `UpdatePaymentRoutingType$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRoutingType$outboundSchema;
}

/** @internal */
export const UpdatePaymentDestination$inboundSchema: z.ZodType<
  UpdatePaymentDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdatePaymentRoutingType$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type UpdatePaymentDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const UpdatePaymentDestination$outboundSchema: z.ZodType<
  UpdatePaymentDestination$Outbound,
  z.ZodTypeDef,
  UpdatePaymentDestination
> = z.object({
  type: UpdatePaymentRoutingType$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentDestination$ {
  /** @deprecated use `UpdatePaymentDestination$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentDestination$inboundSchema;
  /** @deprecated use `UpdatePaymentDestination$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentDestination$outboundSchema;
  /** @deprecated use `UpdatePaymentDestination$Outbound` instead. */
  export type Outbound = UpdatePaymentDestination$Outbound;
}

export function updatePaymentDestinationToJSON(
  updatePaymentDestination: UpdatePaymentDestination,
): string {
  return JSON.stringify(
    UpdatePaymentDestination$outboundSchema.parse(updatePaymentDestination),
  );
}

export function updatePaymentDestinationFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentDestination' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRoutingSelf$inboundSchema: z.ZodType<
  UpdatePaymentRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentRoutingSelf$outboundSchema: z.ZodType<
  UpdatePaymentRoutingSelf$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRoutingSelf$ {
  /** @deprecated use `UpdatePaymentRoutingSelf$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRoutingSelf$inboundSchema;
  /** @deprecated use `UpdatePaymentRoutingSelf$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRoutingSelf$outboundSchema;
  /** @deprecated use `UpdatePaymentRoutingSelf$Outbound` instead. */
  export type Outbound = UpdatePaymentRoutingSelf$Outbound;
}

export function updatePaymentRoutingSelfToJSON(
  updatePaymentRoutingSelf: UpdatePaymentRoutingSelf,
): string {
  return JSON.stringify(
    UpdatePaymentRoutingSelf$outboundSchema.parse(updatePaymentRoutingSelf),
  );
}

export function updatePaymentRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRoutingSelf' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentPayment$inboundSchema: z.ZodType<
  UpdatePaymentPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentPayment$outboundSchema: z.ZodType<
  UpdatePaymentPayment$Outbound,
  z.ZodTypeDef,
  UpdatePaymentPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentPayment$ {
  /** @deprecated use `UpdatePaymentPayment$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentPayment$inboundSchema;
  /** @deprecated use `UpdatePaymentPayment$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentPayment$outboundSchema;
  /** @deprecated use `UpdatePaymentPayment$Outbound` instead. */
  export type Outbound = UpdatePaymentPayment$Outbound;
}

export function updatePaymentPaymentToJSON(
  updatePaymentPayment: UpdatePaymentPayment,
): string {
  return JSON.stringify(
    UpdatePaymentPayment$outboundSchema.parse(updatePaymentPayment),
  );
}

export function updatePaymentPaymentFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentPayment' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRoutingLinks$inboundSchema: z.ZodType<
  UpdatePaymentRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => UpdatePaymentRoutingSelf$inboundSchema),
  payment: z.lazy(() => UpdatePaymentPayment$inboundSchema),
});

/** @internal */
export type UpdatePaymentRoutingLinks$Outbound = {
  self: UpdatePaymentRoutingSelf$Outbound;
  payment: UpdatePaymentPayment$Outbound;
};

/** @internal */
export const UpdatePaymentRoutingLinks$outboundSchema: z.ZodType<
  UpdatePaymentRoutingLinks$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRoutingLinks
> = z.object({
  self: z.lazy(() => UpdatePaymentRoutingSelf$outboundSchema),
  payment: z.lazy(() => UpdatePaymentPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRoutingLinks$ {
  /** @deprecated use `UpdatePaymentRoutingLinks$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRoutingLinks$inboundSchema;
  /** @deprecated use `UpdatePaymentRoutingLinks$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRoutingLinks$outboundSchema;
  /** @deprecated use `UpdatePaymentRoutingLinks$Outbound` instead. */
  export type Outbound = UpdatePaymentRoutingLinks$Outbound;
}

export function updatePaymentRoutingLinksToJSON(
  updatePaymentRoutingLinks: UpdatePaymentRoutingLinks,
): string {
  return JSON.stringify(
    UpdatePaymentRoutingLinks$outboundSchema.parse(updatePaymentRoutingLinks),
  );
}

export function updatePaymentRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRoutingLinks' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRouting$inboundSchema: z.ZodType<
  UpdatePaymentRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdatePaymentRoutingMode$inboundSchema,
  amount: z.lazy(() => UpdatePaymentRoutingAmount$inboundSchema),
  destination: z.lazy(() => UpdatePaymentDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => UpdatePaymentRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type UpdatePaymentRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: UpdatePaymentRoutingAmount$Outbound;
  destination: UpdatePaymentDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: UpdatePaymentRoutingLinks$Outbound;
};

/** @internal */
export const UpdatePaymentRouting$outboundSchema: z.ZodType<
  UpdatePaymentRouting$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdatePaymentRoutingMode$outboundSchema,
  amount: z.lazy(() => UpdatePaymentRoutingAmount$outboundSchema),
  destination: z.lazy(() => UpdatePaymentDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => UpdatePaymentRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRouting$ {
  /** @deprecated use `UpdatePaymentRouting$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRouting$inboundSchema;
  /** @deprecated use `UpdatePaymentRouting$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRouting$outboundSchema;
  /** @deprecated use `UpdatePaymentRouting$Outbound` instead. */
  export type Outbound = UpdatePaymentRouting$Outbound;
}

export function updatePaymentRoutingToJSON(
  updatePaymentRouting: UpdatePaymentRouting,
): string {
  return JSON.stringify(
    UpdatePaymentRouting$outboundSchema.parse(updatePaymentRouting),
  );
}

export function updatePaymentRoutingFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRouting' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentSequenceType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentSequenceType
> = z.nativeEnum(UpdatePaymentSequenceType);

/** @internal */
export const UpdatePaymentSequenceType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentSequenceType
> = UpdatePaymentSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentSequenceType$ {
  /** @deprecated use `UpdatePaymentSequenceType$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentSequenceType$inboundSchema;
  /** @deprecated use `UpdatePaymentSequenceType$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentSequenceType$outboundSchema;
}

/** @internal */
export const UpdatePaymentStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentStatus
> = z.nativeEnum(UpdatePaymentStatus);

/** @internal */
export const UpdatePaymentStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePaymentStatus
> = UpdatePaymentStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentStatus$ {
  /** @deprecated use `UpdatePaymentStatus$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentStatus$inboundSchema;
  /** @deprecated use `UpdatePaymentStatus$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentStatus$outboundSchema;
}

/** @internal */
export const UpdatePaymentStatusReason$inboundSchema: z.ZodType<
  UpdatePaymentStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type UpdatePaymentStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const UpdatePaymentStatusReason$outboundSchema: z.ZodType<
  UpdatePaymentStatusReason$Outbound,
  z.ZodTypeDef,
  UpdatePaymentStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentStatusReason$ {
  /** @deprecated use `UpdatePaymentStatusReason$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentStatusReason$inboundSchema;
  /** @deprecated use `UpdatePaymentStatusReason$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentStatusReason$outboundSchema;
  /** @deprecated use `UpdatePaymentStatusReason$Outbound` instead. */
  export type Outbound = UpdatePaymentStatusReason$Outbound;
}

export function updatePaymentStatusReasonToJSON(
  updatePaymentStatusReason: UpdatePaymentStatusReason,
): string {
  return JSON.stringify(
    UpdatePaymentStatusReason$outboundSchema.parse(updatePaymentStatusReason),
  );
}

export function updatePaymentStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentStatusReason' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentSelf$inboundSchema: z.ZodType<
  UpdatePaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentSelf$outboundSchema: z.ZodType<
  UpdatePaymentSelf$Outbound,
  z.ZodTypeDef,
  UpdatePaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentSelf$ {
  /** @deprecated use `UpdatePaymentSelf$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentSelf$inboundSchema;
  /** @deprecated use `UpdatePaymentSelf$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentSelf$outboundSchema;
  /** @deprecated use `UpdatePaymentSelf$Outbound` instead. */
  export type Outbound = UpdatePaymentSelf$Outbound;
}

export function updatePaymentSelfToJSON(
  updatePaymentSelf: UpdatePaymentSelf,
): string {
  return JSON.stringify(
    UpdatePaymentSelf$outboundSchema.parse(updatePaymentSelf),
  );
}

export function updatePaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentSelf' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentCheckout$inboundSchema: z.ZodType<
  UpdatePaymentCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentCheckout$outboundSchema: z.ZodType<
  UpdatePaymentCheckout$Outbound,
  z.ZodTypeDef,
  UpdatePaymentCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentCheckout$ {
  /** @deprecated use `UpdatePaymentCheckout$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentCheckout$inboundSchema;
  /** @deprecated use `UpdatePaymentCheckout$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentCheckout$outboundSchema;
  /** @deprecated use `UpdatePaymentCheckout$Outbound` instead. */
  export type Outbound = UpdatePaymentCheckout$Outbound;
}

export function updatePaymentCheckoutToJSON(
  updatePaymentCheckout: UpdatePaymentCheckout,
): string {
  return JSON.stringify(
    UpdatePaymentCheckout$outboundSchema.parse(updatePaymentCheckout),
  );
}

export function updatePaymentCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentCheckout' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMobileAppCheckout$inboundSchema: z.ZodType<
  UpdatePaymentMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentMobileAppCheckout$outboundSchema: z.ZodType<
  UpdatePaymentMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMobileAppCheckout$ {
  /** @deprecated use `UpdatePaymentMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMobileAppCheckout$inboundSchema;
  /** @deprecated use `UpdatePaymentMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMobileAppCheckout$outboundSchema;
  /** @deprecated use `UpdatePaymentMobileAppCheckout$Outbound` instead. */
  export type Outbound = UpdatePaymentMobileAppCheckout$Outbound;
}

export function updatePaymentMobileAppCheckoutToJSON(
  updatePaymentMobileAppCheckout: UpdatePaymentMobileAppCheckout,
): string {
  return JSON.stringify(
    UpdatePaymentMobileAppCheckout$outboundSchema.parse(
      updatePaymentMobileAppCheckout,
    ),
  );
}

export function updatePaymentMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentChangePaymentState$inboundSchema: z.ZodType<
  UpdatePaymentChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentChangePaymentState$outboundSchema: z.ZodType<
  UpdatePaymentChangePaymentState$Outbound,
  z.ZodTypeDef,
  UpdatePaymentChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentChangePaymentState$ {
  /** @deprecated use `UpdatePaymentChangePaymentState$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentChangePaymentState$inboundSchema;
  /** @deprecated use `UpdatePaymentChangePaymentState$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentChangePaymentState$outboundSchema;
  /** @deprecated use `UpdatePaymentChangePaymentState$Outbound` instead. */
  export type Outbound = UpdatePaymentChangePaymentState$Outbound;
}

export function updatePaymentChangePaymentStateToJSON(
  updatePaymentChangePaymentState: UpdatePaymentChangePaymentState,
): string {
  return JSON.stringify(
    UpdatePaymentChangePaymentState$outboundSchema.parse(
      updatePaymentChangePaymentState,
    ),
  );
}

export function updatePaymentChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentChangePaymentState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentChangePaymentState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentChangePaymentState' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentDashboard$inboundSchema: z.ZodType<
  UpdatePaymentDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentDashboard$outboundSchema: z.ZodType<
  UpdatePaymentDashboard$Outbound,
  z.ZodTypeDef,
  UpdatePaymentDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentDashboard$ {
  /** @deprecated use `UpdatePaymentDashboard$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentDashboard$inboundSchema;
  /** @deprecated use `UpdatePaymentDashboard$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentDashboard$outboundSchema;
  /** @deprecated use `UpdatePaymentDashboard$Outbound` instead. */
  export type Outbound = UpdatePaymentDashboard$Outbound;
}

export function updatePaymentDashboardToJSON(
  updatePaymentDashboard: UpdatePaymentDashboard,
): string {
  return JSON.stringify(
    UpdatePaymentDashboard$outboundSchema.parse(updatePaymentDashboard),
  );
}

export function updatePaymentDashboardFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentDashboard' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRefunds$inboundSchema: z.ZodType<
  UpdatePaymentRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentRefunds$outboundSchema: z.ZodType<
  UpdatePaymentRefunds$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentRefunds$ {
  /** @deprecated use `UpdatePaymentRefunds$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentRefunds$inboundSchema;
  /** @deprecated use `UpdatePaymentRefunds$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentRefunds$outboundSchema;
  /** @deprecated use `UpdatePaymentRefunds$Outbound` instead. */
  export type Outbound = UpdatePaymentRefunds$Outbound;
}

export function updatePaymentRefundsToJSON(
  updatePaymentRefunds: UpdatePaymentRefunds,
): string {
  return JSON.stringify(
    UpdatePaymentRefunds$outboundSchema.parse(updatePaymentRefunds),
  );
}

export function updatePaymentRefundsFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRefunds' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentChargebacks$inboundSchema: z.ZodType<
  UpdatePaymentChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentChargebacks$outboundSchema: z.ZodType<
  UpdatePaymentChargebacks$Outbound,
  z.ZodTypeDef,
  UpdatePaymentChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentChargebacks$ {
  /** @deprecated use `UpdatePaymentChargebacks$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentChargebacks$inboundSchema;
  /** @deprecated use `UpdatePaymentChargebacks$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentChargebacks$outboundSchema;
  /** @deprecated use `UpdatePaymentChargebacks$Outbound` instead. */
  export type Outbound = UpdatePaymentChargebacks$Outbound;
}

export function updatePaymentChargebacksToJSON(
  updatePaymentChargebacks: UpdatePaymentChargebacks,
): string {
  return JSON.stringify(
    UpdatePaymentChargebacks$outboundSchema.parse(updatePaymentChargebacks),
  );
}

export function updatePaymentChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentChargebacks' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentCaptures$inboundSchema: z.ZodType<
  UpdatePaymentCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentCaptures$outboundSchema: z.ZodType<
  UpdatePaymentCaptures$Outbound,
  z.ZodTypeDef,
  UpdatePaymentCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentCaptures$ {
  /** @deprecated use `UpdatePaymentCaptures$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentCaptures$inboundSchema;
  /** @deprecated use `UpdatePaymentCaptures$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentCaptures$outboundSchema;
  /** @deprecated use `UpdatePaymentCaptures$Outbound` instead. */
  export type Outbound = UpdatePaymentCaptures$Outbound;
}

export function updatePaymentCapturesToJSON(
  updatePaymentCaptures: UpdatePaymentCaptures,
): string {
  return JSON.stringify(
    UpdatePaymentCaptures$outboundSchema.parse(updatePaymentCaptures),
  );
}

export function updatePaymentCapturesFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentCaptures' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentSettlement$inboundSchema: z.ZodType<
  UpdatePaymentSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentSettlement$outboundSchema: z.ZodType<
  UpdatePaymentSettlement$Outbound,
  z.ZodTypeDef,
  UpdatePaymentSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentSettlement$ {
  /** @deprecated use `UpdatePaymentSettlement$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentSettlement$inboundSchema;
  /** @deprecated use `UpdatePaymentSettlement$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentSettlement$outboundSchema;
  /** @deprecated use `UpdatePaymentSettlement$Outbound` instead. */
  export type Outbound = UpdatePaymentSettlement$Outbound;
}

export function updatePaymentSettlementToJSON(
  updatePaymentSettlement: UpdatePaymentSettlement,
): string {
  return JSON.stringify(
    UpdatePaymentSettlement$outboundSchema.parse(updatePaymentSettlement),
  );
}

export function updatePaymentSettlementFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentSettlement' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentCustomer$inboundSchema: z.ZodType<
  UpdatePaymentCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentCustomer$outboundSchema: z.ZodType<
  UpdatePaymentCustomer$Outbound,
  z.ZodTypeDef,
  UpdatePaymentCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentCustomer$ {
  /** @deprecated use `UpdatePaymentCustomer$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentCustomer$inboundSchema;
  /** @deprecated use `UpdatePaymentCustomer$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentCustomer$outboundSchema;
  /** @deprecated use `UpdatePaymentCustomer$Outbound` instead. */
  export type Outbound = UpdatePaymentCustomer$Outbound;
}

export function updatePaymentCustomerToJSON(
  updatePaymentCustomer: UpdatePaymentCustomer,
): string {
  return JSON.stringify(
    UpdatePaymentCustomer$outboundSchema.parse(updatePaymentCustomer),
  );
}

export function updatePaymentCustomerFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentCustomer' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentMandate$inboundSchema: z.ZodType<
  UpdatePaymentMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentMandate$outboundSchema: z.ZodType<
  UpdatePaymentMandate$Outbound,
  z.ZodTypeDef,
  UpdatePaymentMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentMandate$ {
  /** @deprecated use `UpdatePaymentMandate$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentMandate$inboundSchema;
  /** @deprecated use `UpdatePaymentMandate$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentMandate$outboundSchema;
  /** @deprecated use `UpdatePaymentMandate$Outbound` instead. */
  export type Outbound = UpdatePaymentMandate$Outbound;
}

export function updatePaymentMandateToJSON(
  updatePaymentMandate: UpdatePaymentMandate,
): string {
  return JSON.stringify(
    UpdatePaymentMandate$outboundSchema.parse(updatePaymentMandate),
  );
}

export function updatePaymentMandateFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentMandate' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentSubscription$inboundSchema: z.ZodType<
  UpdatePaymentSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentSubscription$outboundSchema: z.ZodType<
  UpdatePaymentSubscription$Outbound,
  z.ZodTypeDef,
  UpdatePaymentSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentSubscription$ {
  /** @deprecated use `UpdatePaymentSubscription$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentSubscription$inboundSchema;
  /** @deprecated use `UpdatePaymentSubscription$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentSubscription$outboundSchema;
  /** @deprecated use `UpdatePaymentSubscription$Outbound` instead. */
  export type Outbound = UpdatePaymentSubscription$Outbound;
}

export function updatePaymentSubscriptionToJSON(
  updatePaymentSubscription: UpdatePaymentSubscription,
): string {
  return JSON.stringify(
    UpdatePaymentSubscription$outboundSchema.parse(updatePaymentSubscription),
  );
}

export function updatePaymentSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentSubscription' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentOrder$inboundSchema: z.ZodType<
  UpdatePaymentOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentOrder$outboundSchema: z.ZodType<
  UpdatePaymentOrder$Outbound,
  z.ZodTypeDef,
  UpdatePaymentOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentOrder$ {
  /** @deprecated use `UpdatePaymentOrder$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentOrder$inboundSchema;
  /** @deprecated use `UpdatePaymentOrder$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentOrder$outboundSchema;
  /** @deprecated use `UpdatePaymentOrder$Outbound` instead. */
  export type Outbound = UpdatePaymentOrder$Outbound;
}

export function updatePaymentOrderToJSON(
  updatePaymentOrder: UpdatePaymentOrder,
): string {
  return JSON.stringify(
    UpdatePaymentOrder$outboundSchema.parse(updatePaymentOrder),
  );
}

export function updatePaymentOrderFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentOrder' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentTerminal$inboundSchema: z.ZodType<
  UpdatePaymentTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentTerminal$outboundSchema: z.ZodType<
  UpdatePaymentTerminal$Outbound,
  z.ZodTypeDef,
  UpdatePaymentTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentTerminal$ {
  /** @deprecated use `UpdatePaymentTerminal$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentTerminal$inboundSchema;
  /** @deprecated use `UpdatePaymentTerminal$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentTerminal$outboundSchema;
  /** @deprecated use `UpdatePaymentTerminal$Outbound` instead. */
  export type Outbound = UpdatePaymentTerminal$Outbound;
}

export function updatePaymentTerminalToJSON(
  updatePaymentTerminal: UpdatePaymentTerminal,
): string {
  return JSON.stringify(
    UpdatePaymentTerminal$outboundSchema.parse(updatePaymentTerminal),
  );
}

export function updatePaymentTerminalFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentTerminal' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentDocumentation$inboundSchema: z.ZodType<
  UpdatePaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdatePaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdatePaymentDocumentation$outboundSchema: z.ZodType<
  UpdatePaymentDocumentation$Outbound,
  z.ZodTypeDef,
  UpdatePaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentDocumentation$ {
  /** @deprecated use `UpdatePaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentDocumentation$inboundSchema;
  /** @deprecated use `UpdatePaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentDocumentation$outboundSchema;
  /** @deprecated use `UpdatePaymentDocumentation$Outbound` instead. */
  export type Outbound = UpdatePaymentDocumentation$Outbound;
}

export function updatePaymentDocumentationToJSON(
  updatePaymentDocumentation: UpdatePaymentDocumentation,
): string {
  return JSON.stringify(
    UpdatePaymentDocumentation$outboundSchema.parse(updatePaymentDocumentation),
  );
}

export function updatePaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentLinks$inboundSchema: z.ZodType<
  UpdatePaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => UpdatePaymentSelf$inboundSchema),
  checkout: z.lazy(() => UpdatePaymentCheckout$inboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => UpdatePaymentMobileAppCheckout$inboundSchema)
    .optional(),
  changePaymentState: z.lazy(() =>
    UpdatePaymentChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => UpdatePaymentDashboard$inboundSchema),
  refunds: z.lazy(() => UpdatePaymentRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => UpdatePaymentChargebacks$inboundSchema).optional(),
  captures: z.lazy(() => UpdatePaymentCaptures$inboundSchema).optional(),
  settlement: z.lazy(() => UpdatePaymentSettlement$inboundSchema).optional(),
  customer: z.lazy(() => UpdatePaymentCustomer$inboundSchema).optional(),
  mandate: z.lazy(() => UpdatePaymentMandate$inboundSchema).optional(),
  subscription: z.lazy(() => UpdatePaymentSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => UpdatePaymentOrder$inboundSchema).optional(),
  terminal: z.lazy(() => UpdatePaymentTerminal$inboundSchema).optional(),
  documentation: z.lazy(() => UpdatePaymentDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type UpdatePaymentLinks$Outbound = {
  self: UpdatePaymentSelf$Outbound;
  checkout?: UpdatePaymentCheckout$Outbound | undefined;
  mobileAppCheckout?: UpdatePaymentMobileAppCheckout$Outbound | undefined;
  changePaymentState?: UpdatePaymentChangePaymentState$Outbound | undefined;
  dashboard: UpdatePaymentDashboard$Outbound;
  refunds?: UpdatePaymentRefunds$Outbound | undefined;
  chargebacks?: UpdatePaymentChargebacks$Outbound | undefined;
  captures?: UpdatePaymentCaptures$Outbound | undefined;
  settlement?: UpdatePaymentSettlement$Outbound | undefined;
  customer?: UpdatePaymentCustomer$Outbound | undefined;
  mandate?: UpdatePaymentMandate$Outbound | undefined;
  subscription?: UpdatePaymentSubscription$Outbound | undefined;
  order?: UpdatePaymentOrder$Outbound | undefined;
  terminal?: UpdatePaymentTerminal$Outbound | undefined;
  documentation?: UpdatePaymentDocumentation$Outbound | undefined;
};

/** @internal */
export const UpdatePaymentLinks$outboundSchema: z.ZodType<
  UpdatePaymentLinks$Outbound,
  z.ZodTypeDef,
  UpdatePaymentLinks
> = z.object({
  self: z.lazy(() => UpdatePaymentSelf$outboundSchema),
  checkout: z.lazy(() => UpdatePaymentCheckout$outboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => UpdatePaymentMobileAppCheckout$outboundSchema)
    .optional(),
  changePaymentState: z.lazy(() =>
    UpdatePaymentChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => UpdatePaymentDashboard$outboundSchema),
  refunds: z.lazy(() => UpdatePaymentRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => UpdatePaymentChargebacks$outboundSchema).optional(),
  captures: z.lazy(() => UpdatePaymentCaptures$outboundSchema).optional(),
  settlement: z.lazy(() => UpdatePaymentSettlement$outboundSchema).optional(),
  customer: z.lazy(() => UpdatePaymentCustomer$outboundSchema).optional(),
  mandate: z.lazy(() => UpdatePaymentMandate$outboundSchema).optional(),
  subscription: z.lazy(() => UpdatePaymentSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => UpdatePaymentOrder$outboundSchema).optional(),
  terminal: z.lazy(() => UpdatePaymentTerminal$outboundSchema).optional(),
  documentation: z.lazy(() => UpdatePaymentDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentLinks$ {
  /** @deprecated use `UpdatePaymentLinks$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentLinks$inboundSchema;
  /** @deprecated use `UpdatePaymentLinks$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentLinks$outboundSchema;
  /** @deprecated use `UpdatePaymentLinks$Outbound` instead. */
  export type Outbound = UpdatePaymentLinks$Outbound;
}

export function updatePaymentLinksToJSON(
  updatePaymentLinks: UpdatePaymentLinks,
): string {
  return JSON.stringify(
    UpdatePaymentLinks$outboundSchema.parse(updatePaymentLinks),
  );
}

export function updatePaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentLinks' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentResponse$inboundSchema: z.ZodType<
  UpdatePaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdatePaymentMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => UpdatePaymentAmount$inboundSchema),
  amountRefunded: z.lazy(() => UpdatePaymentAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => UpdatePaymentAmountRemaining$inboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => UpdatePaymentAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => UpdatePaymentAmountChargedBack$inboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => UpdatePaymentSettlementAmount$inboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => UpdatePaymentLine$inboundSchema)))
    .optional(),
  billingAddress: z.lazy(() =>
    UpdatePaymentBillingAddressResponse$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    UpdatePaymentShippingAddressResponse$inboundSchema
  ).optional(),
  locale: z.nullable(UpdatePaymentLocaleResponse$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(UpdatePaymentMethodResponse$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => UpdatePaymentMetadataResponse$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(UpdatePaymentCaptureMode$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => UpdatePaymentApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(z.lazy(() => UpdatePaymentRouting$inboundSchema)))
    .optional(),
  sequenceType: z.nullable(
    UpdatePaymentSequenceType$inboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: UpdatePaymentStatus$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => UpdatePaymentStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => UpdatePaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type UpdatePaymentResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: UpdatePaymentAmount$Outbound;
  amountRefunded?: UpdatePaymentAmountRefunded$Outbound | undefined;
  amountRemaining?: UpdatePaymentAmountRemaining$Outbound | undefined;
  amountCaptured?: UpdatePaymentAmountCaptured$Outbound | undefined;
  amountChargedBack?: UpdatePaymentAmountChargedBack$Outbound | undefined;
  settlementAmount?: UpdatePaymentSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<UpdatePaymentLine$Outbound> | null | undefined;
  billingAddress?: UpdatePaymentBillingAddressResponse$Outbound | undefined;
  shippingAddress?: UpdatePaymentShippingAddressResponse$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | UpdatePaymentMetadataResponse$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?: UpdatePaymentApplicationFee$Outbound | null | undefined;
  routing?: Array<UpdatePaymentRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: UpdatePaymentStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: UpdatePaymentLinks$Outbound;
};

/** @internal */
export const UpdatePaymentResponse$outboundSchema: z.ZodType<
  UpdatePaymentResponse$Outbound,
  z.ZodTypeDef,
  UpdatePaymentResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdatePaymentMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => UpdatePaymentAmount$outboundSchema),
  amountRefunded: z.lazy(() => UpdatePaymentAmountRefunded$outboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => UpdatePaymentAmountRemaining$outboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => UpdatePaymentAmountCaptured$outboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => UpdatePaymentAmountChargedBack$outboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => UpdatePaymentSettlementAmount$outboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => UpdatePaymentLine$outboundSchema)))
    .optional(),
  billingAddress: z.lazy(() =>
    UpdatePaymentBillingAddressResponse$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    UpdatePaymentShippingAddressResponse$outboundSchema
  ).optional(),
  locale: z.nullable(UpdatePaymentLocaleResponse$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(UpdatePaymentMethodResponse$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => UpdatePaymentMetadataResponse$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(UpdatePaymentCaptureMode$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => UpdatePaymentApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => UpdatePaymentRouting$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    UpdatePaymentSequenceType$outboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: UpdatePaymentStatus$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => UpdatePaymentStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => UpdatePaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatePaymentResponse$ {
  /** @deprecated use `UpdatePaymentResponse$inboundSchema` instead. */
  export const inboundSchema = UpdatePaymentResponse$inboundSchema;
  /** @deprecated use `UpdatePaymentResponse$outboundSchema` instead. */
  export const outboundSchema = UpdatePaymentResponse$outboundSchema;
  /** @deprecated use `UpdatePaymentResponse$Outbound` instead. */
  export type Outbound = UpdatePaymentResponse$Outbound;
}

export function updatePaymentResponseToJSON(
  updatePaymentResponse: UpdatePaymentResponse,
): string {
  return JSON.stringify(
    UpdatePaymentResponse$outboundSchema.parse(updatePaymentResponse),
  );
}

export function updatePaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentResponse' from JSON`,
  );
}
