/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type UpdatePaymentRequestBody = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description?: string | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: models.Metadata | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  method?: models.MethodEnum | null | undefined;
  /**
   * Allows you to preset the language to be used.
   */
  locale?: models.Locale | null | undefined;
  /**
   * The date by which the payment should be completed in `YYYY-MM-DD` format
   */
  dueDate?: string | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Whether the entity was created in test mode or live mode. This field does not update the mode of the entity.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
   * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
   * method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
   * up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
   * `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `alma`, `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: models.BillingAddress | undefined;
  shippingAddress?: models.PaymentAddress | undefined;
  billingEmail?: string | undefined;
};

export type UpdatePaymentRequest = {
  /**
   * Provide the ID of the related payment.
   */
  paymentId: string;
  /**
   * A unique key to ensure idempotent requests. This key should be a UUID v4 string.
   */
  idempotencyKey?: string | undefined;
  requestBody?: UpdatePaymentRequestBody | undefined;
};

/** @internal */
export const UpdatePaymentRequestBody$inboundSchema: z.ZodType<
  UpdatePaymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  metadata: z.nullable(models.Metadata$inboundSchema).optional(),
  method: z.nullable(models.MethodEnum$inboundSchema).optional(),
  locale: z.nullable(models.Locale$inboundSchema).optional(),
  dueDate: z.string().optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  testmode: z.boolean().optional(),
  issuer: z.nullable(z.string()).optional(),
  billingAddress: models.BillingAddress$inboundSchema.optional(),
  shippingAddress: models.PaymentAddress$inboundSchema.optional(),
  billingEmail: z.string().optional(),
});
/** @internal */
export type UpdatePaymentRequestBody$Outbound = {
  description?: string | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  metadata?: models.Metadata$Outbound | null | undefined;
  method?: string | null | undefined;
  locale?: string | null | undefined;
  dueDate?: string | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  testmode?: boolean | undefined;
  issuer?: string | null | undefined;
  billingAddress?: models.BillingAddress$Outbound | undefined;
  shippingAddress?: models.PaymentAddress$Outbound | undefined;
  billingEmail?: string | undefined;
};

/** @internal */
export const UpdatePaymentRequestBody$outboundSchema: z.ZodType<
  UpdatePaymentRequestBody$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRequestBody
> = z.object({
  description: z.string().optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  metadata: z.nullable(models.Metadata$outboundSchema).optional(),
  method: z.nullable(models.MethodEnum$outboundSchema).optional(),
  locale: z.nullable(models.Locale$outboundSchema).optional(),
  dueDate: z.string().optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  testmode: z.boolean().optional(),
  issuer: z.nullable(z.string()).optional(),
  billingAddress: models.BillingAddress$outboundSchema.optional(),
  shippingAddress: models.PaymentAddress$outboundSchema.optional(),
  billingEmail: z.string().optional(),
});

export function updatePaymentRequestBodyToJSON(
  updatePaymentRequestBody: UpdatePaymentRequestBody,
): string {
  return JSON.stringify(
    UpdatePaymentRequestBody$outboundSchema.parse(updatePaymentRequestBody),
  );
}
export function updatePaymentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdatePaymentRequest$inboundSchema: z.ZodType<
  UpdatePaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string(),
  "idempotency-key": z.string().optional(),
  RequestBody: z.lazy(() => UpdatePaymentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "idempotency-key": "idempotencyKey",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdatePaymentRequest$Outbound = {
  paymentId: string;
  "idempotency-key"?: string | undefined;
  RequestBody?: UpdatePaymentRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdatePaymentRequest$outboundSchema: z.ZodType<
  UpdatePaymentRequest$Outbound,
  z.ZodTypeDef,
  UpdatePaymentRequest
> = z.object({
  paymentId: z.string(),
  idempotencyKey: z.string().optional(),
  requestBody: z.lazy(() => UpdatePaymentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    idempotencyKey: "idempotency-key",
    requestBody: "RequestBody",
  });
});

export function updatePaymentRequestToJSON(
  updatePaymentRequest: UpdatePaymentRequest,
): string {
  return JSON.stringify(
    UpdatePaymentRequest$outboundSchema.parse(updatePaymentRequest),
  );
}
export function updatePaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePaymentRequest' from JSON`,
  );
}
