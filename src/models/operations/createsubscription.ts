/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type CreateSubscriptionAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export const CreateSubscriptionIntervalRequest = {
  DotDotDotDays: "... days",
  DotDotDotWeeks: "... weeks",
  DotDotDotMonths: "... months",
} as const;
/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export type CreateSubscriptionIntervalRequest = ClosedEnum<
  typeof CreateSubscriptionIntervalRequest
>;

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const CreateSubscriptionMethodRequest = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type CreateSubscriptionMethodRequest = ClosedEnum<
  typeof CreateSubscriptionMethodRequest
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CreateSubscriptionApplicationFeeAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type CreateSubscriptionApplicationFeeRequest = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CreateSubscriptionApplicationFeeAmountRequest | undefined;
  description?: string | undefined;
};

export type CreateSubscriptionMetadataRequest = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type CreateSubscriptionMetadataRequestUnion =
  | CreateSubscriptionMetadataRequest
  | string
  | Array<string>;

export type CreateSubscriptionRequestBody = {
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount: CreateSubscriptionAmountRequest;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | null | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   */
  interval: CreateSubscriptionIntervalRequest;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method?: CreateSubscriptionMethodRequest | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: CreateSubscriptionApplicationFeeRequest | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata?:
    | CreateSubscriptionMetadataRequest
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

export type CreateSubscriptionRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  requestBody?: CreateSubscriptionRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreateSubscriptionNotFoundDocumentation = {
  href: string;
  type: string;
};

export type CreateSubscriptionNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreateSubscriptionNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreateSubscriptionMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreateSubscriptionMode = ClosedEnum<typeof CreateSubscriptionMode>;

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const CreateSubscriptionStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type CreateSubscriptionStatus = ClosedEnum<
  typeof CreateSubscriptionStatus
>;

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type CreateSubscriptionAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export const CreateSubscriptionIntervalResponse = {
  DotDotDotDays: "... days",
  DotDotDotWeeks: "... weeks",
  DotDotDotMonths: "... months",
} as const;
/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export type CreateSubscriptionIntervalResponse = ClosedEnum<
  typeof CreateSubscriptionIntervalResponse
>;

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const CreateSubscriptionMethodResponse = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type CreateSubscriptionMethodResponse = ClosedEnum<
  typeof CreateSubscriptionMethodResponse
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CreateSubscriptionApplicationFeeAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type CreateSubscriptionApplicationFeeResponse = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CreateSubscriptionApplicationFeeAmountResponse | undefined;
  description?: string | undefined;
};

export type CreateSubscriptionMetadataResponse = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type CreateSubscriptionMetadataResponseUnion =
  | CreateSubscriptionMetadataResponse
  | string
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type CreateSubscriptionCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type CreateSubscriptionMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type CreateSubscriptionProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
 *
 * @remarks
 * payments exist (yet).
 */
export type CreateSubscriptionPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreateSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreateSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: CreateSubscriptionSelf | undefined;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer?: CreateSubscriptionCustomer | null | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: CreateSubscriptionMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile?: CreateSubscriptionProfile | null | undefined;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
   *
   * @remarks
   * payments exist (yet).
   */
  payments?: CreateSubscriptionPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: CreateSubscriptionDocumentation | undefined;
};

/**
 * The newly created subscription object.
 */
export type CreateSubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: CreateSubscriptionMode | undefined;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status?: CreateSubscriptionStatus | undefined;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount?: CreateSubscriptionAmountResponse | undefined;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | null | undefined;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining?: number | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   */
  interval?: CreateSubscriptionIntervalResponse | undefined;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description?: string | undefined;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method?: CreateSubscriptionMethodResponse | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: CreateSubscriptionApplicationFeeResponse | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata?:
    | CreateSubscriptionMetadataResponse
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  /**
   * The customer this subscription belongs to.
   */
  customerId?: string | undefined;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: CreateSubscriptionLinks | undefined;
};

/** @internal */
export const CreateSubscriptionAmountRequest$inboundSchema: z.ZodType<
  CreateSubscriptionAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateSubscriptionAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateSubscriptionAmountRequest$outboundSchema: z.ZodType<
  CreateSubscriptionAmountRequest$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionAmountRequest$ {
  /** @deprecated use `CreateSubscriptionAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionAmountRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionAmountRequest$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionAmountRequest$outboundSchema;
  /** @deprecated use `CreateSubscriptionAmountRequest$Outbound` instead. */
  export type Outbound = CreateSubscriptionAmountRequest$Outbound;
}

export function createSubscriptionAmountRequestToJSON(
  createSubscriptionAmountRequest: CreateSubscriptionAmountRequest,
): string {
  return JSON.stringify(
    CreateSubscriptionAmountRequest$outboundSchema.parse(
      createSubscriptionAmountRequest,
    ),
  );
}

export function createSubscriptionAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionIntervalRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionIntervalRequest
> = z.nativeEnum(CreateSubscriptionIntervalRequest);

/** @internal */
export const CreateSubscriptionIntervalRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionIntervalRequest
> = CreateSubscriptionIntervalRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionIntervalRequest$ {
  /** @deprecated use `CreateSubscriptionIntervalRequest$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionIntervalRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionIntervalRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionIntervalRequest$outboundSchema;
}

/** @internal */
export const CreateSubscriptionMethodRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMethodRequest
> = z.nativeEnum(CreateSubscriptionMethodRequest);

/** @internal */
export const CreateSubscriptionMethodRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMethodRequest
> = CreateSubscriptionMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMethodRequest$ {
  /** @deprecated use `CreateSubscriptionMethodRequest$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMethodRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionMethodRequest$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionMethodRequest$outboundSchema;
}

/** @internal */
export const CreateSubscriptionApplicationFeeAmountRequest$inboundSchema:
  z.ZodType<
    CreateSubscriptionApplicationFeeAmountRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateSubscriptionApplicationFeeAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateSubscriptionApplicationFeeAmountRequest$outboundSchema:
  z.ZodType<
    CreateSubscriptionApplicationFeeAmountRequest$Outbound,
    z.ZodTypeDef,
    CreateSubscriptionApplicationFeeAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionApplicationFeeAmountRequest$ {
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionApplicationFeeAmountRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionApplicationFeeAmountRequest$outboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountRequest$Outbound` instead. */
  export type Outbound = CreateSubscriptionApplicationFeeAmountRequest$Outbound;
}

export function createSubscriptionApplicationFeeAmountRequestToJSON(
  createSubscriptionApplicationFeeAmountRequest:
    CreateSubscriptionApplicationFeeAmountRequest,
): string {
  return JSON.stringify(
    CreateSubscriptionApplicationFeeAmountRequest$outboundSchema.parse(
      createSubscriptionApplicationFeeAmountRequest,
    ),
  );
}

export function createSubscriptionApplicationFeeAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionApplicationFeeAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionApplicationFeeAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionApplicationFeeAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionApplicationFeeRequest$inboundSchema: z.ZodType<
  CreateSubscriptionApplicationFeeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() =>
    CreateSubscriptionApplicationFeeAmountRequest$inboundSchema
  ).optional(),
  description: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionApplicationFeeRequest$Outbound = {
  amount?: CreateSubscriptionApplicationFeeAmountRequest$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreateSubscriptionApplicationFeeRequest$outboundSchema: z.ZodType<
  CreateSubscriptionApplicationFeeRequest$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionApplicationFeeRequest
> = z.object({
  amount: z.lazy(() =>
    CreateSubscriptionApplicationFeeAmountRequest$outboundSchema
  ).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionApplicationFeeRequest$ {
  /** @deprecated use `CreateSubscriptionApplicationFeeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionApplicationFeeRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionApplicationFeeRequest$outboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeRequest$Outbound` instead. */
  export type Outbound = CreateSubscriptionApplicationFeeRequest$Outbound;
}

export function createSubscriptionApplicationFeeRequestToJSON(
  createSubscriptionApplicationFeeRequest:
    CreateSubscriptionApplicationFeeRequest,
): string {
  return JSON.stringify(
    CreateSubscriptionApplicationFeeRequest$outboundSchema.parse(
      createSubscriptionApplicationFeeRequest,
    ),
  );
}

export function createSubscriptionApplicationFeeRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionApplicationFeeRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionApplicationFeeRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionApplicationFeeRequest' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMetadataRequest$inboundSchema: z.ZodType<
  CreateSubscriptionMetadataRequest,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreateSubscriptionMetadataRequest$Outbound = {};

/** @internal */
export const CreateSubscriptionMetadataRequest$outboundSchema: z.ZodType<
  CreateSubscriptionMetadataRequest$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionMetadataRequest
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMetadataRequest$ {
  /** @deprecated use `CreateSubscriptionMetadataRequest$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMetadataRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionMetadataRequest$outboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataRequest$Outbound` instead. */
  export type Outbound = CreateSubscriptionMetadataRequest$Outbound;
}

export function createSubscriptionMetadataRequestToJSON(
  createSubscriptionMetadataRequest: CreateSubscriptionMetadataRequest,
): string {
  return JSON.stringify(
    CreateSubscriptionMetadataRequest$outboundSchema.parse(
      createSubscriptionMetadataRequest,
    ),
  );
}

export function createSubscriptionMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionMetadataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionMetadataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionMetadataRequest' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMetadataRequestUnion$inboundSchema: z.ZodType<
  CreateSubscriptionMetadataRequestUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateSubscriptionMetadataRequest$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CreateSubscriptionMetadataRequestUnion$Outbound =
  | CreateSubscriptionMetadataRequest$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreateSubscriptionMetadataRequestUnion$outboundSchema: z.ZodType<
  CreateSubscriptionMetadataRequestUnion$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionMetadataRequestUnion
> = z.union([
  z.lazy(() => CreateSubscriptionMetadataRequest$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMetadataRequestUnion$ {
  /** @deprecated use `CreateSubscriptionMetadataRequestUnion$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionMetadataRequestUnion$inboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataRequestUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionMetadataRequestUnion$outboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataRequestUnion$Outbound` instead. */
  export type Outbound = CreateSubscriptionMetadataRequestUnion$Outbound;
}

export function createSubscriptionMetadataRequestUnionToJSON(
  createSubscriptionMetadataRequestUnion:
    CreateSubscriptionMetadataRequestUnion,
): string {
  return JSON.stringify(
    CreateSubscriptionMetadataRequestUnion$outboundSchema.parse(
      createSubscriptionMetadataRequestUnion,
    ),
  );
}

export function createSubscriptionMetadataRequestUnionFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionMetadataRequestUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionMetadataRequestUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionMetadataRequestUnion' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionRequestBody$inboundSchema: z.ZodType<
  CreateSubscriptionRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreateSubscriptionAmountRequest$inboundSchema),
  times: z.nullable(z.number().int()).optional(),
  interval: CreateSubscriptionIntervalRequest$inboundSchema,
  startDate: z.string().optional(),
  description: z.string(),
  method: z.nullable(CreateSubscriptionMethodRequest$inboundSchema).optional(),
  applicationFee: z.lazy(() =>
    CreateSubscriptionApplicationFeeRequest$inboundSchema
  ).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateSubscriptionMetadataRequest$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CreateSubscriptionRequestBody$Outbound = {
  amount: CreateSubscriptionAmountRequest$Outbound;
  times?: number | null | undefined;
  interval: string;
  startDate?: string | undefined;
  description: string;
  method?: string | null | undefined;
  applicationFee?: CreateSubscriptionApplicationFeeRequest$Outbound | undefined;
  metadata?:
    | CreateSubscriptionMetadataRequest$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  webhookUrl?: string | undefined;
  mandateId?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CreateSubscriptionRequestBody$outboundSchema: z.ZodType<
  CreateSubscriptionRequestBody$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionRequestBody
> = z.object({
  amount: z.lazy(() => CreateSubscriptionAmountRequest$outboundSchema),
  times: z.nullable(z.number().int()).optional(),
  interval: CreateSubscriptionIntervalRequest$outboundSchema,
  startDate: z.string().optional(),
  description: z.string(),
  method: z.nullable(CreateSubscriptionMethodRequest$outboundSchema).optional(),
  applicationFee: z.lazy(() =>
    CreateSubscriptionApplicationFeeRequest$outboundSchema
  ).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateSubscriptionMetadataRequest$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionRequestBody$ {
  /** @deprecated use `CreateSubscriptionRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionRequestBody$inboundSchema;
  /** @deprecated use `CreateSubscriptionRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionRequestBody$outboundSchema;
  /** @deprecated use `CreateSubscriptionRequestBody$Outbound` instead. */
  export type Outbound = CreateSubscriptionRequestBody$Outbound;
}

export function createSubscriptionRequestBodyToJSON(
  createSubscriptionRequestBody: CreateSubscriptionRequestBody,
): string {
  return JSON.stringify(
    CreateSubscriptionRequestBody$outboundSchema.parse(
      createSubscriptionRequestBody,
    ),
  );
}

export function createSubscriptionRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionRequest$inboundSchema: z.ZodType<
  CreateSubscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  RequestBody: z.lazy(() => CreateSubscriptionRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateSubscriptionRequest$Outbound = {
  customerId: string;
  RequestBody?: CreateSubscriptionRequestBody$Outbound | undefined;
};

/** @internal */
export const CreateSubscriptionRequest$outboundSchema: z.ZodType<
  CreateSubscriptionRequest$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionRequest
> = z.object({
  customerId: z.string(),
  requestBody: z.lazy(() => CreateSubscriptionRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionRequest$ {
  /** @deprecated use `CreateSubscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionRequest$inboundSchema;
  /** @deprecated use `CreateSubscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionRequest$outboundSchema;
  /** @deprecated use `CreateSubscriptionRequest$Outbound` instead. */
  export type Outbound = CreateSubscriptionRequest$Outbound;
}

export function createSubscriptionRequestToJSON(
  createSubscriptionRequest: CreateSubscriptionRequest,
): string {
  return JSON.stringify(
    CreateSubscriptionRequest$outboundSchema.parse(createSubscriptionRequest),
  );
}

export function createSubscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionRequest' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionNotFoundDocumentation$inboundSchema: z.ZodType<
  CreateSubscriptionNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateSubscriptionNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateSubscriptionNotFoundDocumentation$outboundSchema: z.ZodType<
  CreateSubscriptionNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionNotFoundDocumentation$ {
  /** @deprecated use `CreateSubscriptionNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionNotFoundDocumentation$inboundSchema;
  /** @deprecated use `CreateSubscriptionNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionNotFoundDocumentation$outboundSchema;
  /** @deprecated use `CreateSubscriptionNotFoundDocumentation$Outbound` instead. */
  export type Outbound = CreateSubscriptionNotFoundDocumentation$Outbound;
}

export function createSubscriptionNotFoundDocumentationToJSON(
  createSubscriptionNotFoundDocumentation:
    CreateSubscriptionNotFoundDocumentation,
): string {
  return JSON.stringify(
    CreateSubscriptionNotFoundDocumentation$outboundSchema.parse(
      createSubscriptionNotFoundDocumentation,
    ),
  );
}

export function createSubscriptionNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionNotFoundDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionNotFoundDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionNotFoundLinks$inboundSchema: z.ZodType<
  CreateSubscriptionNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CreateSubscriptionNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type CreateSubscriptionNotFoundLinks$Outbound = {
  documentation: CreateSubscriptionNotFoundDocumentation$Outbound;
};

/** @internal */
export const CreateSubscriptionNotFoundLinks$outboundSchema: z.ZodType<
  CreateSubscriptionNotFoundLinks$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    CreateSubscriptionNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionNotFoundLinks$ {
  /** @deprecated use `CreateSubscriptionNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionNotFoundLinks$inboundSchema;
  /** @deprecated use `CreateSubscriptionNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionNotFoundLinks$outboundSchema;
  /** @deprecated use `CreateSubscriptionNotFoundLinks$Outbound` instead. */
  export type Outbound = CreateSubscriptionNotFoundLinks$Outbound;
}

export function createSubscriptionNotFoundLinksToJSON(
  createSubscriptionNotFoundLinks: CreateSubscriptionNotFoundLinks,
): string {
  return JSON.stringify(
    CreateSubscriptionNotFoundLinks$outboundSchema.parse(
      createSubscriptionNotFoundLinks,
    ),
  );
}

export function createSubscriptionNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMode$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMode
> = z.nativeEnum(CreateSubscriptionMode);

/** @internal */
export const CreateSubscriptionMode$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMode
> = CreateSubscriptionMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMode$ {
  /** @deprecated use `CreateSubscriptionMode$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMode$inboundSchema;
  /** @deprecated use `CreateSubscriptionMode$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionMode$outboundSchema;
}

/** @internal */
export const CreateSubscriptionStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionStatus
> = z.nativeEnum(CreateSubscriptionStatus);

/** @internal */
export const CreateSubscriptionStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionStatus
> = CreateSubscriptionStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionStatus$ {
  /** @deprecated use `CreateSubscriptionStatus$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionStatus$inboundSchema;
  /** @deprecated use `CreateSubscriptionStatus$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionStatus$outboundSchema;
}

/** @internal */
export const CreateSubscriptionAmountResponse$inboundSchema: z.ZodType<
  CreateSubscriptionAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateSubscriptionAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateSubscriptionAmountResponse$outboundSchema: z.ZodType<
  CreateSubscriptionAmountResponse$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionAmountResponse$ {
  /** @deprecated use `CreateSubscriptionAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionAmountResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionAmountResponse$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionAmountResponse$outboundSchema;
  /** @deprecated use `CreateSubscriptionAmountResponse$Outbound` instead. */
  export type Outbound = CreateSubscriptionAmountResponse$Outbound;
}

export function createSubscriptionAmountResponseToJSON(
  createSubscriptionAmountResponse: CreateSubscriptionAmountResponse,
): string {
  return JSON.stringify(
    CreateSubscriptionAmountResponse$outboundSchema.parse(
      createSubscriptionAmountResponse,
    ),
  );
}

export function createSubscriptionAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionIntervalResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionIntervalResponse
> = z.nativeEnum(CreateSubscriptionIntervalResponse);

/** @internal */
export const CreateSubscriptionIntervalResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionIntervalResponse
> = CreateSubscriptionIntervalResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionIntervalResponse$ {
  /** @deprecated use `CreateSubscriptionIntervalResponse$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionIntervalResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionIntervalResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionIntervalResponse$outboundSchema;
}

/** @internal */
export const CreateSubscriptionMethodResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMethodResponse
> = z.nativeEnum(CreateSubscriptionMethodResponse);

/** @internal */
export const CreateSubscriptionMethodResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreateSubscriptionMethodResponse
> = CreateSubscriptionMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMethodResponse$ {
  /** @deprecated use `CreateSubscriptionMethodResponse$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMethodResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionMethodResponse$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionMethodResponse$outboundSchema;
}

/** @internal */
export const CreateSubscriptionApplicationFeeAmountResponse$inboundSchema:
  z.ZodType<
    CreateSubscriptionApplicationFeeAmountResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreateSubscriptionApplicationFeeAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreateSubscriptionApplicationFeeAmountResponse$outboundSchema:
  z.ZodType<
    CreateSubscriptionApplicationFeeAmountResponse$Outbound,
    z.ZodTypeDef,
    CreateSubscriptionApplicationFeeAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionApplicationFeeAmountResponse$ {
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionApplicationFeeAmountResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionApplicationFeeAmountResponse$outboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeAmountResponse$Outbound` instead. */
  export type Outbound =
    CreateSubscriptionApplicationFeeAmountResponse$Outbound;
}

export function createSubscriptionApplicationFeeAmountResponseToJSON(
  createSubscriptionApplicationFeeAmountResponse:
    CreateSubscriptionApplicationFeeAmountResponse,
): string {
  return JSON.stringify(
    CreateSubscriptionApplicationFeeAmountResponse$outboundSchema.parse(
      createSubscriptionApplicationFeeAmountResponse,
    ),
  );
}

export function createSubscriptionApplicationFeeAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionApplicationFeeAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionApplicationFeeAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionApplicationFeeAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionApplicationFeeResponse$inboundSchema: z.ZodType<
  CreateSubscriptionApplicationFeeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() =>
    CreateSubscriptionApplicationFeeAmountResponse$inboundSchema
  ).optional(),
  description: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionApplicationFeeResponse$Outbound = {
  amount?: CreateSubscriptionApplicationFeeAmountResponse$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreateSubscriptionApplicationFeeResponse$outboundSchema: z.ZodType<
  CreateSubscriptionApplicationFeeResponse$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionApplicationFeeResponse
> = z.object({
  amount: z.lazy(() =>
    CreateSubscriptionApplicationFeeAmountResponse$outboundSchema
  ).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionApplicationFeeResponse$ {
  /** @deprecated use `CreateSubscriptionApplicationFeeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionApplicationFeeResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionApplicationFeeResponse$outboundSchema;
  /** @deprecated use `CreateSubscriptionApplicationFeeResponse$Outbound` instead. */
  export type Outbound = CreateSubscriptionApplicationFeeResponse$Outbound;
}

export function createSubscriptionApplicationFeeResponseToJSON(
  createSubscriptionApplicationFeeResponse:
    CreateSubscriptionApplicationFeeResponse,
): string {
  return JSON.stringify(
    CreateSubscriptionApplicationFeeResponse$outboundSchema.parse(
      createSubscriptionApplicationFeeResponse,
    ),
  );
}

export function createSubscriptionApplicationFeeResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionApplicationFeeResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionApplicationFeeResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionApplicationFeeResponse' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMetadataResponse$inboundSchema: z.ZodType<
  CreateSubscriptionMetadataResponse,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CreateSubscriptionMetadataResponse$Outbound = {};

/** @internal */
export const CreateSubscriptionMetadataResponse$outboundSchema: z.ZodType<
  CreateSubscriptionMetadataResponse$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionMetadataResponse
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMetadataResponse$ {
  /** @deprecated use `CreateSubscriptionMetadataResponse$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMetadataResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionMetadataResponse$outboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataResponse$Outbound` instead. */
  export type Outbound = CreateSubscriptionMetadataResponse$Outbound;
}

export function createSubscriptionMetadataResponseToJSON(
  createSubscriptionMetadataResponse: CreateSubscriptionMetadataResponse,
): string {
  return JSON.stringify(
    CreateSubscriptionMetadataResponse$outboundSchema.parse(
      createSubscriptionMetadataResponse,
    ),
  );
}

export function createSubscriptionMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionMetadataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionMetadataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionMetadataResponse' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMetadataResponseUnion$inboundSchema: z.ZodType<
  CreateSubscriptionMetadataResponseUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateSubscriptionMetadataResponse$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CreateSubscriptionMetadataResponseUnion$Outbound =
  | CreateSubscriptionMetadataResponse$Outbound
  | string
  | Array<string>;

/** @internal */
export const CreateSubscriptionMetadataResponseUnion$outboundSchema: z.ZodType<
  CreateSubscriptionMetadataResponseUnion$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionMetadataResponseUnion
> = z.union([
  z.lazy(() => CreateSubscriptionMetadataResponse$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMetadataResponseUnion$ {
  /** @deprecated use `CreateSubscriptionMetadataResponseUnion$inboundSchema` instead. */
  export const inboundSchema =
    CreateSubscriptionMetadataResponseUnion$inboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataResponseUnion$outboundSchema` instead. */
  export const outboundSchema =
    CreateSubscriptionMetadataResponseUnion$outboundSchema;
  /** @deprecated use `CreateSubscriptionMetadataResponseUnion$Outbound` instead. */
  export type Outbound = CreateSubscriptionMetadataResponseUnion$Outbound;
}

export function createSubscriptionMetadataResponseUnionToJSON(
  createSubscriptionMetadataResponseUnion:
    CreateSubscriptionMetadataResponseUnion,
): string {
  return JSON.stringify(
    CreateSubscriptionMetadataResponseUnion$outboundSchema.parse(
      createSubscriptionMetadataResponseUnion,
    ),
  );
}

export function createSubscriptionMetadataResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateSubscriptionMetadataResponseUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateSubscriptionMetadataResponseUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateSubscriptionMetadataResponseUnion' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionSelf$inboundSchema: z.ZodType<
  CreateSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateSubscriptionSelf$outboundSchema: z.ZodType<
  CreateSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionSelf$ {
  /** @deprecated use `CreateSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionSelf$inboundSchema;
  /** @deprecated use `CreateSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionSelf$outboundSchema;
  /** @deprecated use `CreateSubscriptionSelf$Outbound` instead. */
  export type Outbound = CreateSubscriptionSelf$Outbound;
}

export function createSubscriptionSelfToJSON(
  createSubscriptionSelf: CreateSubscriptionSelf,
): string {
  return JSON.stringify(
    CreateSubscriptionSelf$outboundSchema.parse(createSubscriptionSelf),
  );
}

export function createSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionCustomer$inboundSchema: z.ZodType<
  CreateSubscriptionCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CreateSubscriptionCustomer$outboundSchema: z.ZodType<
  CreateSubscriptionCustomer$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionCustomer$ {
  /** @deprecated use `CreateSubscriptionCustomer$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionCustomer$inboundSchema;
  /** @deprecated use `CreateSubscriptionCustomer$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionCustomer$outboundSchema;
  /** @deprecated use `CreateSubscriptionCustomer$Outbound` instead. */
  export type Outbound = CreateSubscriptionCustomer$Outbound;
}

export function createSubscriptionCustomerToJSON(
  createSubscriptionCustomer: CreateSubscriptionCustomer,
): string {
  return JSON.stringify(
    CreateSubscriptionCustomer$outboundSchema.parse(createSubscriptionCustomer),
  );
}

export function createSubscriptionCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionCustomer' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionMandate$inboundSchema: z.ZodType<
  CreateSubscriptionMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CreateSubscriptionMandate$outboundSchema: z.ZodType<
  CreateSubscriptionMandate$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionMandate$ {
  /** @deprecated use `CreateSubscriptionMandate$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionMandate$inboundSchema;
  /** @deprecated use `CreateSubscriptionMandate$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionMandate$outboundSchema;
  /** @deprecated use `CreateSubscriptionMandate$Outbound` instead. */
  export type Outbound = CreateSubscriptionMandate$Outbound;
}

export function createSubscriptionMandateToJSON(
  createSubscriptionMandate: CreateSubscriptionMandate,
): string {
  return JSON.stringify(
    CreateSubscriptionMandate$outboundSchema.parse(createSubscriptionMandate),
  );
}

export function createSubscriptionMandateFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionMandate' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionProfile$inboundSchema: z.ZodType<
  CreateSubscriptionProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CreateSubscriptionProfile$outboundSchema: z.ZodType<
  CreateSubscriptionProfile$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionProfile$ {
  /** @deprecated use `CreateSubscriptionProfile$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionProfile$inboundSchema;
  /** @deprecated use `CreateSubscriptionProfile$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionProfile$outboundSchema;
  /** @deprecated use `CreateSubscriptionProfile$Outbound` instead. */
  export type Outbound = CreateSubscriptionProfile$Outbound;
}

export function createSubscriptionProfileToJSON(
  createSubscriptionProfile: CreateSubscriptionProfile,
): string {
  return JSON.stringify(
    CreateSubscriptionProfile$outboundSchema.parse(createSubscriptionProfile),
  );
}

export function createSubscriptionProfileFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionProfile' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionPayments$inboundSchema: z.ZodType<
  CreateSubscriptionPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CreateSubscriptionPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CreateSubscriptionPayments$outboundSchema: z.ZodType<
  CreateSubscriptionPayments$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionPayments$ {
  /** @deprecated use `CreateSubscriptionPayments$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionPayments$inboundSchema;
  /** @deprecated use `CreateSubscriptionPayments$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionPayments$outboundSchema;
  /** @deprecated use `CreateSubscriptionPayments$Outbound` instead. */
  export type Outbound = CreateSubscriptionPayments$Outbound;
}

export function createSubscriptionPaymentsToJSON(
  createSubscriptionPayments: CreateSubscriptionPayments,
): string {
  return JSON.stringify(
    CreateSubscriptionPayments$outboundSchema.parse(createSubscriptionPayments),
  );
}

export function createSubscriptionPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionPayments' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionDocumentation$inboundSchema: z.ZodType<
  CreateSubscriptionDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreateSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreateSubscriptionDocumentation$outboundSchema: z.ZodType<
  CreateSubscriptionDocumentation$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionDocumentation$ {
  /** @deprecated use `CreateSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `CreateSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `CreateSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = CreateSubscriptionDocumentation$Outbound;
}

export function createSubscriptionDocumentationToJSON(
  createSubscriptionDocumentation: CreateSubscriptionDocumentation,
): string {
  return JSON.stringify(
    CreateSubscriptionDocumentation$outboundSchema.parse(
      createSubscriptionDocumentation,
    ),
  );
}

export function createSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionLinks$inboundSchema: z.ZodType<
  CreateSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreateSubscriptionSelf$inboundSchema).optional(),
  customer: z.nullable(z.lazy(() => CreateSubscriptionCustomer$inboundSchema))
    .optional(),
  mandate: z.nullable(z.lazy(() => CreateSubscriptionMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CreateSubscriptionProfile$inboundSchema))
    .optional(),
  payments: z.nullable(z.lazy(() => CreateSubscriptionPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() => CreateSubscriptionDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type CreateSubscriptionLinks$Outbound = {
  self?: CreateSubscriptionSelf$Outbound | undefined;
  customer?: CreateSubscriptionCustomer$Outbound | null | undefined;
  mandate?: CreateSubscriptionMandate$Outbound | null | undefined;
  profile?: CreateSubscriptionProfile$Outbound | null | undefined;
  payments?: CreateSubscriptionPayments$Outbound | null | undefined;
  documentation?: CreateSubscriptionDocumentation$Outbound | undefined;
};

/** @internal */
export const CreateSubscriptionLinks$outboundSchema: z.ZodType<
  CreateSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionLinks
> = z.object({
  self: z.lazy(() => CreateSubscriptionSelf$outboundSchema).optional(),
  customer: z.nullable(z.lazy(() => CreateSubscriptionCustomer$outboundSchema))
    .optional(),
  mandate: z.nullable(z.lazy(() => CreateSubscriptionMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CreateSubscriptionProfile$outboundSchema))
    .optional(),
  payments: z.nullable(z.lazy(() => CreateSubscriptionPayments$outboundSchema))
    .optional(),
  documentation: z.lazy(() => CreateSubscriptionDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionLinks$ {
  /** @deprecated use `CreateSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionLinks$inboundSchema;
  /** @deprecated use `CreateSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionLinks$outboundSchema;
  /** @deprecated use `CreateSubscriptionLinks$Outbound` instead. */
  export type Outbound = CreateSubscriptionLinks$Outbound;
}

export function createSubscriptionLinksToJSON(
  createSubscriptionLinks: CreateSubscriptionLinks,
): string {
  return JSON.stringify(
    CreateSubscriptionLinks$outboundSchema.parse(createSubscriptionLinks),
  );
}

export function createSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const CreateSubscriptionResponse$inboundSchema: z.ZodType<
  CreateSubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("subscription"),
  id: z.string().optional(),
  mode: CreateSubscriptionMode$inboundSchema.optional(),
  status: CreateSubscriptionStatus$inboundSchema.optional(),
  amount: z.lazy(() => CreateSubscriptionAmountResponse$inboundSchema)
    .optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.number().int().optional(),
  interval: CreateSubscriptionIntervalResponse$inboundSchema.optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(CreateSubscriptionMethodResponse$inboundSchema).optional(),
  applicationFee: z.lazy(() =>
    CreateSubscriptionApplicationFeeResponse$inboundSchema
  ).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateSubscriptionMetadataResponse$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreateSubscriptionLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreateSubscriptionResponse$Outbound = {
  resource: string;
  id?: string | undefined;
  mode?: string | undefined;
  status?: string | undefined;
  amount?: CreateSubscriptionAmountResponse$Outbound | undefined;
  times?: number | null | undefined;
  timesRemaining?: number | undefined;
  interval?: string | undefined;
  startDate?: string | undefined;
  nextPaymentDate?: string | null | undefined;
  description?: string | undefined;
  method?: string | null | undefined;
  applicationFee?:
    | CreateSubscriptionApplicationFeeResponse$Outbound
    | undefined;
  metadata?:
    | CreateSubscriptionMetadataResponse$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | null | undefined;
  createdAt?: string | undefined;
  canceledAt?: string | null | undefined;
  _links?: CreateSubscriptionLinks$Outbound | undefined;
};

/** @internal */
export const CreateSubscriptionResponse$outboundSchema: z.ZodType<
  CreateSubscriptionResponse$Outbound,
  z.ZodTypeDef,
  CreateSubscriptionResponse
> = z.object({
  resource: z.string().default("subscription"),
  id: z.string().optional(),
  mode: CreateSubscriptionMode$outboundSchema.optional(),
  status: CreateSubscriptionStatus$outboundSchema.optional(),
  amount: z.lazy(() => CreateSubscriptionAmountResponse$outboundSchema)
    .optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.number().int().optional(),
  interval: CreateSubscriptionIntervalResponse$outboundSchema.optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(CreateSubscriptionMethodResponse$outboundSchema)
    .optional(),
  applicationFee: z.lazy(() =>
    CreateSubscriptionApplicationFeeResponse$outboundSchema
  ).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CreateSubscriptionMetadataResponse$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreateSubscriptionLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriptionResponse$ {
  /** @deprecated use `CreateSubscriptionResponse$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriptionResponse$inboundSchema;
  /** @deprecated use `CreateSubscriptionResponse$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriptionResponse$outboundSchema;
  /** @deprecated use `CreateSubscriptionResponse$Outbound` instead. */
  export type Outbound = CreateSubscriptionResponse$Outbound;
}

export function createSubscriptionResponseToJSON(
  createSubscriptionResponse: CreateSubscriptionResponse,
): string {
  return JSON.stringify(
    CreateSubscriptionResponse$outboundSchema.parse(createSubscriptionResponse),
  );
}

export function createSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriptionResponse' from JSON`,
  );
}
