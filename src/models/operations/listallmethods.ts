/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ListAllMethodsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export const ListAllMethodsInclude = {
  Issuers: "issuers",
  Pricing: "pricing",
} as const;
/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export type ListAllMethodsInclude = ClosedEnum<typeof ListAllMethodsInclude>;

export type ListAllMethodsRequest = {
  /**
   * Passing a locale will sort the payment methods in the preferred order for the country, and translate the payment method names in the corresponding language.
   */
  locale?: string | undefined;
  /**
   * If supplied, only payment methods that support the amount and currency are returned.
   *
   * @remarks
   *
   * Example: `/v2/methods/all?amount[value]=100.00&amount[currency]=USD`
   */
  amount?: ListAllMethodsAmount | undefined;
  /**
   * This endpoint allows you to include additional information via the `include` query string parameter.
   */
  include?: ListAllMethodsInclude | null | undefined;
  /**
   * Set this parameter to `first` to only return the methods that can be used for the first payment of a recurring sequence.
   *
   * @remarks
   *
   * Set it to `recurring` to only return methods that can be used for recurring payments or subscriptions.
   *
   * Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
   */
  sequenceType?: string | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to retrieve the resources for.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.
   *
   * @remarks
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListAllMethodsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListAllMethodsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListAllMethodsBadRequestDocumentation;
};

/**
 * The minimum payment amount required to use this payment method.
 */
export type ListAllMethodsMinimumAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The maximum payment amount allowed when using this payment method. If there is no method-specific maximum, `null` is returned instead.
 */
export type ListAllMethodsMaximumAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * URLs of images representing the payment method.
 */
export type ListAllMethodsImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x: string;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x: string;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can scale to any desired size without compromising visual quality.
   */
  svg: string;
};

/**
 * URLs of images representing the issuer. required: - size1x - size2x - svg
 */
export type ListAllMethodsIssuerImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x?: string | undefined;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x?: string | undefined;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can scale to any desired size without compromising visual quality.
   */
  svg?: string | undefined;
};

export type ListAllMethodsIssuer = {
  resource?: string | undefined;
  id: string;
  /**
   * The full name of the issuer.
   */
  name: string;
  /**
   * URLs of images representing the issuer. required: - size1x - size2x - svg
   */
  image: ListAllMethodsIssuerImage;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllMethodsMethodSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllMethodsMethodDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListAllMethodsMethodLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListAllMethodsMethodSelf;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListAllMethodsMethodDocumentation | undefined;
};

/**
 * The fixed price charged per payment.
 */
export type ListAllMethodsFixed = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type Pricing = {
  /**
   * A description of what the pricing applies to. For example, a specific country (`The Netherlands`) or a category of cards (`American Express`). If a `locale` is provided, the description may be translated.
   */
  description: string;
  /**
   * The fixed price charged per payment.
   */
  fixed: ListAllMethodsFixed;
  /**
   * The variable price charged per payment, as a percentage string.
   */
  variable: string;
  /**
   * Only present for credit card pricing. It will correspond with the `feeRegion` of credit card payments as returned in the [Payments API](get-payment).
   */
  feeRegion?: string | null | undefined;
};

export type ListAllMethodsMethod = {
  /**
   * Indicates the response contains a payment method object. Will always contain the string `method` for this endpoint.
   */
  resource: string;
  /**
   * The unique identifier of the payment method. When used during [payment creation](create-payment), the payment method selection screen will be skipped.
   *
   * @remarks
   *
   * Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
   */
  id: string;
  /**
   * The full name of the payment method.
   *
   * @remarks
   *
   * If a `locale` parameter is provided, the name is translated to the given locale if possible.
   */
  description: string;
  /**
   * The minimum payment amount required to use this payment method.
   */
  minimumAmount: ListAllMethodsMinimumAmount;
  /**
   * The maximum payment amount allowed when using this payment method. If there is no method-specific maximum, `null` is returned instead.
   */
  maximumAmount: ListAllMethodsMaximumAmount | null;
  /**
   * URLs of images representing the payment method.
   */
  image: ListAllMethodsImage;
  /**
   * The payment method's activation status for this profile.
   *
   * @remarks
   *
   * Possible values: `activated` `pending-boarding` `pending-review` `pending-external` `rejected`
   */
  status: string | null;
  /**
   * **Optional include.** Array of objects for each 'issuer' that is available for this payment method. Only relevant for iDEAL, KBC/CBC, gift cards, and vouchers.
   */
  issuers?: Array<ListAllMethodsIssuer> | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListAllMethodsMethodLinks;
  /**
   * **Optional include.** Array of objects describing the pricing configuration applicable for this payment method on your account.
   */
  pricing?: Array<Pricing> | undefined;
};

export type ListAllMethodsEmbedded = {
  /**
   * An array of payment method objects. For a complete reference of the payment method object, refer to the [Get payment method endpoint](get-method) documentation.
   */
  methods: Array<ListAllMethodsMethod>;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllMethodsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllMethodsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

export type ListAllMethodsLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListAllMethodsSelf;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListAllMethodsDocumentation;
};

/**
 * A list of payment method objects. For a complete reference of the payment method object, refer to the [Get payment method endpoint](get-method) documentation.
 */
export type ListAllMethodsResponse = {
  /**
   * The number of payment method objects in this result set. Results are **not** paginated.
   */
  count: number;
  embedded: ListAllMethodsEmbedded;
  links: ListAllMethodsLinks;
};

/** @internal */
export const ListAllMethodsAmount$inboundSchema: z.ZodType<
  ListAllMethodsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllMethodsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllMethodsAmount$outboundSchema: z.ZodType<
  ListAllMethodsAmount$Outbound,
  z.ZodTypeDef,
  ListAllMethodsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsAmount$ {
  /** @deprecated use `ListAllMethodsAmount$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsAmount$inboundSchema;
  /** @deprecated use `ListAllMethodsAmount$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsAmount$outboundSchema;
  /** @deprecated use `ListAllMethodsAmount$Outbound` instead. */
  export type Outbound = ListAllMethodsAmount$Outbound;
}

export function listAllMethodsAmountToJSON(
  listAllMethodsAmount: ListAllMethodsAmount,
): string {
  return JSON.stringify(
    ListAllMethodsAmount$outboundSchema.parse(listAllMethodsAmount),
  );
}

export function listAllMethodsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsAmount' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsInclude$inboundSchema: z.ZodNativeEnum<
  typeof ListAllMethodsInclude
> = z.nativeEnum(ListAllMethodsInclude);

/** @internal */
export const ListAllMethodsInclude$outboundSchema: z.ZodNativeEnum<
  typeof ListAllMethodsInclude
> = ListAllMethodsInclude$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsInclude$ {
  /** @deprecated use `ListAllMethodsInclude$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsInclude$inboundSchema;
  /** @deprecated use `ListAllMethodsInclude$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsInclude$outboundSchema;
}

/** @internal */
export const ListAllMethodsRequest$inboundSchema: z.ZodType<
  ListAllMethodsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  locale: z.string().optional(),
  amount: z.lazy(() => ListAllMethodsAmount$inboundSchema).optional(),
  include: z.nullable(ListAllMethodsInclude$inboundSchema).optional(),
  sequenceType: z.string().optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListAllMethodsRequest$Outbound = {
  locale?: string | undefined;
  amount?: ListAllMethodsAmount$Outbound | undefined;
  include?: string | null | undefined;
  sequenceType?: string | undefined;
  profileId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListAllMethodsRequest$outboundSchema: z.ZodType<
  ListAllMethodsRequest$Outbound,
  z.ZodTypeDef,
  ListAllMethodsRequest
> = z.object({
  locale: z.string().optional(),
  amount: z.lazy(() => ListAllMethodsAmount$outboundSchema).optional(),
  include: z.nullable(ListAllMethodsInclude$outboundSchema).optional(),
  sequenceType: z.string().optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsRequest$ {
  /** @deprecated use `ListAllMethodsRequest$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsRequest$inboundSchema;
  /** @deprecated use `ListAllMethodsRequest$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsRequest$outboundSchema;
  /** @deprecated use `ListAllMethodsRequest$Outbound` instead. */
  export type Outbound = ListAllMethodsRequest$Outbound;
}

export function listAllMethodsRequestToJSON(
  listAllMethodsRequest: ListAllMethodsRequest,
): string {
  return JSON.stringify(
    ListAllMethodsRequest$outboundSchema.parse(listAllMethodsRequest),
  );
}

export function listAllMethodsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsRequest' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsBadRequestDocumentation$inboundSchema: z.ZodType<
  ListAllMethodsBadRequestDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllMethodsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllMethodsBadRequestDocumentation$outboundSchema: z.ZodType<
  ListAllMethodsBadRequestDocumentation$Outbound,
  z.ZodTypeDef,
  ListAllMethodsBadRequestDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsBadRequestDocumentation$ {
  /** @deprecated use `ListAllMethodsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListAllMethodsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListAllMethodsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllMethodsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListAllMethodsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListAllMethodsBadRequestDocumentation$Outbound;
}

export function listAllMethodsBadRequestDocumentationToJSON(
  listAllMethodsBadRequestDocumentation: ListAllMethodsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListAllMethodsBadRequestDocumentation$outboundSchema.parse(
      listAllMethodsBadRequestDocumentation,
    ),
  );
}

export function listAllMethodsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsBadRequestDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllMethodsBadRequestDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsBadRequestLinks$inboundSchema: z.ZodType<
  ListAllMethodsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListAllMethodsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListAllMethodsBadRequestLinks$Outbound = {
  documentation: ListAllMethodsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListAllMethodsBadRequestLinks$outboundSchema: z.ZodType<
  ListAllMethodsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListAllMethodsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListAllMethodsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsBadRequestLinks$ {
  /** @deprecated use `ListAllMethodsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListAllMethodsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListAllMethodsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListAllMethodsBadRequestLinks$Outbound;
}

export function listAllMethodsBadRequestLinksToJSON(
  listAllMethodsBadRequestLinks: ListAllMethodsBadRequestLinks,
): string {
  return JSON.stringify(
    ListAllMethodsBadRequestLinks$outboundSchema.parse(
      listAllMethodsBadRequestLinks,
    ),
  );
}

export function listAllMethodsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMinimumAmount$inboundSchema: z.ZodType<
  ListAllMethodsMinimumAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllMethodsMinimumAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllMethodsMinimumAmount$outboundSchema: z.ZodType<
  ListAllMethodsMinimumAmount$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMinimumAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMinimumAmount$ {
  /** @deprecated use `ListAllMethodsMinimumAmount$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMinimumAmount$inboundSchema;
  /** @deprecated use `ListAllMethodsMinimumAmount$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsMinimumAmount$outboundSchema;
  /** @deprecated use `ListAllMethodsMinimumAmount$Outbound` instead. */
  export type Outbound = ListAllMethodsMinimumAmount$Outbound;
}

export function listAllMethodsMinimumAmountToJSON(
  listAllMethodsMinimumAmount: ListAllMethodsMinimumAmount,
): string {
  return JSON.stringify(
    ListAllMethodsMinimumAmount$outboundSchema.parse(
      listAllMethodsMinimumAmount,
    ),
  );
}

export function listAllMethodsMinimumAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMinimumAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMinimumAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMinimumAmount' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMaximumAmount$inboundSchema: z.ZodType<
  ListAllMethodsMaximumAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllMethodsMaximumAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllMethodsMaximumAmount$outboundSchema: z.ZodType<
  ListAllMethodsMaximumAmount$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMaximumAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMaximumAmount$ {
  /** @deprecated use `ListAllMethodsMaximumAmount$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMaximumAmount$inboundSchema;
  /** @deprecated use `ListAllMethodsMaximumAmount$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsMaximumAmount$outboundSchema;
  /** @deprecated use `ListAllMethodsMaximumAmount$Outbound` instead. */
  export type Outbound = ListAllMethodsMaximumAmount$Outbound;
}

export function listAllMethodsMaximumAmountToJSON(
  listAllMethodsMaximumAmount: ListAllMethodsMaximumAmount,
): string {
  return JSON.stringify(
    ListAllMethodsMaximumAmount$outboundSchema.parse(
      listAllMethodsMaximumAmount,
    ),
  );
}

export function listAllMethodsMaximumAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMaximumAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMaximumAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMaximumAmount' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsImage$inboundSchema: z.ZodType<
  ListAllMethodsImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});

/** @internal */
export type ListAllMethodsImage$Outbound = {
  size1x: string;
  size2x: string;
  svg: string;
};

/** @internal */
export const ListAllMethodsImage$outboundSchema: z.ZodType<
  ListAllMethodsImage$Outbound,
  z.ZodTypeDef,
  ListAllMethodsImage
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsImage$ {
  /** @deprecated use `ListAllMethodsImage$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsImage$inboundSchema;
  /** @deprecated use `ListAllMethodsImage$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsImage$outboundSchema;
  /** @deprecated use `ListAllMethodsImage$Outbound` instead. */
  export type Outbound = ListAllMethodsImage$Outbound;
}

export function listAllMethodsImageToJSON(
  listAllMethodsImage: ListAllMethodsImage,
): string {
  return JSON.stringify(
    ListAllMethodsImage$outboundSchema.parse(listAllMethodsImage),
  );
}

export function listAllMethodsImageFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsImage' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsIssuerImage$inboundSchema: z.ZodType<
  ListAllMethodsIssuerImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});

/** @internal */
export type ListAllMethodsIssuerImage$Outbound = {
  size1x?: string | undefined;
  size2x?: string | undefined;
  svg?: string | undefined;
};

/** @internal */
export const ListAllMethodsIssuerImage$outboundSchema: z.ZodType<
  ListAllMethodsIssuerImage$Outbound,
  z.ZodTypeDef,
  ListAllMethodsIssuerImage
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsIssuerImage$ {
  /** @deprecated use `ListAllMethodsIssuerImage$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsIssuerImage$inboundSchema;
  /** @deprecated use `ListAllMethodsIssuerImage$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsIssuerImage$outboundSchema;
  /** @deprecated use `ListAllMethodsIssuerImage$Outbound` instead. */
  export type Outbound = ListAllMethodsIssuerImage$Outbound;
}

export function listAllMethodsIssuerImageToJSON(
  listAllMethodsIssuerImage: ListAllMethodsIssuerImage,
): string {
  return JSON.stringify(
    ListAllMethodsIssuerImage$outboundSchema.parse(listAllMethodsIssuerImage),
  );
}

export function listAllMethodsIssuerImageFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsIssuerImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsIssuerImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsIssuerImage' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsIssuer$inboundSchema: z.ZodType<
  ListAllMethodsIssuer,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("issuer"),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => ListAllMethodsIssuerImage$inboundSchema),
});

/** @internal */
export type ListAllMethodsIssuer$Outbound = {
  resource: string;
  id: string;
  name: string;
  image: ListAllMethodsIssuerImage$Outbound;
};

/** @internal */
export const ListAllMethodsIssuer$outboundSchema: z.ZodType<
  ListAllMethodsIssuer$Outbound,
  z.ZodTypeDef,
  ListAllMethodsIssuer
> = z.object({
  resource: z.string().default("issuer"),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => ListAllMethodsIssuerImage$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsIssuer$ {
  /** @deprecated use `ListAllMethodsIssuer$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsIssuer$inboundSchema;
  /** @deprecated use `ListAllMethodsIssuer$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsIssuer$outboundSchema;
  /** @deprecated use `ListAllMethodsIssuer$Outbound` instead. */
  export type Outbound = ListAllMethodsIssuer$Outbound;
}

export function listAllMethodsIssuerToJSON(
  listAllMethodsIssuer: ListAllMethodsIssuer,
): string {
  return JSON.stringify(
    ListAllMethodsIssuer$outboundSchema.parse(listAllMethodsIssuer),
  );
}

export function listAllMethodsIssuerFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsIssuer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsIssuer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsIssuer' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMethodSelf$inboundSchema: z.ZodType<
  ListAllMethodsMethodSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllMethodsMethodSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllMethodsMethodSelf$outboundSchema: z.ZodType<
  ListAllMethodsMethodSelf$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMethodSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMethodSelf$ {
  /** @deprecated use `ListAllMethodsMethodSelf$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMethodSelf$inboundSchema;
  /** @deprecated use `ListAllMethodsMethodSelf$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsMethodSelf$outboundSchema;
  /** @deprecated use `ListAllMethodsMethodSelf$Outbound` instead. */
  export type Outbound = ListAllMethodsMethodSelf$Outbound;
}

export function listAllMethodsMethodSelfToJSON(
  listAllMethodsMethodSelf: ListAllMethodsMethodSelf,
): string {
  return JSON.stringify(
    ListAllMethodsMethodSelf$outboundSchema.parse(listAllMethodsMethodSelf),
  );
}

export function listAllMethodsMethodSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMethodSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMethodSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMethodSelf' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMethodDocumentation$inboundSchema: z.ZodType<
  ListAllMethodsMethodDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllMethodsMethodDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllMethodsMethodDocumentation$outboundSchema: z.ZodType<
  ListAllMethodsMethodDocumentation$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMethodDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMethodDocumentation$ {
  /** @deprecated use `ListAllMethodsMethodDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMethodDocumentation$inboundSchema;
  /** @deprecated use `ListAllMethodsMethodDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllMethodsMethodDocumentation$outboundSchema;
  /** @deprecated use `ListAllMethodsMethodDocumentation$Outbound` instead. */
  export type Outbound = ListAllMethodsMethodDocumentation$Outbound;
}

export function listAllMethodsMethodDocumentationToJSON(
  listAllMethodsMethodDocumentation: ListAllMethodsMethodDocumentation,
): string {
  return JSON.stringify(
    ListAllMethodsMethodDocumentation$outboundSchema.parse(
      listAllMethodsMethodDocumentation,
    ),
  );
}

export function listAllMethodsMethodDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMethodDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMethodDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMethodDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMethodLinks$inboundSchema: z.ZodType<
  ListAllMethodsMethodLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListAllMethodsMethodSelf$inboundSchema),
  documentation: z.lazy(() => ListAllMethodsMethodDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type ListAllMethodsMethodLinks$Outbound = {
  self: ListAllMethodsMethodSelf$Outbound;
  documentation?: ListAllMethodsMethodDocumentation$Outbound | undefined;
};

/** @internal */
export const ListAllMethodsMethodLinks$outboundSchema: z.ZodType<
  ListAllMethodsMethodLinks$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMethodLinks
> = z.object({
  self: z.lazy(() => ListAllMethodsMethodSelf$outboundSchema),
  documentation: z.lazy(() => ListAllMethodsMethodDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMethodLinks$ {
  /** @deprecated use `ListAllMethodsMethodLinks$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMethodLinks$inboundSchema;
  /** @deprecated use `ListAllMethodsMethodLinks$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsMethodLinks$outboundSchema;
  /** @deprecated use `ListAllMethodsMethodLinks$Outbound` instead. */
  export type Outbound = ListAllMethodsMethodLinks$Outbound;
}

export function listAllMethodsMethodLinksToJSON(
  listAllMethodsMethodLinks: ListAllMethodsMethodLinks,
): string {
  return JSON.stringify(
    ListAllMethodsMethodLinks$outboundSchema.parse(listAllMethodsMethodLinks),
  );
}

export function listAllMethodsMethodLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMethodLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMethodLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMethodLinks' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsFixed$inboundSchema: z.ZodType<
  ListAllMethodsFixed,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllMethodsFixed$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllMethodsFixed$outboundSchema: z.ZodType<
  ListAllMethodsFixed$Outbound,
  z.ZodTypeDef,
  ListAllMethodsFixed
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsFixed$ {
  /** @deprecated use `ListAllMethodsFixed$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsFixed$inboundSchema;
  /** @deprecated use `ListAllMethodsFixed$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsFixed$outboundSchema;
  /** @deprecated use `ListAllMethodsFixed$Outbound` instead. */
  export type Outbound = ListAllMethodsFixed$Outbound;
}

export function listAllMethodsFixedToJSON(
  listAllMethodsFixed: ListAllMethodsFixed,
): string {
  return JSON.stringify(
    ListAllMethodsFixed$outboundSchema.parse(listAllMethodsFixed),
  );
}

export function listAllMethodsFixedFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsFixed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsFixed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsFixed' from JSON`,
  );
}

/** @internal */
export const Pricing$inboundSchema: z.ZodType<Pricing, z.ZodTypeDef, unknown> =
  z.object({
    description: z.string(),
    fixed: z.lazy(() => ListAllMethodsFixed$inboundSchema),
    variable: z.string(),
    feeRegion: z.nullable(z.string()).optional(),
  });

/** @internal */
export type Pricing$Outbound = {
  description: string;
  fixed: ListAllMethodsFixed$Outbound;
  variable: string;
  feeRegion?: string | null | undefined;
};

/** @internal */
export const Pricing$outboundSchema: z.ZodType<
  Pricing$Outbound,
  z.ZodTypeDef,
  Pricing
> = z.object({
  description: z.string(),
  fixed: z.lazy(() => ListAllMethodsFixed$outboundSchema),
  variable: z.string(),
  feeRegion: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Pricing$ {
  /** @deprecated use `Pricing$inboundSchema` instead. */
  export const inboundSchema = Pricing$inboundSchema;
  /** @deprecated use `Pricing$outboundSchema` instead. */
  export const outboundSchema = Pricing$outboundSchema;
  /** @deprecated use `Pricing$Outbound` instead. */
  export type Outbound = Pricing$Outbound;
}

export function pricingToJSON(pricing: Pricing): string {
  return JSON.stringify(Pricing$outboundSchema.parse(pricing));
}

export function pricingFromJSON(
  jsonString: string,
): SafeParseResult<Pricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pricing' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsMethod$inboundSchema: z.ZodType<
  ListAllMethodsMethod,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  description: z.string(),
  minimumAmount: z.lazy(() => ListAllMethodsMinimumAmount$inboundSchema),
  maximumAmount: z.nullable(
    z.lazy(() => ListAllMethodsMaximumAmount$inboundSchema),
  ),
  image: z.lazy(() => ListAllMethodsImage$inboundSchema),
  status: z.nullable(z.string()),
  issuers: z.array(z.lazy(() => ListAllMethodsIssuer$inboundSchema)).optional(),
  _links: z.lazy(() => ListAllMethodsMethodLinks$inboundSchema),
  pricing: z.array(z.lazy(() => Pricing$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListAllMethodsMethod$Outbound = {
  resource: string;
  id: string;
  description: string;
  minimumAmount: ListAllMethodsMinimumAmount$Outbound;
  maximumAmount: ListAllMethodsMaximumAmount$Outbound | null;
  image: ListAllMethodsImage$Outbound;
  status: string | null;
  issuers?: Array<ListAllMethodsIssuer$Outbound> | undefined;
  _links: ListAllMethodsMethodLinks$Outbound;
  pricing?: Array<Pricing$Outbound> | undefined;
};

/** @internal */
export const ListAllMethodsMethod$outboundSchema: z.ZodType<
  ListAllMethodsMethod$Outbound,
  z.ZodTypeDef,
  ListAllMethodsMethod
> = z.object({
  resource: z.string(),
  id: z.string(),
  description: z.string(),
  minimumAmount: z.lazy(() => ListAllMethodsMinimumAmount$outboundSchema),
  maximumAmount: z.nullable(
    z.lazy(() => ListAllMethodsMaximumAmount$outboundSchema),
  ),
  image: z.lazy(() => ListAllMethodsImage$outboundSchema),
  status: z.nullable(z.string()),
  issuers: z.array(z.lazy(() => ListAllMethodsIssuer$outboundSchema))
    .optional(),
  links: z.lazy(() => ListAllMethodsMethodLinks$outboundSchema),
  pricing: z.array(z.lazy(() => Pricing$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsMethod$ {
  /** @deprecated use `ListAllMethodsMethod$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsMethod$inboundSchema;
  /** @deprecated use `ListAllMethodsMethod$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsMethod$outboundSchema;
  /** @deprecated use `ListAllMethodsMethod$Outbound` instead. */
  export type Outbound = ListAllMethodsMethod$Outbound;
}

export function listAllMethodsMethodToJSON(
  listAllMethodsMethod: ListAllMethodsMethod,
): string {
  return JSON.stringify(
    ListAllMethodsMethod$outboundSchema.parse(listAllMethodsMethod),
  );
}

export function listAllMethodsMethodFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsMethod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsMethod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsMethod' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsEmbedded$inboundSchema: z.ZodType<
  ListAllMethodsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  methods: z.array(z.lazy(() => ListAllMethodsMethod$inboundSchema)),
});

/** @internal */
export type ListAllMethodsEmbedded$Outbound = {
  methods: Array<ListAllMethodsMethod$Outbound>;
};

/** @internal */
export const ListAllMethodsEmbedded$outboundSchema: z.ZodType<
  ListAllMethodsEmbedded$Outbound,
  z.ZodTypeDef,
  ListAllMethodsEmbedded
> = z.object({
  methods: z.array(z.lazy(() => ListAllMethodsMethod$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsEmbedded$ {
  /** @deprecated use `ListAllMethodsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsEmbedded$inboundSchema;
  /** @deprecated use `ListAllMethodsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsEmbedded$outboundSchema;
  /** @deprecated use `ListAllMethodsEmbedded$Outbound` instead. */
  export type Outbound = ListAllMethodsEmbedded$Outbound;
}

export function listAllMethodsEmbeddedToJSON(
  listAllMethodsEmbedded: ListAllMethodsEmbedded,
): string {
  return JSON.stringify(
    ListAllMethodsEmbedded$outboundSchema.parse(listAllMethodsEmbedded),
  );
}

export function listAllMethodsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsSelf$inboundSchema: z.ZodType<
  ListAllMethodsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllMethodsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllMethodsSelf$outboundSchema: z.ZodType<
  ListAllMethodsSelf$Outbound,
  z.ZodTypeDef,
  ListAllMethodsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsSelf$ {
  /** @deprecated use `ListAllMethodsSelf$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsSelf$inboundSchema;
  /** @deprecated use `ListAllMethodsSelf$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsSelf$outboundSchema;
  /** @deprecated use `ListAllMethodsSelf$Outbound` instead. */
  export type Outbound = ListAllMethodsSelf$Outbound;
}

export function listAllMethodsSelfToJSON(
  listAllMethodsSelf: ListAllMethodsSelf,
): string {
  return JSON.stringify(
    ListAllMethodsSelf$outboundSchema.parse(listAllMethodsSelf),
  );
}

export function listAllMethodsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsSelf' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsDocumentation$inboundSchema: z.ZodType<
  ListAllMethodsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllMethodsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllMethodsDocumentation$outboundSchema: z.ZodType<
  ListAllMethodsDocumentation$Outbound,
  z.ZodTypeDef,
  ListAllMethodsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsDocumentation$ {
  /** @deprecated use `ListAllMethodsDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsDocumentation$inboundSchema;
  /** @deprecated use `ListAllMethodsDocumentation$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsDocumentation$outboundSchema;
  /** @deprecated use `ListAllMethodsDocumentation$Outbound` instead. */
  export type Outbound = ListAllMethodsDocumentation$Outbound;
}

export function listAllMethodsDocumentationToJSON(
  listAllMethodsDocumentation: ListAllMethodsDocumentation,
): string {
  return JSON.stringify(
    ListAllMethodsDocumentation$outboundSchema.parse(
      listAllMethodsDocumentation,
    ),
  );
}

export function listAllMethodsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsLinks$inboundSchema: z.ZodType<
  ListAllMethodsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListAllMethodsSelf$inboundSchema),
  documentation: z.lazy(() => ListAllMethodsDocumentation$inboundSchema),
});

/** @internal */
export type ListAllMethodsLinks$Outbound = {
  self: ListAllMethodsSelf$Outbound;
  documentation: ListAllMethodsDocumentation$Outbound;
};

/** @internal */
export const ListAllMethodsLinks$outboundSchema: z.ZodType<
  ListAllMethodsLinks$Outbound,
  z.ZodTypeDef,
  ListAllMethodsLinks
> = z.object({
  self: z.lazy(() => ListAllMethodsSelf$outboundSchema),
  documentation: z.lazy(() => ListAllMethodsDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsLinks$ {
  /** @deprecated use `ListAllMethodsLinks$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsLinks$inboundSchema;
  /** @deprecated use `ListAllMethodsLinks$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsLinks$outboundSchema;
  /** @deprecated use `ListAllMethodsLinks$Outbound` instead. */
  export type Outbound = ListAllMethodsLinks$Outbound;
}

export function listAllMethodsLinksToJSON(
  listAllMethodsLinks: ListAllMethodsLinks,
): string {
  return JSON.stringify(
    ListAllMethodsLinks$outboundSchema.parse(listAllMethodsLinks),
  );
}

export function listAllMethodsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsLinks' from JSON`,
  );
}

/** @internal */
export const ListAllMethodsResponse$inboundSchema: z.ZodType<
  ListAllMethodsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int(),
  _embedded: z.lazy(() => ListAllMethodsEmbedded$inboundSchema),
  _links: z.lazy(() => ListAllMethodsLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListAllMethodsResponse$Outbound = {
  count: number;
  _embedded: ListAllMethodsEmbedded$Outbound;
  _links: ListAllMethodsLinks$Outbound;
};

/** @internal */
export const ListAllMethodsResponse$outboundSchema: z.ZodType<
  ListAllMethodsResponse$Outbound,
  z.ZodTypeDef,
  ListAllMethodsResponse
> = z.object({
  count: z.number().int(),
  embedded: z.lazy(() => ListAllMethodsEmbedded$outboundSchema),
  links: z.lazy(() => ListAllMethodsLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllMethodsResponse$ {
  /** @deprecated use `ListAllMethodsResponse$inboundSchema` instead. */
  export const inboundSchema = ListAllMethodsResponse$inboundSchema;
  /** @deprecated use `ListAllMethodsResponse$outboundSchema` instead. */
  export const outboundSchema = ListAllMethodsResponse$outboundSchema;
  /** @deprecated use `ListAllMethodsResponse$Outbound` instead. */
  export type Outbound = ListAllMethodsResponse$Outbound;
}

export function listAllMethodsResponseToJSON(
  listAllMethodsResponse: ListAllMethodsResponse,
): string {
  return JSON.stringify(
    ListAllMethodsResponse$outboundSchema.parse(listAllMethodsResponse),
  );
}

export function listAllMethodsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListAllMethodsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllMethodsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllMethodsResponse' from JSON`,
  );
}
