/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Update the amount for future payments of this subscription.
 */
export type UpdateSubscriptionAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the
 *
 * @remarks
 * entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to
 * approximately 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type UpdateSubscriptionMetadataRequest =
  | string
  | { [k: string]: any }
  | Array<string>;

export type UpdateSubscriptionRequestBody = {
  /**
   * Update the amount for future payments of this subscription.
   */
  amount?: UpdateSubscriptionAmountRequest | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description?: string | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval?: string | undefined;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the
   *
   * @remarks
   * entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to
   * approximately 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment
   * failures as well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. For organization-level credentials
   *
   * @remarks
   * such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

export type UpdateSubscriptionRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide the ID of the related subscription.
   */
  subscriptionId: string;
  requestBody?: UpdateSubscriptionRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type UpdateSubscriptionNotFoundDocumentation = {
  href: string;
  type: string;
};

export type UpdateSubscriptionNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: UpdateSubscriptionNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const UpdateSubscriptionMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type UpdateSubscriptionMode = ClosedEnum<typeof UpdateSubscriptionMode>;

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const UpdateSubscriptionStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type UpdateSubscriptionStatus = ClosedEnum<
  typeof UpdateSubscriptionStatus
>;

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type UpdateSubscriptionAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const UpdateSubscriptionMethod = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type UpdateSubscriptionMethod = ClosedEnum<
  typeof UpdateSubscriptionMethod
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type UpdateSubscriptionApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type UpdateSubscriptionApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: UpdateSubscriptionApplicationFeeAmount;
  description: string;
};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type UpdateSubscriptionMetadataResponse =
  | string
  | { [k: string]: any }
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type UpdateSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type UpdateSubscriptionCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type UpdateSubscriptionMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type UpdateSubscriptionProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
 *
 * @remarks
 * payments exist (yet).
 */
export type UpdateSubscriptionPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type UpdateSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type UpdateSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: UpdateSubscriptionSelf;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer: UpdateSubscriptionCustomer | null;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: UpdateSubscriptionMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile: UpdateSubscriptionProfile | null;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
   *
   * @remarks
   * payments exist (yet).
   */
  payments?: UpdateSubscriptionPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: UpdateSubscriptionDocumentation;
};

/**
 * The updated subscription object.
 */
export type UpdateSubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: UpdateSubscriptionMode;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status: UpdateSubscriptionStatus;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount: UpdateSubscriptionAmountResponse;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times: number | null;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining: number | null;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval: string;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate: string;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method: UpdateSubscriptionMethod | null;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: UpdateSubscriptionApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata: string | { [k: string]: any } | Array<string> | null;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl: string;
  /**
   * The customer this subscription belongs to.
   */
  customerId: string;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: UpdateSubscriptionLinks;
};

/** @internal */
export const UpdateSubscriptionAmountRequest$inboundSchema: z.ZodType<
  UpdateSubscriptionAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdateSubscriptionAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdateSubscriptionAmountRequest$outboundSchema: z.ZodType<
  UpdateSubscriptionAmountRequest$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionAmountRequest$ {
  /** @deprecated use `UpdateSubscriptionAmountRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionAmountRequest$inboundSchema;
  /** @deprecated use `UpdateSubscriptionAmountRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionAmountRequest$outboundSchema;
  /** @deprecated use `UpdateSubscriptionAmountRequest$Outbound` instead. */
  export type Outbound = UpdateSubscriptionAmountRequest$Outbound;
}

export function updateSubscriptionAmountRequestToJSON(
  updateSubscriptionAmountRequest: UpdateSubscriptionAmountRequest,
): string {
  return JSON.stringify(
    UpdateSubscriptionAmountRequest$outboundSchema.parse(
      updateSubscriptionAmountRequest,
    ),
  );
}

export function updateSubscriptionAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionAmountRequest' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionMetadataRequest$inboundSchema: z.ZodType<
  UpdateSubscriptionMetadataRequest,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type UpdateSubscriptionMetadataRequest$Outbound = string | {
  [k: string]: any;
} | Array<string>;

/** @internal */
export const UpdateSubscriptionMetadataRequest$outboundSchema: z.ZodType<
  UpdateSubscriptionMetadataRequest$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionMetadataRequest
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionMetadataRequest$ {
  /** @deprecated use `UpdateSubscriptionMetadataRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionMetadataRequest$inboundSchema;
  /** @deprecated use `UpdateSubscriptionMetadataRequest$outboundSchema` instead. */
  export const outboundSchema =
    UpdateSubscriptionMetadataRequest$outboundSchema;
  /** @deprecated use `UpdateSubscriptionMetadataRequest$Outbound` instead. */
  export type Outbound = UpdateSubscriptionMetadataRequest$Outbound;
}

export function updateSubscriptionMetadataRequestToJSON(
  updateSubscriptionMetadataRequest: UpdateSubscriptionMetadataRequest,
): string {
  return JSON.stringify(
    UpdateSubscriptionMetadataRequest$outboundSchema.parse(
      updateSubscriptionMetadataRequest,
    ),
  );
}

export function updateSubscriptionMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionMetadataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionMetadataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionMetadataRequest' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionRequestBody$inboundSchema: z.ZodType<
  UpdateSubscriptionRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => UpdateSubscriptionAmountRequest$inboundSchema)
    .optional(),
  description: z.string().optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  times: z.number().int().optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  webhookUrl: z.string().optional(),
  mandateId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type UpdateSubscriptionRequestBody$Outbound = {
  amount?: UpdateSubscriptionAmountRequest$Outbound | undefined;
  description?: string | undefined;
  interval?: string | undefined;
  startDate?: string | undefined;
  times?: number | undefined;
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  webhookUrl?: string | undefined;
  mandateId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const UpdateSubscriptionRequestBody$outboundSchema: z.ZodType<
  UpdateSubscriptionRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionRequestBody
> = z.object({
  amount: z.lazy(() => UpdateSubscriptionAmountRequest$outboundSchema)
    .optional(),
  description: z.string().optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  times: z.number().int().optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  webhookUrl: z.string().optional(),
  mandateId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionRequestBody$ {
  /** @deprecated use `UpdateSubscriptionRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionRequestBody$inboundSchema;
  /** @deprecated use `UpdateSubscriptionRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionRequestBody$outboundSchema;
  /** @deprecated use `UpdateSubscriptionRequestBody$Outbound` instead. */
  export type Outbound = UpdateSubscriptionRequestBody$Outbound;
}

export function updateSubscriptionRequestBodyToJSON(
  updateSubscriptionRequestBody: UpdateSubscriptionRequestBody,
): string {
  return JSON.stringify(
    UpdateSubscriptionRequestBody$outboundSchema.parse(
      updateSubscriptionRequestBody,
    ),
  );
}

export function updateSubscriptionRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionRequest$inboundSchema: z.ZodType<
  UpdateSubscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  RequestBody: z.lazy(() => UpdateSubscriptionRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateSubscriptionRequest$Outbound = {
  customerId: string;
  subscriptionId: string;
  RequestBody?: UpdateSubscriptionRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateSubscriptionRequest$outboundSchema: z.ZodType<
  UpdateSubscriptionRequest$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionRequest
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  requestBody: z.lazy(() => UpdateSubscriptionRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionRequest$ {
  /** @deprecated use `UpdateSubscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionRequest$inboundSchema;
  /** @deprecated use `UpdateSubscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionRequest$outboundSchema;
  /** @deprecated use `UpdateSubscriptionRequest$Outbound` instead. */
  export type Outbound = UpdateSubscriptionRequest$Outbound;
}

export function updateSubscriptionRequestToJSON(
  updateSubscriptionRequest: UpdateSubscriptionRequest,
): string {
  return JSON.stringify(
    UpdateSubscriptionRequest$outboundSchema.parse(updateSubscriptionRequest),
  );
}

export function updateSubscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionRequest' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionNotFoundDocumentation$inboundSchema: z.ZodType<
  UpdateSubscriptionNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdateSubscriptionNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdateSubscriptionNotFoundDocumentation$outboundSchema: z.ZodType<
  UpdateSubscriptionNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionNotFoundDocumentation$ {
  /** @deprecated use `UpdateSubscriptionNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    UpdateSubscriptionNotFoundDocumentation$inboundSchema;
  /** @deprecated use `UpdateSubscriptionNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    UpdateSubscriptionNotFoundDocumentation$outboundSchema;
  /** @deprecated use `UpdateSubscriptionNotFoundDocumentation$Outbound` instead. */
  export type Outbound = UpdateSubscriptionNotFoundDocumentation$Outbound;
}

export function updateSubscriptionNotFoundDocumentationToJSON(
  updateSubscriptionNotFoundDocumentation:
    UpdateSubscriptionNotFoundDocumentation,
): string {
  return JSON.stringify(
    UpdateSubscriptionNotFoundDocumentation$outboundSchema.parse(
      updateSubscriptionNotFoundDocumentation,
    ),
  );
}

export function updateSubscriptionNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateSubscriptionNotFoundDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateSubscriptionNotFoundDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateSubscriptionNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionNotFoundLinks$inboundSchema: z.ZodType<
  UpdateSubscriptionNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    UpdateSubscriptionNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type UpdateSubscriptionNotFoundLinks$Outbound = {
  documentation: UpdateSubscriptionNotFoundDocumentation$Outbound;
};

/** @internal */
export const UpdateSubscriptionNotFoundLinks$outboundSchema: z.ZodType<
  UpdateSubscriptionNotFoundLinks$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    UpdateSubscriptionNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionNotFoundLinks$ {
  /** @deprecated use `UpdateSubscriptionNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionNotFoundLinks$inboundSchema;
  /** @deprecated use `UpdateSubscriptionNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionNotFoundLinks$outboundSchema;
  /** @deprecated use `UpdateSubscriptionNotFoundLinks$Outbound` instead. */
  export type Outbound = UpdateSubscriptionNotFoundLinks$Outbound;
}

export function updateSubscriptionNotFoundLinksToJSON(
  updateSubscriptionNotFoundLinks: UpdateSubscriptionNotFoundLinks,
): string {
  return JSON.stringify(
    UpdateSubscriptionNotFoundLinks$outboundSchema.parse(
      updateSubscriptionNotFoundLinks,
    ),
  );
}

export function updateSubscriptionNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionMode
> = z.nativeEnum(UpdateSubscriptionMode);

/** @internal */
export const UpdateSubscriptionMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionMode
> = UpdateSubscriptionMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionMode$ {
  /** @deprecated use `UpdateSubscriptionMode$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionMode$inboundSchema;
  /** @deprecated use `UpdateSubscriptionMode$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionMode$outboundSchema;
}

/** @internal */
export const UpdateSubscriptionStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionStatus
> = z.nativeEnum(UpdateSubscriptionStatus);

/** @internal */
export const UpdateSubscriptionStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionStatus
> = UpdateSubscriptionStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionStatus$ {
  /** @deprecated use `UpdateSubscriptionStatus$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionStatus$inboundSchema;
  /** @deprecated use `UpdateSubscriptionStatus$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionStatus$outboundSchema;
}

/** @internal */
export const UpdateSubscriptionAmountResponse$inboundSchema: z.ZodType<
  UpdateSubscriptionAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdateSubscriptionAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdateSubscriptionAmountResponse$outboundSchema: z.ZodType<
  UpdateSubscriptionAmountResponse$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionAmountResponse$ {
  /** @deprecated use `UpdateSubscriptionAmountResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionAmountResponse$inboundSchema;
  /** @deprecated use `UpdateSubscriptionAmountResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionAmountResponse$outboundSchema;
  /** @deprecated use `UpdateSubscriptionAmountResponse$Outbound` instead. */
  export type Outbound = UpdateSubscriptionAmountResponse$Outbound;
}

export function updateSubscriptionAmountResponseToJSON(
  updateSubscriptionAmountResponse: UpdateSubscriptionAmountResponse,
): string {
  return JSON.stringify(
    UpdateSubscriptionAmountResponse$outboundSchema.parse(
      updateSubscriptionAmountResponse,
    ),
  );
}

export function updateSubscriptionAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionAmountResponse' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionMethod
> = z.nativeEnum(UpdateSubscriptionMethod);

/** @internal */
export const UpdateSubscriptionMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateSubscriptionMethod
> = UpdateSubscriptionMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionMethod$ {
  /** @deprecated use `UpdateSubscriptionMethod$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionMethod$inboundSchema;
  /** @deprecated use `UpdateSubscriptionMethod$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionMethod$outboundSchema;
}

/** @internal */
export const UpdateSubscriptionApplicationFeeAmount$inboundSchema: z.ZodType<
  UpdateSubscriptionApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UpdateSubscriptionApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UpdateSubscriptionApplicationFeeAmount$outboundSchema: z.ZodType<
  UpdateSubscriptionApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionApplicationFeeAmount$ {
  /** @deprecated use `UpdateSubscriptionApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    UpdateSubscriptionApplicationFeeAmount$inboundSchema;
  /** @deprecated use `UpdateSubscriptionApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    UpdateSubscriptionApplicationFeeAmount$outboundSchema;
  /** @deprecated use `UpdateSubscriptionApplicationFeeAmount$Outbound` instead. */
  export type Outbound = UpdateSubscriptionApplicationFeeAmount$Outbound;
}

export function updateSubscriptionApplicationFeeAmountToJSON(
  updateSubscriptionApplicationFeeAmount:
    UpdateSubscriptionApplicationFeeAmount,
): string {
  return JSON.stringify(
    UpdateSubscriptionApplicationFeeAmount$outboundSchema.parse(
      updateSubscriptionApplicationFeeAmount,
    ),
  );
}

export function updateSubscriptionApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateSubscriptionApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionApplicationFee$inboundSchema: z.ZodType<
  UpdateSubscriptionApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => UpdateSubscriptionApplicationFeeAmount$inboundSchema),
  description: z.string(),
});

/** @internal */
export type UpdateSubscriptionApplicationFee$Outbound = {
  amount: UpdateSubscriptionApplicationFeeAmount$Outbound;
  description: string;
};

/** @internal */
export const UpdateSubscriptionApplicationFee$outboundSchema: z.ZodType<
  UpdateSubscriptionApplicationFee$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionApplicationFee
> = z.object({
  amount: z.lazy(() => UpdateSubscriptionApplicationFeeAmount$outboundSchema),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionApplicationFee$ {
  /** @deprecated use `UpdateSubscriptionApplicationFee$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionApplicationFee$inboundSchema;
  /** @deprecated use `UpdateSubscriptionApplicationFee$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionApplicationFee$outboundSchema;
  /** @deprecated use `UpdateSubscriptionApplicationFee$Outbound` instead. */
  export type Outbound = UpdateSubscriptionApplicationFee$Outbound;
}

export function updateSubscriptionApplicationFeeToJSON(
  updateSubscriptionApplicationFee: UpdateSubscriptionApplicationFee,
): string {
  return JSON.stringify(
    UpdateSubscriptionApplicationFee$outboundSchema.parse(
      updateSubscriptionApplicationFee,
    ),
  );
}

export function updateSubscriptionApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionApplicationFee' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionMetadataResponse$inboundSchema: z.ZodType<
  UpdateSubscriptionMetadataResponse,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type UpdateSubscriptionMetadataResponse$Outbound = string | {
  [k: string]: any;
} | Array<string>;

/** @internal */
export const UpdateSubscriptionMetadataResponse$outboundSchema: z.ZodType<
  UpdateSubscriptionMetadataResponse$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionMetadataResponse
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionMetadataResponse$ {
  /** @deprecated use `UpdateSubscriptionMetadataResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionMetadataResponse$inboundSchema;
  /** @deprecated use `UpdateSubscriptionMetadataResponse$outboundSchema` instead. */
  export const outboundSchema =
    UpdateSubscriptionMetadataResponse$outboundSchema;
  /** @deprecated use `UpdateSubscriptionMetadataResponse$Outbound` instead. */
  export type Outbound = UpdateSubscriptionMetadataResponse$Outbound;
}

export function updateSubscriptionMetadataResponseToJSON(
  updateSubscriptionMetadataResponse: UpdateSubscriptionMetadataResponse,
): string {
  return JSON.stringify(
    UpdateSubscriptionMetadataResponse$outboundSchema.parse(
      updateSubscriptionMetadataResponse,
    ),
  );
}

export function updateSubscriptionMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionMetadataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateSubscriptionMetadataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionMetadataResponse' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionSelf$inboundSchema: z.ZodType<
  UpdateSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdateSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdateSubscriptionSelf$outboundSchema: z.ZodType<
  UpdateSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionSelf$ {
  /** @deprecated use `UpdateSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionSelf$inboundSchema;
  /** @deprecated use `UpdateSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionSelf$outboundSchema;
  /** @deprecated use `UpdateSubscriptionSelf$Outbound` instead. */
  export type Outbound = UpdateSubscriptionSelf$Outbound;
}

export function updateSubscriptionSelfToJSON(
  updateSubscriptionSelf: UpdateSubscriptionSelf,
): string {
  return JSON.stringify(
    UpdateSubscriptionSelf$outboundSchema.parse(updateSubscriptionSelf),
  );
}

export function updateSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionCustomer$inboundSchema: z.ZodType<
  UpdateSubscriptionCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type UpdateSubscriptionCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionCustomer$outboundSchema: z.ZodType<
  UpdateSubscriptionCustomer$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionCustomer$ {
  /** @deprecated use `UpdateSubscriptionCustomer$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionCustomer$inboundSchema;
  /** @deprecated use `UpdateSubscriptionCustomer$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionCustomer$outboundSchema;
  /** @deprecated use `UpdateSubscriptionCustomer$Outbound` instead. */
  export type Outbound = UpdateSubscriptionCustomer$Outbound;
}

export function updateSubscriptionCustomerToJSON(
  updateSubscriptionCustomer: UpdateSubscriptionCustomer,
): string {
  return JSON.stringify(
    UpdateSubscriptionCustomer$outboundSchema.parse(updateSubscriptionCustomer),
  );
}

export function updateSubscriptionCustomerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionCustomer' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionMandate$inboundSchema: z.ZodType<
  UpdateSubscriptionMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type UpdateSubscriptionMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionMandate$outboundSchema: z.ZodType<
  UpdateSubscriptionMandate$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionMandate$ {
  /** @deprecated use `UpdateSubscriptionMandate$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionMandate$inboundSchema;
  /** @deprecated use `UpdateSubscriptionMandate$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionMandate$outboundSchema;
  /** @deprecated use `UpdateSubscriptionMandate$Outbound` instead. */
  export type Outbound = UpdateSubscriptionMandate$Outbound;
}

export function updateSubscriptionMandateToJSON(
  updateSubscriptionMandate: UpdateSubscriptionMandate,
): string {
  return JSON.stringify(
    UpdateSubscriptionMandate$outboundSchema.parse(updateSubscriptionMandate),
  );
}

export function updateSubscriptionMandateFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionMandate' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionProfile$inboundSchema: z.ZodType<
  UpdateSubscriptionProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type UpdateSubscriptionProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionProfile$outboundSchema: z.ZodType<
  UpdateSubscriptionProfile$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionProfile$ {
  /** @deprecated use `UpdateSubscriptionProfile$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionProfile$inboundSchema;
  /** @deprecated use `UpdateSubscriptionProfile$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionProfile$outboundSchema;
  /** @deprecated use `UpdateSubscriptionProfile$Outbound` instead. */
  export type Outbound = UpdateSubscriptionProfile$Outbound;
}

export function updateSubscriptionProfileToJSON(
  updateSubscriptionProfile: UpdateSubscriptionProfile,
): string {
  return JSON.stringify(
    UpdateSubscriptionProfile$outboundSchema.parse(updateSubscriptionProfile),
  );
}

export function updateSubscriptionProfileFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionProfile' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionPayments$inboundSchema: z.ZodType<
  UpdateSubscriptionPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type UpdateSubscriptionPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const UpdateSubscriptionPayments$outboundSchema: z.ZodType<
  UpdateSubscriptionPayments$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionPayments$ {
  /** @deprecated use `UpdateSubscriptionPayments$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionPayments$inboundSchema;
  /** @deprecated use `UpdateSubscriptionPayments$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionPayments$outboundSchema;
  /** @deprecated use `UpdateSubscriptionPayments$Outbound` instead. */
  export type Outbound = UpdateSubscriptionPayments$Outbound;
}

export function updateSubscriptionPaymentsToJSON(
  updateSubscriptionPayments: UpdateSubscriptionPayments,
): string {
  return JSON.stringify(
    UpdateSubscriptionPayments$outboundSchema.parse(updateSubscriptionPayments),
  );
}

export function updateSubscriptionPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionPayments' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionDocumentation$inboundSchema: z.ZodType<
  UpdateSubscriptionDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type UpdateSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const UpdateSubscriptionDocumentation$outboundSchema: z.ZodType<
  UpdateSubscriptionDocumentation$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionDocumentation$ {
  /** @deprecated use `UpdateSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `UpdateSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `UpdateSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = UpdateSubscriptionDocumentation$Outbound;
}

export function updateSubscriptionDocumentationToJSON(
  updateSubscriptionDocumentation: UpdateSubscriptionDocumentation,
): string {
  return JSON.stringify(
    UpdateSubscriptionDocumentation$outboundSchema.parse(
      updateSubscriptionDocumentation,
    ),
  );
}

export function updateSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionLinks$inboundSchema: z.ZodType<
  UpdateSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => UpdateSubscriptionSelf$inboundSchema),
  customer: z.nullable(z.lazy(() => UpdateSubscriptionCustomer$inboundSchema)),
  mandate: z.nullable(z.lazy(() => UpdateSubscriptionMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => UpdateSubscriptionProfile$inboundSchema)),
  payments: z.nullable(z.lazy(() => UpdateSubscriptionPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() => UpdateSubscriptionDocumentation$inboundSchema),
});

/** @internal */
export type UpdateSubscriptionLinks$Outbound = {
  self: UpdateSubscriptionSelf$Outbound;
  customer: UpdateSubscriptionCustomer$Outbound | null;
  mandate?: UpdateSubscriptionMandate$Outbound | null | undefined;
  profile: UpdateSubscriptionProfile$Outbound | null;
  payments?: UpdateSubscriptionPayments$Outbound | null | undefined;
  documentation: UpdateSubscriptionDocumentation$Outbound;
};

/** @internal */
export const UpdateSubscriptionLinks$outboundSchema: z.ZodType<
  UpdateSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionLinks
> = z.object({
  self: z.lazy(() => UpdateSubscriptionSelf$outboundSchema),
  customer: z.nullable(z.lazy(() => UpdateSubscriptionCustomer$outboundSchema)),
  mandate: z.nullable(z.lazy(() => UpdateSubscriptionMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => UpdateSubscriptionProfile$outboundSchema)),
  payments: z.nullable(z.lazy(() => UpdateSubscriptionPayments$outboundSchema))
    .optional(),
  documentation: z.lazy(() => UpdateSubscriptionDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionLinks$ {
  /** @deprecated use `UpdateSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionLinks$inboundSchema;
  /** @deprecated use `UpdateSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionLinks$outboundSchema;
  /** @deprecated use `UpdateSubscriptionLinks$Outbound` instead. */
  export type Outbound = UpdateSubscriptionLinks$Outbound;
}

export function updateSubscriptionLinksToJSON(
  updateSubscriptionLinks: UpdateSubscriptionLinks,
): string {
  return JSON.stringify(
    UpdateSubscriptionLinks$outboundSchema.parse(updateSubscriptionLinks),
  );
}

export function updateSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const UpdateSubscriptionResponse$inboundSchema: z.ZodType<
  UpdateSubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdateSubscriptionMode$inboundSchema,
  status: UpdateSubscriptionStatus$inboundSchema,
  amount: z.lazy(() => UpdateSubscriptionAmountResponse$inboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(UpdateSubscriptionMethod$inboundSchema),
  applicationFee: z.lazy(() => UpdateSubscriptionApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => UpdateSubscriptionLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type UpdateSubscriptionResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  status: string;
  amount: UpdateSubscriptionAmountResponse$Outbound;
  times: number | null;
  timesRemaining: number | null;
  interval: string;
  startDate: string;
  nextPaymentDate?: string | null | undefined;
  description: string;
  method: string | null;
  applicationFee?: UpdateSubscriptionApplicationFee$Outbound | undefined;
  metadata: string | { [k: string]: any } | Array<string> | null;
  webhookUrl: string;
  customerId: string;
  mandateId?: string | null | undefined;
  createdAt: string;
  canceledAt?: string | null | undefined;
  _links: UpdateSubscriptionLinks$Outbound;
};

/** @internal */
export const UpdateSubscriptionResponse$outboundSchema: z.ZodType<
  UpdateSubscriptionResponse$Outbound,
  z.ZodTypeDef,
  UpdateSubscriptionResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: UpdateSubscriptionMode$outboundSchema,
  status: UpdateSubscriptionStatus$outboundSchema,
  amount: z.lazy(() => UpdateSubscriptionAmountResponse$outboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(UpdateSubscriptionMethod$outboundSchema),
  applicationFee: z.lazy(() => UpdateSubscriptionApplicationFee$outboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => UpdateSubscriptionLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriptionResponse$ {
  /** @deprecated use `UpdateSubscriptionResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriptionResponse$inboundSchema;
  /** @deprecated use `UpdateSubscriptionResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriptionResponse$outboundSchema;
  /** @deprecated use `UpdateSubscriptionResponse$Outbound` instead. */
  export type Outbound = UpdateSubscriptionResponse$Outbound;
}

export function updateSubscriptionResponseToJSON(
  updateSubscriptionResponse: UpdateSubscriptionResponse,
): string {
  return JSON.stringify(
    UpdateSubscriptionResponse$outboundSchema.parse(updateSubscriptionResponse),
  );
}

export function updateSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriptionResponse' from JSON`,
  );
}
