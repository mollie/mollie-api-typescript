/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export const ListCustomersSort = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export type ListCustomersSort = ClosedEnum<typeof ListCustomersSort>;

export type ListCustomersRequest = {
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
   *
   * @remarks
   * result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
   *
   * @remarks
   * newest to oldest.
   */
  sort?: ListCustomersSort | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListCustomersNotFoundDocumentation = {
  href: string;
  type: string;
};

export type ListCustomersNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListCustomersNotFoundDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListCustomersBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListCustomersBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListCustomersBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListCustomersMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListCustomersMode = ClosedEnum<typeof ListCustomersMode>;

/**
 * Preconfigure the language to be used in the hosted payment pages shown to the customer. Should only be provided if
 *
 * @remarks
 * absolutely necessary. If not provided, the browser language will be used which is typically highly accurate.
 */
export const ListCustomersLocale = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Preconfigure the language to be used in the hosted payment pages shown to the customer. Should only be provided if
 *
 * @remarks
 * absolutely necessary. If not provided, the browser language will be used which is typically highly accurate.
 */
export type ListCustomersLocale = ClosedEnum<typeof ListCustomersLocale>;

export type ListCustomersMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListCustomersMetadataUnion =
  | ListCustomersMetadata
  | string
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CustomerSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomersDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payments](list-payments) linked to this customer. Omitted if no such payments
 *
 * @remarks
 * exist (yet).
 */
export type ListCustomersPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandates](list-mandates) linked to this customer. Omitted if no such mandates
 *
 * @remarks
 * exist (yet).
 */
export type ListCustomersMandates = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [subscriptions](list-subscriptions) linked to this customer. Omitted if no such
 *
 * @remarks
 * subscriptions exist (yet).
 */
export type ListCustomersSubscriptions = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CustomerDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CustomerLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: CustomerSelf | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  dashboard?: ListCustomersDashboard | undefined;
  /**
   * The API resource URL of the [payments](list-payments) linked to this customer. Omitted if no such payments
   *
   * @remarks
   * exist (yet).
   */
  payments?: ListCustomersPayments | null | undefined;
  /**
   * The API resource URL of the [mandates](list-mandates) linked to this customer. Omitted if no such mandates
   *
   * @remarks
   * exist (yet).
   */
  mandates?: ListCustomersMandates | null | undefined;
  /**
   * The API resource URL of the [subscriptions](list-subscriptions) linked to this customer. Omitted if no such
   *
   * @remarks
   * subscriptions exist (yet).
   */
  subscriptions?: ListCustomersSubscriptions | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: CustomerDocumentation | undefined;
};

export type ListCustomersCustomer = {
  /**
   * Indicates the response contains a customer object. Will always contain the string `customer` for this endpoint.
   */
  resource?: string | undefined;
  /**
   * The identifier uniquely referring to this customer. Example: `cst_vsKJpSsabw`.
   */
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode?: ListCustomersMode | undefined;
  /**
   * The full name of the customer.
   */
  name?: string | null | undefined;
  /**
   * The email address of the customer.
   */
  email?: string | null | undefined;
  /**
   * Preconfigure the language to be used in the hosted payment pages shown to the customer. Should only be provided if
   *
   * @remarks
   * absolutely necessary. If not provided, the browser language will be used which is typically highly accurate.
   */
  locale?: ListCustomersLocale | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: ListCustomersMetadata | string | Array<string> | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: CustomerLinks | undefined;
};

export type ListCustomersEmbedded = {
  /**
   * An array of customer objects.
   */
  customers?: Array<ListCustomersCustomer> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListCustomersSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListCustomersPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListCustomersNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomersDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomersLinks = {
  /**
   * The URL to the current set of items.
   */
  self?: ListCustomersSelf | undefined;
  /**
   * The previous set of items, if available.
   */
  previous?: ListCustomersPrevious | null | undefined;
  /**
   * The next set of items, if available.
   */
  next?: ListCustomersNext | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListCustomersDocumentation | undefined;
};

/**
 * A list of customer objects.
 */
export type ListCustomersResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListCustomersEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListCustomersLinks | undefined;
};

/** @internal */
export const ListCustomersSort$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomersSort
> = z.nativeEnum(ListCustomersSort);

/** @internal */
export const ListCustomersSort$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomersSort
> = ListCustomersSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersSort$ {
  /** @deprecated use `ListCustomersSort$inboundSchema` instead. */
  export const inboundSchema = ListCustomersSort$inboundSchema;
  /** @deprecated use `ListCustomersSort$outboundSchema` instead. */
  export const outboundSchema = ListCustomersSort$outboundSchema;
}

/** @internal */
export const ListCustomersRequest$inboundSchema: z.ZodType<
  ListCustomersRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(ListCustomersSort$inboundSchema.default("desc")),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListCustomersRequest$Outbound = {
  from?: string | undefined;
  limit: number | null;
  sort: string | null;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListCustomersRequest$outboundSchema: z.ZodType<
  ListCustomersRequest$Outbound,
  z.ZodTypeDef,
  ListCustomersRequest
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(ListCustomersSort$outboundSchema.default("desc")),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersRequest$ {
  /** @deprecated use `ListCustomersRequest$inboundSchema` instead. */
  export const inboundSchema = ListCustomersRequest$inboundSchema;
  /** @deprecated use `ListCustomersRequest$outboundSchema` instead. */
  export const outboundSchema = ListCustomersRequest$outboundSchema;
  /** @deprecated use `ListCustomersRequest$Outbound` instead. */
  export type Outbound = ListCustomersRequest$Outbound;
}

export function listCustomersRequestToJSON(
  listCustomersRequest: ListCustomersRequest,
): string {
  return JSON.stringify(
    ListCustomersRequest$outboundSchema.parse(listCustomersRequest),
  );
}

export function listCustomersRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersRequest' from JSON`,
  );
}

/** @internal */
export const ListCustomersNotFoundDocumentation$inboundSchema: z.ZodType<
  ListCustomersNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomersNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomersNotFoundDocumentation$outboundSchema: z.ZodType<
  ListCustomersNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomersNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersNotFoundDocumentation$ {
  /** @deprecated use `ListCustomersNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListCustomersNotFoundDocumentation$inboundSchema;
  /** @deprecated use `ListCustomersNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomersNotFoundDocumentation$outboundSchema;
  /** @deprecated use `ListCustomersNotFoundDocumentation$Outbound` instead. */
  export type Outbound = ListCustomersNotFoundDocumentation$Outbound;
}

export function listCustomersNotFoundDocumentationToJSON(
  listCustomersNotFoundDocumentation: ListCustomersNotFoundDocumentation,
): string {
  return JSON.stringify(
    ListCustomersNotFoundDocumentation$outboundSchema.parse(
      listCustomersNotFoundDocumentation,
    ),
  );
}

export function listCustomersNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomersNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomersNotFoundLinks$inboundSchema: z.ZodType<
  ListCustomersNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() => ListCustomersNotFoundDocumentation$inboundSchema),
});

/** @internal */
export type ListCustomersNotFoundLinks$Outbound = {
  documentation: ListCustomersNotFoundDocumentation$Outbound;
};

/** @internal */
export const ListCustomersNotFoundLinks$outboundSchema: z.ZodType<
  ListCustomersNotFoundLinks$Outbound,
  z.ZodTypeDef,
  ListCustomersNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    ListCustomersNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersNotFoundLinks$ {
  /** @deprecated use `ListCustomersNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomersNotFoundLinks$inboundSchema;
  /** @deprecated use `ListCustomersNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomersNotFoundLinks$outboundSchema;
  /** @deprecated use `ListCustomersNotFoundLinks$Outbound` instead. */
  export type Outbound = ListCustomersNotFoundLinks$Outbound;
}

export function listCustomersNotFoundLinksToJSON(
  listCustomersNotFoundLinks: ListCustomersNotFoundLinks,
): string {
  return JSON.stringify(
    ListCustomersNotFoundLinks$outboundSchema.parse(listCustomersNotFoundLinks),
  );
}

export function listCustomersNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomersBadRequestDocumentation$inboundSchema: z.ZodType<
  ListCustomersBadRequestDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomersBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomersBadRequestDocumentation$outboundSchema: z.ZodType<
  ListCustomersBadRequestDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomersBadRequestDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersBadRequestDocumentation$ {
  /** @deprecated use `ListCustomersBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomersBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListCustomersBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomersBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListCustomersBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListCustomersBadRequestDocumentation$Outbound;
}

export function listCustomersBadRequestDocumentationToJSON(
  listCustomersBadRequestDocumentation: ListCustomersBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListCustomersBadRequestDocumentation$outboundSchema.parse(
      listCustomersBadRequestDocumentation,
    ),
  );
}

export function listCustomersBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersBadRequestDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomersBadRequestDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomersBadRequestLinks$inboundSchema: z.ZodType<
  ListCustomersBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListCustomersBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListCustomersBadRequestLinks$Outbound = {
  documentation: ListCustomersBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListCustomersBadRequestLinks$outboundSchema: z.ZodType<
  ListCustomersBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListCustomersBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListCustomersBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersBadRequestLinks$ {
  /** @deprecated use `ListCustomersBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomersBadRequestLinks$inboundSchema;
  /** @deprecated use `ListCustomersBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomersBadRequestLinks$outboundSchema;
  /** @deprecated use `ListCustomersBadRequestLinks$Outbound` instead. */
  export type Outbound = ListCustomersBadRequestLinks$Outbound;
}

export function listCustomersBadRequestLinksToJSON(
  listCustomersBadRequestLinks: ListCustomersBadRequestLinks,
): string {
  return JSON.stringify(
    ListCustomersBadRequestLinks$outboundSchema.parse(
      listCustomersBadRequestLinks,
    ),
  );
}

export function listCustomersBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomersMode$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomersMode
> = z.nativeEnum(ListCustomersMode);

/** @internal */
export const ListCustomersMode$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomersMode
> = ListCustomersMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersMode$ {
  /** @deprecated use `ListCustomersMode$inboundSchema` instead. */
  export const inboundSchema = ListCustomersMode$inboundSchema;
  /** @deprecated use `ListCustomersMode$outboundSchema` instead. */
  export const outboundSchema = ListCustomersMode$outboundSchema;
}

/** @internal */
export const ListCustomersLocale$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomersLocale
> = z.nativeEnum(ListCustomersLocale);

/** @internal */
export const ListCustomersLocale$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomersLocale
> = ListCustomersLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersLocale$ {
  /** @deprecated use `ListCustomersLocale$inboundSchema` instead. */
  export const inboundSchema = ListCustomersLocale$inboundSchema;
  /** @deprecated use `ListCustomersLocale$outboundSchema` instead. */
  export const outboundSchema = ListCustomersLocale$outboundSchema;
}

/** @internal */
export const ListCustomersMetadata$inboundSchema: z.ZodType<
  ListCustomersMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListCustomersMetadata$Outbound = {};

/** @internal */
export const ListCustomersMetadata$outboundSchema: z.ZodType<
  ListCustomersMetadata$Outbound,
  z.ZodTypeDef,
  ListCustomersMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersMetadata$ {
  /** @deprecated use `ListCustomersMetadata$inboundSchema` instead. */
  export const inboundSchema = ListCustomersMetadata$inboundSchema;
  /** @deprecated use `ListCustomersMetadata$outboundSchema` instead. */
  export const outboundSchema = ListCustomersMetadata$outboundSchema;
  /** @deprecated use `ListCustomersMetadata$Outbound` instead. */
  export type Outbound = ListCustomersMetadata$Outbound;
}

export function listCustomersMetadataToJSON(
  listCustomersMetadata: ListCustomersMetadata,
): string {
  return JSON.stringify(
    ListCustomersMetadata$outboundSchema.parse(listCustomersMetadata),
  );
}

export function listCustomersMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersMetadata' from JSON`,
  );
}

/** @internal */
export const ListCustomersMetadataUnion$inboundSchema: z.ZodType<
  ListCustomersMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListCustomersMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type ListCustomersMetadataUnion$Outbound =
  | ListCustomersMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const ListCustomersMetadataUnion$outboundSchema: z.ZodType<
  ListCustomersMetadataUnion$Outbound,
  z.ZodTypeDef,
  ListCustomersMetadataUnion
> = z.union([
  z.lazy(() => ListCustomersMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersMetadataUnion$ {
  /** @deprecated use `ListCustomersMetadataUnion$inboundSchema` instead. */
  export const inboundSchema = ListCustomersMetadataUnion$inboundSchema;
  /** @deprecated use `ListCustomersMetadataUnion$outboundSchema` instead. */
  export const outboundSchema = ListCustomersMetadataUnion$outboundSchema;
  /** @deprecated use `ListCustomersMetadataUnion$Outbound` instead. */
  export type Outbound = ListCustomersMetadataUnion$Outbound;
}

export function listCustomersMetadataUnionToJSON(
  listCustomersMetadataUnion: ListCustomersMetadataUnion,
): string {
  return JSON.stringify(
    ListCustomersMetadataUnion$outboundSchema.parse(listCustomersMetadataUnion),
  );
}

export function listCustomersMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersMetadataUnion' from JSON`,
  );
}

/** @internal */
export const CustomerSelf$inboundSchema: z.ZodType<
  CustomerSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CustomerSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CustomerSelf$outboundSchema: z.ZodType<
  CustomerSelf$Outbound,
  z.ZodTypeDef,
  CustomerSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomerSelf$ {
  /** @deprecated use `CustomerSelf$inboundSchema` instead. */
  export const inboundSchema = CustomerSelf$inboundSchema;
  /** @deprecated use `CustomerSelf$outboundSchema` instead. */
  export const outboundSchema = CustomerSelf$outboundSchema;
  /** @deprecated use `CustomerSelf$Outbound` instead. */
  export type Outbound = CustomerSelf$Outbound;
}

export function customerSelfToJSON(customerSelf: CustomerSelf): string {
  return JSON.stringify(CustomerSelf$outboundSchema.parse(customerSelf));
}

export function customerSelfFromJSON(
  jsonString: string,
): SafeParseResult<CustomerSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomersDashboard$inboundSchema: z.ZodType<
  ListCustomersDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomersDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomersDashboard$outboundSchema: z.ZodType<
  ListCustomersDashboard$Outbound,
  z.ZodTypeDef,
  ListCustomersDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersDashboard$ {
  /** @deprecated use `ListCustomersDashboard$inboundSchema` instead. */
  export const inboundSchema = ListCustomersDashboard$inboundSchema;
  /** @deprecated use `ListCustomersDashboard$outboundSchema` instead. */
  export const outboundSchema = ListCustomersDashboard$outboundSchema;
  /** @deprecated use `ListCustomersDashboard$Outbound` instead. */
  export type Outbound = ListCustomersDashboard$Outbound;
}

export function listCustomersDashboardToJSON(
  listCustomersDashboard: ListCustomersDashboard,
): string {
  return JSON.stringify(
    ListCustomersDashboard$outboundSchema.parse(listCustomersDashboard),
  );
}

export function listCustomersDashboardFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersDashboard' from JSON`,
  );
}

/** @internal */
export const ListCustomersPayments$inboundSchema: z.ZodType<
  ListCustomersPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomersPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomersPayments$outboundSchema: z.ZodType<
  ListCustomersPayments$Outbound,
  z.ZodTypeDef,
  ListCustomersPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersPayments$ {
  /** @deprecated use `ListCustomersPayments$inboundSchema` instead. */
  export const inboundSchema = ListCustomersPayments$inboundSchema;
  /** @deprecated use `ListCustomersPayments$outboundSchema` instead. */
  export const outboundSchema = ListCustomersPayments$outboundSchema;
  /** @deprecated use `ListCustomersPayments$Outbound` instead. */
  export type Outbound = ListCustomersPayments$Outbound;
}

export function listCustomersPaymentsToJSON(
  listCustomersPayments: ListCustomersPayments,
): string {
  return JSON.stringify(
    ListCustomersPayments$outboundSchema.parse(listCustomersPayments),
  );
}

export function listCustomersPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersPayments' from JSON`,
  );
}

/** @internal */
export const ListCustomersMandates$inboundSchema: z.ZodType<
  ListCustomersMandates,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomersMandates$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomersMandates$outboundSchema: z.ZodType<
  ListCustomersMandates$Outbound,
  z.ZodTypeDef,
  ListCustomersMandates
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersMandates$ {
  /** @deprecated use `ListCustomersMandates$inboundSchema` instead. */
  export const inboundSchema = ListCustomersMandates$inboundSchema;
  /** @deprecated use `ListCustomersMandates$outboundSchema` instead. */
  export const outboundSchema = ListCustomersMandates$outboundSchema;
  /** @deprecated use `ListCustomersMandates$Outbound` instead. */
  export type Outbound = ListCustomersMandates$Outbound;
}

export function listCustomersMandatesToJSON(
  listCustomersMandates: ListCustomersMandates,
): string {
  return JSON.stringify(
    ListCustomersMandates$outboundSchema.parse(listCustomersMandates),
  );
}

export function listCustomersMandatesFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersMandates, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersMandates$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersMandates' from JSON`,
  );
}

/** @internal */
export const ListCustomersSubscriptions$inboundSchema: z.ZodType<
  ListCustomersSubscriptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomersSubscriptions$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomersSubscriptions$outboundSchema: z.ZodType<
  ListCustomersSubscriptions$Outbound,
  z.ZodTypeDef,
  ListCustomersSubscriptions
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersSubscriptions$ {
  /** @deprecated use `ListCustomersSubscriptions$inboundSchema` instead. */
  export const inboundSchema = ListCustomersSubscriptions$inboundSchema;
  /** @deprecated use `ListCustomersSubscriptions$outboundSchema` instead. */
  export const outboundSchema = ListCustomersSubscriptions$outboundSchema;
  /** @deprecated use `ListCustomersSubscriptions$Outbound` instead. */
  export type Outbound = ListCustomersSubscriptions$Outbound;
}

export function listCustomersSubscriptionsToJSON(
  listCustomersSubscriptions: ListCustomersSubscriptions,
): string {
  return JSON.stringify(
    ListCustomersSubscriptions$outboundSchema.parse(listCustomersSubscriptions),
  );
}

export function listCustomersSubscriptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersSubscriptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersSubscriptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersSubscriptions' from JSON`,
  );
}

/** @internal */
export const CustomerDocumentation$inboundSchema: z.ZodType<
  CustomerDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CustomerDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CustomerDocumentation$outboundSchema: z.ZodType<
  CustomerDocumentation$Outbound,
  z.ZodTypeDef,
  CustomerDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomerDocumentation$ {
  /** @deprecated use `CustomerDocumentation$inboundSchema` instead. */
  export const inboundSchema = CustomerDocumentation$inboundSchema;
  /** @deprecated use `CustomerDocumentation$outboundSchema` instead. */
  export const outboundSchema = CustomerDocumentation$outboundSchema;
  /** @deprecated use `CustomerDocumentation$Outbound` instead. */
  export type Outbound = CustomerDocumentation$Outbound;
}

export function customerDocumentationToJSON(
  customerDocumentation: CustomerDocumentation,
): string {
  return JSON.stringify(
    CustomerDocumentation$outboundSchema.parse(customerDocumentation),
  );
}

export function customerDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CustomerDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerDocumentation' from JSON`,
  );
}

/** @internal */
export const CustomerLinks$inboundSchema: z.ZodType<
  CustomerLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CustomerSelf$inboundSchema).optional(),
  dashboard: z.lazy(() => ListCustomersDashboard$inboundSchema).optional(),
  payments: z.nullable(z.lazy(() => ListCustomersPayments$inboundSchema))
    .optional(),
  mandates: z.nullable(z.lazy(() => ListCustomersMandates$inboundSchema))
    .optional(),
  subscriptions: z.nullable(
    z.lazy(() => ListCustomersSubscriptions$inboundSchema),
  ).optional(),
  documentation: z.lazy(() => CustomerDocumentation$inboundSchema).optional(),
});

/** @internal */
export type CustomerLinks$Outbound = {
  self?: CustomerSelf$Outbound | undefined;
  dashboard?: ListCustomersDashboard$Outbound | undefined;
  payments?: ListCustomersPayments$Outbound | null | undefined;
  mandates?: ListCustomersMandates$Outbound | null | undefined;
  subscriptions?: ListCustomersSubscriptions$Outbound | null | undefined;
  documentation?: CustomerDocumentation$Outbound | undefined;
};

/** @internal */
export const CustomerLinks$outboundSchema: z.ZodType<
  CustomerLinks$Outbound,
  z.ZodTypeDef,
  CustomerLinks
> = z.object({
  self: z.lazy(() => CustomerSelf$outboundSchema).optional(),
  dashboard: z.lazy(() => ListCustomersDashboard$outboundSchema).optional(),
  payments: z.nullable(z.lazy(() => ListCustomersPayments$outboundSchema))
    .optional(),
  mandates: z.nullable(z.lazy(() => ListCustomersMandates$outboundSchema))
    .optional(),
  subscriptions: z.nullable(
    z.lazy(() => ListCustomersSubscriptions$outboundSchema),
  ).optional(),
  documentation: z.lazy(() => CustomerDocumentation$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomerLinks$ {
  /** @deprecated use `CustomerLinks$inboundSchema` instead. */
  export const inboundSchema = CustomerLinks$inboundSchema;
  /** @deprecated use `CustomerLinks$outboundSchema` instead. */
  export const outboundSchema = CustomerLinks$outboundSchema;
  /** @deprecated use `CustomerLinks$Outbound` instead. */
  export type Outbound = CustomerLinks$Outbound;
}

export function customerLinksToJSON(customerLinks: CustomerLinks): string {
  return JSON.stringify(CustomerLinks$outboundSchema.parse(customerLinks));
}

export function customerLinksFromJSON(
  jsonString: string,
): SafeParseResult<CustomerLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomersCustomer$inboundSchema: z.ZodType<
  ListCustomersCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("customer"),
  id: z.string().optional(),
  mode: ListCustomersMode$inboundSchema.optional(),
  name: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  locale: z.nullable(ListCustomersLocale$inboundSchema).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListCustomersMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  createdAt: z.string().optional(),
  _links: z.lazy(() => CustomerLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListCustomersCustomer$Outbound = {
  resource: string;
  id?: string | undefined;
  mode?: string | undefined;
  name?: string | null | undefined;
  email?: string | null | undefined;
  locale?: string | null | undefined;
  metadata?:
    | ListCustomersMetadata$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  createdAt?: string | undefined;
  _links?: CustomerLinks$Outbound | undefined;
};

/** @internal */
export const ListCustomersCustomer$outboundSchema: z.ZodType<
  ListCustomersCustomer$Outbound,
  z.ZodTypeDef,
  ListCustomersCustomer
> = z.object({
  resource: z.string().default("customer"),
  id: z.string().optional(),
  mode: ListCustomersMode$outboundSchema.optional(),
  name: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  locale: z.nullable(ListCustomersLocale$outboundSchema).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListCustomersMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  createdAt: z.string().optional(),
  links: z.lazy(() => CustomerLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersCustomer$ {
  /** @deprecated use `ListCustomersCustomer$inboundSchema` instead. */
  export const inboundSchema = ListCustomersCustomer$inboundSchema;
  /** @deprecated use `ListCustomersCustomer$outboundSchema` instead. */
  export const outboundSchema = ListCustomersCustomer$outboundSchema;
  /** @deprecated use `ListCustomersCustomer$Outbound` instead. */
  export type Outbound = ListCustomersCustomer$Outbound;
}

export function listCustomersCustomerToJSON(
  listCustomersCustomer: ListCustomersCustomer,
): string {
  return JSON.stringify(
    ListCustomersCustomer$outboundSchema.parse(listCustomersCustomer),
  );
}

export function listCustomersCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersCustomer' from JSON`,
  );
}

/** @internal */
export const ListCustomersEmbedded$inboundSchema: z.ZodType<
  ListCustomersEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  customers: z.array(z.lazy(() => ListCustomersCustomer$inboundSchema))
    .optional(),
});

/** @internal */
export type ListCustomersEmbedded$Outbound = {
  customers?: Array<ListCustomersCustomer$Outbound> | undefined;
};

/** @internal */
export const ListCustomersEmbedded$outboundSchema: z.ZodType<
  ListCustomersEmbedded$Outbound,
  z.ZodTypeDef,
  ListCustomersEmbedded
> = z.object({
  customers: z.array(z.lazy(() => ListCustomersCustomer$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersEmbedded$ {
  /** @deprecated use `ListCustomersEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListCustomersEmbedded$inboundSchema;
  /** @deprecated use `ListCustomersEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListCustomersEmbedded$outboundSchema;
  /** @deprecated use `ListCustomersEmbedded$Outbound` instead. */
  export type Outbound = ListCustomersEmbedded$Outbound;
}

export function listCustomersEmbeddedToJSON(
  listCustomersEmbedded: ListCustomersEmbedded,
): string {
  return JSON.stringify(
    ListCustomersEmbedded$outboundSchema.parse(listCustomersEmbedded),
  );
}

export function listCustomersEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersEmbedded' from JSON`,
  );
}

/** @internal */
export const ListCustomersSelf$inboundSchema: z.ZodType<
  ListCustomersSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomersSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomersSelf$outboundSchema: z.ZodType<
  ListCustomersSelf$Outbound,
  z.ZodTypeDef,
  ListCustomersSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersSelf$ {
  /** @deprecated use `ListCustomersSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomersSelf$inboundSchema;
  /** @deprecated use `ListCustomersSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomersSelf$outboundSchema;
  /** @deprecated use `ListCustomersSelf$Outbound` instead. */
  export type Outbound = ListCustomersSelf$Outbound;
}

export function listCustomersSelfToJSON(
  listCustomersSelf: ListCustomersSelf,
): string {
  return JSON.stringify(
    ListCustomersSelf$outboundSchema.parse(listCustomersSelf),
  );
}

export function listCustomersSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomersPrevious$inboundSchema: z.ZodType<
  ListCustomersPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomersPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomersPrevious$outboundSchema: z.ZodType<
  ListCustomersPrevious$Outbound,
  z.ZodTypeDef,
  ListCustomersPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersPrevious$ {
  /** @deprecated use `ListCustomersPrevious$inboundSchema` instead. */
  export const inboundSchema = ListCustomersPrevious$inboundSchema;
  /** @deprecated use `ListCustomersPrevious$outboundSchema` instead. */
  export const outboundSchema = ListCustomersPrevious$outboundSchema;
  /** @deprecated use `ListCustomersPrevious$Outbound` instead. */
  export type Outbound = ListCustomersPrevious$Outbound;
}

export function listCustomersPreviousToJSON(
  listCustomersPrevious: ListCustomersPrevious,
): string {
  return JSON.stringify(
    ListCustomersPrevious$outboundSchema.parse(listCustomersPrevious),
  );
}

export function listCustomersPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersPrevious' from JSON`,
  );
}

/** @internal */
export const ListCustomersNext$inboundSchema: z.ZodType<
  ListCustomersNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomersNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomersNext$outboundSchema: z.ZodType<
  ListCustomersNext$Outbound,
  z.ZodTypeDef,
  ListCustomersNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersNext$ {
  /** @deprecated use `ListCustomersNext$inboundSchema` instead. */
  export const inboundSchema = ListCustomersNext$inboundSchema;
  /** @deprecated use `ListCustomersNext$outboundSchema` instead. */
  export const outboundSchema = ListCustomersNext$outboundSchema;
  /** @deprecated use `ListCustomersNext$Outbound` instead. */
  export type Outbound = ListCustomersNext$Outbound;
}

export function listCustomersNextToJSON(
  listCustomersNext: ListCustomersNext,
): string {
  return JSON.stringify(
    ListCustomersNext$outboundSchema.parse(listCustomersNext),
  );
}

export function listCustomersNextFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersNext' from JSON`,
  );
}

/** @internal */
export const ListCustomersDocumentation$inboundSchema: z.ZodType<
  ListCustomersDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomersDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomersDocumentation$outboundSchema: z.ZodType<
  ListCustomersDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomersDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersDocumentation$ {
  /** @deprecated use `ListCustomersDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListCustomersDocumentation$inboundSchema;
  /** @deprecated use `ListCustomersDocumentation$outboundSchema` instead. */
  export const outboundSchema = ListCustomersDocumentation$outboundSchema;
  /** @deprecated use `ListCustomersDocumentation$Outbound` instead. */
  export type Outbound = ListCustomersDocumentation$Outbound;
}

export function listCustomersDocumentationToJSON(
  listCustomersDocumentation: ListCustomersDocumentation,
): string {
  return JSON.stringify(
    ListCustomersDocumentation$outboundSchema.parse(listCustomersDocumentation),
  );
}

export function listCustomersDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomersLinks$inboundSchema: z.ZodType<
  ListCustomersLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomersSelf$inboundSchema).optional(),
  previous: z.nullable(z.lazy(() => ListCustomersPrevious$inboundSchema))
    .optional(),
  next: z.nullable(z.lazy(() => ListCustomersNext$inboundSchema)).optional(),
  documentation: z.lazy(() => ListCustomersDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type ListCustomersLinks$Outbound = {
  self?: ListCustomersSelf$Outbound | undefined;
  previous?: ListCustomersPrevious$Outbound | null | undefined;
  next?: ListCustomersNext$Outbound | null | undefined;
  documentation?: ListCustomersDocumentation$Outbound | undefined;
};

/** @internal */
export const ListCustomersLinks$outboundSchema: z.ZodType<
  ListCustomersLinks$Outbound,
  z.ZodTypeDef,
  ListCustomersLinks
> = z.object({
  self: z.lazy(() => ListCustomersSelf$outboundSchema).optional(),
  previous: z.nullable(z.lazy(() => ListCustomersPrevious$outboundSchema))
    .optional(),
  next: z.nullable(z.lazy(() => ListCustomersNext$outboundSchema)).optional(),
  documentation: z.lazy(() => ListCustomersDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersLinks$ {
  /** @deprecated use `ListCustomersLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomersLinks$inboundSchema;
  /** @deprecated use `ListCustomersLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomersLinks$outboundSchema;
  /** @deprecated use `ListCustomersLinks$Outbound` instead. */
  export type Outbound = ListCustomersLinks$Outbound;
}

export function listCustomersLinksToJSON(
  listCustomersLinks: ListCustomersLinks,
): string {
  return JSON.stringify(
    ListCustomersLinks$outboundSchema.parse(listCustomersLinks),
  );
}

export function listCustomersLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomersResponse$inboundSchema: z.ZodType<
  ListCustomersResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListCustomersEmbedded$inboundSchema).optional(),
  _links: z.lazy(() => ListCustomersLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListCustomersResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListCustomersEmbedded$Outbound | undefined;
  _links?: ListCustomersLinks$Outbound | undefined;
};

/** @internal */
export const ListCustomersResponse$outboundSchema: z.ZodType<
  ListCustomersResponse$Outbound,
  z.ZodTypeDef,
  ListCustomersResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListCustomersEmbedded$outboundSchema).optional(),
  links: z.lazy(() => ListCustomersLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomersResponse$ {
  /** @deprecated use `ListCustomersResponse$inboundSchema` instead. */
  export const inboundSchema = ListCustomersResponse$inboundSchema;
  /** @deprecated use `ListCustomersResponse$outboundSchema` instead. */
  export const outboundSchema = ListCustomersResponse$outboundSchema;
  /** @deprecated use `ListCustomersResponse$Outbound` instead. */
  export type Outbound = ListCustomersResponse$Outbound;
}

export function listCustomersResponseToJSON(
  listCustomersResponse: ListCustomersResponse,
): string {
  return JSON.stringify(
    ListCustomersResponse$outboundSchema.parse(listCustomersResponse),
  );
}

export function listCustomersResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomersResponse' from JSON`,
  );
}
