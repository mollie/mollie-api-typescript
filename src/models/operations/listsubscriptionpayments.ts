/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export const ListSubscriptionPaymentsSort = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export type ListSubscriptionPaymentsSort = ClosedEnum<
  typeof ListSubscriptionPaymentsSort
>;

export type ListSubscriptionPaymentsRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide the ID of the related subscription.
   */
  subscriptionId: string;
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate
   *
   * @remarks
   * the result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
   *
   * @remarks
   * newest to oldest.
   */
  sort?: ListSubscriptionPaymentsSort | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to
   *
   * @remarks
   * retrieve the resources for.
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For
   * organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListSubscriptionPaymentsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListSubscriptionPaymentsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListSubscriptionPaymentsBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListSubscriptionPaymentsMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListSubscriptionPaymentsMode = ClosedEnum<
  typeof ListSubscriptionPaymentsMode
>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type ListSubscriptionPaymentsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type ListSubscriptionPaymentsAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type ListSubscriptionPaymentsAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type ListSubscriptionPaymentsAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type ListSubscriptionPaymentsAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type ListSubscriptionPaymentsSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const ListSubscriptionPaymentsLineType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type ListSubscriptionPaymentsLineType = ClosedEnum<
  typeof ListSubscriptionPaymentsLineType
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type ListSubscriptionPaymentsUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type ListSubscriptionPaymentsDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type ListSubscriptionPaymentsTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type ListSubscriptionPaymentsVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const ListSubscriptionPaymentsCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type ListSubscriptionPaymentsCategory = ClosedEnum<
  typeof ListSubscriptionPaymentsCategory
>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const ListSubscriptionPaymentsInterval = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type ListSubscriptionPaymentsInterval = ClosedEnum<
  typeof ListSubscriptionPaymentsInterval
>;

/**
 * Total amount and currency of the recurring item.
 */
export type ListSubscriptionPaymentsRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type ListSubscriptionPaymentsRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: ListSubscriptionPaymentsInterval;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: ListSubscriptionPaymentsRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type ListSubscriptionPaymentsLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: ListSubscriptionPaymentsLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: ListSubscriptionPaymentsUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: ListSubscriptionPaymentsDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: ListSubscriptionPaymentsTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: ListSubscriptionPaymentsVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<ListSubscriptionPaymentsCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: ListSubscriptionPaymentsRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListSubscriptionPaymentsBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type ListSubscriptionPaymentsShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const ListSubscriptionPaymentsLocale = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type ListSubscriptionPaymentsLocale = ClosedEnum<
  typeof ListSubscriptionPaymentsLocale
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const ListSubscriptionPaymentsMethod = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type ListSubscriptionPaymentsMethod = ClosedEnum<
  typeof ListSubscriptionPaymentsMethod
>;

export type ListSubscriptionPaymentsMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListSubscriptionPaymentsMetadataUnion =
  | ListSubscriptionPaymentsMetadata
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const ListSubscriptionPaymentsCaptureMode = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type ListSubscriptionPaymentsCaptureMode = ClosedEnum<
  typeof ListSubscriptionPaymentsCaptureMode
>;

/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export const ListSubscriptionPaymentsCaptureDelay = {
  DotDotDotHours: "... hours",
  DotDotDotDays: "... days",
} as const;
/**
 * **Only relevant if you wish to manage authorization and capturing separately.**
 *
 * @remarks
 *
 * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
 * later point either be 'captured' or canceled.
 *
 * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
 * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
 * example `8 hours` or `2 days`.
 *
 * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
 *
 * The maximum delay is 7 days (168 hours).
 */
export type ListSubscriptionPaymentsCaptureDelay = ClosedEnum<
  typeof ListSubscriptionPaymentsCaptureDelay
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type ListSubscriptionPaymentsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type ListSubscriptionPaymentsApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: ListSubscriptionPaymentsApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListSubscriptionPaymentsRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListSubscriptionPaymentsRoutingMode = ClosedEnum<
  typeof ListSubscriptionPaymentsRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type ListSubscriptionPaymentsRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const ListSubscriptionPaymentsRoutingType = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type ListSubscriptionPaymentsRoutingType = ClosedEnum<
  typeof ListSubscriptionPaymentsRoutingType
>;

/**
 * The destination of this portion of the payment.
 */
export type ListSubscriptionPaymentsDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: ListSubscriptionPaymentsRoutingType;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionPaymentsRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type ListSubscriptionPaymentsRoutingPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionPaymentsRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListSubscriptionPaymentsRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: ListSubscriptionPaymentsRoutingPayment;
};

export type ListSubscriptionPaymentsRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListSubscriptionPaymentsRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: ListSubscriptionPaymentsRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: ListSubscriptionPaymentsDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListSubscriptionPaymentsRoutingLinks;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const ListSubscriptionPaymentsSequenceType = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type ListSubscriptionPaymentsSequenceType = ClosedEnum<
  typeof ListSubscriptionPaymentsSequenceType
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const ListSubscriptionPaymentsStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type ListSubscriptionPaymentsStatus = ClosedEnum<
  typeof ListSubscriptionPaymentsStatus
>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type ListSubscriptionPaymentsStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionPaymentsPaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type ListSubscriptionPaymentsCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type ListSubscriptionPaymentsMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type ListSubscriptionPaymentsChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type ListSubscriptionPaymentsDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type ListSubscriptionPaymentsRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type ListSubscriptionPaymentsChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type ListSubscriptionPaymentsCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type ListSubscriptionPaymentsSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type ListSubscriptionPaymentsCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type ListSubscriptionPaymentsMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type ListSubscriptionPaymentsSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type ListSubscriptionPaymentsOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type ListSubscriptionPaymentsTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionPaymentsPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionPaymentsPaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListSubscriptionPaymentsPaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: ListSubscriptionPaymentsCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: ListSubscriptionPaymentsMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: ListSubscriptionPaymentsChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: ListSubscriptionPaymentsDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: ListSubscriptionPaymentsRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: ListSubscriptionPaymentsChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: ListSubscriptionPaymentsCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: ListSubscriptionPaymentsSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: ListSubscriptionPaymentsCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: ListSubscriptionPaymentsMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: ListSubscriptionPaymentsSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: ListSubscriptionPaymentsOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: ListSubscriptionPaymentsTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListSubscriptionPaymentsPaymentDocumentation | undefined;
};

export type ListSubscriptionPaymentsPaymentOutput = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListSubscriptionPaymentsMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: ListSubscriptionPaymentsAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: ListSubscriptionPaymentsAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: ListSubscriptionPaymentsAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: ListSubscriptionPaymentsAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: ListSubscriptionPaymentsAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: ListSubscriptionPaymentsSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListSubscriptionPaymentsLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListSubscriptionPaymentsBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: ListSubscriptionPaymentsShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: ListSubscriptionPaymentsLocale | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: ListSubscriptionPaymentsMethod | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | ListSubscriptionPaymentsMetadata
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: ListSubscriptionPaymentsCaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   */
  captureDelay?: ListSubscriptionPaymentsCaptureDelay | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: ListSubscriptionPaymentsApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<ListSubscriptionPaymentsRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType?: ListSubscriptionPaymentsSequenceType | null | undefined;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: ListSubscriptionPaymentsStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: ListSubscriptionPaymentsStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListSubscriptionPaymentsPaymentLinks;
};

export type ListSubscriptionPaymentsEmbedded = {
  /**
   * An array of payment objects.
   */
  payments?: Array<ListSubscriptionPaymentsPaymentOutput> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListSubscriptionPaymentsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListSubscriptionPaymentsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListSubscriptionPaymentsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionPaymentsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionPaymentsLinks = {
  /**
   * The URL to the current set of items.
   */
  self?: ListSubscriptionPaymentsSelf | undefined;
  /**
   * The previous set of items, if available.
   */
  previous?: ListSubscriptionPaymentsPrevious | null | undefined;
  /**
   * The next set of items, if available.
   */
  next?: ListSubscriptionPaymentsNext | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListSubscriptionPaymentsDocumentation | undefined;
};

/**
 * A list of payment objects.
 */
export type ListSubscriptionPaymentsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListSubscriptionPaymentsEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListSubscriptionPaymentsLinks | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsSort$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsSort
> = z.nativeEnum(ListSubscriptionPaymentsSort);

/** @internal */
export const ListSubscriptionPaymentsSort$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsSort
> = ListSubscriptionPaymentsSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSort$ {
  /** @deprecated use `ListSubscriptionPaymentsSort$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsSort$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSort$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsSort$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsRequest$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(ListSubscriptionPaymentsSort$inboundSchema.default("desc")),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListSubscriptionPaymentsRequest$Outbound = {
  customerId: string;
  subscriptionId: string;
  from?: string | undefined;
  limit: number | null;
  sort: string | null;
  profileId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsRequest$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRequest$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRequest
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(ListSubscriptionPaymentsSort$outboundSchema.default("desc")),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRequest$ {
  /** @deprecated use `ListSubscriptionPaymentsRequest$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsRequest$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRequest$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsRequest$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRequest$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRequest$Outbound;
}

export function listSubscriptionPaymentsRequestToJSON(
  listSubscriptionPaymentsRequest: ListSubscriptionPaymentsRequest,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRequest$outboundSchema.parse(
      listSubscriptionPaymentsRequest,
    ),
  );
}

export function listSubscriptionPaymentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRequest' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsBadRequestDocumentation$inboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsBadRequestDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListSubscriptionPaymentsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsBadRequestDocumentation$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsBadRequestDocumentation$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsBadRequestDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsBadRequestDocumentation$ {
  /** @deprecated use `ListSubscriptionPaymentsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBadRequestDocumentation$Outbound` instead. */
  export type Outbound =
    ListSubscriptionPaymentsBadRequestDocumentation$Outbound;
}

export function listSubscriptionPaymentsBadRequestDocumentationToJSON(
  listSubscriptionPaymentsBadRequestDocumentation:
    ListSubscriptionPaymentsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsBadRequestDocumentation$outboundSchema.parse(
      listSubscriptionPaymentsBadRequestDocumentation,
    ),
  );
}

export function listSubscriptionPaymentsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsBadRequestLinks$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListSubscriptionPaymentsBadRequestLinks$Outbound = {
  documentation: ListSubscriptionPaymentsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListSubscriptionPaymentsBadRequestLinks$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsBadRequestLinks$ {
  /** @deprecated use `ListSubscriptionPaymentsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsBadRequestLinks$Outbound;
}

export function listSubscriptionPaymentsBadRequestLinksToJSON(
  listSubscriptionPaymentsBadRequestLinks:
    ListSubscriptionPaymentsBadRequestLinks,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsBadRequestLinks$outboundSchema.parse(
      listSubscriptionPaymentsBadRequestLinks,
    ),
  );
}

export function listSubscriptionPaymentsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsBadRequestLinks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsBadRequestLinks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsMode
> = z.nativeEnum(ListSubscriptionPaymentsMode);

/** @internal */
export const ListSubscriptionPaymentsMode$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsMode
> = ListSubscriptionPaymentsMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMode$ {
  /** @deprecated use `ListSubscriptionPaymentsMode$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsMode$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMode$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsMode$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsAmount$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmount$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsAmount$Outbound;
}

export function listSubscriptionPaymentsAmountToJSON(
  listSubscriptionPaymentsAmount: ListSubscriptionPaymentsAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsAmount$outboundSchema.parse(
      listSubscriptionPaymentsAmount,
    ),
  );
}

export function listSubscriptionPaymentsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsAmountRefunded$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsAmountRefunded$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountRefunded$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsAmountRefunded$ {
  /** @deprecated use `ListSubscriptionPaymentsAmountRefunded$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsAmountRefunded$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountRefunded$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsAmountRefunded$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountRefunded$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsAmountRefunded$Outbound;
}

export function listSubscriptionPaymentsAmountRefundedToJSON(
  listSubscriptionPaymentsAmountRefunded:
    ListSubscriptionPaymentsAmountRefunded,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsAmountRefunded$outboundSchema.parse(
      listSubscriptionPaymentsAmountRefunded,
    ),
  );
}

export function listSubscriptionPaymentsAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsAmountRefunded' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsAmountRemaining$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsAmountRemaining$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountRemaining$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsAmountRemaining$ {
  /** @deprecated use `ListSubscriptionPaymentsAmountRemaining$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsAmountRemaining$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountRemaining$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsAmountRemaining$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountRemaining$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsAmountRemaining$Outbound;
}

export function listSubscriptionPaymentsAmountRemainingToJSON(
  listSubscriptionPaymentsAmountRemaining:
    ListSubscriptionPaymentsAmountRemaining,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsAmountRemaining$outboundSchema.parse(
      listSubscriptionPaymentsAmountRemaining,
    ),
  );
}

export function listSubscriptionPaymentsAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsAmountRemaining,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsAmountRemaining$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsAmountRemaining' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsAmountCaptured$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsAmountCaptured$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountCaptured$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsAmountCaptured$ {
  /** @deprecated use `ListSubscriptionPaymentsAmountCaptured$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsAmountCaptured$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountCaptured$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsAmountCaptured$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountCaptured$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsAmountCaptured$Outbound;
}

export function listSubscriptionPaymentsAmountCapturedToJSON(
  listSubscriptionPaymentsAmountCaptured:
    ListSubscriptionPaymentsAmountCaptured,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsAmountCaptured$outboundSchema.parse(
      listSubscriptionPaymentsAmountCaptured,
    ),
  );
}

export function listSubscriptionPaymentsAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsAmountCaptured' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsAmountChargedBack$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsAmountChargedBack$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsAmountChargedBack$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsAmountChargedBack
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsAmountChargedBack$ {
  /** @deprecated use `ListSubscriptionPaymentsAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsAmountChargedBack$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsAmountChargedBack$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsAmountChargedBack$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsAmountChargedBack$Outbound;
}

export function listSubscriptionPaymentsAmountChargedBackToJSON(
  listSubscriptionPaymentsAmountChargedBack:
    ListSubscriptionPaymentsAmountChargedBack,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsAmountChargedBack$outboundSchema.parse(
      listSubscriptionPaymentsAmountChargedBack,
    ),
  );
}

export function listSubscriptionPaymentsAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsAmountChargedBack,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsAmountChargedBack$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsSettlementAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsSettlementAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsSettlementAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSettlementAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsSettlementAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsSettlementAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSettlementAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsSettlementAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSettlementAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsSettlementAmount$Outbound;
}

export function listSubscriptionPaymentsSettlementAmountToJSON(
  listSubscriptionPaymentsSettlementAmount:
    ListSubscriptionPaymentsSettlementAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsSettlementAmount$outboundSchema.parse(
      listSubscriptionPaymentsSettlementAmount,
    ),
  );
}

export function listSubscriptionPaymentsSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsSettlementAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsSettlementAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsSettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsLineType$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsLineType
> = z.nativeEnum(ListSubscriptionPaymentsLineType);

/** @internal */
export const ListSubscriptionPaymentsLineType$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsLineType
> = ListSubscriptionPaymentsLineType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsLineType$ {
  /** @deprecated use `ListSubscriptionPaymentsLineType$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsLineType$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLineType$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsLineType$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsUnitPrice$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsUnitPrice$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsUnitPrice$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsUnitPrice$ {
  /** @deprecated use `ListSubscriptionPaymentsUnitPrice$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsUnitPrice$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsUnitPrice$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsUnitPrice$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsUnitPrice$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsUnitPrice$Outbound;
}

export function listSubscriptionPaymentsUnitPriceToJSON(
  listSubscriptionPaymentsUnitPrice: ListSubscriptionPaymentsUnitPrice,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsUnitPrice$outboundSchema.parse(
      listSubscriptionPaymentsUnitPrice,
    ),
  );
}

export function listSubscriptionPaymentsUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsUnitPrice' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsDiscountAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsDiscountAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsDiscountAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsDiscountAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsDiscountAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsDiscountAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDiscountAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsDiscountAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDiscountAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsDiscountAmount$Outbound;
}

export function listSubscriptionPaymentsDiscountAmountToJSON(
  listSubscriptionPaymentsDiscountAmount:
    ListSubscriptionPaymentsDiscountAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsDiscountAmount$outboundSchema.parse(
      listSubscriptionPaymentsDiscountAmount,
    ),
  );
}

export function listSubscriptionPaymentsDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsDiscountAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsTotalAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsTotalAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsTotalAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsTotalAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsTotalAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsTotalAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsTotalAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsTotalAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsTotalAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsTotalAmount$Outbound;
}

export function listSubscriptionPaymentsTotalAmountToJSON(
  listSubscriptionPaymentsTotalAmount: ListSubscriptionPaymentsTotalAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsTotalAmount$outboundSchema.parse(
      listSubscriptionPaymentsTotalAmount,
    ),
  );
}

export function listSubscriptionPaymentsTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsVatAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsVatAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsVatAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsVatAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsVatAmount$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsVatAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsVatAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsVatAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsVatAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsVatAmount$Outbound;
}

export function listSubscriptionPaymentsVatAmountToJSON(
  listSubscriptionPaymentsVatAmount: ListSubscriptionPaymentsVatAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsVatAmount$outboundSchema.parse(
      listSubscriptionPaymentsVatAmount,
    ),
  );
}

export function listSubscriptionPaymentsVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsVatAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsCategory$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsCategory
> = z.nativeEnum(ListSubscriptionPaymentsCategory);

/** @internal */
export const ListSubscriptionPaymentsCategory$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsCategory
> = ListSubscriptionPaymentsCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCategory$ {
  /** @deprecated use `ListSubscriptionPaymentsCategory$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsCategory$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCategory$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsCategory$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsInterval$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsInterval
> = z.nativeEnum(ListSubscriptionPaymentsInterval);

/** @internal */
export const ListSubscriptionPaymentsInterval$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsInterval
> = ListSubscriptionPaymentsInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsInterval$ {
  /** @deprecated use `ListSubscriptionPaymentsInterval$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsInterval$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsInterval$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsInterval$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsRecurringAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsRecurringAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRecurringAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRecurringAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsRecurringAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRecurringAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRecurringAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRecurringAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRecurringAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRecurringAmount$Outbound;
}

export function listSubscriptionPaymentsRecurringAmountToJSON(
  listSubscriptionPaymentsRecurringAmount:
    ListSubscriptionPaymentsRecurringAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRecurringAmount$outboundSchema.parse(
      listSubscriptionPaymentsRecurringAmount,
    ),
  );
}

export function listSubscriptionPaymentsRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsRecurringAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsRecurringAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsRecurringAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRecurring$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: ListSubscriptionPaymentsInterval$inboundSchema,
  amount: z.lazy(() => ListSubscriptionPaymentsRecurringAmount$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListSubscriptionPaymentsRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: ListSubscriptionPaymentsRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsRecurring$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRecurring$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRecurring
> = z.object({
  description: z.string().optional(),
  interval: ListSubscriptionPaymentsInterval$outboundSchema,
  amount: z.lazy(() => ListSubscriptionPaymentsRecurringAmount$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRecurring$ {
  /** @deprecated use `ListSubscriptionPaymentsRecurring$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsRecurring$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRecurring$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRecurring$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRecurring$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRecurring$Outbound;
}

export function listSubscriptionPaymentsRecurringToJSON(
  listSubscriptionPaymentsRecurring: ListSubscriptionPaymentsRecurring,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRecurring$outboundSchema.parse(
      listSubscriptionPaymentsRecurring,
    ),
  );
}

export function listSubscriptionPaymentsRecurringFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRecurring' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsLine$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListSubscriptionPaymentsLineType$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListSubscriptionPaymentsUnitPrice$inboundSchema),
  discountAmount: z.lazy(() =>
    ListSubscriptionPaymentsDiscountAmount$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSubscriptionPaymentsTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListSubscriptionPaymentsVatAmount$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListSubscriptionPaymentsCategory$inboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListSubscriptionPaymentsRecurring$inboundSchema)
    .optional(),
});

/** @internal */
export type ListSubscriptionPaymentsLine$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: ListSubscriptionPaymentsUnitPrice$Outbound;
  discountAmount?: ListSubscriptionPaymentsDiscountAmount$Outbound | undefined;
  totalAmount: ListSubscriptionPaymentsTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: ListSubscriptionPaymentsVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: ListSubscriptionPaymentsRecurring$Outbound | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsLine$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsLine$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsLine
> = z.object({
  type: ListSubscriptionPaymentsLineType$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListSubscriptionPaymentsUnitPrice$outboundSchema),
  discountAmount: z.lazy(() =>
    ListSubscriptionPaymentsDiscountAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListSubscriptionPaymentsTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListSubscriptionPaymentsVatAmount$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListSubscriptionPaymentsCategory$outboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListSubscriptionPaymentsRecurring$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsLine$ {
  /** @deprecated use `ListSubscriptionPaymentsLine$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsLine$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLine$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsLine$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLine$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsLine$Outbound;
}

export function listSubscriptionPaymentsLineToJSON(
  listSubscriptionPaymentsLine: ListSubscriptionPaymentsLine,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsLine$outboundSchema.parse(
      listSubscriptionPaymentsLine,
    ),
  );
}

export function listSubscriptionPaymentsLineFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsLine' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsBillingAddress$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListSubscriptionPaymentsBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsBillingAddress$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsBillingAddress$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsBillingAddress$ {
  /** @deprecated use `ListSubscriptionPaymentsBillingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsBillingAddress$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBillingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsBillingAddress$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsBillingAddress$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsBillingAddress$Outbound;
}

export function listSubscriptionPaymentsBillingAddressToJSON(
  listSubscriptionPaymentsBillingAddress:
    ListSubscriptionPaymentsBillingAddress,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsBillingAddress$outboundSchema.parse(
      listSubscriptionPaymentsBillingAddress,
    ),
  );
}

export function listSubscriptionPaymentsBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsShippingAddress$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListSubscriptionPaymentsShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsShippingAddress$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsShippingAddress$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsShippingAddress$ {
  /** @deprecated use `ListSubscriptionPaymentsShippingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsShippingAddress$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsShippingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsShippingAddress$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsShippingAddress$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsShippingAddress$Outbound;
}

export function listSubscriptionPaymentsShippingAddressToJSON(
  listSubscriptionPaymentsShippingAddress:
    ListSubscriptionPaymentsShippingAddress,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsShippingAddress$outboundSchema.parse(
      listSubscriptionPaymentsShippingAddress,
    ),
  );
}

export function listSubscriptionPaymentsShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsShippingAddress,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsShippingAddress$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsShippingAddress' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsLocale$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsLocale
> = z.nativeEnum(ListSubscriptionPaymentsLocale);

/** @internal */
export const ListSubscriptionPaymentsLocale$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsLocale
> = ListSubscriptionPaymentsLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsLocale$ {
  /** @deprecated use `ListSubscriptionPaymentsLocale$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsLocale$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLocale$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsLocale$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsMethod
> = z.nativeEnum(ListSubscriptionPaymentsMethod);

/** @internal */
export const ListSubscriptionPaymentsMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsMethod
> = ListSubscriptionPaymentsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMethod$ {
  /** @deprecated use `ListSubscriptionPaymentsMethod$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsMethod$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMethod$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsMethod$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsMetadata$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListSubscriptionPaymentsMetadata$Outbound = {};

/** @internal */
export const ListSubscriptionPaymentsMetadata$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsMetadata$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMetadata$ {
  /** @deprecated use `ListSubscriptionPaymentsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsMetadata$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsMetadata$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMetadata$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsMetadata$Outbound;
}

export function listSubscriptionPaymentsMetadataToJSON(
  listSubscriptionPaymentsMetadata: ListSubscriptionPaymentsMetadata,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsMetadata$outboundSchema.parse(
      listSubscriptionPaymentsMetadata,
    ),
  );
}

export function listSubscriptionPaymentsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsMetadata' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsMetadataUnion$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListSubscriptionPaymentsMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type ListSubscriptionPaymentsMetadataUnion$Outbound =
  | ListSubscriptionPaymentsMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const ListSubscriptionPaymentsMetadataUnion$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsMetadataUnion$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsMetadataUnion
> = z.union([
  z.lazy(() => ListSubscriptionPaymentsMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMetadataUnion$ {
  /** @deprecated use `ListSubscriptionPaymentsMetadataUnion$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsMetadataUnion$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMetadataUnion$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsMetadataUnion$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMetadataUnion$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsMetadataUnion$Outbound;
}

export function listSubscriptionPaymentsMetadataUnionToJSON(
  listSubscriptionPaymentsMetadataUnion: ListSubscriptionPaymentsMetadataUnion,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsMetadataUnion$outboundSchema.parse(
      listSubscriptionPaymentsMetadataUnion,
    ),
  );
}

export function listSubscriptionPaymentsMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsMetadataUnion' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsCaptureMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsCaptureMode
> = z.nativeEnum(ListSubscriptionPaymentsCaptureMode);

/** @internal */
export const ListSubscriptionPaymentsCaptureMode$outboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsCaptureMode> =
    ListSubscriptionPaymentsCaptureMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCaptureMode$ {
  /** @deprecated use `ListSubscriptionPaymentsCaptureMode$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsCaptureMode$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCaptureMode$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsCaptureMode$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsCaptureDelay$inboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsCaptureDelay> = z.nativeEnum(
    ListSubscriptionPaymentsCaptureDelay,
  );

/** @internal */
export const ListSubscriptionPaymentsCaptureDelay$outboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsCaptureDelay> =
    ListSubscriptionPaymentsCaptureDelay$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCaptureDelay$ {
  /** @deprecated use `ListSubscriptionPaymentsCaptureDelay$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsCaptureDelay$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCaptureDelay$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsCaptureDelay$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsApplicationFeeAmount$inboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsApplicationFeeAmount,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type ListSubscriptionPaymentsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsApplicationFeeAmount$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsApplicationFeeAmount$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsApplicationFeeAmount
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsApplicationFeeAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsApplicationFeeAmount$Outbound;
}

export function listSubscriptionPaymentsApplicationFeeAmountToJSON(
  listSubscriptionPaymentsApplicationFeeAmount:
    ListSubscriptionPaymentsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsApplicationFeeAmount$outboundSchema.parse(
      listSubscriptionPaymentsApplicationFeeAmount,
    ),
  );
}

export function listSubscriptionPaymentsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsApplicationFeeAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsApplicationFeeAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsApplicationFee$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() =>
    ListSubscriptionPaymentsApplicationFeeAmount$inboundSchema
  ).optional(),
  description: z.string().optional(),
});

/** @internal */
export type ListSubscriptionPaymentsApplicationFee$Outbound = {
  amount?: ListSubscriptionPaymentsApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsApplicationFee$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsApplicationFee
> = z.object({
  amount: z.lazy(() =>
    ListSubscriptionPaymentsApplicationFeeAmount$outboundSchema
  ).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsApplicationFee$ {
  /** @deprecated use `ListSubscriptionPaymentsApplicationFee$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsApplicationFee$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsApplicationFee$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsApplicationFee$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsApplicationFee$Outbound;
}

export function listSubscriptionPaymentsApplicationFeeToJSON(
  listSubscriptionPaymentsApplicationFee:
    ListSubscriptionPaymentsApplicationFee,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsApplicationFee$outboundSchema.parse(
      listSubscriptionPaymentsApplicationFee,
    ),
  );
}

export function listSubscriptionPaymentsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsRoutingMode
> = z.nativeEnum(ListSubscriptionPaymentsRoutingMode);

/** @internal */
export const ListSubscriptionPaymentsRoutingMode$outboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsRoutingMode> =
    ListSubscriptionPaymentsRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingMode$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingMode$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingMode$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingMode$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingMode$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsRoutingAmount$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionPaymentsRoutingAmount$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingAmount$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRoutingAmount$Outbound;
}

export function listSubscriptionPaymentsRoutingAmountToJSON(
  listSubscriptionPaymentsRoutingAmount: ListSubscriptionPaymentsRoutingAmount,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRoutingAmount$outboundSchema.parse(
      listSubscriptionPaymentsRoutingAmount,
    ),
  );
}

export function listSubscriptionPaymentsRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRoutingAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsRoutingType
> = z.nativeEnum(ListSubscriptionPaymentsRoutingType);

/** @internal */
export const ListSubscriptionPaymentsRoutingType$outboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsRoutingType> =
    ListSubscriptionPaymentsRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingType$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingType$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingType$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingType$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingType$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsDestination$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListSubscriptionPaymentsRoutingType$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const ListSubscriptionPaymentsDestination$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsDestination$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsDestination
> = z.object({
  type: ListSubscriptionPaymentsRoutingType$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsDestination$ {
  /** @deprecated use `ListSubscriptionPaymentsDestination$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsDestination$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDestination$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsDestination$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDestination$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsDestination$Outbound;
}

export function listSubscriptionPaymentsDestinationToJSON(
  listSubscriptionPaymentsDestination: ListSubscriptionPaymentsDestination,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsDestination$outboundSchema.parse(
      listSubscriptionPaymentsDestination,
    ),
  );
}

export function listSubscriptionPaymentsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsDestination' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRoutingSelf$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsRoutingSelf$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingSelf$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingSelf$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingSelf$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingSelf$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingSelf$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingSelf$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRoutingSelf$Outbound;
}

export function listSubscriptionPaymentsRoutingSelfToJSON(
  listSubscriptionPaymentsRoutingSelf: ListSubscriptionPaymentsRoutingSelf,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRoutingSelf$outboundSchema.parse(
      listSubscriptionPaymentsRoutingSelf,
    ),
  );
}

export function listSubscriptionPaymentsRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRoutingSelf' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRoutingPayment$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsRoutingPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsRoutingPayment$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingPayment$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRoutingPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingPayment$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingPayment$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingPayment$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingPayment$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingPayment$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingPayment$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRoutingPayment$Outbound;
}

export function listSubscriptionPaymentsRoutingPaymentToJSON(
  listSubscriptionPaymentsRoutingPayment:
    ListSubscriptionPaymentsRoutingPayment,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRoutingPayment$outboundSchema.parse(
      listSubscriptionPaymentsRoutingPayment,
    ),
  );
}

export function listSubscriptionPaymentsRoutingPaymentFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRoutingPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsRoutingPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRoutingPayment' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRoutingLinks$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsRoutingSelf$inboundSchema),
  payment: z.lazy(() => ListSubscriptionPaymentsRoutingPayment$inboundSchema),
});

/** @internal */
export type ListSubscriptionPaymentsRoutingLinks$Outbound = {
  self: ListSubscriptionPaymentsRoutingSelf$Outbound;
  payment: ListSubscriptionPaymentsRoutingPayment$Outbound;
};

/** @internal */
export const ListSubscriptionPaymentsRoutingLinks$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRoutingLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRoutingLinks
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsRoutingSelf$outboundSchema),
  payment: z.lazy(() => ListSubscriptionPaymentsRoutingPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRoutingLinks$ {
  /** @deprecated use `ListSubscriptionPaymentsRoutingLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsRoutingLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsRoutingLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRoutingLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRoutingLinks$Outbound;
}

export function listSubscriptionPaymentsRoutingLinksToJSON(
  listSubscriptionPaymentsRoutingLinks: ListSubscriptionPaymentsRoutingLinks,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRoutingLinks$outboundSchema.parse(
      listSubscriptionPaymentsRoutingLinks,
    ),
  );
}

export function listSubscriptionPaymentsRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRoutingLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRouting$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionPaymentsRoutingMode$inboundSchema,
  amount: z.lazy(() => ListSubscriptionPaymentsRoutingAmount$inboundSchema),
  destination: z.lazy(() => ListSubscriptionPaymentsDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSubscriptionPaymentsRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListSubscriptionPaymentsRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: ListSubscriptionPaymentsRoutingAmount$Outbound;
  destination: ListSubscriptionPaymentsDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: ListSubscriptionPaymentsRoutingLinks$Outbound;
};

/** @internal */
export const ListSubscriptionPaymentsRouting$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRouting$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionPaymentsRoutingMode$outboundSchema,
  amount: z.lazy(() => ListSubscriptionPaymentsRoutingAmount$outboundSchema),
  destination: z.lazy(() => ListSubscriptionPaymentsDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSubscriptionPaymentsRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRouting$ {
  /** @deprecated use `ListSubscriptionPaymentsRouting$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsRouting$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRouting$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsRouting$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRouting$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRouting$Outbound;
}

export function listSubscriptionPaymentsRoutingToJSON(
  listSubscriptionPaymentsRouting: ListSubscriptionPaymentsRouting,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRouting$outboundSchema.parse(
      listSubscriptionPaymentsRouting,
    ),
  );
}

export function listSubscriptionPaymentsRoutingFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRouting' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsSequenceType$inboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsSequenceType> = z.nativeEnum(
    ListSubscriptionPaymentsSequenceType,
  );

/** @internal */
export const ListSubscriptionPaymentsSequenceType$outboundSchema:
  z.ZodNativeEnum<typeof ListSubscriptionPaymentsSequenceType> =
    ListSubscriptionPaymentsSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSequenceType$ {
  /** @deprecated use `ListSubscriptionPaymentsSequenceType$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsSequenceType$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSequenceType$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsSequenceType$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsStatus
> = z.nativeEnum(ListSubscriptionPaymentsStatus);

/** @internal */
export const ListSubscriptionPaymentsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionPaymentsStatus
> = ListSubscriptionPaymentsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsStatus$ {
  /** @deprecated use `ListSubscriptionPaymentsStatus$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsStatus$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsStatus$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsStatus$outboundSchema;
}

/** @internal */
export const ListSubscriptionPaymentsStatusReason$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const ListSubscriptionPaymentsStatusReason$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsStatusReason$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsStatusReason$ {
  /** @deprecated use `ListSubscriptionPaymentsStatusReason$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsStatusReason$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsStatusReason$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsStatusReason$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsStatusReason$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsStatusReason$Outbound;
}

export function listSubscriptionPaymentsStatusReasonToJSON(
  listSubscriptionPaymentsStatusReason: ListSubscriptionPaymentsStatusReason,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsStatusReason$outboundSchema.parse(
      listSubscriptionPaymentsStatusReason,
    ),
  );
}

export function listSubscriptionPaymentsStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsStatusReason' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsPaymentSelf$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsPaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsPaymentSelf$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentSelf$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsPaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsPaymentSelf$ {
  /** @deprecated use `ListSubscriptionPaymentsPaymentSelf$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsPaymentSelf$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsPaymentSelf$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentSelf$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsPaymentSelf$Outbound;
}

export function listSubscriptionPaymentsPaymentSelfToJSON(
  listSubscriptionPaymentsPaymentSelf: ListSubscriptionPaymentsPaymentSelf,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsPaymentSelf$outboundSchema.parse(
      listSubscriptionPaymentsPaymentSelf,
    ),
  );
}

export function listSubscriptionPaymentsPaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsPaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsPaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsPaymentSelf' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsCheckout$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsCheckout$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsCheckout$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCheckout$ {
  /** @deprecated use `ListSubscriptionPaymentsCheckout$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsCheckout$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCheckout$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsCheckout$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCheckout$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsCheckout$Outbound;
}

export function listSubscriptionPaymentsCheckoutToJSON(
  listSubscriptionPaymentsCheckout: ListSubscriptionPaymentsCheckout,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsCheckout$outboundSchema.parse(
      listSubscriptionPaymentsCheckout,
    ),
  );
}

export function listSubscriptionPaymentsCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsCheckout' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsMobileAppCheckout$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsMobileAppCheckout$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsMobileAppCheckout$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsMobileAppCheckout
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMobileAppCheckout$ {
  /** @deprecated use `ListSubscriptionPaymentsMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsMobileAppCheckout$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsMobileAppCheckout$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMobileAppCheckout$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsMobileAppCheckout$Outbound;
}

export function listSubscriptionPaymentsMobileAppCheckoutToJSON(
  listSubscriptionPaymentsMobileAppCheckout:
    ListSubscriptionPaymentsMobileAppCheckout,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsMobileAppCheckout$outboundSchema.parse(
      listSubscriptionPaymentsMobileAppCheckout,
    ),
  );
}

export function listSubscriptionPaymentsMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsMobileAppCheckout,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsMobileAppCheckout$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsChangePaymentState$inboundSchema:
  z.ZodType<ListSubscriptionPaymentsChangePaymentState, z.ZodTypeDef, unknown> =
    z.object({
      href: z.string(),
      type: z.string(),
    });

/** @internal */
export type ListSubscriptionPaymentsChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsChangePaymentState$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsChangePaymentState$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsChangePaymentState
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsChangePaymentState$ {
  /** @deprecated use `ListSubscriptionPaymentsChangePaymentState$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsChangePaymentState$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsChangePaymentState$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsChangePaymentState$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsChangePaymentState$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsChangePaymentState$Outbound;
}

export function listSubscriptionPaymentsChangePaymentStateToJSON(
  listSubscriptionPaymentsChangePaymentState:
    ListSubscriptionPaymentsChangePaymentState,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsChangePaymentState$outboundSchema.parse(
      listSubscriptionPaymentsChangePaymentState,
    ),
  );
}

export function listSubscriptionPaymentsChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsChangePaymentState,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsChangePaymentState$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsChangePaymentState' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsDashboard$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsDashboard$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsDashboard$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsDashboard$ {
  /** @deprecated use `ListSubscriptionPaymentsDashboard$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsDashboard$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDashboard$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsDashboard$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDashboard$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsDashboard$Outbound;
}

export function listSubscriptionPaymentsDashboardToJSON(
  listSubscriptionPaymentsDashboard: ListSubscriptionPaymentsDashboard,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsDashboard$outboundSchema.parse(
      listSubscriptionPaymentsDashboard,
    ),
  );
}

export function listSubscriptionPaymentsDashboardFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsDashboard' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsRefunds$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsRefunds$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsRefunds$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsRefunds$ {
  /** @deprecated use `ListSubscriptionPaymentsRefunds$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsRefunds$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRefunds$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsRefunds$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsRefunds$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsRefunds$Outbound;
}

export function listSubscriptionPaymentsRefundsToJSON(
  listSubscriptionPaymentsRefunds: ListSubscriptionPaymentsRefunds,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsRefunds$outboundSchema.parse(
      listSubscriptionPaymentsRefunds,
    ),
  );
}

export function listSubscriptionPaymentsRefundsFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsRefunds' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsChargebacks$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsChargebacks$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsChargebacks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsChargebacks$ {
  /** @deprecated use `ListSubscriptionPaymentsChargebacks$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsChargebacks$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsChargebacks$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsChargebacks$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsChargebacks$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsChargebacks$Outbound;
}

export function listSubscriptionPaymentsChargebacksToJSON(
  listSubscriptionPaymentsChargebacks: ListSubscriptionPaymentsChargebacks,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsChargebacks$outboundSchema.parse(
      listSubscriptionPaymentsChargebacks,
    ),
  );
}

export function listSubscriptionPaymentsChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsChargebacks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsCaptures$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsCaptures$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsCaptures$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCaptures$ {
  /** @deprecated use `ListSubscriptionPaymentsCaptures$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsCaptures$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCaptures$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsCaptures$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCaptures$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsCaptures$Outbound;
}

export function listSubscriptionPaymentsCapturesToJSON(
  listSubscriptionPaymentsCaptures: ListSubscriptionPaymentsCaptures,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsCaptures$outboundSchema.parse(
      listSubscriptionPaymentsCaptures,
    ),
  );
}

export function listSubscriptionPaymentsCapturesFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsCaptures' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsSettlement$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsSettlement$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsSettlement$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSettlement$ {
  /** @deprecated use `ListSubscriptionPaymentsSettlement$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsSettlement$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSettlement$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsSettlement$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSettlement$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsSettlement$Outbound;
}

export function listSubscriptionPaymentsSettlementToJSON(
  listSubscriptionPaymentsSettlement: ListSubscriptionPaymentsSettlement,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsSettlement$outboundSchema.parse(
      listSubscriptionPaymentsSettlement,
    ),
  );
}

export function listSubscriptionPaymentsSettlementFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsSettlement' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsCustomer$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsCustomer$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsCustomer$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsCustomer$ {
  /** @deprecated use `ListSubscriptionPaymentsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsCustomer$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsCustomer$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsCustomer$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsCustomer$Outbound;
}

export function listSubscriptionPaymentsCustomerToJSON(
  listSubscriptionPaymentsCustomer: ListSubscriptionPaymentsCustomer,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsCustomer$outboundSchema.parse(
      listSubscriptionPaymentsCustomer,
    ),
  );
}

export function listSubscriptionPaymentsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsCustomer' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsMandate$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsMandate$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsMandate$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsMandate$ {
  /** @deprecated use `ListSubscriptionPaymentsMandate$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsMandate$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMandate$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsMandate$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsMandate$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsMandate$Outbound;
}

export function listSubscriptionPaymentsMandateToJSON(
  listSubscriptionPaymentsMandate: ListSubscriptionPaymentsMandate,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsMandate$outboundSchema.parse(
      listSubscriptionPaymentsMandate,
    ),
  );
}

export function listSubscriptionPaymentsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsMandate' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsSubscription$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsSubscription$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsSubscription$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSubscription$ {
  /** @deprecated use `ListSubscriptionPaymentsSubscription$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsSubscription$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSubscription$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsSubscription$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSubscription$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsSubscription$Outbound;
}

export function listSubscriptionPaymentsSubscriptionToJSON(
  listSubscriptionPaymentsSubscription: ListSubscriptionPaymentsSubscription,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsSubscription$outboundSchema.parse(
      listSubscriptionPaymentsSubscription,
    ),
  );
}

export function listSubscriptionPaymentsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsSubscription' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsOrder$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsOrder$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsOrder$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsOrder$ {
  /** @deprecated use `ListSubscriptionPaymentsOrder$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsOrder$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsOrder$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsOrder$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsOrder$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsOrder$Outbound;
}

export function listSubscriptionPaymentsOrderToJSON(
  listSubscriptionPaymentsOrder: ListSubscriptionPaymentsOrder,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsOrder$outboundSchema.parse(
      listSubscriptionPaymentsOrder,
    ),
  );
}

export function listSubscriptionPaymentsOrderFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsOrder' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsTerminal$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsTerminal$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsTerminal$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsTerminal$ {
  /** @deprecated use `ListSubscriptionPaymentsTerminal$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsTerminal$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsTerminal$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsTerminal$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsTerminal$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsTerminal$Outbound;
}

export function listSubscriptionPaymentsTerminalToJSON(
  listSubscriptionPaymentsTerminal: ListSubscriptionPaymentsTerminal,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsTerminal$outboundSchema.parse(
      listSubscriptionPaymentsTerminal,
    ),
  );
}

export function listSubscriptionPaymentsTerminalFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsTerminal' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsPaymentDocumentation$inboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsPaymentDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListSubscriptionPaymentsPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsPaymentDocumentation$outboundSchema:
  z.ZodType<
    ListSubscriptionPaymentsPaymentDocumentation$Outbound,
    z.ZodTypeDef,
    ListSubscriptionPaymentsPaymentDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsPaymentDocumentation$ {
  /** @deprecated use `ListSubscriptionPaymentsPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsPaymentDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsPaymentDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsPaymentDocumentation$Outbound;
}

export function listSubscriptionPaymentsPaymentDocumentationToJSON(
  listSubscriptionPaymentsPaymentDocumentation:
    ListSubscriptionPaymentsPaymentDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsPaymentDocumentation$outboundSchema.parse(
      listSubscriptionPaymentsPaymentDocumentation,
    ),
  );
}

export function listSubscriptionPaymentsPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionPaymentsPaymentDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsPaymentDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionPaymentsPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsPaymentLinks$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsPaymentSelf$inboundSchema),
  checkout: z.lazy(() => ListSubscriptionPaymentsCheckout$inboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListSubscriptionPaymentsMobileAppCheckout$inboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListSubscriptionPaymentsChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListSubscriptionPaymentsDashboard$inboundSchema),
  refunds: z.lazy(() => ListSubscriptionPaymentsRefunds$inboundSchema)
    .optional(),
  chargebacks: z.lazy(() => ListSubscriptionPaymentsChargebacks$inboundSchema)
    .optional(),
  captures: z.lazy(() => ListSubscriptionPaymentsCaptures$inboundSchema)
    .optional(),
  settlement: z.lazy(() => ListSubscriptionPaymentsSettlement$inboundSchema)
    .optional(),
  customer: z.lazy(() => ListSubscriptionPaymentsCustomer$inboundSchema)
    .optional(),
  mandate: z.lazy(() => ListSubscriptionPaymentsMandate$inboundSchema)
    .optional(),
  subscription: z.lazy(() => ListSubscriptionPaymentsSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => ListSubscriptionPaymentsOrder$inboundSchema).optional(),
  terminal: z.lazy(() => ListSubscriptionPaymentsTerminal$inboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsPaymentDocumentation$inboundSchema
  ).optional(),
});

/** @internal */
export type ListSubscriptionPaymentsPaymentLinks$Outbound = {
  self: ListSubscriptionPaymentsPaymentSelf$Outbound;
  checkout?: ListSubscriptionPaymentsCheckout$Outbound | undefined;
  mobileAppCheckout?:
    | ListSubscriptionPaymentsMobileAppCheckout$Outbound
    | undefined;
  changePaymentState?:
    | ListSubscriptionPaymentsChangePaymentState$Outbound
    | undefined;
  dashboard: ListSubscriptionPaymentsDashboard$Outbound;
  refunds?: ListSubscriptionPaymentsRefunds$Outbound | undefined;
  chargebacks?: ListSubscriptionPaymentsChargebacks$Outbound | undefined;
  captures?: ListSubscriptionPaymentsCaptures$Outbound | undefined;
  settlement?: ListSubscriptionPaymentsSettlement$Outbound | undefined;
  customer?: ListSubscriptionPaymentsCustomer$Outbound | undefined;
  mandate?: ListSubscriptionPaymentsMandate$Outbound | undefined;
  subscription?: ListSubscriptionPaymentsSubscription$Outbound | undefined;
  order?: ListSubscriptionPaymentsOrder$Outbound | undefined;
  terminal?: ListSubscriptionPaymentsTerminal$Outbound | undefined;
  documentation?:
    | ListSubscriptionPaymentsPaymentDocumentation$Outbound
    | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsPaymentLinks$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsPaymentLinks
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsPaymentSelf$outboundSchema),
  checkout: z.lazy(() => ListSubscriptionPaymentsCheckout$outboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListSubscriptionPaymentsMobileAppCheckout$outboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListSubscriptionPaymentsChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListSubscriptionPaymentsDashboard$outboundSchema),
  refunds: z.lazy(() => ListSubscriptionPaymentsRefunds$outboundSchema)
    .optional(),
  chargebacks: z.lazy(() => ListSubscriptionPaymentsChargebacks$outboundSchema)
    .optional(),
  captures: z.lazy(() => ListSubscriptionPaymentsCaptures$outboundSchema)
    .optional(),
  settlement: z.lazy(() => ListSubscriptionPaymentsSettlement$outboundSchema)
    .optional(),
  customer: z.lazy(() => ListSubscriptionPaymentsCustomer$outboundSchema)
    .optional(),
  mandate: z.lazy(() => ListSubscriptionPaymentsMandate$outboundSchema)
    .optional(),
  subscription: z.lazy(() =>
    ListSubscriptionPaymentsSubscription$outboundSchema
  ).optional(),
  order: z.lazy(() => ListSubscriptionPaymentsOrder$outboundSchema).optional(),
  terminal: z.lazy(() => ListSubscriptionPaymentsTerminal$outboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsPaymentDocumentation$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsPaymentLinks$ {
  /** @deprecated use `ListSubscriptionPaymentsPaymentLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsPaymentLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsPaymentLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsPaymentLinks$Outbound;
}

export function listSubscriptionPaymentsPaymentLinksToJSON(
  listSubscriptionPaymentsPaymentLinks: ListSubscriptionPaymentsPaymentLinks,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsPaymentLinks$outboundSchema.parse(
      listSubscriptionPaymentsPaymentLinks,
    ),
  );
}

export function listSubscriptionPaymentsPaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsPaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsPaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsPaymentLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsPaymentOutput$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionPaymentsMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListSubscriptionPaymentsAmount$inboundSchema),
  amountRefunded: z.lazy(() =>
    ListSubscriptionPaymentsAmountRefunded$inboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListSubscriptionPaymentsAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListSubscriptionPaymentsAmountCaptured$inboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListSubscriptionPaymentsAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListSubscriptionPaymentsSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListSubscriptionPaymentsLine$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListSubscriptionPaymentsBillingAddress$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListSubscriptionPaymentsShippingAddress$inboundSchema
  ).optional(),
  locale: z.nullable(ListSubscriptionPaymentsLocale$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListSubscriptionPaymentsMethod$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListSubscriptionPaymentsMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    ListSubscriptionPaymentsCaptureMode$inboundSchema.default("automatic"),
  ),
  captureDelay: z.nullable(ListSubscriptionPaymentsCaptureDelay$inboundSchema)
    .optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListSubscriptionPaymentsRouting$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    ListSubscriptionPaymentsSequenceType$inboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListSubscriptionPaymentsStatus$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSubscriptionPaymentsPaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListSubscriptionPaymentsPaymentOutput$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: ListSubscriptionPaymentsAmount$Outbound;
  amountRefunded?: ListSubscriptionPaymentsAmountRefunded$Outbound | undefined;
  amountRemaining?:
    | ListSubscriptionPaymentsAmountRemaining$Outbound
    | undefined;
  amountCaptured?: ListSubscriptionPaymentsAmountCaptured$Outbound | undefined;
  amountChargedBack?:
    | ListSubscriptionPaymentsAmountChargedBack$Outbound
    | undefined;
  settlementAmount?:
    | ListSubscriptionPaymentsSettlementAmount$Outbound
    | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<ListSubscriptionPaymentsLine$Outbound> | null | undefined;
  billingAddress?: ListSubscriptionPaymentsBillingAddress$Outbound | undefined;
  shippingAddress?:
    | ListSubscriptionPaymentsShippingAddress$Outbound
    | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | ListSubscriptionPaymentsMetadata$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode: string | null;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | ListSubscriptionPaymentsApplicationFee$Outbound
    | null
    | undefined;
  routing?: Array<ListSubscriptionPaymentsRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?:
    | ListSubscriptionPaymentsStatusReason$Outbound
    | null
    | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: ListSubscriptionPaymentsPaymentLinks$Outbound;
};

/** @internal */
export const ListSubscriptionPaymentsPaymentOutput$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsPaymentOutput$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsPaymentOutput
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionPaymentsMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListSubscriptionPaymentsAmount$outboundSchema),
  amountRefunded: z.lazy(() =>
    ListSubscriptionPaymentsAmountRefunded$outboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListSubscriptionPaymentsAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListSubscriptionPaymentsAmountCaptured$outboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListSubscriptionPaymentsAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListSubscriptionPaymentsSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListSubscriptionPaymentsLine$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListSubscriptionPaymentsBillingAddress$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListSubscriptionPaymentsShippingAddress$outboundSchema
  ).optional(),
  locale: z.nullable(ListSubscriptionPaymentsLocale$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListSubscriptionPaymentsMethod$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListSubscriptionPaymentsMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(
    ListSubscriptionPaymentsCaptureMode$outboundSchema.default("automatic"),
  ),
  captureDelay: z.nullable(ListSubscriptionPaymentsCaptureDelay$outboundSchema)
    .optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListSubscriptionPaymentsRouting$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(
    ListSubscriptionPaymentsSequenceType$outboundSchema.default("oneoff"),
  ),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListSubscriptionPaymentsStatus$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSubscriptionPaymentsPaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsPaymentOutput$ {
  /** @deprecated use `ListSubscriptionPaymentsPaymentOutput$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsPaymentOutput$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentOutput$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsPaymentOutput$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPaymentOutput$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsPaymentOutput$Outbound;
}

export function listSubscriptionPaymentsPaymentOutputToJSON(
  listSubscriptionPaymentsPaymentOutput: ListSubscriptionPaymentsPaymentOutput,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsPaymentOutput$outboundSchema.parse(
      listSubscriptionPaymentsPaymentOutput,
    ),
  );
}

export function listSubscriptionPaymentsPaymentOutputFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsPaymentOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsPaymentOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsPaymentOutput' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsEmbedded$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  payments: z.array(
    z.lazy(() => ListSubscriptionPaymentsPaymentOutput$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListSubscriptionPaymentsEmbedded$Outbound = {
  payments?: Array<ListSubscriptionPaymentsPaymentOutput$Outbound> | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsEmbedded$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsEmbedded$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsEmbedded
> = z.object({
  payments: z.array(
    z.lazy(() => ListSubscriptionPaymentsPaymentOutput$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsEmbedded$ {
  /** @deprecated use `ListSubscriptionPaymentsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsEmbedded$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsEmbedded$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsEmbedded$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsEmbedded$Outbound;
}

export function listSubscriptionPaymentsEmbeddedToJSON(
  listSubscriptionPaymentsEmbedded: ListSubscriptionPaymentsEmbedded,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsEmbedded$outboundSchema.parse(
      listSubscriptionPaymentsEmbedded,
    ),
  );
}

export function listSubscriptionPaymentsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsSelf$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsSelf$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsSelf$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsSelf$ {
  /** @deprecated use `ListSubscriptionPaymentsSelf$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsSelf$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSelf$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsSelf$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsSelf$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsSelf$Outbound;
}

export function listSubscriptionPaymentsSelfToJSON(
  listSubscriptionPaymentsSelf: ListSubscriptionPaymentsSelf,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsSelf$outboundSchema.parse(
      listSubscriptionPaymentsSelf,
    ),
  );
}

export function listSubscriptionPaymentsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsSelf' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsPrevious$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionPaymentsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsPrevious$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsPrevious$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsPrevious$ {
  /** @deprecated use `ListSubscriptionPaymentsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsPrevious$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsPrevious$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsPrevious$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsPrevious$Outbound;
}

export function listSubscriptionPaymentsPreviousToJSON(
  listSubscriptionPaymentsPrevious: ListSubscriptionPaymentsPrevious,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsPrevious$outboundSchema.parse(
      listSubscriptionPaymentsPrevious,
    ),
  );
}

export function listSubscriptionPaymentsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsPrevious' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsNext$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionPaymentsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsNext$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsNext$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsNext$ {
  /** @deprecated use `ListSubscriptionPaymentsNext$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsNext$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsNext$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsNext$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsNext$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsNext$Outbound;
}

export function listSubscriptionPaymentsNextToJSON(
  listSubscriptionPaymentsNext: ListSubscriptionPaymentsNext,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsNext$outboundSchema.parse(
      listSubscriptionPaymentsNext,
    ),
  );
}

export function listSubscriptionPaymentsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsNext' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsDocumentation$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionPaymentsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionPaymentsDocumentation$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsDocumentation$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsDocumentation$ {
  /** @deprecated use `ListSubscriptionPaymentsDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionPaymentsDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionPaymentsDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsDocumentation$Outbound;
}

export function listSubscriptionPaymentsDocumentationToJSON(
  listSubscriptionPaymentsDocumentation: ListSubscriptionPaymentsDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsDocumentation$outboundSchema.parse(
      listSubscriptionPaymentsDocumentation,
    ),
  );
}

export function listSubscriptionPaymentsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionPaymentsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsLinks$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsSelf$inboundSchema).optional(),
  previous: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsPrevious$inboundSchema),
  ).optional(),
  next: z.nullable(z.lazy(() => ListSubscriptionPaymentsNext$inboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsDocumentation$inboundSchema
  ).optional(),
});

/** @internal */
export type ListSubscriptionPaymentsLinks$Outbound = {
  self?: ListSubscriptionPaymentsSelf$Outbound | undefined;
  previous?: ListSubscriptionPaymentsPrevious$Outbound | null | undefined;
  next?: ListSubscriptionPaymentsNext$Outbound | null | undefined;
  documentation?: ListSubscriptionPaymentsDocumentation$Outbound | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsLinks$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsLinks
> = z.object({
  self: z.lazy(() => ListSubscriptionPaymentsSelf$outboundSchema).optional(),
  previous: z.nullable(
    z.lazy(() => ListSubscriptionPaymentsPrevious$outboundSchema),
  ).optional(),
  next: z.nullable(z.lazy(() => ListSubscriptionPaymentsNext$outboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionPaymentsDocumentation$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsLinks$ {
  /** @deprecated use `ListSubscriptionPaymentsLinks$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLinks$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsLinks$Outbound;
}

export function listSubscriptionPaymentsLinksToJSON(
  listSubscriptionPaymentsLinks: ListSubscriptionPaymentsLinks,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsLinks$outboundSchema.parse(
      listSubscriptionPaymentsLinks,
    ),
  );
}

export function listSubscriptionPaymentsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionPaymentsResponse$inboundSchema: z.ZodType<
  ListSubscriptionPaymentsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListSubscriptionPaymentsEmbedded$inboundSchema)
    .optional(),
  _links: z.lazy(() => ListSubscriptionPaymentsLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListSubscriptionPaymentsResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListSubscriptionPaymentsEmbedded$Outbound | undefined;
  _links?: ListSubscriptionPaymentsLinks$Outbound | undefined;
};

/** @internal */
export const ListSubscriptionPaymentsResponse$outboundSchema: z.ZodType<
  ListSubscriptionPaymentsResponse$Outbound,
  z.ZodTypeDef,
  ListSubscriptionPaymentsResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListSubscriptionPaymentsEmbedded$outboundSchema)
    .optional(),
  links: z.lazy(() => ListSubscriptionPaymentsLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionPaymentsResponse$ {
  /** @deprecated use `ListSubscriptionPaymentsResponse$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionPaymentsResponse$inboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsResponse$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionPaymentsResponse$outboundSchema;
  /** @deprecated use `ListSubscriptionPaymentsResponse$Outbound` instead. */
  export type Outbound = ListSubscriptionPaymentsResponse$Outbound;
}

export function listSubscriptionPaymentsResponseToJSON(
  listSubscriptionPaymentsResponse: ListSubscriptionPaymentsResponse,
): string {
  return JSON.stringify(
    ListSubscriptionPaymentsResponse$outboundSchema.parse(
      listSubscriptionPaymentsResponse,
    ),
  );
}

export function listSubscriptionPaymentsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionPaymentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionPaymentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionPaymentsResponse' from JSON`,
  );
}
