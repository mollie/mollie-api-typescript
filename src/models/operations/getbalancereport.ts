/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetBalanceReportRequest = {
  /**
   * Provide the ID of the related balance.
   */
  balanceId: string;
  /**
   * The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time. This means a report with for example `from=2024-01-01` will include transactions from 2024-01-01 0:00:00 CET and onwards.
   */
  from: string;
  /**
   * The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time. This means a report with for example `until=2024-02-01` will include transactions up until 2024-01-31 23:59:59 CET.
   */
  until: string;
  /**
   * You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by status (e.g. `pending`, `available`), then by transaction type, and then by other sub-groupings where available (e.g. payment method).
   *
   * @remarks
   *
   * With the `transaction-categories` format, transactions are grouped by transaction type, then by status, and then again by other sub-groupings where available.
   *
   * Possible values: `status-balances` `transaction-categories` (default: `status-balances`)
   */
  grouping?: string | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.
   *
   * @remarks
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type GetBalanceReportUnprocessableEntityDocumentation = {
  href: string;
  type: string;
};

export type GetBalanceReportUnprocessableEntityLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: GetBalanceReportUnprocessableEntityDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type GetBalanceReportNotFoundDocumentation = {
  href: string;
  type: string;
};

export type GetBalanceReportNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: GetBalanceReportNotFoundDocumentation;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PendingBalanceOpenAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PendingBalanceOpenSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceOpenSubtotal2 = {
  subTotals?: Array<PendingBalanceOpenSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceOpen = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PendingBalanceOpenAmount | undefined;
  subtotals?: Array<PendingBalanceOpenSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PendingBalanceCloseAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PendingBalanceCloseSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceCloseSubtotal2 = {
  subTotals?: Array<PendingBalanceCloseSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceClose = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PendingBalanceCloseAmount | undefined;
  subtotals?: Array<PendingBalanceCloseSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PendingBalancePendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PendingBalancePendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalancePendingSubtotal2 = {
  subTotals?: Array<PendingBalancePendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalancePending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PendingBalancePendingAmount | undefined;
  subtotals?: Array<PendingBalancePendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PendingBalanceMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PendingBalanceMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceMovedToAvailableSubtotal2 = {
  subTotals?: Array<PendingBalanceMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PendingBalanceMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PendingBalanceMovedToAvailableAmount | undefined;
  subtotals?: Array<PendingBalanceMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * The pending balance. Only available if grouping is `status-balances`.
 */
export type PendingBalance = {
  open?: PendingBalanceOpen | undefined;
  close?: PendingBalanceClose | undefined;
  pending?: PendingBalancePending | undefined;
  movedToAvailable?: PendingBalanceMovedToAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type AvailableBalanceOpenAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type AvailableBalanceOpenSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceOpenSubtotal2 = {
  subTotals?: Array<AvailableBalanceOpenSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceOpen = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: AvailableBalanceOpenAmount | undefined;
  subtotals?: Array<AvailableBalanceOpenSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type MovedFromPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type MovedFromPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type MovedFromPendingSubtotal2 = {
  subTotals?: Array<MovedFromPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type MovedFromPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: MovedFromPendingAmount | undefined;
  subtotals?: Array<MovedFromPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type AvailableBalanceImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type AvailableBalanceImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceImmediatelyAvailableSubtotal2 = {
  subTotals?:
    | Array<AvailableBalanceImmediatelyAvailableSubTotal1>
    | null
    | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: AvailableBalanceImmediatelyAvailableAmount | undefined;
  subtotals?:
    | Array<AvailableBalanceImmediatelyAvailableSubtotal2>
    | null
    | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type AvailableBalanceCloseAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type AvailableBalanceCloseSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceCloseSubtotal2 = {
  subTotals?: Array<AvailableBalanceCloseSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type AvailableBalanceClose = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: AvailableBalanceCloseAmount | undefined;
  subtotals?: Array<AvailableBalanceCloseSubtotal2> | null | undefined;
};

/**
 * The available balance. Only available if grouping is `status-balances`.
 */
export type AvailableBalance = {
  open?: AvailableBalanceOpen | undefined;
  movedFromPending?: MovedFromPending | undefined;
  immediatelyAvailable?: AvailableBalanceImmediatelyAvailable | undefined;
  close?: AvailableBalanceClose | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type OpenPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type OpenPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type OpenPendingSubtotal2 = {
  subTotals?: Array<OpenPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type OpenPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: OpenPendingAmount | undefined;
  subtotals?: Array<OpenPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type OpenAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type OpenAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type OpenAvailableSubtotal2 = {
  subTotals?: Array<OpenAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type OpenAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: OpenAvailableAmount | undefined;
  subtotals?: Array<OpenAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Open = {
  pending?: OpenPending | undefined;
  available?: OpenAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ClosePendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type ClosePendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ClosePendingSubtotal2 = {
  subTotals?: Array<ClosePendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ClosePending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: ClosePendingAmount | undefined;
  subtotals?: Array<ClosePendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CloseAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CloseAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CloseAvailableSubtotal2 = {
  subTotals?: Array<CloseAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CloseAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CloseAvailableAmount | undefined;
  subtotals?: Array<CloseAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Close = {
  pending?: ClosePending | undefined;
  available?: CloseAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PaymentsPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PaymentsPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsPendingSubtotal2 = {
  subTotals?: Array<PaymentsPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PaymentsPendingAmount | undefined;
  subtotals?: Array<PaymentsPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PaymentsMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PaymentsMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsMovedToAvailableSubtotal2 = {
  subTotals?: Array<PaymentsMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PaymentsMovedToAvailableAmount | undefined;
  subtotals?: Array<PaymentsMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type PaymentsImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type PaymentsImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsImmediatelyAvailableSubtotal2 = {
  subTotals?: Array<PaymentsImmediatelyAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type PaymentsImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: PaymentsImmediatelyAvailableAmount | undefined;
  subtotals?: Array<PaymentsImmediatelyAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type GetBalanceReportPayments = {
  pending?: PaymentsPending | undefined;
  movedToAvailable?: PaymentsMovedToAvailable | undefined;
  immediatelyAvailable?: PaymentsImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type RefundsPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type RefundsPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsPendingSubtotal2 = {
  subTotals?: Array<RefundsPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: RefundsPendingAmount | undefined;
  subtotals?: Array<RefundsPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type RefundsMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type RefundsMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsMovedToAvailableSubtotal2 = {
  subTotals?: Array<RefundsMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: RefundsMovedToAvailableAmount | undefined;
  subtotals?: Array<RefundsMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type RefundsImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type RefundsImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsImmediatelyAvailableSubtotal2 = {
  subTotals?: Array<RefundsImmediatelyAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type RefundsImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: RefundsImmediatelyAvailableAmount | undefined;
  subtotals?: Array<RefundsImmediatelyAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type GetBalanceReportRefunds = {
  pending?: RefundsPending | undefined;
  movedToAvailable?: RefundsMovedToAvailable | undefined;
  immediatelyAvailable?: RefundsImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ChargebacksPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type ChargebacksPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksPendingSubtotal2 = {
  subTotals?: Array<ChargebacksPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: ChargebacksPendingAmount | undefined;
  subtotals?: Array<ChargebacksPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ChargebacksMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type ChargebacksMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksMovedToAvailableSubtotal2 = {
  subTotals?: Array<ChargebacksMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: ChargebacksMovedToAvailableAmount | undefined;
  subtotals?: Array<ChargebacksMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ChargebacksImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type ChargebacksImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksImmediatelyAvailableSubtotal2 = {
  subTotals?:
    | Array<ChargebacksImmediatelyAvailableSubTotal1>
    | null
    | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type ChargebacksImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: ChargebacksImmediatelyAvailableAmount | undefined;
  subtotals?:
    | Array<ChargebacksImmediatelyAvailableSubtotal2>
    | null
    | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type GetBalanceReportChargebacks = {
  pending?: ChargebacksPending | undefined;
  movedToAvailable?: ChargebacksMovedToAvailable | undefined;
  immediatelyAvailable?: ChargebacksImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CapitalPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CapitalPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalPendingSubtotal2 = {
  subTotals?: Array<CapitalPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CapitalPendingAmount | undefined;
  subtotals?: Array<CapitalPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CapitalMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CapitalMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalMovedToAvailableSubtotal2 = {
  subTotals?: Array<CapitalMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CapitalMovedToAvailableAmount | undefined;
  subtotals?: Array<CapitalMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CapitalImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CapitalImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalImmediatelyAvailableSubtotal2 = {
  subTotals?: Array<CapitalImmediatelyAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CapitalImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CapitalImmediatelyAvailableAmount | undefined;
  subtotals?: Array<CapitalImmediatelyAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Capital = {
  pending?: CapitalPending | undefined;
  movedToAvailable?: CapitalMovedToAvailable | undefined;
  immediatelyAvailable?: CapitalImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TransfersPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TransfersPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersPendingSubtotal2 = {
  subTotals?: Array<TransfersPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TransfersPendingAmount | undefined;
  subtotals?: Array<TransfersPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TransfersMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TransfersMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersMovedToAvailableSubtotal2 = {
  subTotals?: Array<TransfersMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TransfersMovedToAvailableAmount | undefined;
  subtotals?: Array<TransfersMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TransfersImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TransfersImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersImmediatelyAvailableSubtotal2 = {
  subTotals?: Array<TransfersImmediatelyAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TransfersImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TransfersImmediatelyAvailableAmount | undefined;
  subtotals?: Array<TransfersImmediatelyAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Transfers = {
  pending?: TransfersPending | undefined;
  movedToAvailable?: TransfersMovedToAvailable | undefined;
  immediatelyAvailable?: TransfersImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type FeePrepaymentsPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type FeePrepaymentsPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsPendingSubtotal2 = {
  subTotals?: Array<FeePrepaymentsPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: FeePrepaymentsPendingAmount | undefined;
  subtotals?: Array<FeePrepaymentsPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type FeePrepaymentsMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type FeePrepaymentsMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsMovedToAvailableSubtotal2 = {
  subTotals?: Array<FeePrepaymentsMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: FeePrepaymentsMovedToAvailableAmount | undefined;
  subtotals?: Array<FeePrepaymentsMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type FeePrepaymentsImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type FeePrepaymentsImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsImmediatelyAvailableSubtotal2 = {
  subTotals?:
    | Array<FeePrepaymentsImmediatelyAvailableSubTotal1>
    | null
    | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type FeePrepaymentsImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: FeePrepaymentsImmediatelyAvailableAmount | undefined;
  subtotals?:
    | Array<FeePrepaymentsImmediatelyAvailableSubtotal2>
    | null
    | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type FeePrepayments = {
  pending?: FeePrepaymentsPending | undefined;
  movedToAvailable?: FeePrepaymentsMovedToAvailable | undefined;
  immediatelyAvailable?: FeePrepaymentsImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CorrectionsPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CorrectionsPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsPendingSubtotal2 = {
  subTotals?: Array<CorrectionsPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CorrectionsPendingAmount | undefined;
  subtotals?: Array<CorrectionsPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CorrectionsMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CorrectionsMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsMovedToAvailableSubtotal2 = {
  subTotals?: Array<CorrectionsMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CorrectionsMovedToAvailableAmount | undefined;
  subtotals?: Array<CorrectionsMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CorrectionsImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type CorrectionsImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsImmediatelyAvailableSubtotal2 = {
  subTotals?:
    | Array<CorrectionsImmediatelyAvailableSubTotal1>
    | null
    | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type CorrectionsImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CorrectionsImmediatelyAvailableAmount | undefined;
  subtotals?:
    | Array<CorrectionsImmediatelyAvailableSubtotal2>
    | null
    | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Corrections = {
  pending?: CorrectionsPending | undefined;
  movedToAvailable?: CorrectionsMovedToAvailable | undefined;
  immediatelyAvailable?: CorrectionsImmediatelyAvailable | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TopupsPendingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TopupsPendingSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsPendingSubtotal2 = {
  subTotals?: Array<TopupsPendingSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsPending = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TopupsPendingAmount | undefined;
  subtotals?: Array<TopupsPendingSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TopupsMovedToAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TopupsMovedToAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsMovedToAvailableSubtotal2 = {
  subTotals?: Array<TopupsMovedToAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsMovedToAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TopupsMovedToAvailableAmount | undefined;
  subtotals?: Array<TopupsMovedToAvailableSubtotal2> | null | undefined;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type TopupsImmediatelyAvailableAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type TopupsImmediatelyAvailableSubTotal1 = {
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsImmediatelyAvailableSubtotal2 = {
  subTotals?: Array<TopupsImmediatelyAvailableSubTotal1> | null | undefined;
  /**
   * Number of transactions of this type
   */
  count?: number | undefined;
  /**
   * Payment type of the transactions
   */
  method?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card issuer will be available
   *
   * @remarks
   *
   * Possible values: `amex` `maestro` `carte-bancaire` `other`
   */
  cardIssuer?: string | null | undefined;
  /**
   * In case of payments trnsactions with card, the card audience will be available.
   *
   * @remarks
   *
   * Possible values: `corporate` `other`
   */
  cardAudience?: string | null | undefined;
  /**
   * In case of payments transactions with card, the card region will be available.
   *
   * @remarks
   *
   * Possible values: `intra-eea` `intra-eu` `domestic` `other`
   */
  cardRegion?: string | null | undefined;
  /**
   * Present when the transaction represents a fee.
   *
   * @remarks
   *
   * Possible values: `payment-fee` `direct-debit-failure-fee` `unauthorized-direct-debit-fee` `bank-charged-direct-debit-failure-fee` `partner-commission` `application-fee` `capture-fee` `refund-fee` `chargeback-fee` `payment-notification-fee` `transfer-notification-fee` `payout-fee` `fee-discount` `fee-reimbursement` `platform-volume-fee` `platform-connected-organizations-fee` `balance-charge-fee` `3ds-authentication-attempt-fee` `terminal-monthly-fee` `acceptance-risk-fee` `top-up-fee` `payment-gateway-fee` `mastercard-specialty-merchant-program-processing-fee` `mastercard-specialty-merchant-program-registration-fee` `visa-integrity-risk-program-processing-fee` `visa-integrity-risk-program-registration-fee` `minimum-invoice-amount-fee`
   */
  feeType?: string | null | undefined;
  /**
   * Prepayment part: fee itself, reimbursement, discount, VAT or rounding compensation.
   *
   * @remarks
   *
   * Possible values: `fee` `fee-reimbursement` `fee-discount` `fee-vat` `fee-rounding-compensation`
   */
  prepaymentPartType?: string | null | undefined;
  /**
   * Represents the transaction type
   *
   * @remarks
   *
   * Possible values: `payment` `split-payment` `failed-payment` `failed-platform-split-payment` `failed-split-payment-compensation` `capture` `split-transaction` `refund` `platform-payment-refund` `returned-platform-payment-refund` `refund-compensation` `returned-refund-compensation` `returned-refund` `chargeback` `chargeback-reversal` `chargeback-compensation` `reversed-chargeback-compensation` `platform-payment-chargeback` `reversed-platform-payment-chargeback` `fee-prepayment` `outgoing-transfer` `incoming-transfer` `canceled-transfer` `returned-transfer` `balance-reserve` `balance-reserve-return` `invoice-rounding-compensation` `rolling-reserve-hold` `rolling-reserve-release` `balance-correction` `repayment` `loan` `balance-topup` `cash-collateral-issuance';` `cash-collateral-release` `pending-rolling-reserve` `to-be-released-rolling-reserve` `held-rolling-reserve` `released-rolling-reserve`
   */
  transactionType?: string | null | undefined;
};

export type TopupsImmediatelyAvailable = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: TopupsImmediatelyAvailableAmount | undefined;
  subtotals?: Array<TopupsImmediatelyAvailableSubtotal2> | null | undefined;
};

/**
 * Only available on `transaction-categories` grouping.
 */
export type Topups = {
  pending?: TopupsPending | undefined;
  movedToAvailable?: TopupsMovedToAvailable | undefined;
  immediatelyAvailable?: TopupsImmediatelyAvailable | undefined;
};

/**
 * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a typical grouping looks like.
 *
 * @remarks
 *
 * If grouping `status-balances` is chosen, the main grouping is as follows:
 *
 * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
 * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
 *
 * If grouping `transaction-categories` is chosen, the main grouping is as follows:
 *
 * * `open` and `close` groups, each containing a `pending` and `available` sub-group
 * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups` each containing a `pending`, `movedToAvailable`, and `immediatelyAvailable` sub-group
 *
 * Each sub-group typically has:
 *
 * * An `amount` object containing the group's total amount
 * * A `count` integer if relevant (for example, counting the number of refunds)
 * * A `subtotals` array containing more sub-group objects if applicable
 */
export type Totals = {
  /**
   * The pending balance. Only available if grouping is `status-balances`.
   */
  pendingBalance?: PendingBalance | null | undefined;
  /**
   * The available balance. Only available if grouping is `status-balances`.
   */
  availableBalance?: AvailableBalance | null | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  open?: Open | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  close?: Close | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  payments?: GetBalanceReportPayments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  refunds?: GetBalanceReportRefunds | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  chargebacks?: GetBalanceReportChargebacks | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  capital?: Capital | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  transfers?: Transfers | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  feePrepayments?: FeePrepayments | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  corrections?: Corrections | undefined;
  /**
   * Only available on `transaction-categories` grouping.
   */
  topups?: Topups | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type GetBalanceReportSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type GetBalanceReportDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type GetBalanceReportLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: GetBalanceReportSelf | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: GetBalanceReportDocumentation | undefined;
};

/**
 * The balance report object.
 */
export type GetBalanceReportResponse = {
  /**
   * Indicates the response contains a balance report object. Will always contain the string `balance-report` for this endpoint.
   */
  resource?: string | undefined;
  /**
   * The ID of the balance this report is generated for.
   */
  balanceId?: string | undefined;
  /**
   * The time zone used for the from and until parameters. Currently only time zone `Europe/Amsterdam` is supported.
   */
  timeZone?: string | undefined;
  /**
   * The start date of the report, in `YYYY-MM-DD` format. The from date is 'inclusive', and in Central European Time. This means a report with for example `from=2024-01-01` will include movements of 2024-01-01 00:00:00 CET and onwards.
   */
  from?: string | undefined;
  /**
   * The end date of the report, in `YYYY-MM-DD` format. The until date is 'exclusive', and in Central European Time. This means a report with for example `until=2024-02-01` will include movements up until 2024-01-31 23:59:59 CET.
   */
  until?: string | undefined;
  /**
   * You can retrieve reports in two different formats. With the `status-balances` format, transactions are grouped by status (e.g. `pending`, `available`), then by direction of movement (e.g. moved from pending to available), then by transaction type, and then by other sub-groupings where available (e.g. payment method).
   *
   * @remarks
   *
   * With the `transaction-categories` format, transactions are grouped by transaction type, then by direction of movement, and then again by other sub-groupings where available.
   *
   * Both reporting formats will always contain opening and closing amounts that correspond to the start and end dates of the report.
   *
   * Possible values: `status-balances` `transaction-categories` (default: `status-balances`)
   */
  grouping?: string | undefined;
  /**
   * Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a typical grouping looks like.
   *
   * @remarks
   *
   * If grouping `status-balances` is chosen, the main grouping is as follows:
   *
   * * `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
   * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
   *
   * If grouping `transaction-categories` is chosen, the main grouping is as follows:
   *
   * * `open` and `close` groups, each containing a `pending` and `available` sub-group
   * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups` each containing a `pending`, `movedToAvailable`, and `immediatelyAvailable` sub-group
   *
   * Each sub-group typically has:
   *
   * * An `amount` object containing the group's total amount
   * * A `count` integer if relevant (for example, counting the number of refunds)
   * * A `subtotals` array containing more sub-group objects if applicable
   */
  totals?: Totals | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: GetBalanceReportLinks | undefined;
};

/** @internal */
export const GetBalanceReportRequest$inboundSchema: z.ZodType<
  GetBalanceReportRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  balanceId: z.string(),
  from: z.string(),
  until: z.string(),
  grouping: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type GetBalanceReportRequest$Outbound = {
  balanceId: string;
  from: string;
  until: string;
  grouping?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const GetBalanceReportRequest$outboundSchema: z.ZodType<
  GetBalanceReportRequest$Outbound,
  z.ZodTypeDef,
  GetBalanceReportRequest
> = z.object({
  balanceId: z.string(),
  from: z.string(),
  until: z.string(),
  grouping: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportRequest$ {
  /** @deprecated use `GetBalanceReportRequest$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportRequest$inboundSchema;
  /** @deprecated use `GetBalanceReportRequest$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportRequest$outboundSchema;
  /** @deprecated use `GetBalanceReportRequest$Outbound` instead. */
  export type Outbound = GetBalanceReportRequest$Outbound;
}

export function getBalanceReportRequestToJSON(
  getBalanceReportRequest: GetBalanceReportRequest,
): string {
  return JSON.stringify(
    GetBalanceReportRequest$outboundSchema.parse(getBalanceReportRequest),
  );
}

export function getBalanceReportRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportRequest' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportUnprocessableEntityDocumentation$inboundSchema:
  z.ZodType<
    GetBalanceReportUnprocessableEntityDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type GetBalanceReportUnprocessableEntityDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetBalanceReportUnprocessableEntityDocumentation$outboundSchema:
  z.ZodType<
    GetBalanceReportUnprocessableEntityDocumentation$Outbound,
    z.ZodTypeDef,
    GetBalanceReportUnprocessableEntityDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportUnprocessableEntityDocumentation$ {
  /** @deprecated use `GetBalanceReportUnprocessableEntityDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    GetBalanceReportUnprocessableEntityDocumentation$inboundSchema;
  /** @deprecated use `GetBalanceReportUnprocessableEntityDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    GetBalanceReportUnprocessableEntityDocumentation$outboundSchema;
  /** @deprecated use `GetBalanceReportUnprocessableEntityDocumentation$Outbound` instead. */
  export type Outbound =
    GetBalanceReportUnprocessableEntityDocumentation$Outbound;
}

export function getBalanceReportUnprocessableEntityDocumentationToJSON(
  getBalanceReportUnprocessableEntityDocumentation:
    GetBalanceReportUnprocessableEntityDocumentation,
): string {
  return JSON.stringify(
    GetBalanceReportUnprocessableEntityDocumentation$outboundSchema.parse(
      getBalanceReportUnprocessableEntityDocumentation,
    ),
  );
}

export function getBalanceReportUnprocessableEntityDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  GetBalanceReportUnprocessableEntityDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetBalanceReportUnprocessableEntityDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetBalanceReportUnprocessableEntityDocumentation' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportUnprocessableEntityLinks$inboundSchema: z.ZodType<
  GetBalanceReportUnprocessableEntityLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    GetBalanceReportUnprocessableEntityDocumentation$inboundSchema
  ),
});

/** @internal */
export type GetBalanceReportUnprocessableEntityLinks$Outbound = {
  documentation: GetBalanceReportUnprocessableEntityDocumentation$Outbound;
};

/** @internal */
export const GetBalanceReportUnprocessableEntityLinks$outboundSchema: z.ZodType<
  GetBalanceReportUnprocessableEntityLinks$Outbound,
  z.ZodTypeDef,
  GetBalanceReportUnprocessableEntityLinks
> = z.object({
  documentation: z.lazy(() =>
    GetBalanceReportUnprocessableEntityDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportUnprocessableEntityLinks$ {
  /** @deprecated use `GetBalanceReportUnprocessableEntityLinks$inboundSchema` instead. */
  export const inboundSchema =
    GetBalanceReportUnprocessableEntityLinks$inboundSchema;
  /** @deprecated use `GetBalanceReportUnprocessableEntityLinks$outboundSchema` instead. */
  export const outboundSchema =
    GetBalanceReportUnprocessableEntityLinks$outboundSchema;
  /** @deprecated use `GetBalanceReportUnprocessableEntityLinks$Outbound` instead. */
  export type Outbound = GetBalanceReportUnprocessableEntityLinks$Outbound;
}

export function getBalanceReportUnprocessableEntityLinksToJSON(
  getBalanceReportUnprocessableEntityLinks:
    GetBalanceReportUnprocessableEntityLinks,
): string {
  return JSON.stringify(
    GetBalanceReportUnprocessableEntityLinks$outboundSchema.parse(
      getBalanceReportUnprocessableEntityLinks,
    ),
  );
}

export function getBalanceReportUnprocessableEntityLinksFromJSON(
  jsonString: string,
): SafeParseResult<
  GetBalanceReportUnprocessableEntityLinks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetBalanceReportUnprocessableEntityLinks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetBalanceReportUnprocessableEntityLinks' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportNotFoundDocumentation$inboundSchema: z.ZodType<
  GetBalanceReportNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetBalanceReportNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetBalanceReportNotFoundDocumentation$outboundSchema: z.ZodType<
  GetBalanceReportNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  GetBalanceReportNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportNotFoundDocumentation$ {
  /** @deprecated use `GetBalanceReportNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    GetBalanceReportNotFoundDocumentation$inboundSchema;
  /** @deprecated use `GetBalanceReportNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    GetBalanceReportNotFoundDocumentation$outboundSchema;
  /** @deprecated use `GetBalanceReportNotFoundDocumentation$Outbound` instead. */
  export type Outbound = GetBalanceReportNotFoundDocumentation$Outbound;
}

export function getBalanceReportNotFoundDocumentationToJSON(
  getBalanceReportNotFoundDocumentation: GetBalanceReportNotFoundDocumentation,
): string {
  return JSON.stringify(
    GetBalanceReportNotFoundDocumentation$outboundSchema.parse(
      getBalanceReportNotFoundDocumentation,
    ),
  );
}

export function getBalanceReportNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetBalanceReportNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportNotFoundLinks$inboundSchema: z.ZodType<
  GetBalanceReportNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    GetBalanceReportNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type GetBalanceReportNotFoundLinks$Outbound = {
  documentation: GetBalanceReportNotFoundDocumentation$Outbound;
};

/** @internal */
export const GetBalanceReportNotFoundLinks$outboundSchema: z.ZodType<
  GetBalanceReportNotFoundLinks$Outbound,
  z.ZodTypeDef,
  GetBalanceReportNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    GetBalanceReportNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportNotFoundLinks$ {
  /** @deprecated use `GetBalanceReportNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportNotFoundLinks$inboundSchema;
  /** @deprecated use `GetBalanceReportNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportNotFoundLinks$outboundSchema;
  /** @deprecated use `GetBalanceReportNotFoundLinks$Outbound` instead. */
  export type Outbound = GetBalanceReportNotFoundLinks$Outbound;
}

export function getBalanceReportNotFoundLinksToJSON(
  getBalanceReportNotFoundLinks: GetBalanceReportNotFoundLinks,
): string {
  return JSON.stringify(
    GetBalanceReportNotFoundLinks$outboundSchema.parse(
      getBalanceReportNotFoundLinks,
    ),
  );
}

export function getBalanceReportNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const PendingBalanceOpenAmount$inboundSchema: z.ZodType<
  PendingBalanceOpenAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PendingBalanceOpenAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PendingBalanceOpenAmount$outboundSchema: z.ZodType<
  PendingBalanceOpenAmount$Outbound,
  z.ZodTypeDef,
  PendingBalanceOpenAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceOpenAmount$ {
  /** @deprecated use `PendingBalanceOpenAmount$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceOpenAmount$inboundSchema;
  /** @deprecated use `PendingBalanceOpenAmount$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceOpenAmount$outboundSchema;
  /** @deprecated use `PendingBalanceOpenAmount$Outbound` instead. */
  export type Outbound = PendingBalanceOpenAmount$Outbound;
}

export function pendingBalanceOpenAmountToJSON(
  pendingBalanceOpenAmount: PendingBalanceOpenAmount,
): string {
  return JSON.stringify(
    PendingBalanceOpenAmount$outboundSchema.parse(pendingBalanceOpenAmount),
  );
}

export function pendingBalanceOpenAmountFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceOpenAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceOpenAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceOpenAmount' from JSON`,
  );
}

/** @internal */
export const PendingBalanceOpenSubTotal1$inboundSchema: z.ZodType<
  PendingBalanceOpenSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PendingBalanceOpenSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceOpenSubTotal1$outboundSchema: z.ZodType<
  PendingBalanceOpenSubTotal1$Outbound,
  z.ZodTypeDef,
  PendingBalanceOpenSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceOpenSubTotal1$ {
  /** @deprecated use `PendingBalanceOpenSubTotal1$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceOpenSubTotal1$inboundSchema;
  /** @deprecated use `PendingBalanceOpenSubTotal1$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceOpenSubTotal1$outboundSchema;
  /** @deprecated use `PendingBalanceOpenSubTotal1$Outbound` instead. */
  export type Outbound = PendingBalanceOpenSubTotal1$Outbound;
}

export function pendingBalanceOpenSubTotal1ToJSON(
  pendingBalanceOpenSubTotal1: PendingBalanceOpenSubTotal1,
): string {
  return JSON.stringify(
    PendingBalanceOpenSubTotal1$outboundSchema.parse(
      pendingBalanceOpenSubTotal1,
    ),
  );
}

export function pendingBalanceOpenSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceOpenSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceOpenSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceOpenSubTotal1' from JSON`,
  );
}

/** @internal */
export const PendingBalanceOpenSubtotal2$inboundSchema: z.ZodType<
  PendingBalanceOpenSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PendingBalanceOpenSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PendingBalanceOpenSubtotal2$Outbound = {
  "sub-totals"?: Array<PendingBalanceOpenSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceOpenSubtotal2$outboundSchema: z.ZodType<
  PendingBalanceOpenSubtotal2$Outbound,
  z.ZodTypeDef,
  PendingBalanceOpenSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceOpenSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceOpenSubtotal2$ {
  /** @deprecated use `PendingBalanceOpenSubtotal2$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceOpenSubtotal2$inboundSchema;
  /** @deprecated use `PendingBalanceOpenSubtotal2$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceOpenSubtotal2$outboundSchema;
  /** @deprecated use `PendingBalanceOpenSubtotal2$Outbound` instead. */
  export type Outbound = PendingBalanceOpenSubtotal2$Outbound;
}

export function pendingBalanceOpenSubtotal2ToJSON(
  pendingBalanceOpenSubtotal2: PendingBalanceOpenSubtotal2,
): string {
  return JSON.stringify(
    PendingBalanceOpenSubtotal2$outboundSchema.parse(
      pendingBalanceOpenSubtotal2,
    ),
  );
}

export function pendingBalanceOpenSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceOpenSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceOpenSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceOpenSubtotal2' from JSON`,
  );
}

/** @internal */
export const PendingBalanceOpen$inboundSchema: z.ZodType<
  PendingBalanceOpen,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PendingBalanceOpenAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceOpenSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PendingBalanceOpen$Outbound = {
  amount?: PendingBalanceOpenAmount$Outbound | undefined;
  subtotals?: Array<PendingBalanceOpenSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const PendingBalanceOpen$outboundSchema: z.ZodType<
  PendingBalanceOpen$Outbound,
  z.ZodTypeDef,
  PendingBalanceOpen
> = z.object({
  amount: z.lazy(() => PendingBalanceOpenAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceOpenSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceOpen$ {
  /** @deprecated use `PendingBalanceOpen$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceOpen$inboundSchema;
  /** @deprecated use `PendingBalanceOpen$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceOpen$outboundSchema;
  /** @deprecated use `PendingBalanceOpen$Outbound` instead. */
  export type Outbound = PendingBalanceOpen$Outbound;
}

export function pendingBalanceOpenToJSON(
  pendingBalanceOpen: PendingBalanceOpen,
): string {
  return JSON.stringify(
    PendingBalanceOpen$outboundSchema.parse(pendingBalanceOpen),
  );
}

export function pendingBalanceOpenFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceOpen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceOpen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceOpen' from JSON`,
  );
}

/** @internal */
export const PendingBalanceCloseAmount$inboundSchema: z.ZodType<
  PendingBalanceCloseAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PendingBalanceCloseAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PendingBalanceCloseAmount$outboundSchema: z.ZodType<
  PendingBalanceCloseAmount$Outbound,
  z.ZodTypeDef,
  PendingBalanceCloseAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceCloseAmount$ {
  /** @deprecated use `PendingBalanceCloseAmount$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceCloseAmount$inboundSchema;
  /** @deprecated use `PendingBalanceCloseAmount$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceCloseAmount$outboundSchema;
  /** @deprecated use `PendingBalanceCloseAmount$Outbound` instead. */
  export type Outbound = PendingBalanceCloseAmount$Outbound;
}

export function pendingBalanceCloseAmountToJSON(
  pendingBalanceCloseAmount: PendingBalanceCloseAmount,
): string {
  return JSON.stringify(
    PendingBalanceCloseAmount$outboundSchema.parse(pendingBalanceCloseAmount),
  );
}

export function pendingBalanceCloseAmountFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceCloseAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceCloseAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceCloseAmount' from JSON`,
  );
}

/** @internal */
export const PendingBalanceCloseSubTotal1$inboundSchema: z.ZodType<
  PendingBalanceCloseSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PendingBalanceCloseSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceCloseSubTotal1$outboundSchema: z.ZodType<
  PendingBalanceCloseSubTotal1$Outbound,
  z.ZodTypeDef,
  PendingBalanceCloseSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceCloseSubTotal1$ {
  /** @deprecated use `PendingBalanceCloseSubTotal1$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceCloseSubTotal1$inboundSchema;
  /** @deprecated use `PendingBalanceCloseSubTotal1$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceCloseSubTotal1$outboundSchema;
  /** @deprecated use `PendingBalanceCloseSubTotal1$Outbound` instead. */
  export type Outbound = PendingBalanceCloseSubTotal1$Outbound;
}

export function pendingBalanceCloseSubTotal1ToJSON(
  pendingBalanceCloseSubTotal1: PendingBalanceCloseSubTotal1,
): string {
  return JSON.stringify(
    PendingBalanceCloseSubTotal1$outboundSchema.parse(
      pendingBalanceCloseSubTotal1,
    ),
  );
}

export function pendingBalanceCloseSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceCloseSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceCloseSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceCloseSubTotal1' from JSON`,
  );
}

/** @internal */
export const PendingBalanceCloseSubtotal2$inboundSchema: z.ZodType<
  PendingBalanceCloseSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PendingBalanceCloseSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PendingBalanceCloseSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<PendingBalanceCloseSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceCloseSubtotal2$outboundSchema: z.ZodType<
  PendingBalanceCloseSubtotal2$Outbound,
  z.ZodTypeDef,
  PendingBalanceCloseSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceCloseSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceCloseSubtotal2$ {
  /** @deprecated use `PendingBalanceCloseSubtotal2$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceCloseSubtotal2$inboundSchema;
  /** @deprecated use `PendingBalanceCloseSubtotal2$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceCloseSubtotal2$outboundSchema;
  /** @deprecated use `PendingBalanceCloseSubtotal2$Outbound` instead. */
  export type Outbound = PendingBalanceCloseSubtotal2$Outbound;
}

export function pendingBalanceCloseSubtotal2ToJSON(
  pendingBalanceCloseSubtotal2: PendingBalanceCloseSubtotal2,
): string {
  return JSON.stringify(
    PendingBalanceCloseSubtotal2$outboundSchema.parse(
      pendingBalanceCloseSubtotal2,
    ),
  );
}

export function pendingBalanceCloseSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceCloseSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceCloseSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceCloseSubtotal2' from JSON`,
  );
}

/** @internal */
export const PendingBalanceClose$inboundSchema: z.ZodType<
  PendingBalanceClose,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PendingBalanceCloseAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceCloseSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PendingBalanceClose$Outbound = {
  amount?: PendingBalanceCloseAmount$Outbound | undefined;
  subtotals?: Array<PendingBalanceCloseSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const PendingBalanceClose$outboundSchema: z.ZodType<
  PendingBalanceClose$Outbound,
  z.ZodTypeDef,
  PendingBalanceClose
> = z.object({
  amount: z.lazy(() => PendingBalanceCloseAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalanceCloseSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceClose$ {
  /** @deprecated use `PendingBalanceClose$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceClose$inboundSchema;
  /** @deprecated use `PendingBalanceClose$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceClose$outboundSchema;
  /** @deprecated use `PendingBalanceClose$Outbound` instead. */
  export type Outbound = PendingBalanceClose$Outbound;
}

export function pendingBalanceCloseToJSON(
  pendingBalanceClose: PendingBalanceClose,
): string {
  return JSON.stringify(
    PendingBalanceClose$outboundSchema.parse(pendingBalanceClose),
  );
}

export function pendingBalanceCloseFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceClose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceClose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceClose' from JSON`,
  );
}

/** @internal */
export const PendingBalancePendingAmount$inboundSchema: z.ZodType<
  PendingBalancePendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PendingBalancePendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PendingBalancePendingAmount$outboundSchema: z.ZodType<
  PendingBalancePendingAmount$Outbound,
  z.ZodTypeDef,
  PendingBalancePendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalancePendingAmount$ {
  /** @deprecated use `PendingBalancePendingAmount$inboundSchema` instead. */
  export const inboundSchema = PendingBalancePendingAmount$inboundSchema;
  /** @deprecated use `PendingBalancePendingAmount$outboundSchema` instead. */
  export const outboundSchema = PendingBalancePendingAmount$outboundSchema;
  /** @deprecated use `PendingBalancePendingAmount$Outbound` instead. */
  export type Outbound = PendingBalancePendingAmount$Outbound;
}

export function pendingBalancePendingAmountToJSON(
  pendingBalancePendingAmount: PendingBalancePendingAmount,
): string {
  return JSON.stringify(
    PendingBalancePendingAmount$outboundSchema.parse(
      pendingBalancePendingAmount,
    ),
  );
}

export function pendingBalancePendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalancePendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalancePendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalancePendingAmount' from JSON`,
  );
}

/** @internal */
export const PendingBalancePendingSubTotal1$inboundSchema: z.ZodType<
  PendingBalancePendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PendingBalancePendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalancePendingSubTotal1$outboundSchema: z.ZodType<
  PendingBalancePendingSubTotal1$Outbound,
  z.ZodTypeDef,
  PendingBalancePendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalancePendingSubTotal1$ {
  /** @deprecated use `PendingBalancePendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = PendingBalancePendingSubTotal1$inboundSchema;
  /** @deprecated use `PendingBalancePendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = PendingBalancePendingSubTotal1$outboundSchema;
  /** @deprecated use `PendingBalancePendingSubTotal1$Outbound` instead. */
  export type Outbound = PendingBalancePendingSubTotal1$Outbound;
}

export function pendingBalancePendingSubTotal1ToJSON(
  pendingBalancePendingSubTotal1: PendingBalancePendingSubTotal1,
): string {
  return JSON.stringify(
    PendingBalancePendingSubTotal1$outboundSchema.parse(
      pendingBalancePendingSubTotal1,
    ),
  );
}

export function pendingBalancePendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalancePendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalancePendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalancePendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const PendingBalancePendingSubtotal2$inboundSchema: z.ZodType<
  PendingBalancePendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PendingBalancePendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PendingBalancePendingSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<PendingBalancePendingSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalancePendingSubtotal2$outboundSchema: z.ZodType<
  PendingBalancePendingSubtotal2$Outbound,
  z.ZodTypeDef,
  PendingBalancePendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PendingBalancePendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalancePendingSubtotal2$ {
  /** @deprecated use `PendingBalancePendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = PendingBalancePendingSubtotal2$inboundSchema;
  /** @deprecated use `PendingBalancePendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = PendingBalancePendingSubtotal2$outboundSchema;
  /** @deprecated use `PendingBalancePendingSubtotal2$Outbound` instead. */
  export type Outbound = PendingBalancePendingSubtotal2$Outbound;
}

export function pendingBalancePendingSubtotal2ToJSON(
  pendingBalancePendingSubtotal2: PendingBalancePendingSubtotal2,
): string {
  return JSON.stringify(
    PendingBalancePendingSubtotal2$outboundSchema.parse(
      pendingBalancePendingSubtotal2,
    ),
  );
}

export function pendingBalancePendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PendingBalancePendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalancePendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalancePendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const PendingBalancePending$inboundSchema: z.ZodType<
  PendingBalancePending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PendingBalancePendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalancePendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PendingBalancePending$Outbound = {
  amount?: PendingBalancePendingAmount$Outbound | undefined;
  subtotals?: Array<PendingBalancePendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const PendingBalancePending$outboundSchema: z.ZodType<
  PendingBalancePending$Outbound,
  z.ZodTypeDef,
  PendingBalancePending
> = z.object({
  amount: z.lazy(() => PendingBalancePendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PendingBalancePendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalancePending$ {
  /** @deprecated use `PendingBalancePending$inboundSchema` instead. */
  export const inboundSchema = PendingBalancePending$inboundSchema;
  /** @deprecated use `PendingBalancePending$outboundSchema` instead. */
  export const outboundSchema = PendingBalancePending$outboundSchema;
  /** @deprecated use `PendingBalancePending$Outbound` instead. */
  export type Outbound = PendingBalancePending$Outbound;
}

export function pendingBalancePendingToJSON(
  pendingBalancePending: PendingBalancePending,
): string {
  return JSON.stringify(
    PendingBalancePending$outboundSchema.parse(pendingBalancePending),
  );
}

export function pendingBalancePendingFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalancePending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalancePending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalancePending' from JSON`,
  );
}

/** @internal */
export const PendingBalanceMovedToAvailableAmount$inboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PendingBalanceMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PendingBalanceMovedToAvailableAmount$outboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  PendingBalanceMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceMovedToAvailableAmount$ {
  /** @deprecated use `PendingBalanceMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    PendingBalanceMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    PendingBalanceMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = PendingBalanceMovedToAvailableAmount$Outbound;
}

export function pendingBalanceMovedToAvailableAmountToJSON(
  pendingBalanceMovedToAvailableAmount: PendingBalanceMovedToAvailableAmount,
): string {
  return JSON.stringify(
    PendingBalanceMovedToAvailableAmount$outboundSchema.parse(
      pendingBalanceMovedToAvailableAmount,
    ),
  );
}

export function pendingBalanceMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PendingBalanceMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const PendingBalanceMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PendingBalanceMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  PendingBalanceMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceMovedToAvailableSubTotal1$ {
  /** @deprecated use `PendingBalanceMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    PendingBalanceMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    PendingBalanceMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = PendingBalanceMovedToAvailableSubTotal1$Outbound;
}

export function pendingBalanceMovedToAvailableSubTotal1ToJSON(
  pendingBalanceMovedToAvailableSubTotal1:
    PendingBalanceMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    PendingBalanceMovedToAvailableSubTotal1$outboundSchema.parse(
      pendingBalanceMovedToAvailableSubTotal1,
    ),
  );
}

export function pendingBalanceMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  PendingBalanceMovedToAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PendingBalanceMovedToAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PendingBalanceMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const PendingBalanceMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(
      z.lazy(() => PendingBalanceMovedToAvailableSubTotal1$inboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PendingBalanceMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<PendingBalanceMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PendingBalanceMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  PendingBalanceMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  PendingBalanceMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(
      z.lazy(() => PendingBalanceMovedToAvailableSubTotal1$outboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceMovedToAvailableSubtotal2$ {
  /** @deprecated use `PendingBalanceMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    PendingBalanceMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    PendingBalanceMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = PendingBalanceMovedToAvailableSubtotal2$Outbound;
}

export function pendingBalanceMovedToAvailableSubtotal2ToJSON(
  pendingBalanceMovedToAvailableSubtotal2:
    PendingBalanceMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    PendingBalanceMovedToAvailableSubtotal2$outboundSchema.parse(
      pendingBalanceMovedToAvailableSubtotal2,
    ),
  );
}

export function pendingBalanceMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  PendingBalanceMovedToAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PendingBalanceMovedToAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PendingBalanceMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const PendingBalanceMovedToAvailable$inboundSchema: z.ZodType<
  PendingBalanceMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PendingBalanceMovedToAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => PendingBalanceMovedToAvailableSubtotal2$inboundSchema),
    ),
  ).optional(),
});

/** @internal */
export type PendingBalanceMovedToAvailable$Outbound = {
  amount?: PendingBalanceMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<PendingBalanceMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const PendingBalanceMovedToAvailable$outboundSchema: z.ZodType<
  PendingBalanceMovedToAvailable$Outbound,
  z.ZodTypeDef,
  PendingBalanceMovedToAvailable
> = z.object({
  amount: z.lazy(() => PendingBalanceMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => PendingBalanceMovedToAvailableSubtotal2$outboundSchema),
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalanceMovedToAvailable$ {
  /** @deprecated use `PendingBalanceMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = PendingBalanceMovedToAvailable$inboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = PendingBalanceMovedToAvailable$outboundSchema;
  /** @deprecated use `PendingBalanceMovedToAvailable$Outbound` instead. */
  export type Outbound = PendingBalanceMovedToAvailable$Outbound;
}

export function pendingBalanceMovedToAvailableToJSON(
  pendingBalanceMovedToAvailable: PendingBalanceMovedToAvailable,
): string {
  return JSON.stringify(
    PendingBalanceMovedToAvailable$outboundSchema.parse(
      pendingBalanceMovedToAvailable,
    ),
  );
}

export function pendingBalanceMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalanceMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalanceMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalanceMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const PendingBalance$inboundSchema: z.ZodType<
  PendingBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: z.lazy(() => PendingBalanceOpen$inboundSchema).optional(),
  close: z.lazy(() => PendingBalanceClose$inboundSchema).optional(),
  pending: z.lazy(() => PendingBalancePending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => PendingBalanceMovedToAvailable$inboundSchema)
    .optional(),
});

/** @internal */
export type PendingBalance$Outbound = {
  open?: PendingBalanceOpen$Outbound | undefined;
  close?: PendingBalanceClose$Outbound | undefined;
  pending?: PendingBalancePending$Outbound | undefined;
  movedToAvailable?: PendingBalanceMovedToAvailable$Outbound | undefined;
};

/** @internal */
export const PendingBalance$outboundSchema: z.ZodType<
  PendingBalance$Outbound,
  z.ZodTypeDef,
  PendingBalance
> = z.object({
  open: z.lazy(() => PendingBalanceOpen$outboundSchema).optional(),
  close: z.lazy(() => PendingBalanceClose$outboundSchema).optional(),
  pending: z.lazy(() => PendingBalancePending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => PendingBalanceMovedToAvailable$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingBalance$ {
  /** @deprecated use `PendingBalance$inboundSchema` instead. */
  export const inboundSchema = PendingBalance$inboundSchema;
  /** @deprecated use `PendingBalance$outboundSchema` instead. */
  export const outboundSchema = PendingBalance$outboundSchema;
  /** @deprecated use `PendingBalance$Outbound` instead. */
  export type Outbound = PendingBalance$Outbound;
}

export function pendingBalanceToJSON(pendingBalance: PendingBalance): string {
  return JSON.stringify(PendingBalance$outboundSchema.parse(pendingBalance));
}

export function pendingBalanceFromJSON(
  jsonString: string,
): SafeParseResult<PendingBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingBalance' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceOpenAmount$inboundSchema: z.ZodType<
  AvailableBalanceOpenAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type AvailableBalanceOpenAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const AvailableBalanceOpenAmount$outboundSchema: z.ZodType<
  AvailableBalanceOpenAmount$Outbound,
  z.ZodTypeDef,
  AvailableBalanceOpenAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceOpenAmount$ {
  /** @deprecated use `AvailableBalanceOpenAmount$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceOpenAmount$inboundSchema;
  /** @deprecated use `AvailableBalanceOpenAmount$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceOpenAmount$outboundSchema;
  /** @deprecated use `AvailableBalanceOpenAmount$Outbound` instead. */
  export type Outbound = AvailableBalanceOpenAmount$Outbound;
}

export function availableBalanceOpenAmountToJSON(
  availableBalanceOpenAmount: AvailableBalanceOpenAmount,
): string {
  return JSON.stringify(
    AvailableBalanceOpenAmount$outboundSchema.parse(availableBalanceOpenAmount),
  );
}

export function availableBalanceOpenAmountFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceOpenAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceOpenAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceOpenAmount' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceOpenSubTotal1$inboundSchema: z.ZodType<
  AvailableBalanceOpenSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type AvailableBalanceOpenSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceOpenSubTotal1$outboundSchema: z.ZodType<
  AvailableBalanceOpenSubTotal1$Outbound,
  z.ZodTypeDef,
  AvailableBalanceOpenSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceOpenSubTotal1$ {
  /** @deprecated use `AvailableBalanceOpenSubTotal1$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceOpenSubTotal1$inboundSchema;
  /** @deprecated use `AvailableBalanceOpenSubTotal1$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceOpenSubTotal1$outboundSchema;
  /** @deprecated use `AvailableBalanceOpenSubTotal1$Outbound` instead. */
  export type Outbound = AvailableBalanceOpenSubTotal1$Outbound;
}

export function availableBalanceOpenSubTotal1ToJSON(
  availableBalanceOpenSubTotal1: AvailableBalanceOpenSubTotal1,
): string {
  return JSON.stringify(
    AvailableBalanceOpenSubTotal1$outboundSchema.parse(
      availableBalanceOpenSubTotal1,
    ),
  );
}

export function availableBalanceOpenSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceOpenSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceOpenSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceOpenSubTotal1' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceOpenSubtotal2$inboundSchema: z.ZodType<
  AvailableBalanceOpenSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => AvailableBalanceOpenSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type AvailableBalanceOpenSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<AvailableBalanceOpenSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceOpenSubtotal2$outboundSchema: z.ZodType<
  AvailableBalanceOpenSubtotal2$Outbound,
  z.ZodTypeDef,
  AvailableBalanceOpenSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceOpenSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceOpenSubtotal2$ {
  /** @deprecated use `AvailableBalanceOpenSubtotal2$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceOpenSubtotal2$inboundSchema;
  /** @deprecated use `AvailableBalanceOpenSubtotal2$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceOpenSubtotal2$outboundSchema;
  /** @deprecated use `AvailableBalanceOpenSubtotal2$Outbound` instead. */
  export type Outbound = AvailableBalanceOpenSubtotal2$Outbound;
}

export function availableBalanceOpenSubtotal2ToJSON(
  availableBalanceOpenSubtotal2: AvailableBalanceOpenSubtotal2,
): string {
  return JSON.stringify(
    AvailableBalanceOpenSubtotal2$outboundSchema.parse(
      availableBalanceOpenSubtotal2,
    ),
  );
}

export function availableBalanceOpenSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceOpenSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceOpenSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceOpenSubtotal2' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceOpen$inboundSchema: z.ZodType<
  AvailableBalanceOpen,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => AvailableBalanceOpenAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceOpenSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type AvailableBalanceOpen$Outbound = {
  amount?: AvailableBalanceOpenAmount$Outbound | undefined;
  subtotals?: Array<AvailableBalanceOpenSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const AvailableBalanceOpen$outboundSchema: z.ZodType<
  AvailableBalanceOpen$Outbound,
  z.ZodTypeDef,
  AvailableBalanceOpen
> = z.object({
  amount: z.lazy(() => AvailableBalanceOpenAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceOpenSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceOpen$ {
  /** @deprecated use `AvailableBalanceOpen$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceOpen$inboundSchema;
  /** @deprecated use `AvailableBalanceOpen$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceOpen$outboundSchema;
  /** @deprecated use `AvailableBalanceOpen$Outbound` instead. */
  export type Outbound = AvailableBalanceOpen$Outbound;
}

export function availableBalanceOpenToJSON(
  availableBalanceOpen: AvailableBalanceOpen,
): string {
  return JSON.stringify(
    AvailableBalanceOpen$outboundSchema.parse(availableBalanceOpen),
  );
}

export function availableBalanceOpenFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceOpen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceOpen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceOpen' from JSON`,
  );
}

/** @internal */
export const MovedFromPendingAmount$inboundSchema: z.ZodType<
  MovedFromPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type MovedFromPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const MovedFromPendingAmount$outboundSchema: z.ZodType<
  MovedFromPendingAmount$Outbound,
  z.ZodTypeDef,
  MovedFromPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MovedFromPendingAmount$ {
  /** @deprecated use `MovedFromPendingAmount$inboundSchema` instead. */
  export const inboundSchema = MovedFromPendingAmount$inboundSchema;
  /** @deprecated use `MovedFromPendingAmount$outboundSchema` instead. */
  export const outboundSchema = MovedFromPendingAmount$outboundSchema;
  /** @deprecated use `MovedFromPendingAmount$Outbound` instead. */
  export type Outbound = MovedFromPendingAmount$Outbound;
}

export function movedFromPendingAmountToJSON(
  movedFromPendingAmount: MovedFromPendingAmount,
): string {
  return JSON.stringify(
    MovedFromPendingAmount$outboundSchema.parse(movedFromPendingAmount),
  );
}

export function movedFromPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<MovedFromPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MovedFromPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MovedFromPendingAmount' from JSON`,
  );
}

/** @internal */
export const MovedFromPendingSubTotal1$inboundSchema: z.ZodType<
  MovedFromPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type MovedFromPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const MovedFromPendingSubTotal1$outboundSchema: z.ZodType<
  MovedFromPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  MovedFromPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MovedFromPendingSubTotal1$ {
  /** @deprecated use `MovedFromPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = MovedFromPendingSubTotal1$inboundSchema;
  /** @deprecated use `MovedFromPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = MovedFromPendingSubTotal1$outboundSchema;
  /** @deprecated use `MovedFromPendingSubTotal1$Outbound` instead. */
  export type Outbound = MovedFromPendingSubTotal1$Outbound;
}

export function movedFromPendingSubTotal1ToJSON(
  movedFromPendingSubTotal1: MovedFromPendingSubTotal1,
): string {
  return JSON.stringify(
    MovedFromPendingSubTotal1$outboundSchema.parse(movedFromPendingSubTotal1),
  );
}

export function movedFromPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<MovedFromPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MovedFromPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MovedFromPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const MovedFromPendingSubtotal2$inboundSchema: z.ZodType<
  MovedFromPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => MovedFromPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type MovedFromPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<MovedFromPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const MovedFromPendingSubtotal2$outboundSchema: z.ZodType<
  MovedFromPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  MovedFromPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => MovedFromPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MovedFromPendingSubtotal2$ {
  /** @deprecated use `MovedFromPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = MovedFromPendingSubtotal2$inboundSchema;
  /** @deprecated use `MovedFromPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = MovedFromPendingSubtotal2$outboundSchema;
  /** @deprecated use `MovedFromPendingSubtotal2$Outbound` instead. */
  export type Outbound = MovedFromPendingSubtotal2$Outbound;
}

export function movedFromPendingSubtotal2ToJSON(
  movedFromPendingSubtotal2: MovedFromPendingSubtotal2,
): string {
  return JSON.stringify(
    MovedFromPendingSubtotal2$outboundSchema.parse(movedFromPendingSubtotal2),
  );
}

export function movedFromPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<MovedFromPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MovedFromPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MovedFromPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const MovedFromPending$inboundSchema: z.ZodType<
  MovedFromPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => MovedFromPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => MovedFromPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type MovedFromPending$Outbound = {
  amount?: MovedFromPendingAmount$Outbound | undefined;
  subtotals?: Array<MovedFromPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const MovedFromPending$outboundSchema: z.ZodType<
  MovedFromPending$Outbound,
  z.ZodTypeDef,
  MovedFromPending
> = z.object({
  amount: z.lazy(() => MovedFromPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => MovedFromPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MovedFromPending$ {
  /** @deprecated use `MovedFromPending$inboundSchema` instead. */
  export const inboundSchema = MovedFromPending$inboundSchema;
  /** @deprecated use `MovedFromPending$outboundSchema` instead. */
  export const outboundSchema = MovedFromPending$outboundSchema;
  /** @deprecated use `MovedFromPending$Outbound` instead. */
  export type Outbound = MovedFromPending$Outbound;
}

export function movedFromPendingToJSON(
  movedFromPending: MovedFromPending,
): string {
  return JSON.stringify(
    MovedFromPending$outboundSchema.parse(movedFromPending),
  );
}

export function movedFromPendingFromJSON(
  jsonString: string,
): SafeParseResult<MovedFromPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MovedFromPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MovedFromPending' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceImmediatelyAvailableAmount$inboundSchema:
  z.ZodType<AvailableBalanceImmediatelyAvailableAmount, z.ZodTypeDef, unknown> =
    z.object({
      currency: z.string(),
      value: z.string(),
    });

/** @internal */
export type AvailableBalanceImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const AvailableBalanceImmediatelyAvailableAmount$outboundSchema:
  z.ZodType<
    AvailableBalanceImmediatelyAvailableAmount$Outbound,
    z.ZodTypeDef,
    AvailableBalanceImmediatelyAvailableAmount
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceImmediatelyAvailableAmount$ {
  /** @deprecated use `AvailableBalanceImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    AvailableBalanceImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    AvailableBalanceImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = AvailableBalanceImmediatelyAvailableAmount$Outbound;
}

export function availableBalanceImmediatelyAvailableAmountToJSON(
  availableBalanceImmediatelyAvailableAmount:
    AvailableBalanceImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    AvailableBalanceImmediatelyAvailableAmount$outboundSchema.parse(
      availableBalanceImmediatelyAvailableAmount,
    ),
  );
}

export function availableBalanceImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  AvailableBalanceImmediatelyAvailableAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AvailableBalanceImmediatelyAvailableAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AvailableBalanceImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceImmediatelyAvailableSubTotal1$inboundSchema:
  z.ZodType<
    AvailableBalanceImmediatelyAvailableSubTotal1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  });

/** @internal */
export type AvailableBalanceImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceImmediatelyAvailableSubTotal1$outboundSchema:
  z.ZodType<
    AvailableBalanceImmediatelyAvailableSubTotal1$Outbound,
    z.ZodTypeDef,
    AvailableBalanceImmediatelyAvailableSubTotal1
  > = z.object({
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    AvailableBalanceImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    AvailableBalanceImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = AvailableBalanceImmediatelyAvailableSubTotal1$Outbound;
}

export function availableBalanceImmediatelyAvailableSubTotal1ToJSON(
  availableBalanceImmediatelyAvailableSubTotal1:
    AvailableBalanceImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    AvailableBalanceImmediatelyAvailableSubTotal1$outboundSchema.parse(
      availableBalanceImmediatelyAvailableSubTotal1,
    ),
  );
}

export function availableBalanceImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  AvailableBalanceImmediatelyAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AvailableBalanceImmediatelyAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AvailableBalanceImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceImmediatelyAvailableSubtotal2$inboundSchema:
  z.ZodType<
    AvailableBalanceImmediatelyAvailableSubtotal2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    "sub-totals": z.nullable(
      z.array(z.lazy(() =>
        AvailableBalanceImmediatelyAvailableSubTotal1$inboundSchema
      )),
    ).optional(),
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "sub-totals": "subTotals",
    });
  });

/** @internal */
export type AvailableBalanceImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<AvailableBalanceImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceImmediatelyAvailableSubtotal2$outboundSchema:
  z.ZodType<
    AvailableBalanceImmediatelyAvailableSubtotal2$Outbound,
    z.ZodTypeDef,
    AvailableBalanceImmediatelyAvailableSubtotal2
  > = z.object({
    subTotals: z.nullable(
      z.array(z.lazy(() =>
        AvailableBalanceImmediatelyAvailableSubTotal1$outboundSchema
      )),
    ).optional(),
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      subTotals: "sub-totals",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    AvailableBalanceImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    AvailableBalanceImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = AvailableBalanceImmediatelyAvailableSubtotal2$Outbound;
}

export function availableBalanceImmediatelyAvailableSubtotal2ToJSON(
  availableBalanceImmediatelyAvailableSubtotal2:
    AvailableBalanceImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    AvailableBalanceImmediatelyAvailableSubtotal2$outboundSchema.parse(
      availableBalanceImmediatelyAvailableSubtotal2,
    ),
  );
}

export function availableBalanceImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  AvailableBalanceImmediatelyAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AvailableBalanceImmediatelyAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AvailableBalanceImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceImmediatelyAvailable$inboundSchema: z.ZodType<
  AvailableBalanceImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => AvailableBalanceImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() =>
      AvailableBalanceImmediatelyAvailableSubtotal2$inboundSchema
    )),
  ).optional(),
});

/** @internal */
export type AvailableBalanceImmediatelyAvailable$Outbound = {
  amount?: AvailableBalanceImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<AvailableBalanceImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const AvailableBalanceImmediatelyAvailable$outboundSchema: z.ZodType<
  AvailableBalanceImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  AvailableBalanceImmediatelyAvailable
> = z.object({
  amount: z.lazy(() =>
    AvailableBalanceImmediatelyAvailableAmount$outboundSchema
  ).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() =>
      AvailableBalanceImmediatelyAvailableSubtotal2$outboundSchema
    )),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceImmediatelyAvailable$ {
  /** @deprecated use `AvailableBalanceImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema =
    AvailableBalanceImmediatelyAvailable$inboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema =
    AvailableBalanceImmediatelyAvailable$outboundSchema;
  /** @deprecated use `AvailableBalanceImmediatelyAvailable$Outbound` instead. */
  export type Outbound = AvailableBalanceImmediatelyAvailable$Outbound;
}

export function availableBalanceImmediatelyAvailableToJSON(
  availableBalanceImmediatelyAvailable: AvailableBalanceImmediatelyAvailable,
): string {
  return JSON.stringify(
    AvailableBalanceImmediatelyAvailable$outboundSchema.parse(
      availableBalanceImmediatelyAvailable,
    ),
  );
}

export function availableBalanceImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AvailableBalanceImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceCloseAmount$inboundSchema: z.ZodType<
  AvailableBalanceCloseAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type AvailableBalanceCloseAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const AvailableBalanceCloseAmount$outboundSchema: z.ZodType<
  AvailableBalanceCloseAmount$Outbound,
  z.ZodTypeDef,
  AvailableBalanceCloseAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceCloseAmount$ {
  /** @deprecated use `AvailableBalanceCloseAmount$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceCloseAmount$inboundSchema;
  /** @deprecated use `AvailableBalanceCloseAmount$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceCloseAmount$outboundSchema;
  /** @deprecated use `AvailableBalanceCloseAmount$Outbound` instead. */
  export type Outbound = AvailableBalanceCloseAmount$Outbound;
}

export function availableBalanceCloseAmountToJSON(
  availableBalanceCloseAmount: AvailableBalanceCloseAmount,
): string {
  return JSON.stringify(
    AvailableBalanceCloseAmount$outboundSchema.parse(
      availableBalanceCloseAmount,
    ),
  );
}

export function availableBalanceCloseAmountFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceCloseAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceCloseAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceCloseAmount' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceCloseSubTotal1$inboundSchema: z.ZodType<
  AvailableBalanceCloseSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type AvailableBalanceCloseSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceCloseSubTotal1$outboundSchema: z.ZodType<
  AvailableBalanceCloseSubTotal1$Outbound,
  z.ZodTypeDef,
  AvailableBalanceCloseSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceCloseSubTotal1$ {
  /** @deprecated use `AvailableBalanceCloseSubTotal1$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceCloseSubTotal1$inboundSchema;
  /** @deprecated use `AvailableBalanceCloseSubTotal1$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceCloseSubTotal1$outboundSchema;
  /** @deprecated use `AvailableBalanceCloseSubTotal1$Outbound` instead. */
  export type Outbound = AvailableBalanceCloseSubTotal1$Outbound;
}

export function availableBalanceCloseSubTotal1ToJSON(
  availableBalanceCloseSubTotal1: AvailableBalanceCloseSubTotal1,
): string {
  return JSON.stringify(
    AvailableBalanceCloseSubTotal1$outboundSchema.parse(
      availableBalanceCloseSubTotal1,
    ),
  );
}

export function availableBalanceCloseSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceCloseSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceCloseSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceCloseSubTotal1' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceCloseSubtotal2$inboundSchema: z.ZodType<
  AvailableBalanceCloseSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => AvailableBalanceCloseSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type AvailableBalanceCloseSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<AvailableBalanceCloseSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const AvailableBalanceCloseSubtotal2$outboundSchema: z.ZodType<
  AvailableBalanceCloseSubtotal2$Outbound,
  z.ZodTypeDef,
  AvailableBalanceCloseSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceCloseSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceCloseSubtotal2$ {
  /** @deprecated use `AvailableBalanceCloseSubtotal2$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceCloseSubtotal2$inboundSchema;
  /** @deprecated use `AvailableBalanceCloseSubtotal2$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceCloseSubtotal2$outboundSchema;
  /** @deprecated use `AvailableBalanceCloseSubtotal2$Outbound` instead. */
  export type Outbound = AvailableBalanceCloseSubtotal2$Outbound;
}

export function availableBalanceCloseSubtotal2ToJSON(
  availableBalanceCloseSubtotal2: AvailableBalanceCloseSubtotal2,
): string {
  return JSON.stringify(
    AvailableBalanceCloseSubtotal2$outboundSchema.parse(
      availableBalanceCloseSubtotal2,
    ),
  );
}

export function availableBalanceCloseSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceCloseSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceCloseSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceCloseSubtotal2' from JSON`,
  );
}

/** @internal */
export const AvailableBalanceClose$inboundSchema: z.ZodType<
  AvailableBalanceClose,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => AvailableBalanceCloseAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceCloseSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type AvailableBalanceClose$Outbound = {
  amount?: AvailableBalanceCloseAmount$Outbound | undefined;
  subtotals?: Array<AvailableBalanceCloseSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const AvailableBalanceClose$outboundSchema: z.ZodType<
  AvailableBalanceClose$Outbound,
  z.ZodTypeDef,
  AvailableBalanceClose
> = z.object({
  amount: z.lazy(() => AvailableBalanceCloseAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => AvailableBalanceCloseSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalanceClose$ {
  /** @deprecated use `AvailableBalanceClose$inboundSchema` instead. */
  export const inboundSchema = AvailableBalanceClose$inboundSchema;
  /** @deprecated use `AvailableBalanceClose$outboundSchema` instead. */
  export const outboundSchema = AvailableBalanceClose$outboundSchema;
  /** @deprecated use `AvailableBalanceClose$Outbound` instead. */
  export type Outbound = AvailableBalanceClose$Outbound;
}

export function availableBalanceCloseToJSON(
  availableBalanceClose: AvailableBalanceClose,
): string {
  return JSON.stringify(
    AvailableBalanceClose$outboundSchema.parse(availableBalanceClose),
  );
}

export function availableBalanceCloseFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalanceClose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalanceClose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalanceClose' from JSON`,
  );
}

/** @internal */
export const AvailableBalance$inboundSchema: z.ZodType<
  AvailableBalance,
  z.ZodTypeDef,
  unknown
> = z.object({
  open: z.lazy(() => AvailableBalanceOpen$inboundSchema).optional(),
  movedFromPending: z.lazy(() => MovedFromPending$inboundSchema).optional(),
  immediatelyAvailable: z.lazy(() =>
    AvailableBalanceImmediatelyAvailable$inboundSchema
  ).optional(),
  close: z.lazy(() => AvailableBalanceClose$inboundSchema).optional(),
});

/** @internal */
export type AvailableBalance$Outbound = {
  open?: AvailableBalanceOpen$Outbound | undefined;
  movedFromPending?: MovedFromPending$Outbound | undefined;
  immediatelyAvailable?:
    | AvailableBalanceImmediatelyAvailable$Outbound
    | undefined;
  close?: AvailableBalanceClose$Outbound | undefined;
};

/** @internal */
export const AvailableBalance$outboundSchema: z.ZodType<
  AvailableBalance$Outbound,
  z.ZodTypeDef,
  AvailableBalance
> = z.object({
  open: z.lazy(() => AvailableBalanceOpen$outboundSchema).optional(),
  movedFromPending: z.lazy(() => MovedFromPending$outboundSchema).optional(),
  immediatelyAvailable: z.lazy(() =>
    AvailableBalanceImmediatelyAvailable$outboundSchema
  ).optional(),
  close: z.lazy(() => AvailableBalanceClose$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AvailableBalance$ {
  /** @deprecated use `AvailableBalance$inboundSchema` instead. */
  export const inboundSchema = AvailableBalance$inboundSchema;
  /** @deprecated use `AvailableBalance$outboundSchema` instead. */
  export const outboundSchema = AvailableBalance$outboundSchema;
  /** @deprecated use `AvailableBalance$Outbound` instead. */
  export type Outbound = AvailableBalance$Outbound;
}

export function availableBalanceToJSON(
  availableBalance: AvailableBalance,
): string {
  return JSON.stringify(
    AvailableBalance$outboundSchema.parse(availableBalance),
  );
}

export function availableBalanceFromJSON(
  jsonString: string,
): SafeParseResult<AvailableBalance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvailableBalance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvailableBalance' from JSON`,
  );
}

/** @internal */
export const OpenPendingAmount$inboundSchema: z.ZodType<
  OpenPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type OpenPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const OpenPendingAmount$outboundSchema: z.ZodType<
  OpenPendingAmount$Outbound,
  z.ZodTypeDef,
  OpenPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenPendingAmount$ {
  /** @deprecated use `OpenPendingAmount$inboundSchema` instead. */
  export const inboundSchema = OpenPendingAmount$inboundSchema;
  /** @deprecated use `OpenPendingAmount$outboundSchema` instead. */
  export const outboundSchema = OpenPendingAmount$outboundSchema;
  /** @deprecated use `OpenPendingAmount$Outbound` instead. */
  export type Outbound = OpenPendingAmount$Outbound;
}

export function openPendingAmountToJSON(
  openPendingAmount: OpenPendingAmount,
): string {
  return JSON.stringify(
    OpenPendingAmount$outboundSchema.parse(openPendingAmount),
  );
}

export function openPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<OpenPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenPendingAmount' from JSON`,
  );
}

/** @internal */
export const OpenPendingSubTotal1$inboundSchema: z.ZodType<
  OpenPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type OpenPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const OpenPendingSubTotal1$outboundSchema: z.ZodType<
  OpenPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  OpenPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenPendingSubTotal1$ {
  /** @deprecated use `OpenPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = OpenPendingSubTotal1$inboundSchema;
  /** @deprecated use `OpenPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = OpenPendingSubTotal1$outboundSchema;
  /** @deprecated use `OpenPendingSubTotal1$Outbound` instead. */
  export type Outbound = OpenPendingSubTotal1$Outbound;
}

export function openPendingSubTotal1ToJSON(
  openPendingSubTotal1: OpenPendingSubTotal1,
): string {
  return JSON.stringify(
    OpenPendingSubTotal1$outboundSchema.parse(openPendingSubTotal1),
  );
}

export function openPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<OpenPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const OpenPendingSubtotal2$inboundSchema: z.ZodType<
  OpenPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => OpenPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type OpenPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<OpenPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const OpenPendingSubtotal2$outboundSchema: z.ZodType<
  OpenPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  OpenPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => OpenPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenPendingSubtotal2$ {
  /** @deprecated use `OpenPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = OpenPendingSubtotal2$inboundSchema;
  /** @deprecated use `OpenPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = OpenPendingSubtotal2$outboundSchema;
  /** @deprecated use `OpenPendingSubtotal2$Outbound` instead. */
  export type Outbound = OpenPendingSubtotal2$Outbound;
}

export function openPendingSubtotal2ToJSON(
  openPendingSubtotal2: OpenPendingSubtotal2,
): string {
  return JSON.stringify(
    OpenPendingSubtotal2$outboundSchema.parse(openPendingSubtotal2),
  );
}

export function openPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<OpenPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const OpenPending$inboundSchema: z.ZodType<
  OpenPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => OpenPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => OpenPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type OpenPending$Outbound = {
  amount?: OpenPendingAmount$Outbound | undefined;
  subtotals?: Array<OpenPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const OpenPending$outboundSchema: z.ZodType<
  OpenPending$Outbound,
  z.ZodTypeDef,
  OpenPending
> = z.object({
  amount: z.lazy(() => OpenPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => OpenPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenPending$ {
  /** @deprecated use `OpenPending$inboundSchema` instead. */
  export const inboundSchema = OpenPending$inboundSchema;
  /** @deprecated use `OpenPending$outboundSchema` instead. */
  export const outboundSchema = OpenPending$outboundSchema;
  /** @deprecated use `OpenPending$Outbound` instead. */
  export type Outbound = OpenPending$Outbound;
}

export function openPendingToJSON(openPending: OpenPending): string {
  return JSON.stringify(OpenPending$outboundSchema.parse(openPending));
}

export function openPendingFromJSON(
  jsonString: string,
): SafeParseResult<OpenPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenPending' from JSON`,
  );
}

/** @internal */
export const OpenAvailableAmount$inboundSchema: z.ZodType<
  OpenAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type OpenAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const OpenAvailableAmount$outboundSchema: z.ZodType<
  OpenAvailableAmount$Outbound,
  z.ZodTypeDef,
  OpenAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenAvailableAmount$ {
  /** @deprecated use `OpenAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = OpenAvailableAmount$inboundSchema;
  /** @deprecated use `OpenAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = OpenAvailableAmount$outboundSchema;
  /** @deprecated use `OpenAvailableAmount$Outbound` instead. */
  export type Outbound = OpenAvailableAmount$Outbound;
}

export function openAvailableAmountToJSON(
  openAvailableAmount: OpenAvailableAmount,
): string {
  return JSON.stringify(
    OpenAvailableAmount$outboundSchema.parse(openAvailableAmount),
  );
}

export function openAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<OpenAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenAvailableAmount' from JSON`,
  );
}

/** @internal */
export const OpenAvailableSubTotal1$inboundSchema: z.ZodType<
  OpenAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type OpenAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const OpenAvailableSubTotal1$outboundSchema: z.ZodType<
  OpenAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  OpenAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenAvailableSubTotal1$ {
  /** @deprecated use `OpenAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = OpenAvailableSubTotal1$inboundSchema;
  /** @deprecated use `OpenAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema = OpenAvailableSubTotal1$outboundSchema;
  /** @deprecated use `OpenAvailableSubTotal1$Outbound` instead. */
  export type Outbound = OpenAvailableSubTotal1$Outbound;
}

export function openAvailableSubTotal1ToJSON(
  openAvailableSubTotal1: OpenAvailableSubTotal1,
): string {
  return JSON.stringify(
    OpenAvailableSubTotal1$outboundSchema.parse(openAvailableSubTotal1),
  );
}

export function openAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<OpenAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const OpenAvailableSubtotal2$inboundSchema: z.ZodType<
  OpenAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => OpenAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type OpenAvailableSubtotal2$Outbound = {
  "sub-totals"?: Array<OpenAvailableSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const OpenAvailableSubtotal2$outboundSchema: z.ZodType<
  OpenAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  OpenAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => OpenAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenAvailableSubtotal2$ {
  /** @deprecated use `OpenAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = OpenAvailableSubtotal2$inboundSchema;
  /** @deprecated use `OpenAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema = OpenAvailableSubtotal2$outboundSchema;
  /** @deprecated use `OpenAvailableSubtotal2$Outbound` instead. */
  export type Outbound = OpenAvailableSubtotal2$Outbound;
}

export function openAvailableSubtotal2ToJSON(
  openAvailableSubtotal2: OpenAvailableSubtotal2,
): string {
  return JSON.stringify(
    OpenAvailableSubtotal2$outboundSchema.parse(openAvailableSubtotal2),
  );
}

export function openAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<OpenAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const OpenAvailable$inboundSchema: z.ZodType<
  OpenAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => OpenAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => OpenAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type OpenAvailable$Outbound = {
  amount?: OpenAvailableAmount$Outbound | undefined;
  subtotals?: Array<OpenAvailableSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const OpenAvailable$outboundSchema: z.ZodType<
  OpenAvailable$Outbound,
  z.ZodTypeDef,
  OpenAvailable
> = z.object({
  amount: z.lazy(() => OpenAvailableAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => OpenAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OpenAvailable$ {
  /** @deprecated use `OpenAvailable$inboundSchema` instead. */
  export const inboundSchema = OpenAvailable$inboundSchema;
  /** @deprecated use `OpenAvailable$outboundSchema` instead. */
  export const outboundSchema = OpenAvailable$outboundSchema;
  /** @deprecated use `OpenAvailable$Outbound` instead. */
  export type Outbound = OpenAvailable$Outbound;
}

export function openAvailableToJSON(openAvailable: OpenAvailable): string {
  return JSON.stringify(OpenAvailable$outboundSchema.parse(openAvailable));
}

export function openAvailableFromJSON(
  jsonString: string,
): SafeParseResult<OpenAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OpenAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OpenAvailable' from JSON`,
  );
}

/** @internal */
export const Open$inboundSchema: z.ZodType<Open, z.ZodTypeDef, unknown> = z
  .object({
    pending: z.lazy(() => OpenPending$inboundSchema).optional(),
    available: z.lazy(() => OpenAvailable$inboundSchema).optional(),
  });

/** @internal */
export type Open$Outbound = {
  pending?: OpenPending$Outbound | undefined;
  available?: OpenAvailable$Outbound | undefined;
};

/** @internal */
export const Open$outboundSchema: z.ZodType<Open$Outbound, z.ZodTypeDef, Open> =
  z.object({
    pending: z.lazy(() => OpenPending$outboundSchema).optional(),
    available: z.lazy(() => OpenAvailable$outboundSchema).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Open$ {
  /** @deprecated use `Open$inboundSchema` instead. */
  export const inboundSchema = Open$inboundSchema;
  /** @deprecated use `Open$outboundSchema` instead. */
  export const outboundSchema = Open$outboundSchema;
  /** @deprecated use `Open$Outbound` instead. */
  export type Outbound = Open$Outbound;
}

export function openToJSON(open: Open): string {
  return JSON.stringify(Open$outboundSchema.parse(open));
}

export function openFromJSON(
  jsonString: string,
): SafeParseResult<Open, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Open$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Open' from JSON`,
  );
}

/** @internal */
export const ClosePendingAmount$inboundSchema: z.ZodType<
  ClosePendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ClosePendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ClosePendingAmount$outboundSchema: z.ZodType<
  ClosePendingAmount$Outbound,
  z.ZodTypeDef,
  ClosePendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClosePendingAmount$ {
  /** @deprecated use `ClosePendingAmount$inboundSchema` instead. */
  export const inboundSchema = ClosePendingAmount$inboundSchema;
  /** @deprecated use `ClosePendingAmount$outboundSchema` instead. */
  export const outboundSchema = ClosePendingAmount$outboundSchema;
  /** @deprecated use `ClosePendingAmount$Outbound` instead. */
  export type Outbound = ClosePendingAmount$Outbound;
}

export function closePendingAmountToJSON(
  closePendingAmount: ClosePendingAmount,
): string {
  return JSON.stringify(
    ClosePendingAmount$outboundSchema.parse(closePendingAmount),
  );
}

export function closePendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ClosePendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClosePendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClosePendingAmount' from JSON`,
  );
}

/** @internal */
export const ClosePendingSubTotal1$inboundSchema: z.ZodType<
  ClosePendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type ClosePendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ClosePendingSubTotal1$outboundSchema: z.ZodType<
  ClosePendingSubTotal1$Outbound,
  z.ZodTypeDef,
  ClosePendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClosePendingSubTotal1$ {
  /** @deprecated use `ClosePendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = ClosePendingSubTotal1$inboundSchema;
  /** @deprecated use `ClosePendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = ClosePendingSubTotal1$outboundSchema;
  /** @deprecated use `ClosePendingSubTotal1$Outbound` instead. */
  export type Outbound = ClosePendingSubTotal1$Outbound;
}

export function closePendingSubTotal1ToJSON(
  closePendingSubTotal1: ClosePendingSubTotal1,
): string {
  return JSON.stringify(
    ClosePendingSubTotal1$outboundSchema.parse(closePendingSubTotal1),
  );
}

export function closePendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<ClosePendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClosePendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClosePendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const ClosePendingSubtotal2$inboundSchema: z.ZodType<
  ClosePendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => ClosePendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type ClosePendingSubtotal2$Outbound = {
  "sub-totals"?: Array<ClosePendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ClosePendingSubtotal2$outboundSchema: z.ZodType<
  ClosePendingSubtotal2$Outbound,
  z.ZodTypeDef,
  ClosePendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => ClosePendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClosePendingSubtotal2$ {
  /** @deprecated use `ClosePendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = ClosePendingSubtotal2$inboundSchema;
  /** @deprecated use `ClosePendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = ClosePendingSubtotal2$outboundSchema;
  /** @deprecated use `ClosePendingSubtotal2$Outbound` instead. */
  export type Outbound = ClosePendingSubtotal2$Outbound;
}

export function closePendingSubtotal2ToJSON(
  closePendingSubtotal2: ClosePendingSubtotal2,
): string {
  return JSON.stringify(
    ClosePendingSubtotal2$outboundSchema.parse(closePendingSubtotal2),
  );
}

export function closePendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<ClosePendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClosePendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClosePendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const ClosePending$inboundSchema: z.ZodType<
  ClosePending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ClosePendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ClosePendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type ClosePending$Outbound = {
  amount?: ClosePendingAmount$Outbound | undefined;
  subtotals?: Array<ClosePendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const ClosePending$outboundSchema: z.ZodType<
  ClosePending$Outbound,
  z.ZodTypeDef,
  ClosePending
> = z.object({
  amount: z.lazy(() => ClosePendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ClosePendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClosePending$ {
  /** @deprecated use `ClosePending$inboundSchema` instead. */
  export const inboundSchema = ClosePending$inboundSchema;
  /** @deprecated use `ClosePending$outboundSchema` instead. */
  export const outboundSchema = ClosePending$outboundSchema;
  /** @deprecated use `ClosePending$Outbound` instead. */
  export type Outbound = ClosePending$Outbound;
}

export function closePendingToJSON(closePending: ClosePending): string {
  return JSON.stringify(ClosePending$outboundSchema.parse(closePending));
}

export function closePendingFromJSON(
  jsonString: string,
): SafeParseResult<ClosePending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClosePending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClosePending' from JSON`,
  );
}

/** @internal */
export const CloseAvailableAmount$inboundSchema: z.ZodType<
  CloseAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CloseAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CloseAvailableAmount$outboundSchema: z.ZodType<
  CloseAvailableAmount$Outbound,
  z.ZodTypeDef,
  CloseAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CloseAvailableAmount$ {
  /** @deprecated use `CloseAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = CloseAvailableAmount$inboundSchema;
  /** @deprecated use `CloseAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = CloseAvailableAmount$outboundSchema;
  /** @deprecated use `CloseAvailableAmount$Outbound` instead. */
  export type Outbound = CloseAvailableAmount$Outbound;
}

export function closeAvailableAmountToJSON(
  closeAvailableAmount: CloseAvailableAmount,
): string {
  return JSON.stringify(
    CloseAvailableAmount$outboundSchema.parse(closeAvailableAmount),
  );
}

export function closeAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<CloseAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CloseAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CloseAvailableAmount' from JSON`,
  );
}

/** @internal */
export const CloseAvailableSubTotal1$inboundSchema: z.ZodType<
  CloseAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CloseAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CloseAvailableSubTotal1$outboundSchema: z.ZodType<
  CloseAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  CloseAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CloseAvailableSubTotal1$ {
  /** @deprecated use `CloseAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = CloseAvailableSubTotal1$inboundSchema;
  /** @deprecated use `CloseAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema = CloseAvailableSubTotal1$outboundSchema;
  /** @deprecated use `CloseAvailableSubTotal1$Outbound` instead. */
  export type Outbound = CloseAvailableSubTotal1$Outbound;
}

export function closeAvailableSubTotal1ToJSON(
  closeAvailableSubTotal1: CloseAvailableSubTotal1,
): string {
  return JSON.stringify(
    CloseAvailableSubTotal1$outboundSchema.parse(closeAvailableSubTotal1),
  );
}

export function closeAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CloseAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CloseAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CloseAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const CloseAvailableSubtotal2$inboundSchema: z.ZodType<
  CloseAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CloseAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CloseAvailableSubtotal2$Outbound = {
  "sub-totals"?: Array<CloseAvailableSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CloseAvailableSubtotal2$outboundSchema: z.ZodType<
  CloseAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  CloseAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CloseAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CloseAvailableSubtotal2$ {
  /** @deprecated use `CloseAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = CloseAvailableSubtotal2$inboundSchema;
  /** @deprecated use `CloseAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema = CloseAvailableSubtotal2$outboundSchema;
  /** @deprecated use `CloseAvailableSubtotal2$Outbound` instead. */
  export type Outbound = CloseAvailableSubtotal2$Outbound;
}

export function closeAvailableSubtotal2ToJSON(
  closeAvailableSubtotal2: CloseAvailableSubtotal2,
): string {
  return JSON.stringify(
    CloseAvailableSubtotal2$outboundSchema.parse(closeAvailableSubtotal2),
  );
}

export function closeAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CloseAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CloseAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CloseAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const CloseAvailable$inboundSchema: z.ZodType<
  CloseAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CloseAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CloseAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CloseAvailable$Outbound = {
  amount?: CloseAvailableAmount$Outbound | undefined;
  subtotals?: Array<CloseAvailableSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const CloseAvailable$outboundSchema: z.ZodType<
  CloseAvailable$Outbound,
  z.ZodTypeDef,
  CloseAvailable
> = z.object({
  amount: z.lazy(() => CloseAvailableAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CloseAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CloseAvailable$ {
  /** @deprecated use `CloseAvailable$inboundSchema` instead. */
  export const inboundSchema = CloseAvailable$inboundSchema;
  /** @deprecated use `CloseAvailable$outboundSchema` instead. */
  export const outboundSchema = CloseAvailable$outboundSchema;
  /** @deprecated use `CloseAvailable$Outbound` instead. */
  export type Outbound = CloseAvailable$Outbound;
}

export function closeAvailableToJSON(closeAvailable: CloseAvailable): string {
  return JSON.stringify(CloseAvailable$outboundSchema.parse(closeAvailable));
}

export function closeAvailableFromJSON(
  jsonString: string,
): SafeParseResult<CloseAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CloseAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CloseAvailable' from JSON`,
  );
}

/** @internal */
export const Close$inboundSchema: z.ZodType<Close, z.ZodTypeDef, unknown> = z
  .object({
    pending: z.lazy(() => ClosePending$inboundSchema).optional(),
    available: z.lazy(() => CloseAvailable$inboundSchema).optional(),
  });

/** @internal */
export type Close$Outbound = {
  pending?: ClosePending$Outbound | undefined;
  available?: CloseAvailable$Outbound | undefined;
};

/** @internal */
export const Close$outboundSchema: z.ZodType<
  Close$Outbound,
  z.ZodTypeDef,
  Close
> = z.object({
  pending: z.lazy(() => ClosePending$outboundSchema).optional(),
  available: z.lazy(() => CloseAvailable$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Close$ {
  /** @deprecated use `Close$inboundSchema` instead. */
  export const inboundSchema = Close$inboundSchema;
  /** @deprecated use `Close$outboundSchema` instead. */
  export const outboundSchema = Close$outboundSchema;
  /** @deprecated use `Close$Outbound` instead. */
  export type Outbound = Close$Outbound;
}

export function closeToJSON(close: Close): string {
  return JSON.stringify(Close$outboundSchema.parse(close));
}

export function closeFromJSON(
  jsonString: string,
): SafeParseResult<Close, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Close$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Close' from JSON`,
  );
}

/** @internal */
export const PaymentsPendingAmount$inboundSchema: z.ZodType<
  PaymentsPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PaymentsPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PaymentsPendingAmount$outboundSchema: z.ZodType<
  PaymentsPendingAmount$Outbound,
  z.ZodTypeDef,
  PaymentsPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsPendingAmount$ {
  /** @deprecated use `PaymentsPendingAmount$inboundSchema` instead. */
  export const inboundSchema = PaymentsPendingAmount$inboundSchema;
  /** @deprecated use `PaymentsPendingAmount$outboundSchema` instead. */
  export const outboundSchema = PaymentsPendingAmount$outboundSchema;
  /** @deprecated use `PaymentsPendingAmount$Outbound` instead. */
  export type Outbound = PaymentsPendingAmount$Outbound;
}

export function paymentsPendingAmountToJSON(
  paymentsPendingAmount: PaymentsPendingAmount,
): string {
  return JSON.stringify(
    PaymentsPendingAmount$outboundSchema.parse(paymentsPendingAmount),
  );
}

export function paymentsPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsPendingAmount' from JSON`,
  );
}

/** @internal */
export const PaymentsPendingSubTotal1$inboundSchema: z.ZodType<
  PaymentsPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PaymentsPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsPendingSubTotal1$outboundSchema: z.ZodType<
  PaymentsPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  PaymentsPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsPendingSubTotal1$ {
  /** @deprecated use `PaymentsPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = PaymentsPendingSubTotal1$inboundSchema;
  /** @deprecated use `PaymentsPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = PaymentsPendingSubTotal1$outboundSchema;
  /** @deprecated use `PaymentsPendingSubTotal1$Outbound` instead. */
  export type Outbound = PaymentsPendingSubTotal1$Outbound;
}

export function paymentsPendingSubTotal1ToJSON(
  paymentsPendingSubTotal1: PaymentsPendingSubTotal1,
): string {
  return JSON.stringify(
    PaymentsPendingSubTotal1$outboundSchema.parse(paymentsPendingSubTotal1),
  );
}

export function paymentsPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const PaymentsPendingSubtotal2$inboundSchema: z.ZodType<
  PaymentsPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PaymentsPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PaymentsPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<PaymentsPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsPendingSubtotal2$outboundSchema: z.ZodType<
  PaymentsPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  PaymentsPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PaymentsPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsPendingSubtotal2$ {
  /** @deprecated use `PaymentsPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = PaymentsPendingSubtotal2$inboundSchema;
  /** @deprecated use `PaymentsPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = PaymentsPendingSubtotal2$outboundSchema;
  /** @deprecated use `PaymentsPendingSubtotal2$Outbound` instead. */
  export type Outbound = PaymentsPendingSubtotal2$Outbound;
}

export function paymentsPendingSubtotal2ToJSON(
  paymentsPendingSubtotal2: PaymentsPendingSubtotal2,
): string {
  return JSON.stringify(
    PaymentsPendingSubtotal2$outboundSchema.parse(paymentsPendingSubtotal2),
  );
}

export function paymentsPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const PaymentsPending$inboundSchema: z.ZodType<
  PaymentsPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PaymentsPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PaymentsPending$Outbound = {
  amount?: PaymentsPendingAmount$Outbound | undefined;
  subtotals?: Array<PaymentsPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const PaymentsPending$outboundSchema: z.ZodType<
  PaymentsPending$Outbound,
  z.ZodTypeDef,
  PaymentsPending
> = z.object({
  amount: z.lazy(() => PaymentsPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsPending$ {
  /** @deprecated use `PaymentsPending$inboundSchema` instead. */
  export const inboundSchema = PaymentsPending$inboundSchema;
  /** @deprecated use `PaymentsPending$outboundSchema` instead. */
  export const outboundSchema = PaymentsPending$outboundSchema;
  /** @deprecated use `PaymentsPending$Outbound` instead. */
  export type Outbound = PaymentsPending$Outbound;
}

export function paymentsPendingToJSON(
  paymentsPending: PaymentsPending,
): string {
  return JSON.stringify(PaymentsPending$outboundSchema.parse(paymentsPending));
}

export function paymentsPendingFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsPending' from JSON`,
  );
}

/** @internal */
export const PaymentsMovedToAvailableAmount$inboundSchema: z.ZodType<
  PaymentsMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PaymentsMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PaymentsMovedToAvailableAmount$outboundSchema: z.ZodType<
  PaymentsMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  PaymentsMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsMovedToAvailableAmount$ {
  /** @deprecated use `PaymentsMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = PaymentsMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = PaymentsMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = PaymentsMovedToAvailableAmount$Outbound;
}

export function paymentsMovedToAvailableAmountToJSON(
  paymentsMovedToAvailableAmount: PaymentsMovedToAvailableAmount,
): string {
  return JSON.stringify(
    PaymentsMovedToAvailableAmount$outboundSchema.parse(
      paymentsMovedToAvailableAmount,
    ),
  );
}

export function paymentsMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const PaymentsMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  PaymentsMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PaymentsMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  PaymentsMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  PaymentsMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsMovedToAvailableSubTotal1$ {
  /** @deprecated use `PaymentsMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = PaymentsMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    PaymentsMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = PaymentsMovedToAvailableSubTotal1$Outbound;
}

export function paymentsMovedToAvailableSubTotal1ToJSON(
  paymentsMovedToAvailableSubTotal1: PaymentsMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    PaymentsMovedToAvailableSubTotal1$outboundSchema.parse(
      paymentsMovedToAvailableSubTotal1,
    ),
  );
}

export function paymentsMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const PaymentsMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  PaymentsMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PaymentsMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PaymentsMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<PaymentsMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  PaymentsMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  PaymentsMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PaymentsMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsMovedToAvailableSubtotal2$ {
  /** @deprecated use `PaymentsMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = PaymentsMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    PaymentsMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `PaymentsMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = PaymentsMovedToAvailableSubtotal2$Outbound;
}

export function paymentsMovedToAvailableSubtotal2ToJSON(
  paymentsMovedToAvailableSubtotal2: PaymentsMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    PaymentsMovedToAvailableSubtotal2$outboundSchema.parse(
      paymentsMovedToAvailableSubtotal2,
    ),
  );
}

export function paymentsMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const PaymentsMovedToAvailable$inboundSchema: z.ZodType<
  PaymentsMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PaymentsMovedToAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PaymentsMovedToAvailable$Outbound = {
  amount?: PaymentsMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<PaymentsMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const PaymentsMovedToAvailable$outboundSchema: z.ZodType<
  PaymentsMovedToAvailable$Outbound,
  z.ZodTypeDef,
  PaymentsMovedToAvailable
> = z.object({
  amount: z.lazy(() => PaymentsMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsMovedToAvailable$ {
  /** @deprecated use `PaymentsMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = PaymentsMovedToAvailable$inboundSchema;
  /** @deprecated use `PaymentsMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = PaymentsMovedToAvailable$outboundSchema;
  /** @deprecated use `PaymentsMovedToAvailable$Outbound` instead. */
  export type Outbound = PaymentsMovedToAvailable$Outbound;
}

export function paymentsMovedToAvailableToJSON(
  paymentsMovedToAvailable: PaymentsMovedToAvailable,
): string {
  return JSON.stringify(
    PaymentsMovedToAvailable$outboundSchema.parse(paymentsMovedToAvailable),
  );
}

export function paymentsMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const PaymentsImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type PaymentsImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const PaymentsImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  PaymentsImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsImmediatelyAvailableAmount$ {
  /** @deprecated use `PaymentsImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = PaymentsImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    PaymentsImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = PaymentsImmediatelyAvailableAmount$Outbound;
}

export function paymentsImmediatelyAvailableAmountToJSON(
  paymentsImmediatelyAvailableAmount: PaymentsImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    PaymentsImmediatelyAvailableAmount$outboundSchema.parse(
      paymentsImmediatelyAvailableAmount,
    ),
  );
}

export function paymentsImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PaymentsImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const PaymentsImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type PaymentsImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  PaymentsImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `PaymentsImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    PaymentsImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    PaymentsImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = PaymentsImmediatelyAvailableSubTotal1$Outbound;
}

export function paymentsImmediatelyAvailableSubTotal1ToJSON(
  paymentsImmediatelyAvailableSubTotal1: PaymentsImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    PaymentsImmediatelyAvailableSubTotal1$outboundSchema.parse(
      paymentsImmediatelyAvailableSubTotal1,
    ),
  );
}

export function paymentsImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsImmediatelyAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PaymentsImmediatelyAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const PaymentsImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => PaymentsImmediatelyAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type PaymentsImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<PaymentsImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const PaymentsImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  PaymentsImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  PaymentsImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => PaymentsImmediatelyAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `PaymentsImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    PaymentsImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    PaymentsImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = PaymentsImmediatelyAvailableSubtotal2$Outbound;
}

export function paymentsImmediatelyAvailableSubtotal2ToJSON(
  paymentsImmediatelyAvailableSubtotal2: PaymentsImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    PaymentsImmediatelyAvailableSubtotal2$outboundSchema.parse(
      paymentsImmediatelyAvailableSubtotal2,
    ),
  );
}

export function paymentsImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<PaymentsImmediatelyAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PaymentsImmediatelyAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const PaymentsImmediatelyAvailable$inboundSchema: z.ZodType<
  PaymentsImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => PaymentsImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsImmediatelyAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type PaymentsImmediatelyAvailable$Outbound = {
  amount?: PaymentsImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<PaymentsImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const PaymentsImmediatelyAvailable$outboundSchema: z.ZodType<
  PaymentsImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  PaymentsImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => PaymentsImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => PaymentsImmediatelyAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentsImmediatelyAvailable$ {
  /** @deprecated use `PaymentsImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = PaymentsImmediatelyAvailable$inboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = PaymentsImmediatelyAvailable$outboundSchema;
  /** @deprecated use `PaymentsImmediatelyAvailable$Outbound` instead. */
  export type Outbound = PaymentsImmediatelyAvailable$Outbound;
}

export function paymentsImmediatelyAvailableToJSON(
  paymentsImmediatelyAvailable: PaymentsImmediatelyAvailable,
): string {
  return JSON.stringify(
    PaymentsImmediatelyAvailable$outboundSchema.parse(
      paymentsImmediatelyAvailable,
    ),
  );
}

export function paymentsImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<PaymentsImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentsImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentsImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportPayments$inboundSchema: z.ZodType<
  GetBalanceReportPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => PaymentsPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => PaymentsMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() => PaymentsImmediatelyAvailable$inboundSchema)
    .optional(),
});

/** @internal */
export type GetBalanceReportPayments$Outbound = {
  pending?: PaymentsPending$Outbound | undefined;
  movedToAvailable?: PaymentsMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: PaymentsImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const GetBalanceReportPayments$outboundSchema: z.ZodType<
  GetBalanceReportPayments$Outbound,
  z.ZodTypeDef,
  GetBalanceReportPayments
> = z.object({
  pending: z.lazy(() => PaymentsPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => PaymentsMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    PaymentsImmediatelyAvailable$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportPayments$ {
  /** @deprecated use `GetBalanceReportPayments$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportPayments$inboundSchema;
  /** @deprecated use `GetBalanceReportPayments$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportPayments$outboundSchema;
  /** @deprecated use `GetBalanceReportPayments$Outbound` instead. */
  export type Outbound = GetBalanceReportPayments$Outbound;
}

export function getBalanceReportPaymentsToJSON(
  getBalanceReportPayments: GetBalanceReportPayments,
): string {
  return JSON.stringify(
    GetBalanceReportPayments$outboundSchema.parse(getBalanceReportPayments),
  );
}

export function getBalanceReportPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportPayments' from JSON`,
  );
}

/** @internal */
export const RefundsPendingAmount$inboundSchema: z.ZodType<
  RefundsPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type RefundsPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const RefundsPendingAmount$outboundSchema: z.ZodType<
  RefundsPendingAmount$Outbound,
  z.ZodTypeDef,
  RefundsPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsPendingAmount$ {
  /** @deprecated use `RefundsPendingAmount$inboundSchema` instead. */
  export const inboundSchema = RefundsPendingAmount$inboundSchema;
  /** @deprecated use `RefundsPendingAmount$outboundSchema` instead. */
  export const outboundSchema = RefundsPendingAmount$outboundSchema;
  /** @deprecated use `RefundsPendingAmount$Outbound` instead. */
  export type Outbound = RefundsPendingAmount$Outbound;
}

export function refundsPendingAmountToJSON(
  refundsPendingAmount: RefundsPendingAmount,
): string {
  return JSON.stringify(
    RefundsPendingAmount$outboundSchema.parse(refundsPendingAmount),
  );
}

export function refundsPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<RefundsPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsPendingAmount' from JSON`,
  );
}

/** @internal */
export const RefundsPendingSubTotal1$inboundSchema: z.ZodType<
  RefundsPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type RefundsPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsPendingSubTotal1$outboundSchema: z.ZodType<
  RefundsPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  RefundsPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsPendingSubTotal1$ {
  /** @deprecated use `RefundsPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = RefundsPendingSubTotal1$inboundSchema;
  /** @deprecated use `RefundsPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = RefundsPendingSubTotal1$outboundSchema;
  /** @deprecated use `RefundsPendingSubTotal1$Outbound` instead. */
  export type Outbound = RefundsPendingSubTotal1$Outbound;
}

export function refundsPendingSubTotal1ToJSON(
  refundsPendingSubTotal1: RefundsPendingSubTotal1,
): string {
  return JSON.stringify(
    RefundsPendingSubTotal1$outboundSchema.parse(refundsPendingSubTotal1),
  );
}

export function refundsPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<RefundsPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const RefundsPendingSubtotal2$inboundSchema: z.ZodType<
  RefundsPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => RefundsPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type RefundsPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<RefundsPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsPendingSubtotal2$outboundSchema: z.ZodType<
  RefundsPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  RefundsPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => RefundsPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsPendingSubtotal2$ {
  /** @deprecated use `RefundsPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = RefundsPendingSubtotal2$inboundSchema;
  /** @deprecated use `RefundsPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = RefundsPendingSubtotal2$outboundSchema;
  /** @deprecated use `RefundsPendingSubtotal2$Outbound` instead. */
  export type Outbound = RefundsPendingSubtotal2$Outbound;
}

export function refundsPendingSubtotal2ToJSON(
  refundsPendingSubtotal2: RefundsPendingSubtotal2,
): string {
  return JSON.stringify(
    RefundsPendingSubtotal2$outboundSchema.parse(refundsPendingSubtotal2),
  );
}

export function refundsPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<RefundsPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const RefundsPending$inboundSchema: z.ZodType<
  RefundsPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => RefundsPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type RefundsPending$Outbound = {
  amount?: RefundsPendingAmount$Outbound | undefined;
  subtotals?: Array<RefundsPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const RefundsPending$outboundSchema: z.ZodType<
  RefundsPending$Outbound,
  z.ZodTypeDef,
  RefundsPending
> = z.object({
  amount: z.lazy(() => RefundsPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsPending$ {
  /** @deprecated use `RefundsPending$inboundSchema` instead. */
  export const inboundSchema = RefundsPending$inboundSchema;
  /** @deprecated use `RefundsPending$outboundSchema` instead. */
  export const outboundSchema = RefundsPending$outboundSchema;
  /** @deprecated use `RefundsPending$Outbound` instead. */
  export type Outbound = RefundsPending$Outbound;
}

export function refundsPendingToJSON(refundsPending: RefundsPending): string {
  return JSON.stringify(RefundsPending$outboundSchema.parse(refundsPending));
}

export function refundsPendingFromJSON(
  jsonString: string,
): SafeParseResult<RefundsPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsPending' from JSON`,
  );
}

/** @internal */
export const RefundsMovedToAvailableAmount$inboundSchema: z.ZodType<
  RefundsMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type RefundsMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const RefundsMovedToAvailableAmount$outboundSchema: z.ZodType<
  RefundsMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  RefundsMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsMovedToAvailableAmount$ {
  /** @deprecated use `RefundsMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = RefundsMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `RefundsMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = RefundsMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `RefundsMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = RefundsMovedToAvailableAmount$Outbound;
}

export function refundsMovedToAvailableAmountToJSON(
  refundsMovedToAvailableAmount: RefundsMovedToAvailableAmount,
): string {
  return JSON.stringify(
    RefundsMovedToAvailableAmount$outboundSchema.parse(
      refundsMovedToAvailableAmount,
    ),
  );
}

export function refundsMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<RefundsMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const RefundsMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  RefundsMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type RefundsMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  RefundsMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  RefundsMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsMovedToAvailableSubTotal1$ {
  /** @deprecated use `RefundsMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = RefundsMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `RefundsMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema = RefundsMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `RefundsMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = RefundsMovedToAvailableSubTotal1$Outbound;
}

export function refundsMovedToAvailableSubTotal1ToJSON(
  refundsMovedToAvailableSubTotal1: RefundsMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    RefundsMovedToAvailableSubTotal1$outboundSchema.parse(
      refundsMovedToAvailableSubTotal1,
    ),
  );
}

export function refundsMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<RefundsMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const RefundsMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  RefundsMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => RefundsMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type RefundsMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<RefundsMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  RefundsMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  RefundsMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => RefundsMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsMovedToAvailableSubtotal2$ {
  /** @deprecated use `RefundsMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = RefundsMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `RefundsMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema = RefundsMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `RefundsMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = RefundsMovedToAvailableSubtotal2$Outbound;
}

export function refundsMovedToAvailableSubtotal2ToJSON(
  refundsMovedToAvailableSubtotal2: RefundsMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    RefundsMovedToAvailableSubtotal2$outboundSchema.parse(
      refundsMovedToAvailableSubtotal2,
    ),
  );
}

export function refundsMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<RefundsMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const RefundsMovedToAvailable$inboundSchema: z.ZodType<
  RefundsMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => RefundsMovedToAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type RefundsMovedToAvailable$Outbound = {
  amount?: RefundsMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<RefundsMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const RefundsMovedToAvailable$outboundSchema: z.ZodType<
  RefundsMovedToAvailable$Outbound,
  z.ZodTypeDef,
  RefundsMovedToAvailable
> = z.object({
  amount: z.lazy(() => RefundsMovedToAvailableAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsMovedToAvailable$ {
  /** @deprecated use `RefundsMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = RefundsMovedToAvailable$inboundSchema;
  /** @deprecated use `RefundsMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = RefundsMovedToAvailable$outboundSchema;
  /** @deprecated use `RefundsMovedToAvailable$Outbound` instead. */
  export type Outbound = RefundsMovedToAvailable$Outbound;
}

export function refundsMovedToAvailableToJSON(
  refundsMovedToAvailable: RefundsMovedToAvailable,
): string {
  return JSON.stringify(
    RefundsMovedToAvailable$outboundSchema.parse(refundsMovedToAvailable),
  );
}

export function refundsMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<RefundsMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const RefundsImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  RefundsImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type RefundsImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const RefundsImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  RefundsImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  RefundsImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsImmediatelyAvailableAmount$ {
  /** @deprecated use `RefundsImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = RefundsImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    RefundsImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = RefundsImmediatelyAvailableAmount$Outbound;
}

export function refundsImmediatelyAvailableAmountToJSON(
  refundsImmediatelyAvailableAmount: RefundsImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    RefundsImmediatelyAvailableAmount$outboundSchema.parse(
      refundsImmediatelyAvailableAmount,
    ),
  );
}

export function refundsImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<RefundsImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const RefundsImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  RefundsImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type RefundsImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  RefundsImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  RefundsImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `RefundsImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    RefundsImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    RefundsImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = RefundsImmediatelyAvailableSubTotal1$Outbound;
}

export function refundsImmediatelyAvailableSubTotal1ToJSON(
  refundsImmediatelyAvailableSubTotal1: RefundsImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    RefundsImmediatelyAvailableSubTotal1$outboundSchema.parse(
      refundsImmediatelyAvailableSubTotal1,
    ),
  );
}

export function refundsImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<RefundsImmediatelyAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RefundsImmediatelyAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const RefundsImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  RefundsImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => RefundsImmediatelyAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type RefundsImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<RefundsImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const RefundsImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  RefundsImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  RefundsImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => RefundsImmediatelyAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `RefundsImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    RefundsImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    RefundsImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = RefundsImmediatelyAvailableSubtotal2$Outbound;
}

export function refundsImmediatelyAvailableSubtotal2ToJSON(
  refundsImmediatelyAvailableSubtotal2: RefundsImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    RefundsImmediatelyAvailableSubtotal2$outboundSchema.parse(
      refundsImmediatelyAvailableSubtotal2,
    ),
  );
}

export function refundsImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<RefundsImmediatelyAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RefundsImmediatelyAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const RefundsImmediatelyAvailable$inboundSchema: z.ZodType<
  RefundsImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => RefundsImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsImmediatelyAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type RefundsImmediatelyAvailable$Outbound = {
  amount?: RefundsImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<RefundsImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const RefundsImmediatelyAvailable$outboundSchema: z.ZodType<
  RefundsImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  RefundsImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => RefundsImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => RefundsImmediatelyAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefundsImmediatelyAvailable$ {
  /** @deprecated use `RefundsImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = RefundsImmediatelyAvailable$inboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = RefundsImmediatelyAvailable$outboundSchema;
  /** @deprecated use `RefundsImmediatelyAvailable$Outbound` instead. */
  export type Outbound = RefundsImmediatelyAvailable$Outbound;
}

export function refundsImmediatelyAvailableToJSON(
  refundsImmediatelyAvailable: RefundsImmediatelyAvailable,
): string {
  return JSON.stringify(
    RefundsImmediatelyAvailable$outboundSchema.parse(
      refundsImmediatelyAvailable,
    ),
  );
}

export function refundsImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<RefundsImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefundsImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefundsImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportRefunds$inboundSchema: z.ZodType<
  GetBalanceReportRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => RefundsPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => RefundsMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() => RefundsImmediatelyAvailable$inboundSchema)
    .optional(),
});

/** @internal */
export type GetBalanceReportRefunds$Outbound = {
  pending?: RefundsPending$Outbound | undefined;
  movedToAvailable?: RefundsMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: RefundsImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const GetBalanceReportRefunds$outboundSchema: z.ZodType<
  GetBalanceReportRefunds$Outbound,
  z.ZodTypeDef,
  GetBalanceReportRefunds
> = z.object({
  pending: z.lazy(() => RefundsPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => RefundsMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() => RefundsImmediatelyAvailable$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportRefunds$ {
  /** @deprecated use `GetBalanceReportRefunds$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportRefunds$inboundSchema;
  /** @deprecated use `GetBalanceReportRefunds$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportRefunds$outboundSchema;
  /** @deprecated use `GetBalanceReportRefunds$Outbound` instead. */
  export type Outbound = GetBalanceReportRefunds$Outbound;
}

export function getBalanceReportRefundsToJSON(
  getBalanceReportRefunds: GetBalanceReportRefunds,
): string {
  return JSON.stringify(
    GetBalanceReportRefunds$outboundSchema.parse(getBalanceReportRefunds),
  );
}

export function getBalanceReportRefundsFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportRefunds' from JSON`,
  );
}

/** @internal */
export const ChargebacksPendingAmount$inboundSchema: z.ZodType<
  ChargebacksPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ChargebacksPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ChargebacksPendingAmount$outboundSchema: z.ZodType<
  ChargebacksPendingAmount$Outbound,
  z.ZodTypeDef,
  ChargebacksPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksPendingAmount$ {
  /** @deprecated use `ChargebacksPendingAmount$inboundSchema` instead. */
  export const inboundSchema = ChargebacksPendingAmount$inboundSchema;
  /** @deprecated use `ChargebacksPendingAmount$outboundSchema` instead. */
  export const outboundSchema = ChargebacksPendingAmount$outboundSchema;
  /** @deprecated use `ChargebacksPendingAmount$Outbound` instead. */
  export type Outbound = ChargebacksPendingAmount$Outbound;
}

export function chargebacksPendingAmountToJSON(
  chargebacksPendingAmount: ChargebacksPendingAmount,
): string {
  return JSON.stringify(
    ChargebacksPendingAmount$outboundSchema.parse(chargebacksPendingAmount),
  );
}

export function chargebacksPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksPendingAmount' from JSON`,
  );
}

/** @internal */
export const ChargebacksPendingSubTotal1$inboundSchema: z.ZodType<
  ChargebacksPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type ChargebacksPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksPendingSubTotal1$outboundSchema: z.ZodType<
  ChargebacksPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  ChargebacksPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksPendingSubTotal1$ {
  /** @deprecated use `ChargebacksPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = ChargebacksPendingSubTotal1$inboundSchema;
  /** @deprecated use `ChargebacksPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = ChargebacksPendingSubTotal1$outboundSchema;
  /** @deprecated use `ChargebacksPendingSubTotal1$Outbound` instead. */
  export type Outbound = ChargebacksPendingSubTotal1$Outbound;
}

export function chargebacksPendingSubTotal1ToJSON(
  chargebacksPendingSubTotal1: ChargebacksPendingSubTotal1,
): string {
  return JSON.stringify(
    ChargebacksPendingSubTotal1$outboundSchema.parse(
      chargebacksPendingSubTotal1,
    ),
  );
}

export function chargebacksPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const ChargebacksPendingSubtotal2$inboundSchema: z.ZodType<
  ChargebacksPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => ChargebacksPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type ChargebacksPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<ChargebacksPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksPendingSubtotal2$outboundSchema: z.ZodType<
  ChargebacksPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  ChargebacksPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => ChargebacksPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksPendingSubtotal2$ {
  /** @deprecated use `ChargebacksPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = ChargebacksPendingSubtotal2$inboundSchema;
  /** @deprecated use `ChargebacksPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = ChargebacksPendingSubtotal2$outboundSchema;
  /** @deprecated use `ChargebacksPendingSubtotal2$Outbound` instead. */
  export type Outbound = ChargebacksPendingSubtotal2$Outbound;
}

export function chargebacksPendingSubtotal2ToJSON(
  chargebacksPendingSubtotal2: ChargebacksPendingSubtotal2,
): string {
  return JSON.stringify(
    ChargebacksPendingSubtotal2$outboundSchema.parse(
      chargebacksPendingSubtotal2,
    ),
  );
}

export function chargebacksPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const ChargebacksPending$inboundSchema: z.ZodType<
  ChargebacksPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ChargebacksPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ChargebacksPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type ChargebacksPending$Outbound = {
  amount?: ChargebacksPendingAmount$Outbound | undefined;
  subtotals?: Array<ChargebacksPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const ChargebacksPending$outboundSchema: z.ZodType<
  ChargebacksPending$Outbound,
  z.ZodTypeDef,
  ChargebacksPending
> = z.object({
  amount: z.lazy(() => ChargebacksPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ChargebacksPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksPending$ {
  /** @deprecated use `ChargebacksPending$inboundSchema` instead. */
  export const inboundSchema = ChargebacksPending$inboundSchema;
  /** @deprecated use `ChargebacksPending$outboundSchema` instead. */
  export const outboundSchema = ChargebacksPending$outboundSchema;
  /** @deprecated use `ChargebacksPending$Outbound` instead. */
  export type Outbound = ChargebacksPending$Outbound;
}

export function chargebacksPendingToJSON(
  chargebacksPending: ChargebacksPending,
): string {
  return JSON.stringify(
    ChargebacksPending$outboundSchema.parse(chargebacksPending),
  );
}

export function chargebacksPendingFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksPending' from JSON`,
  );
}

/** @internal */
export const ChargebacksMovedToAvailableAmount$inboundSchema: z.ZodType<
  ChargebacksMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ChargebacksMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ChargebacksMovedToAvailableAmount$outboundSchema: z.ZodType<
  ChargebacksMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  ChargebacksMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksMovedToAvailableAmount$ {
  /** @deprecated use `ChargebacksMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = ChargebacksMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = ChargebacksMovedToAvailableAmount$Outbound;
}

export function chargebacksMovedToAvailableAmountToJSON(
  chargebacksMovedToAvailableAmount: ChargebacksMovedToAvailableAmount,
): string {
  return JSON.stringify(
    ChargebacksMovedToAvailableAmount$outboundSchema.parse(
      chargebacksMovedToAvailableAmount,
    ),
  );
}

export function chargebacksMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const ChargebacksMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  ChargebacksMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type ChargebacksMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  ChargebacksMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  ChargebacksMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksMovedToAvailableSubTotal1$ {
  /** @deprecated use `ChargebacksMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    ChargebacksMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = ChargebacksMovedToAvailableSubTotal1$Outbound;
}

export function chargebacksMovedToAvailableSubTotal1ToJSON(
  chargebacksMovedToAvailableSubTotal1: ChargebacksMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    ChargebacksMovedToAvailableSubTotal1$outboundSchema.parse(
      chargebacksMovedToAvailableSubTotal1,
    ),
  );
}

export function chargebacksMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ChargebacksMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const ChargebacksMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  ChargebacksMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => ChargebacksMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type ChargebacksMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<ChargebacksMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  ChargebacksMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  ChargebacksMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => ChargebacksMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksMovedToAvailableSubtotal2$ {
  /** @deprecated use `ChargebacksMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    ChargebacksMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = ChargebacksMovedToAvailableSubtotal2$Outbound;
}

export function chargebacksMovedToAvailableSubtotal2ToJSON(
  chargebacksMovedToAvailableSubtotal2: ChargebacksMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    ChargebacksMovedToAvailableSubtotal2$outboundSchema.parse(
      chargebacksMovedToAvailableSubtotal2,
    ),
  );
}

export function chargebacksMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ChargebacksMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const ChargebacksMovedToAvailable$inboundSchema: z.ZodType<
  ChargebacksMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ChargebacksMovedToAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ChargebacksMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type ChargebacksMovedToAvailable$Outbound = {
  amount?: ChargebacksMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<ChargebacksMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const ChargebacksMovedToAvailable$outboundSchema: z.ZodType<
  ChargebacksMovedToAvailable$Outbound,
  z.ZodTypeDef,
  ChargebacksMovedToAvailable
> = z.object({
  amount: z.lazy(() => ChargebacksMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => ChargebacksMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksMovedToAvailable$ {
  /** @deprecated use `ChargebacksMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = ChargebacksMovedToAvailable$inboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = ChargebacksMovedToAvailable$outboundSchema;
  /** @deprecated use `ChargebacksMovedToAvailable$Outbound` instead. */
  export type Outbound = ChargebacksMovedToAvailable$Outbound;
}

export function chargebacksMovedToAvailableToJSON(
  chargebacksMovedToAvailable: ChargebacksMovedToAvailable,
): string {
  return JSON.stringify(
    ChargebacksMovedToAvailable$outboundSchema.parse(
      chargebacksMovedToAvailable,
    ),
  );
}

export function chargebacksMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const ChargebacksImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ChargebacksImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ChargebacksImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  ChargebacksImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksImmediatelyAvailableAmount$ {
  /** @deprecated use `ChargebacksImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    ChargebacksImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = ChargebacksImmediatelyAvailableAmount$Outbound;
}

export function chargebacksImmediatelyAvailableAmountToJSON(
  chargebacksImmediatelyAvailableAmount: ChargebacksImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    ChargebacksImmediatelyAvailableAmount$outboundSchema.parse(
      chargebacksImmediatelyAvailableAmount,
    ),
  );
}

export function chargebacksImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ChargebacksImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const ChargebacksImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type ChargebacksImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  ChargebacksImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `ChargebacksImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    ChargebacksImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = ChargebacksImmediatelyAvailableSubTotal1$Outbound;
}

export function chargebacksImmediatelyAvailableSubTotal1ToJSON(
  chargebacksImmediatelyAvailableSubTotal1:
    ChargebacksImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    ChargebacksImmediatelyAvailableSubTotal1$outboundSchema.parse(
      chargebacksImmediatelyAvailableSubTotal1,
    ),
  );
}

export function chargebacksImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  ChargebacksImmediatelyAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ChargebacksImmediatelyAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ChargebacksImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const ChargebacksImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(
      z.lazy(() => ChargebacksImmediatelyAvailableSubTotal1$inboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type ChargebacksImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<ChargebacksImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const ChargebacksImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  ChargebacksImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(
      z.lazy(() => ChargebacksImmediatelyAvailableSubTotal1$outboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `ChargebacksImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    ChargebacksImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    ChargebacksImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = ChargebacksImmediatelyAvailableSubtotal2$Outbound;
}

export function chargebacksImmediatelyAvailableSubtotal2ToJSON(
  chargebacksImmediatelyAvailableSubtotal2:
    ChargebacksImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    ChargebacksImmediatelyAvailableSubtotal2$outboundSchema.parse(
      chargebacksImmediatelyAvailableSubtotal2,
    ),
  );
}

export function chargebacksImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  ChargebacksImmediatelyAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ChargebacksImmediatelyAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ChargebacksImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const ChargebacksImmediatelyAvailable$inboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ChargebacksImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => ChargebacksImmediatelyAvailableSubtotal2$inboundSchema),
    ),
  ).optional(),
});

/** @internal */
export type ChargebacksImmediatelyAvailable$Outbound = {
  amount?: ChargebacksImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<ChargebacksImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const ChargebacksImmediatelyAvailable$outboundSchema: z.ZodType<
  ChargebacksImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  ChargebacksImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => ChargebacksImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => ChargebacksImmediatelyAvailableSubtotal2$outboundSchema),
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChargebacksImmediatelyAvailable$ {
  /** @deprecated use `ChargebacksImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = ChargebacksImmediatelyAvailable$inboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = ChargebacksImmediatelyAvailable$outboundSchema;
  /** @deprecated use `ChargebacksImmediatelyAvailable$Outbound` instead. */
  export type Outbound = ChargebacksImmediatelyAvailable$Outbound;
}

export function chargebacksImmediatelyAvailableToJSON(
  chargebacksImmediatelyAvailable: ChargebacksImmediatelyAvailable,
): string {
  return JSON.stringify(
    ChargebacksImmediatelyAvailable$outboundSchema.parse(
      chargebacksImmediatelyAvailable,
    ),
  );
}

export function chargebacksImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<ChargebacksImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChargebacksImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChargebacksImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportChargebacks$inboundSchema: z.ZodType<
  GetBalanceReportChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => ChargebacksPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => ChargebacksMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    ChargebacksImmediatelyAvailable$inboundSchema
  ).optional(),
});

/** @internal */
export type GetBalanceReportChargebacks$Outbound = {
  pending?: ChargebacksPending$Outbound | undefined;
  movedToAvailable?: ChargebacksMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: ChargebacksImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const GetBalanceReportChargebacks$outboundSchema: z.ZodType<
  GetBalanceReportChargebacks$Outbound,
  z.ZodTypeDef,
  GetBalanceReportChargebacks
> = z.object({
  pending: z.lazy(() => ChargebacksPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => ChargebacksMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    ChargebacksImmediatelyAvailable$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportChargebacks$ {
  /** @deprecated use `GetBalanceReportChargebacks$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportChargebacks$inboundSchema;
  /** @deprecated use `GetBalanceReportChargebacks$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportChargebacks$outboundSchema;
  /** @deprecated use `GetBalanceReportChargebacks$Outbound` instead. */
  export type Outbound = GetBalanceReportChargebacks$Outbound;
}

export function getBalanceReportChargebacksToJSON(
  getBalanceReportChargebacks: GetBalanceReportChargebacks,
): string {
  return JSON.stringify(
    GetBalanceReportChargebacks$outboundSchema.parse(
      getBalanceReportChargebacks,
    ),
  );
}

export function getBalanceReportChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportChargebacks' from JSON`,
  );
}

/** @internal */
export const CapitalPendingAmount$inboundSchema: z.ZodType<
  CapitalPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CapitalPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CapitalPendingAmount$outboundSchema: z.ZodType<
  CapitalPendingAmount$Outbound,
  z.ZodTypeDef,
  CapitalPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalPendingAmount$ {
  /** @deprecated use `CapitalPendingAmount$inboundSchema` instead. */
  export const inboundSchema = CapitalPendingAmount$inboundSchema;
  /** @deprecated use `CapitalPendingAmount$outboundSchema` instead. */
  export const outboundSchema = CapitalPendingAmount$outboundSchema;
  /** @deprecated use `CapitalPendingAmount$Outbound` instead. */
  export type Outbound = CapitalPendingAmount$Outbound;
}

export function capitalPendingAmountToJSON(
  capitalPendingAmount: CapitalPendingAmount,
): string {
  return JSON.stringify(
    CapitalPendingAmount$outboundSchema.parse(capitalPendingAmount),
  );
}

export function capitalPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<CapitalPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalPendingAmount' from JSON`,
  );
}

/** @internal */
export const CapitalPendingSubTotal1$inboundSchema: z.ZodType<
  CapitalPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CapitalPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalPendingSubTotal1$outboundSchema: z.ZodType<
  CapitalPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  CapitalPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalPendingSubTotal1$ {
  /** @deprecated use `CapitalPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = CapitalPendingSubTotal1$inboundSchema;
  /** @deprecated use `CapitalPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = CapitalPendingSubTotal1$outboundSchema;
  /** @deprecated use `CapitalPendingSubTotal1$Outbound` instead. */
  export type Outbound = CapitalPendingSubTotal1$Outbound;
}

export function capitalPendingSubTotal1ToJSON(
  capitalPendingSubTotal1: CapitalPendingSubTotal1,
): string {
  return JSON.stringify(
    CapitalPendingSubTotal1$outboundSchema.parse(capitalPendingSubTotal1),
  );
}

export function capitalPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CapitalPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const CapitalPendingSubtotal2$inboundSchema: z.ZodType<
  CapitalPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CapitalPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CapitalPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<CapitalPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalPendingSubtotal2$outboundSchema: z.ZodType<
  CapitalPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  CapitalPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CapitalPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalPendingSubtotal2$ {
  /** @deprecated use `CapitalPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = CapitalPendingSubtotal2$inboundSchema;
  /** @deprecated use `CapitalPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = CapitalPendingSubtotal2$outboundSchema;
  /** @deprecated use `CapitalPendingSubtotal2$Outbound` instead. */
  export type Outbound = CapitalPendingSubtotal2$Outbound;
}

export function capitalPendingSubtotal2ToJSON(
  capitalPendingSubtotal2: CapitalPendingSubtotal2,
): string {
  return JSON.stringify(
    CapitalPendingSubtotal2$outboundSchema.parse(capitalPendingSubtotal2),
  );
}

export function capitalPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CapitalPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const CapitalPending$inboundSchema: z.ZodType<
  CapitalPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CapitalPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CapitalPending$Outbound = {
  amount?: CapitalPendingAmount$Outbound | undefined;
  subtotals?: Array<CapitalPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const CapitalPending$outboundSchema: z.ZodType<
  CapitalPending$Outbound,
  z.ZodTypeDef,
  CapitalPending
> = z.object({
  amount: z.lazy(() => CapitalPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalPending$ {
  /** @deprecated use `CapitalPending$inboundSchema` instead. */
  export const inboundSchema = CapitalPending$inboundSchema;
  /** @deprecated use `CapitalPending$outboundSchema` instead. */
  export const outboundSchema = CapitalPending$outboundSchema;
  /** @deprecated use `CapitalPending$Outbound` instead. */
  export type Outbound = CapitalPending$Outbound;
}

export function capitalPendingToJSON(capitalPending: CapitalPending): string {
  return JSON.stringify(CapitalPending$outboundSchema.parse(capitalPending));
}

export function capitalPendingFromJSON(
  jsonString: string,
): SafeParseResult<CapitalPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalPending' from JSON`,
  );
}

/** @internal */
export const CapitalMovedToAvailableAmount$inboundSchema: z.ZodType<
  CapitalMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CapitalMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CapitalMovedToAvailableAmount$outboundSchema: z.ZodType<
  CapitalMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  CapitalMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalMovedToAvailableAmount$ {
  /** @deprecated use `CapitalMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = CapitalMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `CapitalMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = CapitalMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `CapitalMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = CapitalMovedToAvailableAmount$Outbound;
}

export function capitalMovedToAvailableAmountToJSON(
  capitalMovedToAvailableAmount: CapitalMovedToAvailableAmount,
): string {
  return JSON.stringify(
    CapitalMovedToAvailableAmount$outboundSchema.parse(
      capitalMovedToAvailableAmount,
    ),
  );
}

export function capitalMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<CapitalMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const CapitalMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  CapitalMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CapitalMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  CapitalMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  CapitalMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalMovedToAvailableSubTotal1$ {
  /** @deprecated use `CapitalMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = CapitalMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `CapitalMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema = CapitalMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `CapitalMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = CapitalMovedToAvailableSubTotal1$Outbound;
}

export function capitalMovedToAvailableSubTotal1ToJSON(
  capitalMovedToAvailableSubTotal1: CapitalMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    CapitalMovedToAvailableSubTotal1$outboundSchema.parse(
      capitalMovedToAvailableSubTotal1,
    ),
  );
}

export function capitalMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CapitalMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const CapitalMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  CapitalMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CapitalMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CapitalMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<CapitalMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  CapitalMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  CapitalMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CapitalMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalMovedToAvailableSubtotal2$ {
  /** @deprecated use `CapitalMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = CapitalMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `CapitalMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema = CapitalMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `CapitalMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = CapitalMovedToAvailableSubtotal2$Outbound;
}

export function capitalMovedToAvailableSubtotal2ToJSON(
  capitalMovedToAvailableSubtotal2: CapitalMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    CapitalMovedToAvailableSubtotal2$outboundSchema.parse(
      capitalMovedToAvailableSubtotal2,
    ),
  );
}

export function capitalMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CapitalMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const CapitalMovedToAvailable$inboundSchema: z.ZodType<
  CapitalMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CapitalMovedToAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CapitalMovedToAvailable$Outbound = {
  amount?: CapitalMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<CapitalMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CapitalMovedToAvailable$outboundSchema: z.ZodType<
  CapitalMovedToAvailable$Outbound,
  z.ZodTypeDef,
  CapitalMovedToAvailable
> = z.object({
  amount: z.lazy(() => CapitalMovedToAvailableAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalMovedToAvailable$ {
  /** @deprecated use `CapitalMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = CapitalMovedToAvailable$inboundSchema;
  /** @deprecated use `CapitalMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = CapitalMovedToAvailable$outboundSchema;
  /** @deprecated use `CapitalMovedToAvailable$Outbound` instead. */
  export type Outbound = CapitalMovedToAvailable$Outbound;
}

export function capitalMovedToAvailableToJSON(
  capitalMovedToAvailable: CapitalMovedToAvailable,
): string {
  return JSON.stringify(
    CapitalMovedToAvailable$outboundSchema.parse(capitalMovedToAvailable),
  );
}

export function capitalMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<CapitalMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const CapitalImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  CapitalImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CapitalImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CapitalImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  CapitalImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  CapitalImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalImmediatelyAvailableAmount$ {
  /** @deprecated use `CapitalImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = CapitalImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    CapitalImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = CapitalImmediatelyAvailableAmount$Outbound;
}

export function capitalImmediatelyAvailableAmountToJSON(
  capitalImmediatelyAvailableAmount: CapitalImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    CapitalImmediatelyAvailableAmount$outboundSchema.parse(
      capitalImmediatelyAvailableAmount,
    ),
  );
}

export function capitalImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<CapitalImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const CapitalImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  CapitalImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CapitalImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  CapitalImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  CapitalImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `CapitalImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    CapitalImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    CapitalImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = CapitalImmediatelyAvailableSubTotal1$Outbound;
}

export function capitalImmediatelyAvailableSubTotal1ToJSON(
  capitalImmediatelyAvailableSubTotal1: CapitalImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    CapitalImmediatelyAvailableSubTotal1$outboundSchema.parse(
      capitalImmediatelyAvailableSubTotal1,
    ),
  );
}

export function capitalImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CapitalImmediatelyAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CapitalImmediatelyAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const CapitalImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  CapitalImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CapitalImmediatelyAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CapitalImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<CapitalImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CapitalImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  CapitalImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  CapitalImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CapitalImmediatelyAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `CapitalImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    CapitalImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    CapitalImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = CapitalImmediatelyAvailableSubtotal2$Outbound;
}

export function capitalImmediatelyAvailableSubtotal2ToJSON(
  capitalImmediatelyAvailableSubtotal2: CapitalImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    CapitalImmediatelyAvailableSubtotal2$outboundSchema.parse(
      capitalImmediatelyAvailableSubtotal2,
    ),
  );
}

export function capitalImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CapitalImmediatelyAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CapitalImmediatelyAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const CapitalImmediatelyAvailable$inboundSchema: z.ZodType<
  CapitalImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CapitalImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalImmediatelyAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CapitalImmediatelyAvailable$Outbound = {
  amount?: CapitalImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<CapitalImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CapitalImmediatelyAvailable$outboundSchema: z.ZodType<
  CapitalImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  CapitalImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => CapitalImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CapitalImmediatelyAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalImmediatelyAvailable$ {
  /** @deprecated use `CapitalImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = CapitalImmediatelyAvailable$inboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = CapitalImmediatelyAvailable$outboundSchema;
  /** @deprecated use `CapitalImmediatelyAvailable$Outbound` instead. */
  export type Outbound = CapitalImmediatelyAvailable$Outbound;
}

export function capitalImmediatelyAvailableToJSON(
  capitalImmediatelyAvailable: CapitalImmediatelyAvailable,
): string {
  return JSON.stringify(
    CapitalImmediatelyAvailable$outboundSchema.parse(
      capitalImmediatelyAvailable,
    ),
  );
}

export function capitalImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<CapitalImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const Capital$inboundSchema: z.ZodType<Capital, z.ZodTypeDef, unknown> =
  z.object({
    pending: z.lazy(() => CapitalPending$inboundSchema).optional(),
    movedToAvailable: z.lazy(() => CapitalMovedToAvailable$inboundSchema)
      .optional(),
    immediatelyAvailable: z.lazy(() =>
      CapitalImmediatelyAvailable$inboundSchema
    ).optional(),
  });

/** @internal */
export type Capital$Outbound = {
  pending?: CapitalPending$Outbound | undefined;
  movedToAvailable?: CapitalMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: CapitalImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const Capital$outboundSchema: z.ZodType<
  Capital$Outbound,
  z.ZodTypeDef,
  Capital
> = z.object({
  pending: z.lazy(() => CapitalPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => CapitalMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() => CapitalImmediatelyAvailable$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Capital$ {
  /** @deprecated use `Capital$inboundSchema` instead. */
  export const inboundSchema = Capital$inboundSchema;
  /** @deprecated use `Capital$outboundSchema` instead. */
  export const outboundSchema = Capital$outboundSchema;
  /** @deprecated use `Capital$Outbound` instead. */
  export type Outbound = Capital$Outbound;
}

export function capitalToJSON(capital: Capital): string {
  return JSON.stringify(Capital$outboundSchema.parse(capital));
}

export function capitalFromJSON(
  jsonString: string,
): SafeParseResult<Capital, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Capital$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Capital' from JSON`,
  );
}

/** @internal */
export const TransfersPendingAmount$inboundSchema: z.ZodType<
  TransfersPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TransfersPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TransfersPendingAmount$outboundSchema: z.ZodType<
  TransfersPendingAmount$Outbound,
  z.ZodTypeDef,
  TransfersPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersPendingAmount$ {
  /** @deprecated use `TransfersPendingAmount$inboundSchema` instead. */
  export const inboundSchema = TransfersPendingAmount$inboundSchema;
  /** @deprecated use `TransfersPendingAmount$outboundSchema` instead. */
  export const outboundSchema = TransfersPendingAmount$outboundSchema;
  /** @deprecated use `TransfersPendingAmount$Outbound` instead. */
  export type Outbound = TransfersPendingAmount$Outbound;
}

export function transfersPendingAmountToJSON(
  transfersPendingAmount: TransfersPendingAmount,
): string {
  return JSON.stringify(
    TransfersPendingAmount$outboundSchema.parse(transfersPendingAmount),
  );
}

export function transfersPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<TransfersPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersPendingAmount' from JSON`,
  );
}

/** @internal */
export const TransfersPendingSubTotal1$inboundSchema: z.ZodType<
  TransfersPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TransfersPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersPendingSubTotal1$outboundSchema: z.ZodType<
  TransfersPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  TransfersPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersPendingSubTotal1$ {
  /** @deprecated use `TransfersPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = TransfersPendingSubTotal1$inboundSchema;
  /** @deprecated use `TransfersPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = TransfersPendingSubTotal1$outboundSchema;
  /** @deprecated use `TransfersPendingSubTotal1$Outbound` instead. */
  export type Outbound = TransfersPendingSubTotal1$Outbound;
}

export function transfersPendingSubTotal1ToJSON(
  transfersPendingSubTotal1: TransfersPendingSubTotal1,
): string {
  return JSON.stringify(
    TransfersPendingSubTotal1$outboundSchema.parse(transfersPendingSubTotal1),
  );
}

export function transfersPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TransfersPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const TransfersPendingSubtotal2$inboundSchema: z.ZodType<
  TransfersPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TransfersPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TransfersPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<TransfersPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersPendingSubtotal2$outboundSchema: z.ZodType<
  TransfersPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  TransfersPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => TransfersPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersPendingSubtotal2$ {
  /** @deprecated use `TransfersPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = TransfersPendingSubtotal2$inboundSchema;
  /** @deprecated use `TransfersPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = TransfersPendingSubtotal2$outboundSchema;
  /** @deprecated use `TransfersPendingSubtotal2$Outbound` instead. */
  export type Outbound = TransfersPendingSubtotal2$Outbound;
}

export function transfersPendingSubtotal2ToJSON(
  transfersPendingSubtotal2: TransfersPendingSubtotal2,
): string {
  return JSON.stringify(
    TransfersPendingSubtotal2$outboundSchema.parse(transfersPendingSubtotal2),
  );
}

export function transfersPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TransfersPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const TransfersPending$inboundSchema: z.ZodType<
  TransfersPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TransfersPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TransfersPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TransfersPending$Outbound = {
  amount?: TransfersPendingAmount$Outbound | undefined;
  subtotals?: Array<TransfersPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const TransfersPending$outboundSchema: z.ZodType<
  TransfersPending$Outbound,
  z.ZodTypeDef,
  TransfersPending
> = z.object({
  amount: z.lazy(() => TransfersPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TransfersPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersPending$ {
  /** @deprecated use `TransfersPending$inboundSchema` instead. */
  export const inboundSchema = TransfersPending$inboundSchema;
  /** @deprecated use `TransfersPending$outboundSchema` instead. */
  export const outboundSchema = TransfersPending$outboundSchema;
  /** @deprecated use `TransfersPending$Outbound` instead. */
  export type Outbound = TransfersPending$Outbound;
}

export function transfersPendingToJSON(
  transfersPending: TransfersPending,
): string {
  return JSON.stringify(
    TransfersPending$outboundSchema.parse(transfersPending),
  );
}

export function transfersPendingFromJSON(
  jsonString: string,
): SafeParseResult<TransfersPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersPending' from JSON`,
  );
}

/** @internal */
export const TransfersMovedToAvailableAmount$inboundSchema: z.ZodType<
  TransfersMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TransfersMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TransfersMovedToAvailableAmount$outboundSchema: z.ZodType<
  TransfersMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  TransfersMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersMovedToAvailableAmount$ {
  /** @deprecated use `TransfersMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = TransfersMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `TransfersMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = TransfersMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `TransfersMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = TransfersMovedToAvailableAmount$Outbound;
}

export function transfersMovedToAvailableAmountToJSON(
  transfersMovedToAvailableAmount: TransfersMovedToAvailableAmount,
): string {
  return JSON.stringify(
    TransfersMovedToAvailableAmount$outboundSchema.parse(
      transfersMovedToAvailableAmount,
    ),
  );
}

export function transfersMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<TransfersMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const TransfersMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  TransfersMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TransfersMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  TransfersMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  TransfersMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersMovedToAvailableSubTotal1$ {
  /** @deprecated use `TransfersMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = TransfersMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `TransfersMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    TransfersMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `TransfersMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = TransfersMovedToAvailableSubTotal1$Outbound;
}

export function transfersMovedToAvailableSubTotal1ToJSON(
  transfersMovedToAvailableSubTotal1: TransfersMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    TransfersMovedToAvailableSubTotal1$outboundSchema.parse(
      transfersMovedToAvailableSubTotal1,
    ),
  );
}

export function transfersMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TransfersMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TransfersMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const TransfersMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  TransfersMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TransfersMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TransfersMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<TransfersMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  TransfersMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  TransfersMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => TransfersMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersMovedToAvailableSubtotal2$ {
  /** @deprecated use `TransfersMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = TransfersMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `TransfersMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    TransfersMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `TransfersMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = TransfersMovedToAvailableSubtotal2$Outbound;
}

export function transfersMovedToAvailableSubtotal2ToJSON(
  transfersMovedToAvailableSubtotal2: TransfersMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    TransfersMovedToAvailableSubtotal2$outboundSchema.parse(
      transfersMovedToAvailableSubtotal2,
    ),
  );
}

export function transfersMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TransfersMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TransfersMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const TransfersMovedToAvailable$inboundSchema: z.ZodType<
  TransfersMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TransfersMovedToAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TransfersMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TransfersMovedToAvailable$Outbound = {
  amount?: TransfersMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<TransfersMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const TransfersMovedToAvailable$outboundSchema: z.ZodType<
  TransfersMovedToAvailable$Outbound,
  z.ZodTypeDef,
  TransfersMovedToAvailable
> = z.object({
  amount: z.lazy(() => TransfersMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TransfersMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersMovedToAvailable$ {
  /** @deprecated use `TransfersMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = TransfersMovedToAvailable$inboundSchema;
  /** @deprecated use `TransfersMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = TransfersMovedToAvailable$outboundSchema;
  /** @deprecated use `TransfersMovedToAvailable$Outbound` instead. */
  export type Outbound = TransfersMovedToAvailable$Outbound;
}

export function transfersMovedToAvailableToJSON(
  transfersMovedToAvailable: TransfersMovedToAvailable,
): string {
  return JSON.stringify(
    TransfersMovedToAvailable$outboundSchema.parse(transfersMovedToAvailable),
  );
}

export function transfersMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<TransfersMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const TransfersImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  TransfersImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TransfersImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TransfersImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  TransfersImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  TransfersImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersImmediatelyAvailableAmount$ {
  /** @deprecated use `TransfersImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    TransfersImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    TransfersImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = TransfersImmediatelyAvailableAmount$Outbound;
}

export function transfersImmediatelyAvailableAmountToJSON(
  transfersImmediatelyAvailableAmount: TransfersImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    TransfersImmediatelyAvailableAmount$outboundSchema.parse(
      transfersImmediatelyAvailableAmount,
    ),
  );
}

export function transfersImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<TransfersImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TransfersImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const TransfersImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  TransfersImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TransfersImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  TransfersImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  TransfersImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `TransfersImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    TransfersImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    TransfersImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = TransfersImmediatelyAvailableSubTotal1$Outbound;
}

export function transfersImmediatelyAvailableSubTotal1ToJSON(
  transfersImmediatelyAvailableSubTotal1:
    TransfersImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    TransfersImmediatelyAvailableSubTotal1$outboundSchema.parse(
      transfersImmediatelyAvailableSubTotal1,
    ),
  );
}

export function transfersImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TransfersImmediatelyAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TransfersImmediatelyAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const TransfersImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  TransfersImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TransfersImmediatelyAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TransfersImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<TransfersImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TransfersImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  TransfersImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  TransfersImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(
      z.lazy(() => TransfersImmediatelyAvailableSubTotal1$outboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `TransfersImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    TransfersImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    TransfersImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = TransfersImmediatelyAvailableSubtotal2$Outbound;
}

export function transfersImmediatelyAvailableSubtotal2ToJSON(
  transfersImmediatelyAvailableSubtotal2:
    TransfersImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    TransfersImmediatelyAvailableSubtotal2$outboundSchema.parse(
      transfersImmediatelyAvailableSubtotal2,
    ),
  );
}

export function transfersImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TransfersImmediatelyAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TransfersImmediatelyAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const TransfersImmediatelyAvailable$inboundSchema: z.ZodType<
  TransfersImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TransfersImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TransfersImmediatelyAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TransfersImmediatelyAvailable$Outbound = {
  amount?: TransfersImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<TransfersImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const TransfersImmediatelyAvailable$outboundSchema: z.ZodType<
  TransfersImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  TransfersImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => TransfersImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => TransfersImmediatelyAvailableSubtotal2$outboundSchema),
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransfersImmediatelyAvailable$ {
  /** @deprecated use `TransfersImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = TransfersImmediatelyAvailable$inboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = TransfersImmediatelyAvailable$outboundSchema;
  /** @deprecated use `TransfersImmediatelyAvailable$Outbound` instead. */
  export type Outbound = TransfersImmediatelyAvailable$Outbound;
}

export function transfersImmediatelyAvailableToJSON(
  transfersImmediatelyAvailable: TransfersImmediatelyAvailable,
): string {
  return JSON.stringify(
    TransfersImmediatelyAvailable$outboundSchema.parse(
      transfersImmediatelyAvailable,
    ),
  );
}

export function transfersImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<TransfersImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransfersImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransfersImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const Transfers$inboundSchema: z.ZodType<
  Transfers,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => TransfersPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => TransfersMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    TransfersImmediatelyAvailable$inboundSchema
  ).optional(),
});

/** @internal */
export type Transfers$Outbound = {
  pending?: TransfersPending$Outbound | undefined;
  movedToAvailable?: TransfersMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: TransfersImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const Transfers$outboundSchema: z.ZodType<
  Transfers$Outbound,
  z.ZodTypeDef,
  Transfers
> = z.object({
  pending: z.lazy(() => TransfersPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => TransfersMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    TransfersImmediatelyAvailable$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Transfers$ {
  /** @deprecated use `Transfers$inboundSchema` instead. */
  export const inboundSchema = Transfers$inboundSchema;
  /** @deprecated use `Transfers$outboundSchema` instead. */
  export const outboundSchema = Transfers$outboundSchema;
  /** @deprecated use `Transfers$Outbound` instead. */
  export type Outbound = Transfers$Outbound;
}

export function transfersToJSON(transfers: Transfers): string {
  return JSON.stringify(Transfers$outboundSchema.parse(transfers));
}

export function transfersFromJSON(
  jsonString: string,
): SafeParseResult<Transfers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transfers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transfers' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsPendingAmount$inboundSchema: z.ZodType<
  FeePrepaymentsPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type FeePrepaymentsPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const FeePrepaymentsPendingAmount$outboundSchema: z.ZodType<
  FeePrepaymentsPendingAmount$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsPendingAmount$ {
  /** @deprecated use `FeePrepaymentsPendingAmount$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsPendingAmount$inboundSchema;
  /** @deprecated use `FeePrepaymentsPendingAmount$outboundSchema` instead. */
  export const outboundSchema = FeePrepaymentsPendingAmount$outboundSchema;
  /** @deprecated use `FeePrepaymentsPendingAmount$Outbound` instead. */
  export type Outbound = FeePrepaymentsPendingAmount$Outbound;
}

export function feePrepaymentsPendingAmountToJSON(
  feePrepaymentsPendingAmount: FeePrepaymentsPendingAmount,
): string {
  return JSON.stringify(
    FeePrepaymentsPendingAmount$outboundSchema.parse(
      feePrepaymentsPendingAmount,
    ),
  );
}

export function feePrepaymentsPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepaymentsPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsPendingAmount' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsPendingSubTotal1$inboundSchema: z.ZodType<
  FeePrepaymentsPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type FeePrepaymentsPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsPendingSubTotal1$outboundSchema: z.ZodType<
  FeePrepaymentsPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsPendingSubTotal1$ {
  /** @deprecated use `FeePrepaymentsPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsPendingSubTotal1$inboundSchema;
  /** @deprecated use `FeePrepaymentsPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = FeePrepaymentsPendingSubTotal1$outboundSchema;
  /** @deprecated use `FeePrepaymentsPendingSubTotal1$Outbound` instead. */
  export type Outbound = FeePrepaymentsPendingSubTotal1$Outbound;
}

export function feePrepaymentsPendingSubTotal1ToJSON(
  feePrepaymentsPendingSubTotal1: FeePrepaymentsPendingSubTotal1,
): string {
  return JSON.stringify(
    FeePrepaymentsPendingSubTotal1$outboundSchema.parse(
      feePrepaymentsPendingSubTotal1,
    ),
  );
}

export function feePrepaymentsPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepaymentsPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsPendingSubtotal2$inboundSchema: z.ZodType<
  FeePrepaymentsPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => FeePrepaymentsPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type FeePrepaymentsPendingSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<FeePrepaymentsPendingSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsPendingSubtotal2$outboundSchema: z.ZodType<
  FeePrepaymentsPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => FeePrepaymentsPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsPendingSubtotal2$ {
  /** @deprecated use `FeePrepaymentsPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsPendingSubtotal2$inboundSchema;
  /** @deprecated use `FeePrepaymentsPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = FeePrepaymentsPendingSubtotal2$outboundSchema;
  /** @deprecated use `FeePrepaymentsPendingSubtotal2$Outbound` instead. */
  export type Outbound = FeePrepaymentsPendingSubtotal2$Outbound;
}

export function feePrepaymentsPendingSubtotal2ToJSON(
  feePrepaymentsPendingSubtotal2: FeePrepaymentsPendingSubtotal2,
): string {
  return JSON.stringify(
    FeePrepaymentsPendingSubtotal2$outboundSchema.parse(
      feePrepaymentsPendingSubtotal2,
    ),
  );
}

export function feePrepaymentsPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepaymentsPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsPending$inboundSchema: z.ZodType<
  FeePrepaymentsPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => FeePrepaymentsPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => FeePrepaymentsPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type FeePrepaymentsPending$Outbound = {
  amount?: FeePrepaymentsPendingAmount$Outbound | undefined;
  subtotals?: Array<FeePrepaymentsPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const FeePrepaymentsPending$outboundSchema: z.ZodType<
  FeePrepaymentsPending$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsPending
> = z.object({
  amount: z.lazy(() => FeePrepaymentsPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => FeePrepaymentsPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsPending$ {
  /** @deprecated use `FeePrepaymentsPending$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsPending$inboundSchema;
  /** @deprecated use `FeePrepaymentsPending$outboundSchema` instead. */
  export const outboundSchema = FeePrepaymentsPending$outboundSchema;
  /** @deprecated use `FeePrepaymentsPending$Outbound` instead. */
  export type Outbound = FeePrepaymentsPending$Outbound;
}

export function feePrepaymentsPendingToJSON(
  feePrepaymentsPending: FeePrepaymentsPending,
): string {
  return JSON.stringify(
    FeePrepaymentsPending$outboundSchema.parse(feePrepaymentsPending),
  );
}

export function feePrepaymentsPendingFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepaymentsPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsPending' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsMovedToAvailableAmount$inboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type FeePrepaymentsMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const FeePrepaymentsMovedToAvailableAmount$outboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsMovedToAvailableAmount$ {
  /** @deprecated use `FeePrepaymentsMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = FeePrepaymentsMovedToAvailableAmount$Outbound;
}

export function feePrepaymentsMovedToAvailableAmountToJSON(
  feePrepaymentsMovedToAvailableAmount: FeePrepaymentsMovedToAvailableAmount,
): string {
  return JSON.stringify(
    FeePrepaymentsMovedToAvailableAmount$outboundSchema.parse(
      feePrepaymentsMovedToAvailableAmount,
    ),
  );
}

export function feePrepaymentsMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type FeePrepaymentsMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsMovedToAvailableSubTotal1$ {
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = FeePrepaymentsMovedToAvailableSubTotal1$Outbound;
}

export function feePrepaymentsMovedToAvailableSubTotal1ToJSON(
  feePrepaymentsMovedToAvailableSubTotal1:
    FeePrepaymentsMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    FeePrepaymentsMovedToAvailableSubTotal1$outboundSchema.parse(
      feePrepaymentsMovedToAvailableSubTotal1,
    ),
  );
}

export function feePrepaymentsMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  FeePrepaymentsMovedToAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsMovedToAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FeePrepaymentsMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(
      z.lazy(() => FeePrepaymentsMovedToAvailableSubTotal1$inboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type FeePrepaymentsMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<FeePrepaymentsMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(
      z.lazy(() => FeePrepaymentsMovedToAvailableSubTotal1$outboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsMovedToAvailableSubtotal2$ {
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = FeePrepaymentsMovedToAvailableSubtotal2$Outbound;
}

export function feePrepaymentsMovedToAvailableSubtotal2ToJSON(
  feePrepaymentsMovedToAvailableSubtotal2:
    FeePrepaymentsMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    FeePrepaymentsMovedToAvailableSubtotal2$outboundSchema.parse(
      feePrepaymentsMovedToAvailableSubtotal2,
    ),
  );
}

export function feePrepaymentsMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  FeePrepaymentsMovedToAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsMovedToAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FeePrepaymentsMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsMovedToAvailable$inboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => FeePrepaymentsMovedToAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => FeePrepaymentsMovedToAvailableSubtotal2$inboundSchema),
    ),
  ).optional(),
});

/** @internal */
export type FeePrepaymentsMovedToAvailable$Outbound = {
  amount?: FeePrepaymentsMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<FeePrepaymentsMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const FeePrepaymentsMovedToAvailable$outboundSchema: z.ZodType<
  FeePrepaymentsMovedToAvailable$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsMovedToAvailable
> = z.object({
  amount: z.lazy(() => FeePrepaymentsMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => FeePrepaymentsMovedToAvailableSubtotal2$outboundSchema),
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsMovedToAvailable$ {
  /** @deprecated use `FeePrepaymentsMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsMovedToAvailable$inboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = FeePrepaymentsMovedToAvailable$outboundSchema;
  /** @deprecated use `FeePrepaymentsMovedToAvailable$Outbound` instead. */
  export type Outbound = FeePrepaymentsMovedToAvailable$Outbound;
}

export function feePrepaymentsMovedToAvailableToJSON(
  feePrepaymentsMovedToAvailable: FeePrepaymentsMovedToAvailable,
): string {
  return JSON.stringify(
    FeePrepaymentsMovedToAvailable$outboundSchema.parse(
      feePrepaymentsMovedToAvailable,
    ),
  );
}

export function feePrepaymentsMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepaymentsMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  FeePrepaymentsImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type FeePrepaymentsImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const FeePrepaymentsImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  FeePrepaymentsImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsImmediatelyAvailableAmount$ {
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = FeePrepaymentsImmediatelyAvailableAmount$Outbound;
}

export function feePrepaymentsImmediatelyAvailableAmountToJSON(
  feePrepaymentsImmediatelyAvailableAmount:
    FeePrepaymentsImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    FeePrepaymentsImmediatelyAvailableAmount$outboundSchema.parse(
      feePrepaymentsImmediatelyAvailableAmount,
    ),
  );
}

export function feePrepaymentsImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  FeePrepaymentsImmediatelyAvailableAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsImmediatelyAvailableAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FeePrepaymentsImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsImmediatelyAvailableSubTotal1$inboundSchema:
  z.ZodType<
    FeePrepaymentsImmediatelyAvailableSubTotal1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  });

/** @internal */
export type FeePrepaymentsImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsImmediatelyAvailableSubTotal1$outboundSchema:
  z.ZodType<
    FeePrepaymentsImmediatelyAvailableSubTotal1$Outbound,
    z.ZodTypeDef,
    FeePrepaymentsImmediatelyAvailableSubTotal1
  > = z.object({
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = FeePrepaymentsImmediatelyAvailableSubTotal1$Outbound;
}

export function feePrepaymentsImmediatelyAvailableSubTotal1ToJSON(
  feePrepaymentsImmediatelyAvailableSubTotal1:
    FeePrepaymentsImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    FeePrepaymentsImmediatelyAvailableSubTotal1$outboundSchema.parse(
      feePrepaymentsImmediatelyAvailableSubTotal1,
    ),
  );
}

export function feePrepaymentsImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  FeePrepaymentsImmediatelyAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsImmediatelyAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FeePrepaymentsImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsImmediatelyAvailableSubtotal2$inboundSchema:
  z.ZodType<
    FeePrepaymentsImmediatelyAvailableSubtotal2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    "sub-totals": z.nullable(
      z.array(z.lazy(() =>
        FeePrepaymentsImmediatelyAvailableSubTotal1$inboundSchema
      )),
    ).optional(),
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "sub-totals": "subTotals",
    });
  });

/** @internal */
export type FeePrepaymentsImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<FeePrepaymentsImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const FeePrepaymentsImmediatelyAvailableSubtotal2$outboundSchema:
  z.ZodType<
    FeePrepaymentsImmediatelyAvailableSubtotal2$Outbound,
    z.ZodTypeDef,
    FeePrepaymentsImmediatelyAvailableSubtotal2
  > = z.object({
    subTotals: z.nullable(
      z.array(z.lazy(() =>
        FeePrepaymentsImmediatelyAvailableSubTotal1$outboundSchema
      )),
    ).optional(),
    count: z.number().int().optional(),
    method: z.nullable(z.string()).optional(),
    cardIssuer: z.nullable(z.string()).optional(),
    cardAudience: z.nullable(z.string()).optional(),
    cardRegion: z.nullable(z.string()).optional(),
    feeType: z.nullable(z.string()).optional(),
    prepaymentPartType: z.nullable(z.string()).optional(),
    transactionType: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      subTotals: "sub-totals",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    FeePrepaymentsImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = FeePrepaymentsImmediatelyAvailableSubtotal2$Outbound;
}

export function feePrepaymentsImmediatelyAvailableSubtotal2ToJSON(
  feePrepaymentsImmediatelyAvailableSubtotal2:
    FeePrepaymentsImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    FeePrepaymentsImmediatelyAvailableSubtotal2$outboundSchema.parse(
      feePrepaymentsImmediatelyAvailableSubtotal2,
    ),
  );
}

export function feePrepaymentsImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  FeePrepaymentsImmediatelyAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsImmediatelyAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FeePrepaymentsImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const FeePrepaymentsImmediatelyAvailable$inboundSchema: z.ZodType<
  FeePrepaymentsImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => FeePrepaymentsImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() =>
      FeePrepaymentsImmediatelyAvailableSubtotal2$inboundSchema
    )),
  ).optional(),
});

/** @internal */
export type FeePrepaymentsImmediatelyAvailable$Outbound = {
  amount?: FeePrepaymentsImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<FeePrepaymentsImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const FeePrepaymentsImmediatelyAvailable$outboundSchema: z.ZodType<
  FeePrepaymentsImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  FeePrepaymentsImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => FeePrepaymentsImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() =>
      FeePrepaymentsImmediatelyAvailableSubtotal2$outboundSchema
    )),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepaymentsImmediatelyAvailable$ {
  /** @deprecated use `FeePrepaymentsImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = FeePrepaymentsImmediatelyAvailable$inboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema =
    FeePrepaymentsImmediatelyAvailable$outboundSchema;
  /** @deprecated use `FeePrepaymentsImmediatelyAvailable$Outbound` instead. */
  export type Outbound = FeePrepaymentsImmediatelyAvailable$Outbound;
}

export function feePrepaymentsImmediatelyAvailableToJSON(
  feePrepaymentsImmediatelyAvailable: FeePrepaymentsImmediatelyAvailable,
): string {
  return JSON.stringify(
    FeePrepaymentsImmediatelyAvailable$outboundSchema.parse(
      feePrepaymentsImmediatelyAvailable,
    ),
  );
}

export function feePrepaymentsImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepaymentsImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FeePrepaymentsImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepaymentsImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const FeePrepayments$inboundSchema: z.ZodType<
  FeePrepayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => FeePrepaymentsPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => FeePrepaymentsMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    FeePrepaymentsImmediatelyAvailable$inboundSchema
  ).optional(),
});

/** @internal */
export type FeePrepayments$Outbound = {
  pending?: FeePrepaymentsPending$Outbound | undefined;
  movedToAvailable?: FeePrepaymentsMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?:
    | FeePrepaymentsImmediatelyAvailable$Outbound
    | undefined;
};

/** @internal */
export const FeePrepayments$outboundSchema: z.ZodType<
  FeePrepayments$Outbound,
  z.ZodTypeDef,
  FeePrepayments
> = z.object({
  pending: z.lazy(() => FeePrepaymentsPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => FeePrepaymentsMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    FeePrepaymentsImmediatelyAvailable$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeePrepayments$ {
  /** @deprecated use `FeePrepayments$inboundSchema` instead. */
  export const inboundSchema = FeePrepayments$inboundSchema;
  /** @deprecated use `FeePrepayments$outboundSchema` instead. */
  export const outboundSchema = FeePrepayments$outboundSchema;
  /** @deprecated use `FeePrepayments$Outbound` instead. */
  export type Outbound = FeePrepayments$Outbound;
}

export function feePrepaymentsToJSON(feePrepayments: FeePrepayments): string {
  return JSON.stringify(FeePrepayments$outboundSchema.parse(feePrepayments));
}

export function feePrepaymentsFromJSON(
  jsonString: string,
): SafeParseResult<FeePrepayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeePrepayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeePrepayments' from JSON`,
  );
}

/** @internal */
export const CorrectionsPendingAmount$inboundSchema: z.ZodType<
  CorrectionsPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CorrectionsPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CorrectionsPendingAmount$outboundSchema: z.ZodType<
  CorrectionsPendingAmount$Outbound,
  z.ZodTypeDef,
  CorrectionsPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsPendingAmount$ {
  /** @deprecated use `CorrectionsPendingAmount$inboundSchema` instead. */
  export const inboundSchema = CorrectionsPendingAmount$inboundSchema;
  /** @deprecated use `CorrectionsPendingAmount$outboundSchema` instead. */
  export const outboundSchema = CorrectionsPendingAmount$outboundSchema;
  /** @deprecated use `CorrectionsPendingAmount$Outbound` instead. */
  export type Outbound = CorrectionsPendingAmount$Outbound;
}

export function correctionsPendingAmountToJSON(
  correctionsPendingAmount: CorrectionsPendingAmount,
): string {
  return JSON.stringify(
    CorrectionsPendingAmount$outboundSchema.parse(correctionsPendingAmount),
  );
}

export function correctionsPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsPendingAmount' from JSON`,
  );
}

/** @internal */
export const CorrectionsPendingSubTotal1$inboundSchema: z.ZodType<
  CorrectionsPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CorrectionsPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsPendingSubTotal1$outboundSchema: z.ZodType<
  CorrectionsPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  CorrectionsPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsPendingSubTotal1$ {
  /** @deprecated use `CorrectionsPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = CorrectionsPendingSubTotal1$inboundSchema;
  /** @deprecated use `CorrectionsPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = CorrectionsPendingSubTotal1$outboundSchema;
  /** @deprecated use `CorrectionsPendingSubTotal1$Outbound` instead. */
  export type Outbound = CorrectionsPendingSubTotal1$Outbound;
}

export function correctionsPendingSubTotal1ToJSON(
  correctionsPendingSubTotal1: CorrectionsPendingSubTotal1,
): string {
  return JSON.stringify(
    CorrectionsPendingSubTotal1$outboundSchema.parse(
      correctionsPendingSubTotal1,
    ),
  );
}

export function correctionsPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const CorrectionsPendingSubtotal2$inboundSchema: z.ZodType<
  CorrectionsPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CorrectionsPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CorrectionsPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<CorrectionsPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsPendingSubtotal2$outboundSchema: z.ZodType<
  CorrectionsPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  CorrectionsPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CorrectionsPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsPendingSubtotal2$ {
  /** @deprecated use `CorrectionsPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = CorrectionsPendingSubtotal2$inboundSchema;
  /** @deprecated use `CorrectionsPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = CorrectionsPendingSubtotal2$outboundSchema;
  /** @deprecated use `CorrectionsPendingSubtotal2$Outbound` instead. */
  export type Outbound = CorrectionsPendingSubtotal2$Outbound;
}

export function correctionsPendingSubtotal2ToJSON(
  correctionsPendingSubtotal2: CorrectionsPendingSubtotal2,
): string {
  return JSON.stringify(
    CorrectionsPendingSubtotal2$outboundSchema.parse(
      correctionsPendingSubtotal2,
    ),
  );
}

export function correctionsPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const CorrectionsPending$inboundSchema: z.ZodType<
  CorrectionsPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CorrectionsPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CorrectionsPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CorrectionsPending$Outbound = {
  amount?: CorrectionsPendingAmount$Outbound | undefined;
  subtotals?: Array<CorrectionsPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const CorrectionsPending$outboundSchema: z.ZodType<
  CorrectionsPending$Outbound,
  z.ZodTypeDef,
  CorrectionsPending
> = z.object({
  amount: z.lazy(() => CorrectionsPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CorrectionsPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsPending$ {
  /** @deprecated use `CorrectionsPending$inboundSchema` instead. */
  export const inboundSchema = CorrectionsPending$inboundSchema;
  /** @deprecated use `CorrectionsPending$outboundSchema` instead. */
  export const outboundSchema = CorrectionsPending$outboundSchema;
  /** @deprecated use `CorrectionsPending$Outbound` instead. */
  export type Outbound = CorrectionsPending$Outbound;
}

export function correctionsPendingToJSON(
  correctionsPending: CorrectionsPending,
): string {
  return JSON.stringify(
    CorrectionsPending$outboundSchema.parse(correctionsPending),
  );
}

export function correctionsPendingFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsPending' from JSON`,
  );
}

/** @internal */
export const CorrectionsMovedToAvailableAmount$inboundSchema: z.ZodType<
  CorrectionsMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CorrectionsMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CorrectionsMovedToAvailableAmount$outboundSchema: z.ZodType<
  CorrectionsMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  CorrectionsMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsMovedToAvailableAmount$ {
  /** @deprecated use `CorrectionsMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = CorrectionsMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = CorrectionsMovedToAvailableAmount$Outbound;
}

export function correctionsMovedToAvailableAmountToJSON(
  correctionsMovedToAvailableAmount: CorrectionsMovedToAvailableAmount,
): string {
  return JSON.stringify(
    CorrectionsMovedToAvailableAmount$outboundSchema.parse(
      correctionsMovedToAvailableAmount,
    ),
  );
}

export function correctionsMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const CorrectionsMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  CorrectionsMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CorrectionsMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  CorrectionsMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  CorrectionsMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsMovedToAvailableSubTotal1$ {
  /** @deprecated use `CorrectionsMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    CorrectionsMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = CorrectionsMovedToAvailableSubTotal1$Outbound;
}

export function correctionsMovedToAvailableSubTotal1ToJSON(
  correctionsMovedToAvailableSubTotal1: CorrectionsMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    CorrectionsMovedToAvailableSubTotal1$outboundSchema.parse(
      correctionsMovedToAvailableSubTotal1,
    ),
  );
}

export function correctionsMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CorrectionsMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const CorrectionsMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  CorrectionsMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => CorrectionsMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CorrectionsMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<CorrectionsMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  CorrectionsMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  CorrectionsMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => CorrectionsMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsMovedToAvailableSubtotal2$ {
  /** @deprecated use `CorrectionsMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    CorrectionsMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = CorrectionsMovedToAvailableSubtotal2$Outbound;
}

export function correctionsMovedToAvailableSubtotal2ToJSON(
  correctionsMovedToAvailableSubtotal2: CorrectionsMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    CorrectionsMovedToAvailableSubtotal2$outboundSchema.parse(
      correctionsMovedToAvailableSubtotal2,
    ),
  );
}

export function correctionsMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CorrectionsMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const CorrectionsMovedToAvailable$inboundSchema: z.ZodType<
  CorrectionsMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CorrectionsMovedToAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CorrectionsMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type CorrectionsMovedToAvailable$Outbound = {
  amount?: CorrectionsMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<CorrectionsMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CorrectionsMovedToAvailable$outboundSchema: z.ZodType<
  CorrectionsMovedToAvailable$Outbound,
  z.ZodTypeDef,
  CorrectionsMovedToAvailable
> = z.object({
  amount: z.lazy(() => CorrectionsMovedToAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => CorrectionsMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsMovedToAvailable$ {
  /** @deprecated use `CorrectionsMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = CorrectionsMovedToAvailable$inboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = CorrectionsMovedToAvailable$outboundSchema;
  /** @deprecated use `CorrectionsMovedToAvailable$Outbound` instead. */
  export type Outbound = CorrectionsMovedToAvailable$Outbound;
}

export function correctionsMovedToAvailableToJSON(
  correctionsMovedToAvailable: CorrectionsMovedToAvailable,
): string {
  return JSON.stringify(
    CorrectionsMovedToAvailable$outboundSchema.parse(
      correctionsMovedToAvailable,
    ),
  );
}

export function correctionsMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const CorrectionsImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CorrectionsImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CorrectionsImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  CorrectionsImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsImmediatelyAvailableAmount$ {
  /** @deprecated use `CorrectionsImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema =
    CorrectionsImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = CorrectionsImmediatelyAvailableAmount$Outbound;
}

export function correctionsImmediatelyAvailableAmountToJSON(
  correctionsImmediatelyAvailableAmount: CorrectionsImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    CorrectionsImmediatelyAvailableAmount$outboundSchema.parse(
      correctionsImmediatelyAvailableAmount,
    ),
  );
}

export function correctionsImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CorrectionsImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const CorrectionsImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type CorrectionsImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  CorrectionsImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `CorrectionsImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    CorrectionsImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = CorrectionsImmediatelyAvailableSubTotal1$Outbound;
}

export function correctionsImmediatelyAvailableSubTotal1ToJSON(
  correctionsImmediatelyAvailableSubTotal1:
    CorrectionsImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    CorrectionsImmediatelyAvailableSubTotal1$outboundSchema.parse(
      correctionsImmediatelyAvailableSubTotal1,
    ),
  );
}

export function correctionsImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<
  CorrectionsImmediatelyAvailableSubTotal1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CorrectionsImmediatelyAvailableSubTotal1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CorrectionsImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const CorrectionsImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(
      z.lazy(() => CorrectionsImmediatelyAvailableSubTotal1$inboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type CorrectionsImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<CorrectionsImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const CorrectionsImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  CorrectionsImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(
      z.lazy(() => CorrectionsImmediatelyAvailableSubTotal1$outboundSchema),
    ),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `CorrectionsImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    CorrectionsImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    CorrectionsImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = CorrectionsImmediatelyAvailableSubtotal2$Outbound;
}

export function correctionsImmediatelyAvailableSubtotal2ToJSON(
  correctionsImmediatelyAvailableSubtotal2:
    CorrectionsImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    CorrectionsImmediatelyAvailableSubtotal2$outboundSchema.parse(
      correctionsImmediatelyAvailableSubtotal2,
    ),
  );
}

export function correctionsImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<
  CorrectionsImmediatelyAvailableSubtotal2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CorrectionsImmediatelyAvailableSubtotal2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CorrectionsImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const CorrectionsImmediatelyAvailable$inboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CorrectionsImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => CorrectionsImmediatelyAvailableSubtotal2$inboundSchema),
    ),
  ).optional(),
});

/** @internal */
export type CorrectionsImmediatelyAvailable$Outbound = {
  amount?: CorrectionsImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<CorrectionsImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CorrectionsImmediatelyAvailable$outboundSchema: z.ZodType<
  CorrectionsImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  CorrectionsImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => CorrectionsImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(
      z.lazy(() => CorrectionsImmediatelyAvailableSubtotal2$outboundSchema),
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorrectionsImmediatelyAvailable$ {
  /** @deprecated use `CorrectionsImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = CorrectionsImmediatelyAvailable$inboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = CorrectionsImmediatelyAvailable$outboundSchema;
  /** @deprecated use `CorrectionsImmediatelyAvailable$Outbound` instead. */
  export type Outbound = CorrectionsImmediatelyAvailable$Outbound;
}

export function correctionsImmediatelyAvailableToJSON(
  correctionsImmediatelyAvailable: CorrectionsImmediatelyAvailable,
): string {
  return JSON.stringify(
    CorrectionsImmediatelyAvailable$outboundSchema.parse(
      correctionsImmediatelyAvailable,
    ),
  );
}

export function correctionsImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<CorrectionsImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorrectionsImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorrectionsImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const Corrections$inboundSchema: z.ZodType<
  Corrections,
  z.ZodTypeDef,
  unknown
> = z.object({
  pending: z.lazy(() => CorrectionsPending$inboundSchema).optional(),
  movedToAvailable: z.lazy(() => CorrectionsMovedToAvailable$inboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    CorrectionsImmediatelyAvailable$inboundSchema
  ).optional(),
});

/** @internal */
export type Corrections$Outbound = {
  pending?: CorrectionsPending$Outbound | undefined;
  movedToAvailable?: CorrectionsMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: CorrectionsImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const Corrections$outboundSchema: z.ZodType<
  Corrections$Outbound,
  z.ZodTypeDef,
  Corrections
> = z.object({
  pending: z.lazy(() => CorrectionsPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => CorrectionsMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() =>
    CorrectionsImmediatelyAvailable$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Corrections$ {
  /** @deprecated use `Corrections$inboundSchema` instead. */
  export const inboundSchema = Corrections$inboundSchema;
  /** @deprecated use `Corrections$outboundSchema` instead. */
  export const outboundSchema = Corrections$outboundSchema;
  /** @deprecated use `Corrections$Outbound` instead. */
  export type Outbound = Corrections$Outbound;
}

export function correctionsToJSON(corrections: Corrections): string {
  return JSON.stringify(Corrections$outboundSchema.parse(corrections));
}

export function correctionsFromJSON(
  jsonString: string,
): SafeParseResult<Corrections, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Corrections$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Corrections' from JSON`,
  );
}

/** @internal */
export const TopupsPendingAmount$inboundSchema: z.ZodType<
  TopupsPendingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TopupsPendingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TopupsPendingAmount$outboundSchema: z.ZodType<
  TopupsPendingAmount$Outbound,
  z.ZodTypeDef,
  TopupsPendingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsPendingAmount$ {
  /** @deprecated use `TopupsPendingAmount$inboundSchema` instead. */
  export const inboundSchema = TopupsPendingAmount$inboundSchema;
  /** @deprecated use `TopupsPendingAmount$outboundSchema` instead. */
  export const outboundSchema = TopupsPendingAmount$outboundSchema;
  /** @deprecated use `TopupsPendingAmount$Outbound` instead. */
  export type Outbound = TopupsPendingAmount$Outbound;
}

export function topupsPendingAmountToJSON(
  topupsPendingAmount: TopupsPendingAmount,
): string {
  return JSON.stringify(
    TopupsPendingAmount$outboundSchema.parse(topupsPendingAmount),
  );
}

export function topupsPendingAmountFromJSON(
  jsonString: string,
): SafeParseResult<TopupsPendingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsPendingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsPendingAmount' from JSON`,
  );
}

/** @internal */
export const TopupsPendingSubTotal1$inboundSchema: z.ZodType<
  TopupsPendingSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TopupsPendingSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsPendingSubTotal1$outboundSchema: z.ZodType<
  TopupsPendingSubTotal1$Outbound,
  z.ZodTypeDef,
  TopupsPendingSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsPendingSubTotal1$ {
  /** @deprecated use `TopupsPendingSubTotal1$inboundSchema` instead. */
  export const inboundSchema = TopupsPendingSubTotal1$inboundSchema;
  /** @deprecated use `TopupsPendingSubTotal1$outboundSchema` instead. */
  export const outboundSchema = TopupsPendingSubTotal1$outboundSchema;
  /** @deprecated use `TopupsPendingSubTotal1$Outbound` instead. */
  export type Outbound = TopupsPendingSubTotal1$Outbound;
}

export function topupsPendingSubTotal1ToJSON(
  topupsPendingSubTotal1: TopupsPendingSubTotal1,
): string {
  return JSON.stringify(
    TopupsPendingSubTotal1$outboundSchema.parse(topupsPendingSubTotal1),
  );
}

export function topupsPendingSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TopupsPendingSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsPendingSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsPendingSubTotal1' from JSON`,
  );
}

/** @internal */
export const TopupsPendingSubtotal2$inboundSchema: z.ZodType<
  TopupsPendingSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TopupsPendingSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TopupsPendingSubtotal2$Outbound = {
  "sub-totals"?: Array<TopupsPendingSubTotal1$Outbound> | null | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsPendingSubtotal2$outboundSchema: z.ZodType<
  TopupsPendingSubtotal2$Outbound,
  z.ZodTypeDef,
  TopupsPendingSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => TopupsPendingSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsPendingSubtotal2$ {
  /** @deprecated use `TopupsPendingSubtotal2$inboundSchema` instead. */
  export const inboundSchema = TopupsPendingSubtotal2$inboundSchema;
  /** @deprecated use `TopupsPendingSubtotal2$outboundSchema` instead. */
  export const outboundSchema = TopupsPendingSubtotal2$outboundSchema;
  /** @deprecated use `TopupsPendingSubtotal2$Outbound` instead. */
  export type Outbound = TopupsPendingSubtotal2$Outbound;
}

export function topupsPendingSubtotal2ToJSON(
  topupsPendingSubtotal2: TopupsPendingSubtotal2,
): string {
  return JSON.stringify(
    TopupsPendingSubtotal2$outboundSchema.parse(topupsPendingSubtotal2),
  );
}

export function topupsPendingSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TopupsPendingSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsPendingSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsPendingSubtotal2' from JSON`,
  );
}

/** @internal */
export const TopupsPending$inboundSchema: z.ZodType<
  TopupsPending,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TopupsPendingAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsPendingSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TopupsPending$Outbound = {
  amount?: TopupsPendingAmount$Outbound | undefined;
  subtotals?: Array<TopupsPendingSubtotal2$Outbound> | null | undefined;
};

/** @internal */
export const TopupsPending$outboundSchema: z.ZodType<
  TopupsPending$Outbound,
  z.ZodTypeDef,
  TopupsPending
> = z.object({
  amount: z.lazy(() => TopupsPendingAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsPendingSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsPending$ {
  /** @deprecated use `TopupsPending$inboundSchema` instead. */
  export const inboundSchema = TopupsPending$inboundSchema;
  /** @deprecated use `TopupsPending$outboundSchema` instead. */
  export const outboundSchema = TopupsPending$outboundSchema;
  /** @deprecated use `TopupsPending$Outbound` instead. */
  export type Outbound = TopupsPending$Outbound;
}

export function topupsPendingToJSON(topupsPending: TopupsPending): string {
  return JSON.stringify(TopupsPending$outboundSchema.parse(topupsPending));
}

export function topupsPendingFromJSON(
  jsonString: string,
): SafeParseResult<TopupsPending, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsPending$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsPending' from JSON`,
  );
}

/** @internal */
export const TopupsMovedToAvailableAmount$inboundSchema: z.ZodType<
  TopupsMovedToAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TopupsMovedToAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TopupsMovedToAvailableAmount$outboundSchema: z.ZodType<
  TopupsMovedToAvailableAmount$Outbound,
  z.ZodTypeDef,
  TopupsMovedToAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsMovedToAvailableAmount$ {
  /** @deprecated use `TopupsMovedToAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = TopupsMovedToAvailableAmount$inboundSchema;
  /** @deprecated use `TopupsMovedToAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = TopupsMovedToAvailableAmount$outboundSchema;
  /** @deprecated use `TopupsMovedToAvailableAmount$Outbound` instead. */
  export type Outbound = TopupsMovedToAvailableAmount$Outbound;
}

export function topupsMovedToAvailableAmountToJSON(
  topupsMovedToAvailableAmount: TopupsMovedToAvailableAmount,
): string {
  return JSON.stringify(
    TopupsMovedToAvailableAmount$outboundSchema.parse(
      topupsMovedToAvailableAmount,
    ),
  );
}

export function topupsMovedToAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<TopupsMovedToAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsMovedToAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsMovedToAvailableAmount' from JSON`,
  );
}

/** @internal */
export const TopupsMovedToAvailableSubTotal1$inboundSchema: z.ZodType<
  TopupsMovedToAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TopupsMovedToAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsMovedToAvailableSubTotal1$outboundSchema: z.ZodType<
  TopupsMovedToAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  TopupsMovedToAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsMovedToAvailableSubTotal1$ {
  /** @deprecated use `TopupsMovedToAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema = TopupsMovedToAvailableSubTotal1$inboundSchema;
  /** @deprecated use `TopupsMovedToAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema = TopupsMovedToAvailableSubTotal1$outboundSchema;
  /** @deprecated use `TopupsMovedToAvailableSubTotal1$Outbound` instead. */
  export type Outbound = TopupsMovedToAvailableSubTotal1$Outbound;
}

export function topupsMovedToAvailableSubTotal1ToJSON(
  topupsMovedToAvailableSubTotal1: TopupsMovedToAvailableSubTotal1,
): string {
  return JSON.stringify(
    TopupsMovedToAvailableSubTotal1$outboundSchema.parse(
      topupsMovedToAvailableSubTotal1,
    ),
  );
}

export function topupsMovedToAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TopupsMovedToAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsMovedToAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsMovedToAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const TopupsMovedToAvailableSubtotal2$inboundSchema: z.ZodType<
  TopupsMovedToAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TopupsMovedToAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TopupsMovedToAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<TopupsMovedToAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsMovedToAvailableSubtotal2$outboundSchema: z.ZodType<
  TopupsMovedToAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  TopupsMovedToAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => TopupsMovedToAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsMovedToAvailableSubtotal2$ {
  /** @deprecated use `TopupsMovedToAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema = TopupsMovedToAvailableSubtotal2$inboundSchema;
  /** @deprecated use `TopupsMovedToAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema = TopupsMovedToAvailableSubtotal2$outboundSchema;
  /** @deprecated use `TopupsMovedToAvailableSubtotal2$Outbound` instead. */
  export type Outbound = TopupsMovedToAvailableSubtotal2$Outbound;
}

export function topupsMovedToAvailableSubtotal2ToJSON(
  topupsMovedToAvailableSubtotal2: TopupsMovedToAvailableSubtotal2,
): string {
  return JSON.stringify(
    TopupsMovedToAvailableSubtotal2$outboundSchema.parse(
      topupsMovedToAvailableSubtotal2,
    ),
  );
}

export function topupsMovedToAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TopupsMovedToAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsMovedToAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsMovedToAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const TopupsMovedToAvailable$inboundSchema: z.ZodType<
  TopupsMovedToAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TopupsMovedToAvailableAmount$inboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsMovedToAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TopupsMovedToAvailable$Outbound = {
  amount?: TopupsMovedToAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<TopupsMovedToAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const TopupsMovedToAvailable$outboundSchema: z.ZodType<
  TopupsMovedToAvailable$Outbound,
  z.ZodTypeDef,
  TopupsMovedToAvailable
> = z.object({
  amount: z.lazy(() => TopupsMovedToAvailableAmount$outboundSchema).optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsMovedToAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsMovedToAvailable$ {
  /** @deprecated use `TopupsMovedToAvailable$inboundSchema` instead. */
  export const inboundSchema = TopupsMovedToAvailable$inboundSchema;
  /** @deprecated use `TopupsMovedToAvailable$outboundSchema` instead. */
  export const outboundSchema = TopupsMovedToAvailable$outboundSchema;
  /** @deprecated use `TopupsMovedToAvailable$Outbound` instead. */
  export type Outbound = TopupsMovedToAvailable$Outbound;
}

export function topupsMovedToAvailableToJSON(
  topupsMovedToAvailable: TopupsMovedToAvailable,
): string {
  return JSON.stringify(
    TopupsMovedToAvailable$outboundSchema.parse(topupsMovedToAvailable),
  );
}

export function topupsMovedToAvailableFromJSON(
  jsonString: string,
): SafeParseResult<TopupsMovedToAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsMovedToAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsMovedToAvailable' from JSON`,
  );
}

/** @internal */
export const TopupsImmediatelyAvailableAmount$inboundSchema: z.ZodType<
  TopupsImmediatelyAvailableAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TopupsImmediatelyAvailableAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TopupsImmediatelyAvailableAmount$outboundSchema: z.ZodType<
  TopupsImmediatelyAvailableAmount$Outbound,
  z.ZodTypeDef,
  TopupsImmediatelyAvailableAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsImmediatelyAvailableAmount$ {
  /** @deprecated use `TopupsImmediatelyAvailableAmount$inboundSchema` instead. */
  export const inboundSchema = TopupsImmediatelyAvailableAmount$inboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableAmount$outboundSchema` instead. */
  export const outboundSchema = TopupsImmediatelyAvailableAmount$outboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableAmount$Outbound` instead. */
  export type Outbound = TopupsImmediatelyAvailableAmount$Outbound;
}

export function topupsImmediatelyAvailableAmountToJSON(
  topupsImmediatelyAvailableAmount: TopupsImmediatelyAvailableAmount,
): string {
  return JSON.stringify(
    TopupsImmediatelyAvailableAmount$outboundSchema.parse(
      topupsImmediatelyAvailableAmount,
    ),
  );
}

export function topupsImmediatelyAvailableAmountFromJSON(
  jsonString: string,
): SafeParseResult<TopupsImmediatelyAvailableAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsImmediatelyAvailableAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsImmediatelyAvailableAmount' from JSON`,
  );
}

/** @internal */
export const TopupsImmediatelyAvailableSubTotal1$inboundSchema: z.ZodType<
  TopupsImmediatelyAvailableSubTotal1,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/** @internal */
export type TopupsImmediatelyAvailableSubTotal1$Outbound = {
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsImmediatelyAvailableSubTotal1$outboundSchema: z.ZodType<
  TopupsImmediatelyAvailableSubTotal1$Outbound,
  z.ZodTypeDef,
  TopupsImmediatelyAvailableSubTotal1
> = z.object({
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsImmediatelyAvailableSubTotal1$ {
  /** @deprecated use `TopupsImmediatelyAvailableSubTotal1$inboundSchema` instead. */
  export const inboundSchema =
    TopupsImmediatelyAvailableSubTotal1$inboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableSubTotal1$outboundSchema` instead. */
  export const outboundSchema =
    TopupsImmediatelyAvailableSubTotal1$outboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableSubTotal1$Outbound` instead. */
  export type Outbound = TopupsImmediatelyAvailableSubTotal1$Outbound;
}

export function topupsImmediatelyAvailableSubTotal1ToJSON(
  topupsImmediatelyAvailableSubTotal1: TopupsImmediatelyAvailableSubTotal1,
): string {
  return JSON.stringify(
    TopupsImmediatelyAvailableSubTotal1$outboundSchema.parse(
      topupsImmediatelyAvailableSubTotal1,
    ),
  );
}

export function topupsImmediatelyAvailableSubTotal1FromJSON(
  jsonString: string,
): SafeParseResult<TopupsImmediatelyAvailableSubTotal1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TopupsImmediatelyAvailableSubTotal1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsImmediatelyAvailableSubTotal1' from JSON`,
  );
}

/** @internal */
export const TopupsImmediatelyAvailableSubtotal2$inboundSchema: z.ZodType<
  TopupsImmediatelyAvailableSubtotal2,
  z.ZodTypeDef,
  unknown
> = z.object({
  "sub-totals": z.nullable(
    z.array(z.lazy(() => TopupsImmediatelyAvailableSubTotal1$inboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "sub-totals": "subTotals",
  });
});

/** @internal */
export type TopupsImmediatelyAvailableSubtotal2$Outbound = {
  "sub-totals"?:
    | Array<TopupsImmediatelyAvailableSubTotal1$Outbound>
    | null
    | undefined;
  count?: number | undefined;
  method?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  cardAudience?: string | null | undefined;
  cardRegion?: string | null | undefined;
  feeType?: string | null | undefined;
  prepaymentPartType?: string | null | undefined;
  transactionType?: string | null | undefined;
};

/** @internal */
export const TopupsImmediatelyAvailableSubtotal2$outboundSchema: z.ZodType<
  TopupsImmediatelyAvailableSubtotal2$Outbound,
  z.ZodTypeDef,
  TopupsImmediatelyAvailableSubtotal2
> = z.object({
  subTotals: z.nullable(
    z.array(z.lazy(() => TopupsImmediatelyAvailableSubTotal1$outboundSchema)),
  ).optional(),
  count: z.number().int().optional(),
  method: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  cardAudience: z.nullable(z.string()).optional(),
  cardRegion: z.nullable(z.string()).optional(),
  feeType: z.nullable(z.string()).optional(),
  prepaymentPartType: z.nullable(z.string()).optional(),
  transactionType: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    subTotals: "sub-totals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsImmediatelyAvailableSubtotal2$ {
  /** @deprecated use `TopupsImmediatelyAvailableSubtotal2$inboundSchema` instead. */
  export const inboundSchema =
    TopupsImmediatelyAvailableSubtotal2$inboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableSubtotal2$outboundSchema` instead. */
  export const outboundSchema =
    TopupsImmediatelyAvailableSubtotal2$outboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailableSubtotal2$Outbound` instead. */
  export type Outbound = TopupsImmediatelyAvailableSubtotal2$Outbound;
}

export function topupsImmediatelyAvailableSubtotal2ToJSON(
  topupsImmediatelyAvailableSubtotal2: TopupsImmediatelyAvailableSubtotal2,
): string {
  return JSON.stringify(
    TopupsImmediatelyAvailableSubtotal2$outboundSchema.parse(
      topupsImmediatelyAvailableSubtotal2,
    ),
  );
}

export function topupsImmediatelyAvailableSubtotal2FromJSON(
  jsonString: string,
): SafeParseResult<TopupsImmediatelyAvailableSubtotal2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TopupsImmediatelyAvailableSubtotal2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsImmediatelyAvailableSubtotal2' from JSON`,
  );
}

/** @internal */
export const TopupsImmediatelyAvailable$inboundSchema: z.ZodType<
  TopupsImmediatelyAvailable,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => TopupsImmediatelyAvailableAmount$inboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsImmediatelyAvailableSubtotal2$inboundSchema)),
  ).optional(),
});

/** @internal */
export type TopupsImmediatelyAvailable$Outbound = {
  amount?: TopupsImmediatelyAvailableAmount$Outbound | undefined;
  subtotals?:
    | Array<TopupsImmediatelyAvailableSubtotal2$Outbound>
    | null
    | undefined;
};

/** @internal */
export const TopupsImmediatelyAvailable$outboundSchema: z.ZodType<
  TopupsImmediatelyAvailable$Outbound,
  z.ZodTypeDef,
  TopupsImmediatelyAvailable
> = z.object({
  amount: z.lazy(() => TopupsImmediatelyAvailableAmount$outboundSchema)
    .optional(),
  subtotals: z.nullable(
    z.array(z.lazy(() => TopupsImmediatelyAvailableSubtotal2$outboundSchema)),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopupsImmediatelyAvailable$ {
  /** @deprecated use `TopupsImmediatelyAvailable$inboundSchema` instead. */
  export const inboundSchema = TopupsImmediatelyAvailable$inboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailable$outboundSchema` instead. */
  export const outboundSchema = TopupsImmediatelyAvailable$outboundSchema;
  /** @deprecated use `TopupsImmediatelyAvailable$Outbound` instead. */
  export type Outbound = TopupsImmediatelyAvailable$Outbound;
}

export function topupsImmediatelyAvailableToJSON(
  topupsImmediatelyAvailable: TopupsImmediatelyAvailable,
): string {
  return JSON.stringify(
    TopupsImmediatelyAvailable$outboundSchema.parse(topupsImmediatelyAvailable),
  );
}

export function topupsImmediatelyAvailableFromJSON(
  jsonString: string,
): SafeParseResult<TopupsImmediatelyAvailable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupsImmediatelyAvailable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupsImmediatelyAvailable' from JSON`,
  );
}

/** @internal */
export const Topups$inboundSchema: z.ZodType<Topups, z.ZodTypeDef, unknown> = z
  .object({
    pending: z.lazy(() => TopupsPending$inboundSchema).optional(),
    movedToAvailable: z.lazy(() => TopupsMovedToAvailable$inboundSchema)
      .optional(),
    immediatelyAvailable: z.lazy(() => TopupsImmediatelyAvailable$inboundSchema)
      .optional(),
  });

/** @internal */
export type Topups$Outbound = {
  pending?: TopupsPending$Outbound | undefined;
  movedToAvailable?: TopupsMovedToAvailable$Outbound | undefined;
  immediatelyAvailable?: TopupsImmediatelyAvailable$Outbound | undefined;
};

/** @internal */
export const Topups$outboundSchema: z.ZodType<
  Topups$Outbound,
  z.ZodTypeDef,
  Topups
> = z.object({
  pending: z.lazy(() => TopupsPending$outboundSchema).optional(),
  movedToAvailable: z.lazy(() => TopupsMovedToAvailable$outboundSchema)
    .optional(),
  immediatelyAvailable: z.lazy(() => TopupsImmediatelyAvailable$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Topups$ {
  /** @deprecated use `Topups$inboundSchema` instead. */
  export const inboundSchema = Topups$inboundSchema;
  /** @deprecated use `Topups$outboundSchema` instead. */
  export const outboundSchema = Topups$outboundSchema;
  /** @deprecated use `Topups$Outbound` instead. */
  export type Outbound = Topups$Outbound;
}

export function topupsToJSON(topups: Topups): string {
  return JSON.stringify(Topups$outboundSchema.parse(topups));
}

export function topupsFromJSON(
  jsonString: string,
): SafeParseResult<Topups, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Topups$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Topups' from JSON`,
  );
}

/** @internal */
export const Totals$inboundSchema: z.ZodType<Totals, z.ZodTypeDef, unknown> = z
  .object({
    pendingBalance: z.nullable(z.lazy(() => PendingBalance$inboundSchema))
      .optional(),
    availableBalance: z.nullable(z.lazy(() => AvailableBalance$inboundSchema))
      .optional(),
    open: z.lazy(() => Open$inboundSchema).optional(),
    close: z.lazy(() => Close$inboundSchema).optional(),
    payments: z.lazy(() => GetBalanceReportPayments$inboundSchema).optional(),
    refunds: z.lazy(() => GetBalanceReportRefunds$inboundSchema).optional(),
    chargebacks: z.lazy(() => GetBalanceReportChargebacks$inboundSchema)
      .optional(),
    capital: z.lazy(() => Capital$inboundSchema).optional(),
    transfers: z.lazy(() => Transfers$inboundSchema).optional(),
    "fee-prepayments": z.lazy(() => FeePrepayments$inboundSchema).optional(),
    corrections: z.lazy(() => Corrections$inboundSchema).optional(),
    topups: z.lazy(() => Topups$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "fee-prepayments": "feePrepayments",
    });
  });

/** @internal */
export type Totals$Outbound = {
  pendingBalance?: PendingBalance$Outbound | null | undefined;
  availableBalance?: AvailableBalance$Outbound | null | undefined;
  open?: Open$Outbound | undefined;
  close?: Close$Outbound | undefined;
  payments?: GetBalanceReportPayments$Outbound | undefined;
  refunds?: GetBalanceReportRefunds$Outbound | undefined;
  chargebacks?: GetBalanceReportChargebacks$Outbound | undefined;
  capital?: Capital$Outbound | undefined;
  transfers?: Transfers$Outbound | undefined;
  "fee-prepayments"?: FeePrepayments$Outbound | undefined;
  corrections?: Corrections$Outbound | undefined;
  topups?: Topups$Outbound | undefined;
};

/** @internal */
export const Totals$outboundSchema: z.ZodType<
  Totals$Outbound,
  z.ZodTypeDef,
  Totals
> = z.object({
  pendingBalance: z.nullable(z.lazy(() => PendingBalance$outboundSchema))
    .optional(),
  availableBalance: z.nullable(z.lazy(() => AvailableBalance$outboundSchema))
    .optional(),
  open: z.lazy(() => Open$outboundSchema).optional(),
  close: z.lazy(() => Close$outboundSchema).optional(),
  payments: z.lazy(() => GetBalanceReportPayments$outboundSchema).optional(),
  refunds: z.lazy(() => GetBalanceReportRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => GetBalanceReportChargebacks$outboundSchema)
    .optional(),
  capital: z.lazy(() => Capital$outboundSchema).optional(),
  transfers: z.lazy(() => Transfers$outboundSchema).optional(),
  feePrepayments: z.lazy(() => FeePrepayments$outboundSchema).optional(),
  corrections: z.lazy(() => Corrections$outboundSchema).optional(),
  topups: z.lazy(() => Topups$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    feePrepayments: "fee-prepayments",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Totals$ {
  /** @deprecated use `Totals$inboundSchema` instead. */
  export const inboundSchema = Totals$inboundSchema;
  /** @deprecated use `Totals$outboundSchema` instead. */
  export const outboundSchema = Totals$outboundSchema;
  /** @deprecated use `Totals$Outbound` instead. */
  export type Outbound = Totals$Outbound;
}

export function totalsToJSON(totals: Totals): string {
  return JSON.stringify(Totals$outboundSchema.parse(totals));
}

export function totalsFromJSON(
  jsonString: string,
): SafeParseResult<Totals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Totals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Totals' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportSelf$inboundSchema: z.ZodType<
  GetBalanceReportSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetBalanceReportSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetBalanceReportSelf$outboundSchema: z.ZodType<
  GetBalanceReportSelf$Outbound,
  z.ZodTypeDef,
  GetBalanceReportSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportSelf$ {
  /** @deprecated use `GetBalanceReportSelf$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportSelf$inboundSchema;
  /** @deprecated use `GetBalanceReportSelf$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportSelf$outboundSchema;
  /** @deprecated use `GetBalanceReportSelf$Outbound` instead. */
  export type Outbound = GetBalanceReportSelf$Outbound;
}

export function getBalanceReportSelfToJSON(
  getBalanceReportSelf: GetBalanceReportSelf,
): string {
  return JSON.stringify(
    GetBalanceReportSelf$outboundSchema.parse(getBalanceReportSelf),
  );
}

export function getBalanceReportSelfFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportSelf' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportDocumentation$inboundSchema: z.ZodType<
  GetBalanceReportDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetBalanceReportDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetBalanceReportDocumentation$outboundSchema: z.ZodType<
  GetBalanceReportDocumentation$Outbound,
  z.ZodTypeDef,
  GetBalanceReportDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportDocumentation$ {
  /** @deprecated use `GetBalanceReportDocumentation$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportDocumentation$inboundSchema;
  /** @deprecated use `GetBalanceReportDocumentation$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportDocumentation$outboundSchema;
  /** @deprecated use `GetBalanceReportDocumentation$Outbound` instead. */
  export type Outbound = GetBalanceReportDocumentation$Outbound;
}

export function getBalanceReportDocumentationToJSON(
  getBalanceReportDocumentation: GetBalanceReportDocumentation,
): string {
  return JSON.stringify(
    GetBalanceReportDocumentation$outboundSchema.parse(
      getBalanceReportDocumentation,
    ),
  );
}

export function getBalanceReportDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportDocumentation' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportLinks$inboundSchema: z.ZodType<
  GetBalanceReportLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => GetBalanceReportSelf$inboundSchema).optional(),
  documentation: z.lazy(() => GetBalanceReportDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type GetBalanceReportLinks$Outbound = {
  self?: GetBalanceReportSelf$Outbound | undefined;
  documentation?: GetBalanceReportDocumentation$Outbound | undefined;
};

/** @internal */
export const GetBalanceReportLinks$outboundSchema: z.ZodType<
  GetBalanceReportLinks$Outbound,
  z.ZodTypeDef,
  GetBalanceReportLinks
> = z.object({
  self: z.lazy(() => GetBalanceReportSelf$outboundSchema).optional(),
  documentation: z.lazy(() => GetBalanceReportDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportLinks$ {
  /** @deprecated use `GetBalanceReportLinks$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportLinks$inboundSchema;
  /** @deprecated use `GetBalanceReportLinks$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportLinks$outboundSchema;
  /** @deprecated use `GetBalanceReportLinks$Outbound` instead. */
  export type Outbound = GetBalanceReportLinks$Outbound;
}

export function getBalanceReportLinksToJSON(
  getBalanceReportLinks: GetBalanceReportLinks,
): string {
  return JSON.stringify(
    GetBalanceReportLinks$outboundSchema.parse(getBalanceReportLinks),
  );
}

export function getBalanceReportLinksFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportLinks' from JSON`,
  );
}

/** @internal */
export const GetBalanceReportResponse$inboundSchema: z.ZodType<
  GetBalanceReportResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("balance-report"),
  balanceId: z.string().optional(),
  timeZone: z.string().optional(),
  from: z.string().optional(),
  until: z.string().optional(),
  grouping: z.string().optional(),
  totals: z.lazy(() => Totals$inboundSchema).optional(),
  _links: z.lazy(() => GetBalanceReportLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type GetBalanceReportResponse$Outbound = {
  resource: string;
  balanceId?: string | undefined;
  timeZone?: string | undefined;
  from?: string | undefined;
  until?: string | undefined;
  grouping?: string | undefined;
  totals?: Totals$Outbound | undefined;
  _links?: GetBalanceReportLinks$Outbound | undefined;
};

/** @internal */
export const GetBalanceReportResponse$outboundSchema: z.ZodType<
  GetBalanceReportResponse$Outbound,
  z.ZodTypeDef,
  GetBalanceReportResponse
> = z.object({
  resource: z.string().default("balance-report"),
  balanceId: z.string().optional(),
  timeZone: z.string().optional(),
  from: z.string().optional(),
  until: z.string().optional(),
  grouping: z.string().optional(),
  totals: z.lazy(() => Totals$outboundSchema).optional(),
  links: z.lazy(() => GetBalanceReportLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBalanceReportResponse$ {
  /** @deprecated use `GetBalanceReportResponse$inboundSchema` instead. */
  export const inboundSchema = GetBalanceReportResponse$inboundSchema;
  /** @deprecated use `GetBalanceReportResponse$outboundSchema` instead. */
  export const outboundSchema = GetBalanceReportResponse$outboundSchema;
  /** @deprecated use `GetBalanceReportResponse$Outbound` instead. */
  export type Outbound = GetBalanceReportResponse$Outbound;
}

export function getBalanceReportResponseToJSON(
  getBalanceReportResponse: GetBalanceReportResponse,
): string {
  return JSON.stringify(
    GetBalanceReportResponse$outboundSchema.parse(getBalanceReportResponse),
  );
}

export function getBalanceReportResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetBalanceReportResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBalanceReportResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBalanceReportResponse' from JSON`,
  );
}
