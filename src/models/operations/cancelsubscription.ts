/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CancelSubscriptionRequestBody = {
  /**
   * Most API credentials are specifically created for either live mode or test mode. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
   *
   * @remarks
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

export type CancelSubscriptionRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide the ID of the related subscription.
   */
  subscriptionId: string;
  requestBody?: CancelSubscriptionRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CancelSubscriptionNotFoundDocumentation = {
  href: string;
  type: string;
};

export type CancelSubscriptionNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CancelSubscriptionNotFoundDocumentation;
};

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
 */
export type CancelSubscriptionAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CancelSubscriptionApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
 *
 * @remarks
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
 */
export type CancelSubscriptionApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: CancelSubscriptionApplicationFeeAmount | undefined;
  description?: string | undefined;
};

export type CancelSubscriptionMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 *
 * @remarks
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type CancelSubscriptionMetadataUnion =
  | CancelSubscriptionMetadata
  | string
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CancelSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type CancelSubscriptionCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type CancelSubscriptionMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type CancelSubscriptionProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such payments exist (yet).
 */
export type CancelSubscriptionPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CancelSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CancelSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self?: CancelSubscriptionSelf | undefined;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer?: CancelSubscriptionCustomer | null | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: CancelSubscriptionMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile?: CancelSubscriptionProfile | null | undefined;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such payments exist (yet).
   */
  payments?: CancelSubscriptionPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: CancelSubscriptionDocumentation | undefined;
};

/**
 * The updated subscription object with status `canceled`. For a complete reference of the subscription object, refer to the [Get subscription endpoint](get-subscription) documentation.
 */
export type CancelSubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
   */
  resource?: string | undefined;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id?: string | undefined;
  /**
   * Whether this entity was created in live mode or in test mode.
   *
   * @remarks
   *
   * Possible values: `live` `test`
   */
  mode?: string | undefined;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
   *
   * @remarks
   *
   * Possible values: `pending` `active` `canceled` `suspended` `completed`
   */
  status?: string | undefined;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
   */
  amount?: CancelSubscriptionAmount | undefined;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
   *
   * @remarks
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times?: number | null | undefined;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining?: number | undefined;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days` `... weeks` `... months`
   */
  interval?: string | undefined;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate?: string | undefined;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
   *
   * @remarks
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description?: string | undefined;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   *
   * @remarks
   *
   * Possible values: `creditcard` `directdebit` `paypal`
   */
  method?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
   *
   * @remarks
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
   */
  applicationFee?: CancelSubscriptionApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   *
   * @remarks
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata?:
    | CancelSubscriptionMetadata
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl?: string | undefined;
  /**
   * The customer this subscription belongs to.
   */
  customerId?: string | undefined;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt?: string | undefined;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: CancelSubscriptionLinks | undefined;
};

/** @internal */
export const CancelSubscriptionRequestBody$inboundSchema: z.ZodType<
  CancelSubscriptionRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CancelSubscriptionRequestBody$Outbound = {
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CancelSubscriptionRequestBody$outboundSchema: z.ZodType<
  CancelSubscriptionRequestBody$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionRequestBody
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionRequestBody$ {
  /** @deprecated use `CancelSubscriptionRequestBody$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionRequestBody$inboundSchema;
  /** @deprecated use `CancelSubscriptionRequestBody$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionRequestBody$outboundSchema;
  /** @deprecated use `CancelSubscriptionRequestBody$Outbound` instead. */
  export type Outbound = CancelSubscriptionRequestBody$Outbound;
}

export function cancelSubscriptionRequestBodyToJSON(
  cancelSubscriptionRequestBody: CancelSubscriptionRequestBody,
): string {
  return JSON.stringify(
    CancelSubscriptionRequestBody$outboundSchema.parse(
      cancelSubscriptionRequestBody,
    ),
  );
}

export function cancelSubscriptionRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionRequestBody' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionRequest$inboundSchema: z.ZodType<
  CancelSubscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  RequestBody: z.lazy(() => CancelSubscriptionRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CancelSubscriptionRequest$Outbound = {
  customerId: string;
  subscriptionId: string;
  RequestBody?: CancelSubscriptionRequestBody$Outbound | undefined;
};

/** @internal */
export const CancelSubscriptionRequest$outboundSchema: z.ZodType<
  CancelSubscriptionRequest$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionRequest
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  requestBody: z.lazy(() => CancelSubscriptionRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionRequest$ {
  /** @deprecated use `CancelSubscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionRequest$inboundSchema;
  /** @deprecated use `CancelSubscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionRequest$outboundSchema;
  /** @deprecated use `CancelSubscriptionRequest$Outbound` instead. */
  export type Outbound = CancelSubscriptionRequest$Outbound;
}

export function cancelSubscriptionRequestToJSON(
  cancelSubscriptionRequest: CancelSubscriptionRequest,
): string {
  return JSON.stringify(
    CancelSubscriptionRequest$outboundSchema.parse(cancelSubscriptionRequest),
  );
}

export function cancelSubscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionRequest' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionNotFoundDocumentation$inboundSchema: z.ZodType<
  CancelSubscriptionNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionNotFoundDocumentation$outboundSchema: z.ZodType<
  CancelSubscriptionNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionNotFoundDocumentation$ {
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CancelSubscriptionNotFoundDocumentation$inboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CancelSubscriptionNotFoundDocumentation$outboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$Outbound` instead. */
  export type Outbound = CancelSubscriptionNotFoundDocumentation$Outbound;
}

export function cancelSubscriptionNotFoundDocumentationToJSON(
  cancelSubscriptionNotFoundDocumentation:
    CancelSubscriptionNotFoundDocumentation,
): string {
  return JSON.stringify(
    CancelSubscriptionNotFoundDocumentation$outboundSchema.parse(
      cancelSubscriptionNotFoundDocumentation,
    ),
  );
}

export function cancelSubscriptionNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CancelSubscriptionNotFoundDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CancelSubscriptionNotFoundDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CancelSubscriptionNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionNotFoundLinks$inboundSchema: z.ZodType<
  CancelSubscriptionNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CancelSubscriptionNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type CancelSubscriptionNotFoundLinks$Outbound = {
  documentation: CancelSubscriptionNotFoundDocumentation$Outbound;
};

/** @internal */
export const CancelSubscriptionNotFoundLinks$outboundSchema: z.ZodType<
  CancelSubscriptionNotFoundLinks$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    CancelSubscriptionNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionNotFoundLinks$ {
  /** @deprecated use `CancelSubscriptionNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionNotFoundLinks$inboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionNotFoundLinks$outboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundLinks$Outbound` instead. */
  export type Outbound = CancelSubscriptionNotFoundLinks$Outbound;
}

export function cancelSubscriptionNotFoundLinksToJSON(
  cancelSubscriptionNotFoundLinks: CancelSubscriptionNotFoundLinks,
): string {
  return JSON.stringify(
    CancelSubscriptionNotFoundLinks$outboundSchema.parse(
      cancelSubscriptionNotFoundLinks,
    ),
  );
}

export function cancelSubscriptionNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionAmount$inboundSchema: z.ZodType<
  CancelSubscriptionAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CancelSubscriptionAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CancelSubscriptionAmount$outboundSchema: z.ZodType<
  CancelSubscriptionAmount$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionAmount$ {
  /** @deprecated use `CancelSubscriptionAmount$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionAmount$inboundSchema;
  /** @deprecated use `CancelSubscriptionAmount$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionAmount$outboundSchema;
  /** @deprecated use `CancelSubscriptionAmount$Outbound` instead. */
  export type Outbound = CancelSubscriptionAmount$Outbound;
}

export function cancelSubscriptionAmountToJSON(
  cancelSubscriptionAmount: CancelSubscriptionAmount,
): string {
  return JSON.stringify(
    CancelSubscriptionAmount$outboundSchema.parse(cancelSubscriptionAmount),
  );
}

export function cancelSubscriptionAmountFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionAmount' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionApplicationFeeAmount$inboundSchema: z.ZodType<
  CancelSubscriptionApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CancelSubscriptionApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CancelSubscriptionApplicationFeeAmount$outboundSchema: z.ZodType<
  CancelSubscriptionApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionApplicationFeeAmount$ {
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    CancelSubscriptionApplicationFeeAmount$inboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    CancelSubscriptionApplicationFeeAmount$outboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$Outbound` instead. */
  export type Outbound = CancelSubscriptionApplicationFeeAmount$Outbound;
}

export function cancelSubscriptionApplicationFeeAmountToJSON(
  cancelSubscriptionApplicationFeeAmount:
    CancelSubscriptionApplicationFeeAmount,
): string {
  return JSON.stringify(
    CancelSubscriptionApplicationFeeAmount$outboundSchema.parse(
      cancelSubscriptionApplicationFeeAmount,
    ),
  );
}

export function cancelSubscriptionApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CancelSubscriptionApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionApplicationFee$inboundSchema: z.ZodType<
  CancelSubscriptionApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CancelSubscriptionApplicationFeeAmount$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionApplicationFee$Outbound = {
  amount?: CancelSubscriptionApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const CancelSubscriptionApplicationFee$outboundSchema: z.ZodType<
  CancelSubscriptionApplicationFee$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionApplicationFee
> = z.object({
  amount: z.lazy(() => CancelSubscriptionApplicationFeeAmount$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionApplicationFee$ {
  /** @deprecated use `CancelSubscriptionApplicationFee$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionApplicationFee$inboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFee$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionApplicationFee$outboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFee$Outbound` instead. */
  export type Outbound = CancelSubscriptionApplicationFee$Outbound;
}

export function cancelSubscriptionApplicationFeeToJSON(
  cancelSubscriptionApplicationFee: CancelSubscriptionApplicationFee,
): string {
  return JSON.stringify(
    CancelSubscriptionApplicationFee$outboundSchema.parse(
      cancelSubscriptionApplicationFee,
    ),
  );
}

export function cancelSubscriptionApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionApplicationFee' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMetadata$inboundSchema: z.ZodType<
  CancelSubscriptionMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CancelSubscriptionMetadata$Outbound = {};

/** @internal */
export const CancelSubscriptionMetadata$outboundSchema: z.ZodType<
  CancelSubscriptionMetadata$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMetadata$ {
  /** @deprecated use `CancelSubscriptionMetadata$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMetadata$inboundSchema;
  /** @deprecated use `CancelSubscriptionMetadata$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMetadata$outboundSchema;
  /** @deprecated use `CancelSubscriptionMetadata$Outbound` instead. */
  export type Outbound = CancelSubscriptionMetadata$Outbound;
}

export function cancelSubscriptionMetadataToJSON(
  cancelSubscriptionMetadata: CancelSubscriptionMetadata,
): string {
  return JSON.stringify(
    CancelSubscriptionMetadata$outboundSchema.parse(cancelSubscriptionMetadata),
  );
}

export function cancelSubscriptionMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMetadata' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMetadataUnion$inboundSchema: z.ZodType<
  CancelSubscriptionMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CancelSubscriptionMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CancelSubscriptionMetadataUnion$Outbound =
  | CancelSubscriptionMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const CancelSubscriptionMetadataUnion$outboundSchema: z.ZodType<
  CancelSubscriptionMetadataUnion$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMetadataUnion
> = z.union([
  z.lazy(() => CancelSubscriptionMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMetadataUnion$ {
  /** @deprecated use `CancelSubscriptionMetadataUnion$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMetadataUnion$inboundSchema;
  /** @deprecated use `CancelSubscriptionMetadataUnion$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMetadataUnion$outboundSchema;
  /** @deprecated use `CancelSubscriptionMetadataUnion$Outbound` instead. */
  export type Outbound = CancelSubscriptionMetadataUnion$Outbound;
}

export function cancelSubscriptionMetadataUnionToJSON(
  cancelSubscriptionMetadataUnion: CancelSubscriptionMetadataUnion,
): string {
  return JSON.stringify(
    CancelSubscriptionMetadataUnion$outboundSchema.parse(
      cancelSubscriptionMetadataUnion,
    ),
  );
}

export function cancelSubscriptionMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMetadataUnion' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionSelf$inboundSchema: z.ZodType<
  CancelSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionSelf$outboundSchema: z.ZodType<
  CancelSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionSelf$ {
  /** @deprecated use `CancelSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionSelf$inboundSchema;
  /** @deprecated use `CancelSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionSelf$outboundSchema;
  /** @deprecated use `CancelSubscriptionSelf$Outbound` instead. */
  export type Outbound = CancelSubscriptionSelf$Outbound;
}

export function cancelSubscriptionSelfToJSON(
  cancelSubscriptionSelf: CancelSubscriptionSelf,
): string {
  return JSON.stringify(
    CancelSubscriptionSelf$outboundSchema.parse(cancelSubscriptionSelf),
  );
}

export function cancelSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionCustomer$inboundSchema: z.ZodType<
  CancelSubscriptionCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionCustomer$outboundSchema: z.ZodType<
  CancelSubscriptionCustomer$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionCustomer$ {
  /** @deprecated use `CancelSubscriptionCustomer$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionCustomer$inboundSchema;
  /** @deprecated use `CancelSubscriptionCustomer$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionCustomer$outboundSchema;
  /** @deprecated use `CancelSubscriptionCustomer$Outbound` instead. */
  export type Outbound = CancelSubscriptionCustomer$Outbound;
}

export function cancelSubscriptionCustomerToJSON(
  cancelSubscriptionCustomer: CancelSubscriptionCustomer,
): string {
  return JSON.stringify(
    CancelSubscriptionCustomer$outboundSchema.parse(cancelSubscriptionCustomer),
  );
}

export function cancelSubscriptionCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionCustomer' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMandate$inboundSchema: z.ZodType<
  CancelSubscriptionMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionMandate$outboundSchema: z.ZodType<
  CancelSubscriptionMandate$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMandate$ {
  /** @deprecated use `CancelSubscriptionMandate$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMandate$inboundSchema;
  /** @deprecated use `CancelSubscriptionMandate$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMandate$outboundSchema;
  /** @deprecated use `CancelSubscriptionMandate$Outbound` instead. */
  export type Outbound = CancelSubscriptionMandate$Outbound;
}

export function cancelSubscriptionMandateToJSON(
  cancelSubscriptionMandate: CancelSubscriptionMandate,
): string {
  return JSON.stringify(
    CancelSubscriptionMandate$outboundSchema.parse(cancelSubscriptionMandate),
  );
}

export function cancelSubscriptionMandateFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMandate' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionProfile$inboundSchema: z.ZodType<
  CancelSubscriptionProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionProfile$outboundSchema: z.ZodType<
  CancelSubscriptionProfile$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionProfile$ {
  /** @deprecated use `CancelSubscriptionProfile$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionProfile$inboundSchema;
  /** @deprecated use `CancelSubscriptionProfile$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionProfile$outboundSchema;
  /** @deprecated use `CancelSubscriptionProfile$Outbound` instead. */
  export type Outbound = CancelSubscriptionProfile$Outbound;
}

export function cancelSubscriptionProfileToJSON(
  cancelSubscriptionProfile: CancelSubscriptionProfile,
): string {
  return JSON.stringify(
    CancelSubscriptionProfile$outboundSchema.parse(cancelSubscriptionProfile),
  );
}

export function cancelSubscriptionProfileFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionProfile' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionPayments$inboundSchema: z.ZodType<
  CancelSubscriptionPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionPayments$outboundSchema: z.ZodType<
  CancelSubscriptionPayments$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionPayments$ {
  /** @deprecated use `CancelSubscriptionPayments$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionPayments$inboundSchema;
  /** @deprecated use `CancelSubscriptionPayments$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionPayments$outboundSchema;
  /** @deprecated use `CancelSubscriptionPayments$Outbound` instead. */
  export type Outbound = CancelSubscriptionPayments$Outbound;
}

export function cancelSubscriptionPaymentsToJSON(
  cancelSubscriptionPayments: CancelSubscriptionPayments,
): string {
  return JSON.stringify(
    CancelSubscriptionPayments$outboundSchema.parse(cancelSubscriptionPayments),
  );
}

export function cancelSubscriptionPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionPayments' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionDocumentation$inboundSchema: z.ZodType<
  CancelSubscriptionDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionDocumentation$outboundSchema: z.ZodType<
  CancelSubscriptionDocumentation$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionDocumentation$ {
  /** @deprecated use `CancelSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `CancelSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `CancelSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = CancelSubscriptionDocumentation$Outbound;
}

export function cancelSubscriptionDocumentationToJSON(
  cancelSubscriptionDocumentation: CancelSubscriptionDocumentation,
): string {
  return JSON.stringify(
    CancelSubscriptionDocumentation$outboundSchema.parse(
      cancelSubscriptionDocumentation,
    ),
  );
}

export function cancelSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionLinks$inboundSchema: z.ZodType<
  CancelSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CancelSubscriptionSelf$inboundSchema).optional(),
  customer: z.nullable(z.lazy(() => CancelSubscriptionCustomer$inboundSchema))
    .optional(),
  mandate: z.nullable(z.lazy(() => CancelSubscriptionMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CancelSubscriptionProfile$inboundSchema))
    .optional(),
  payments: z.nullable(z.lazy(() => CancelSubscriptionPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() => CancelSubscriptionDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type CancelSubscriptionLinks$Outbound = {
  self?: CancelSubscriptionSelf$Outbound | undefined;
  customer?: CancelSubscriptionCustomer$Outbound | null | undefined;
  mandate?: CancelSubscriptionMandate$Outbound | null | undefined;
  profile?: CancelSubscriptionProfile$Outbound | null | undefined;
  payments?: CancelSubscriptionPayments$Outbound | null | undefined;
  documentation?: CancelSubscriptionDocumentation$Outbound | undefined;
};

/** @internal */
export const CancelSubscriptionLinks$outboundSchema: z.ZodType<
  CancelSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionLinks
> = z.object({
  self: z.lazy(() => CancelSubscriptionSelf$outboundSchema).optional(),
  customer: z.nullable(z.lazy(() => CancelSubscriptionCustomer$outboundSchema))
    .optional(),
  mandate: z.nullable(z.lazy(() => CancelSubscriptionMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CancelSubscriptionProfile$outboundSchema))
    .optional(),
  payments: z.nullable(z.lazy(() => CancelSubscriptionPayments$outboundSchema))
    .optional(),
  documentation: z.lazy(() => CancelSubscriptionDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionLinks$ {
  /** @deprecated use `CancelSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionLinks$inboundSchema;
  /** @deprecated use `CancelSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionLinks$outboundSchema;
  /** @deprecated use `CancelSubscriptionLinks$Outbound` instead. */
  export type Outbound = CancelSubscriptionLinks$Outbound;
}

export function cancelSubscriptionLinksToJSON(
  cancelSubscriptionLinks: CancelSubscriptionLinks,
): string {
  return JSON.stringify(
    CancelSubscriptionLinks$outboundSchema.parse(cancelSubscriptionLinks),
  );
}

export function cancelSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionResponse$inboundSchema: z.ZodType<
  CancelSubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("subscription"),
  id: z.string().optional(),
  mode: z.string().optional(),
  status: z.string().optional(),
  amount: z.lazy(() => CancelSubscriptionAmount$inboundSchema).optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.number().int().optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(z.string()).optional(),
  applicationFee: z.lazy(() => CancelSubscriptionApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CancelSubscriptionMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CancelSubscriptionLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CancelSubscriptionResponse$Outbound = {
  resource: string;
  id?: string | undefined;
  mode?: string | undefined;
  status?: string | undefined;
  amount?: CancelSubscriptionAmount$Outbound | undefined;
  times?: number | null | undefined;
  timesRemaining?: number | undefined;
  interval?: string | undefined;
  startDate?: string | undefined;
  nextPaymentDate?: string | null | undefined;
  description?: string | undefined;
  method?: string | null | undefined;
  applicationFee?: CancelSubscriptionApplicationFee$Outbound | undefined;
  metadata?:
    | CancelSubscriptionMetadata$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  webhookUrl?: string | undefined;
  customerId?: string | undefined;
  mandateId?: string | null | undefined;
  createdAt?: string | undefined;
  canceledAt?: string | null | undefined;
  _links?: CancelSubscriptionLinks$Outbound | undefined;
};

/** @internal */
export const CancelSubscriptionResponse$outboundSchema: z.ZodType<
  CancelSubscriptionResponse$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionResponse
> = z.object({
  resource: z.string().default("subscription"),
  id: z.string().optional(),
  mode: z.string().optional(),
  status: z.string().optional(),
  amount: z.lazy(() => CancelSubscriptionAmount$outboundSchema).optional(),
  times: z.nullable(z.number().int()).optional(),
  timesRemaining: z.number().int().optional(),
  interval: z.string().optional(),
  startDate: z.string().optional(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string().optional(),
  method: z.nullable(z.string()).optional(),
  applicationFee: z.lazy(() => CancelSubscriptionApplicationFee$outboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CancelSubscriptionMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  webhookUrl: z.string().optional(),
  customerId: z.string().optional(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string().optional(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => CancelSubscriptionLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionResponse$ {
  /** @deprecated use `CancelSubscriptionResponse$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionResponse$inboundSchema;
  /** @deprecated use `CancelSubscriptionResponse$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionResponse$outboundSchema;
  /** @deprecated use `CancelSubscriptionResponse$Outbound` instead. */
  export type Outbound = CancelSubscriptionResponse$Outbound;
}

export function cancelSubscriptionResponseToJSON(
  cancelSubscriptionResponse: CancelSubscriptionResponse,
): string {
  return JSON.stringify(
    CancelSubscriptionResponse$outboundSchema.parse(cancelSubscriptionResponse),
  );
}

export function cancelSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionResponse' from JSON`,
  );
}
