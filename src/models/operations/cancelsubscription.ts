/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CancelSubscriptionRequestBody = {
  /**
   * Most API credentials are specifically created for either live mode or test mode. For organization-level credentials
   *
   * @remarks
   * such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

export type CancelSubscriptionRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide the ID of the related subscription.
   */
  subscriptionId: string;
  requestBody?: CancelSubscriptionRequestBody | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CancelSubscriptionNotFoundDocumentation = {
  href: string;
  type: string;
};

export type CancelSubscriptionNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CancelSubscriptionNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CancelSubscriptionMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CancelSubscriptionMode = ClosedEnum<typeof CancelSubscriptionMode>;

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const CancelSubscriptionStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type CancelSubscriptionStatus = ClosedEnum<
  typeof CancelSubscriptionStatus
>;

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type CancelSubscriptionAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export const CancelSubscriptionInterval = {
  DotDotDotDays: "... days",
  DotDotDotWeeks: "... weeks",
  DotDotDotMonths: "... months",
} as const;
/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export type CancelSubscriptionInterval = ClosedEnum<
  typeof CancelSubscriptionInterval
>;

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const CancelSubscriptionMethod = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type CancelSubscriptionMethod = ClosedEnum<
  typeof CancelSubscriptionMethod
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type CancelSubscriptionApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type CancelSubscriptionApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: CancelSubscriptionApplicationFeeAmount;
  description: string;
};

export type CancelSubscriptionMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type CancelSubscriptionMetadataUnion =
  | CancelSubscriptionMetadata
  | string
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CancelSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type CancelSubscriptionCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type CancelSubscriptionMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type CancelSubscriptionProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
 *
 * @remarks
 * payments exist (yet).
 */
export type CancelSubscriptionPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CancelSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CancelSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CancelSubscriptionSelf;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer: CancelSubscriptionCustomer | null;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: CancelSubscriptionMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile: CancelSubscriptionProfile | null;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
   *
   * @remarks
   * payments exist (yet).
   */
  payments?: CancelSubscriptionPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: CancelSubscriptionDocumentation;
};

/**
 * The updated subscription object with status `canceled`. For a complete reference of the subscription object,
 *
 * @remarks
 * refer to the [Get subscription endpoint](get-subscription) documentation.
 */
export type CancelSubscriptionResponse = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CancelSubscriptionMode;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status: CancelSubscriptionStatus;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount: CancelSubscriptionAmount;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times: number | null;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining: number;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   */
  interval: CancelSubscriptionInterval;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate: string;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method: CancelSubscriptionMethod | null;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: CancelSubscriptionApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata: CancelSubscriptionMetadata | string | Array<string> | null;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl: string;
  /**
   * The customer this subscription belongs to.
   */
  customerId: string;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: CancelSubscriptionLinks | undefined;
};

/** @internal */
export const CancelSubscriptionRequestBody$inboundSchema: z.ZodType<
  CancelSubscriptionRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CancelSubscriptionRequestBody$Outbound = {
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CancelSubscriptionRequestBody$outboundSchema: z.ZodType<
  CancelSubscriptionRequestBody$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionRequestBody
> = z.object({
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionRequestBody$ {
  /** @deprecated use `CancelSubscriptionRequestBody$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionRequestBody$inboundSchema;
  /** @deprecated use `CancelSubscriptionRequestBody$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionRequestBody$outboundSchema;
  /** @deprecated use `CancelSubscriptionRequestBody$Outbound` instead. */
  export type Outbound = CancelSubscriptionRequestBody$Outbound;
}

export function cancelSubscriptionRequestBodyToJSON(
  cancelSubscriptionRequestBody: CancelSubscriptionRequestBody,
): string {
  return JSON.stringify(
    CancelSubscriptionRequestBody$outboundSchema.parse(
      cancelSubscriptionRequestBody,
    ),
  );
}

export function cancelSubscriptionRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionRequestBody' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionRequest$inboundSchema: z.ZodType<
  CancelSubscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  RequestBody: z.lazy(() => CancelSubscriptionRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CancelSubscriptionRequest$Outbound = {
  customerId: string;
  subscriptionId: string;
  RequestBody?: CancelSubscriptionRequestBody$Outbound | undefined;
};

/** @internal */
export const CancelSubscriptionRequest$outboundSchema: z.ZodType<
  CancelSubscriptionRequest$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionRequest
> = z.object({
  customerId: z.string(),
  subscriptionId: z.string(),
  requestBody: z.lazy(() => CancelSubscriptionRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionRequest$ {
  /** @deprecated use `CancelSubscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionRequest$inboundSchema;
  /** @deprecated use `CancelSubscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionRequest$outboundSchema;
  /** @deprecated use `CancelSubscriptionRequest$Outbound` instead. */
  export type Outbound = CancelSubscriptionRequest$Outbound;
}

export function cancelSubscriptionRequestToJSON(
  cancelSubscriptionRequest: CancelSubscriptionRequest,
): string {
  return JSON.stringify(
    CancelSubscriptionRequest$outboundSchema.parse(cancelSubscriptionRequest),
  );
}

export function cancelSubscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionRequest' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionNotFoundDocumentation$inboundSchema: z.ZodType<
  CancelSubscriptionNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionNotFoundDocumentation$outboundSchema: z.ZodType<
  CancelSubscriptionNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionNotFoundDocumentation$ {
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CancelSubscriptionNotFoundDocumentation$inboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CancelSubscriptionNotFoundDocumentation$outboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundDocumentation$Outbound` instead. */
  export type Outbound = CancelSubscriptionNotFoundDocumentation$Outbound;
}

export function cancelSubscriptionNotFoundDocumentationToJSON(
  cancelSubscriptionNotFoundDocumentation:
    CancelSubscriptionNotFoundDocumentation,
): string {
  return JSON.stringify(
    CancelSubscriptionNotFoundDocumentation$outboundSchema.parse(
      cancelSubscriptionNotFoundDocumentation,
    ),
  );
}

export function cancelSubscriptionNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CancelSubscriptionNotFoundDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CancelSubscriptionNotFoundDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CancelSubscriptionNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionNotFoundLinks$inboundSchema: z.ZodType<
  CancelSubscriptionNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CancelSubscriptionNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type CancelSubscriptionNotFoundLinks$Outbound = {
  documentation: CancelSubscriptionNotFoundDocumentation$Outbound;
};

/** @internal */
export const CancelSubscriptionNotFoundLinks$outboundSchema: z.ZodType<
  CancelSubscriptionNotFoundLinks$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    CancelSubscriptionNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionNotFoundLinks$ {
  /** @deprecated use `CancelSubscriptionNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionNotFoundLinks$inboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionNotFoundLinks$outboundSchema;
  /** @deprecated use `CancelSubscriptionNotFoundLinks$Outbound` instead. */
  export type Outbound = CancelSubscriptionNotFoundLinks$Outbound;
}

export function cancelSubscriptionNotFoundLinksToJSON(
  cancelSubscriptionNotFoundLinks: CancelSubscriptionNotFoundLinks,
): string {
  return JSON.stringify(
    CancelSubscriptionNotFoundLinks$outboundSchema.parse(
      cancelSubscriptionNotFoundLinks,
    ),
  );
}

export function cancelSubscriptionNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMode$inboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionMode
> = z.nativeEnum(CancelSubscriptionMode);

/** @internal */
export const CancelSubscriptionMode$outboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionMode
> = CancelSubscriptionMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMode$ {
  /** @deprecated use `CancelSubscriptionMode$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMode$inboundSchema;
  /** @deprecated use `CancelSubscriptionMode$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMode$outboundSchema;
}

/** @internal */
export const CancelSubscriptionStatus$inboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionStatus
> = z.nativeEnum(CancelSubscriptionStatus);

/** @internal */
export const CancelSubscriptionStatus$outboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionStatus
> = CancelSubscriptionStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionStatus$ {
  /** @deprecated use `CancelSubscriptionStatus$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionStatus$inboundSchema;
  /** @deprecated use `CancelSubscriptionStatus$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionStatus$outboundSchema;
}

/** @internal */
export const CancelSubscriptionAmount$inboundSchema: z.ZodType<
  CancelSubscriptionAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CancelSubscriptionAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CancelSubscriptionAmount$outboundSchema: z.ZodType<
  CancelSubscriptionAmount$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionAmount$ {
  /** @deprecated use `CancelSubscriptionAmount$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionAmount$inboundSchema;
  /** @deprecated use `CancelSubscriptionAmount$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionAmount$outboundSchema;
  /** @deprecated use `CancelSubscriptionAmount$Outbound` instead. */
  export type Outbound = CancelSubscriptionAmount$Outbound;
}

export function cancelSubscriptionAmountToJSON(
  cancelSubscriptionAmount: CancelSubscriptionAmount,
): string {
  return JSON.stringify(
    CancelSubscriptionAmount$outboundSchema.parse(cancelSubscriptionAmount),
  );
}

export function cancelSubscriptionAmountFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionAmount' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionInterval$inboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionInterval
> = z.nativeEnum(CancelSubscriptionInterval);

/** @internal */
export const CancelSubscriptionInterval$outboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionInterval
> = CancelSubscriptionInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionInterval$ {
  /** @deprecated use `CancelSubscriptionInterval$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionInterval$inboundSchema;
  /** @deprecated use `CancelSubscriptionInterval$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionInterval$outboundSchema;
}

/** @internal */
export const CancelSubscriptionMethod$inboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionMethod
> = z.nativeEnum(CancelSubscriptionMethod);

/** @internal */
export const CancelSubscriptionMethod$outboundSchema: z.ZodNativeEnum<
  typeof CancelSubscriptionMethod
> = CancelSubscriptionMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMethod$ {
  /** @deprecated use `CancelSubscriptionMethod$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMethod$inboundSchema;
  /** @deprecated use `CancelSubscriptionMethod$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMethod$outboundSchema;
}

/** @internal */
export const CancelSubscriptionApplicationFeeAmount$inboundSchema: z.ZodType<
  CancelSubscriptionApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CancelSubscriptionApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CancelSubscriptionApplicationFeeAmount$outboundSchema: z.ZodType<
  CancelSubscriptionApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionApplicationFeeAmount$ {
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    CancelSubscriptionApplicationFeeAmount$inboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    CancelSubscriptionApplicationFeeAmount$outboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFeeAmount$Outbound` instead. */
  export type Outbound = CancelSubscriptionApplicationFeeAmount$Outbound;
}

export function cancelSubscriptionApplicationFeeAmountToJSON(
  cancelSubscriptionApplicationFeeAmount:
    CancelSubscriptionApplicationFeeAmount,
): string {
  return JSON.stringify(
    CancelSubscriptionApplicationFeeAmount$outboundSchema.parse(
      cancelSubscriptionApplicationFeeAmount,
    ),
  );
}

export function cancelSubscriptionApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CancelSubscriptionApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionApplicationFee$inboundSchema: z.ZodType<
  CancelSubscriptionApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CancelSubscriptionApplicationFeeAmount$inboundSchema),
  description: z.string(),
});

/** @internal */
export type CancelSubscriptionApplicationFee$Outbound = {
  amount: CancelSubscriptionApplicationFeeAmount$Outbound;
  description: string;
};

/** @internal */
export const CancelSubscriptionApplicationFee$outboundSchema: z.ZodType<
  CancelSubscriptionApplicationFee$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionApplicationFee
> = z.object({
  amount: z.lazy(() => CancelSubscriptionApplicationFeeAmount$outboundSchema),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionApplicationFee$ {
  /** @deprecated use `CancelSubscriptionApplicationFee$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionApplicationFee$inboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFee$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionApplicationFee$outboundSchema;
  /** @deprecated use `CancelSubscriptionApplicationFee$Outbound` instead. */
  export type Outbound = CancelSubscriptionApplicationFee$Outbound;
}

export function cancelSubscriptionApplicationFeeToJSON(
  cancelSubscriptionApplicationFee: CancelSubscriptionApplicationFee,
): string {
  return JSON.stringify(
    CancelSubscriptionApplicationFee$outboundSchema.parse(
      cancelSubscriptionApplicationFee,
    ),
  );
}

export function cancelSubscriptionApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionApplicationFee' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMetadata$inboundSchema: z.ZodType<
  CancelSubscriptionMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CancelSubscriptionMetadata$Outbound = {};

/** @internal */
export const CancelSubscriptionMetadata$outboundSchema: z.ZodType<
  CancelSubscriptionMetadata$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMetadata$ {
  /** @deprecated use `CancelSubscriptionMetadata$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMetadata$inboundSchema;
  /** @deprecated use `CancelSubscriptionMetadata$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMetadata$outboundSchema;
  /** @deprecated use `CancelSubscriptionMetadata$Outbound` instead. */
  export type Outbound = CancelSubscriptionMetadata$Outbound;
}

export function cancelSubscriptionMetadataToJSON(
  cancelSubscriptionMetadata: CancelSubscriptionMetadata,
): string {
  return JSON.stringify(
    CancelSubscriptionMetadata$outboundSchema.parse(cancelSubscriptionMetadata),
  );
}

export function cancelSubscriptionMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMetadata' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMetadataUnion$inboundSchema: z.ZodType<
  CancelSubscriptionMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CancelSubscriptionMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type CancelSubscriptionMetadataUnion$Outbound =
  | CancelSubscriptionMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const CancelSubscriptionMetadataUnion$outboundSchema: z.ZodType<
  CancelSubscriptionMetadataUnion$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMetadataUnion
> = z.union([
  z.lazy(() => CancelSubscriptionMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMetadataUnion$ {
  /** @deprecated use `CancelSubscriptionMetadataUnion$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMetadataUnion$inboundSchema;
  /** @deprecated use `CancelSubscriptionMetadataUnion$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMetadataUnion$outboundSchema;
  /** @deprecated use `CancelSubscriptionMetadataUnion$Outbound` instead. */
  export type Outbound = CancelSubscriptionMetadataUnion$Outbound;
}

export function cancelSubscriptionMetadataUnionToJSON(
  cancelSubscriptionMetadataUnion: CancelSubscriptionMetadataUnion,
): string {
  return JSON.stringify(
    CancelSubscriptionMetadataUnion$outboundSchema.parse(
      cancelSubscriptionMetadataUnion,
    ),
  );
}

export function cancelSubscriptionMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMetadataUnion' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionSelf$inboundSchema: z.ZodType<
  CancelSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionSelf$outboundSchema: z.ZodType<
  CancelSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionSelf$ {
  /** @deprecated use `CancelSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionSelf$inboundSchema;
  /** @deprecated use `CancelSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionSelf$outboundSchema;
  /** @deprecated use `CancelSubscriptionSelf$Outbound` instead. */
  export type Outbound = CancelSubscriptionSelf$Outbound;
}

export function cancelSubscriptionSelfToJSON(
  cancelSubscriptionSelf: CancelSubscriptionSelf,
): string {
  return JSON.stringify(
    CancelSubscriptionSelf$outboundSchema.parse(cancelSubscriptionSelf),
  );
}

export function cancelSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionCustomer$inboundSchema: z.ZodType<
  CancelSubscriptionCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionCustomer$outboundSchema: z.ZodType<
  CancelSubscriptionCustomer$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionCustomer$ {
  /** @deprecated use `CancelSubscriptionCustomer$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionCustomer$inboundSchema;
  /** @deprecated use `CancelSubscriptionCustomer$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionCustomer$outboundSchema;
  /** @deprecated use `CancelSubscriptionCustomer$Outbound` instead. */
  export type Outbound = CancelSubscriptionCustomer$Outbound;
}

export function cancelSubscriptionCustomerToJSON(
  cancelSubscriptionCustomer: CancelSubscriptionCustomer,
): string {
  return JSON.stringify(
    CancelSubscriptionCustomer$outboundSchema.parse(cancelSubscriptionCustomer),
  );
}

export function cancelSubscriptionCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionCustomer' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionMandate$inboundSchema: z.ZodType<
  CancelSubscriptionMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionMandate$outboundSchema: z.ZodType<
  CancelSubscriptionMandate$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionMandate$ {
  /** @deprecated use `CancelSubscriptionMandate$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionMandate$inboundSchema;
  /** @deprecated use `CancelSubscriptionMandate$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionMandate$outboundSchema;
  /** @deprecated use `CancelSubscriptionMandate$Outbound` instead. */
  export type Outbound = CancelSubscriptionMandate$Outbound;
}

export function cancelSubscriptionMandateToJSON(
  cancelSubscriptionMandate: CancelSubscriptionMandate,
): string {
  return JSON.stringify(
    CancelSubscriptionMandate$outboundSchema.parse(cancelSubscriptionMandate),
  );
}

export function cancelSubscriptionMandateFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionMandate' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionProfile$inboundSchema: z.ZodType<
  CancelSubscriptionProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionProfile$outboundSchema: z.ZodType<
  CancelSubscriptionProfile$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionProfile$ {
  /** @deprecated use `CancelSubscriptionProfile$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionProfile$inboundSchema;
  /** @deprecated use `CancelSubscriptionProfile$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionProfile$outboundSchema;
  /** @deprecated use `CancelSubscriptionProfile$Outbound` instead. */
  export type Outbound = CancelSubscriptionProfile$Outbound;
}

export function cancelSubscriptionProfileToJSON(
  cancelSubscriptionProfile: CancelSubscriptionProfile,
): string {
  return JSON.stringify(
    CancelSubscriptionProfile$outboundSchema.parse(cancelSubscriptionProfile),
  );
}

export function cancelSubscriptionProfileFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionProfile' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionPayments$inboundSchema: z.ZodType<
  CancelSubscriptionPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type CancelSubscriptionPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const CancelSubscriptionPayments$outboundSchema: z.ZodType<
  CancelSubscriptionPayments$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionPayments$ {
  /** @deprecated use `CancelSubscriptionPayments$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionPayments$inboundSchema;
  /** @deprecated use `CancelSubscriptionPayments$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionPayments$outboundSchema;
  /** @deprecated use `CancelSubscriptionPayments$Outbound` instead. */
  export type Outbound = CancelSubscriptionPayments$Outbound;
}

export function cancelSubscriptionPaymentsToJSON(
  cancelSubscriptionPayments: CancelSubscriptionPayments,
): string {
  return JSON.stringify(
    CancelSubscriptionPayments$outboundSchema.parse(cancelSubscriptionPayments),
  );
}

export function cancelSubscriptionPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionPayments' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionDocumentation$inboundSchema: z.ZodType<
  CancelSubscriptionDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CancelSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CancelSubscriptionDocumentation$outboundSchema: z.ZodType<
  CancelSubscriptionDocumentation$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionDocumentation$ {
  /** @deprecated use `CancelSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `CancelSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `CancelSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = CancelSubscriptionDocumentation$Outbound;
}

export function cancelSubscriptionDocumentationToJSON(
  cancelSubscriptionDocumentation: CancelSubscriptionDocumentation,
): string {
  return JSON.stringify(
    CancelSubscriptionDocumentation$outboundSchema.parse(
      cancelSubscriptionDocumentation,
    ),
  );
}

export function cancelSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionLinks$inboundSchema: z.ZodType<
  CancelSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CancelSubscriptionSelf$inboundSchema),
  customer: z.nullable(z.lazy(() => CancelSubscriptionCustomer$inboundSchema)),
  mandate: z.nullable(z.lazy(() => CancelSubscriptionMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CancelSubscriptionProfile$inboundSchema)),
  payments: z.nullable(z.lazy(() => CancelSubscriptionPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() => CancelSubscriptionDocumentation$inboundSchema),
});

/** @internal */
export type CancelSubscriptionLinks$Outbound = {
  self: CancelSubscriptionSelf$Outbound;
  customer: CancelSubscriptionCustomer$Outbound | null;
  mandate?: CancelSubscriptionMandate$Outbound | null | undefined;
  profile: CancelSubscriptionProfile$Outbound | null;
  payments?: CancelSubscriptionPayments$Outbound | null | undefined;
  documentation: CancelSubscriptionDocumentation$Outbound;
};

/** @internal */
export const CancelSubscriptionLinks$outboundSchema: z.ZodType<
  CancelSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionLinks
> = z.object({
  self: z.lazy(() => CancelSubscriptionSelf$outboundSchema),
  customer: z.nullable(z.lazy(() => CancelSubscriptionCustomer$outboundSchema)),
  mandate: z.nullable(z.lazy(() => CancelSubscriptionMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => CancelSubscriptionProfile$outboundSchema)),
  payments: z.nullable(z.lazy(() => CancelSubscriptionPayments$outboundSchema))
    .optional(),
  documentation: z.lazy(() => CancelSubscriptionDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionLinks$ {
  /** @deprecated use `CancelSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionLinks$inboundSchema;
  /** @deprecated use `CancelSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionLinks$outboundSchema;
  /** @deprecated use `CancelSubscriptionLinks$Outbound` instead. */
  export type Outbound = CancelSubscriptionLinks$Outbound;
}

export function cancelSubscriptionLinksToJSON(
  cancelSubscriptionLinks: CancelSubscriptionLinks,
): string {
  return JSON.stringify(
    CancelSubscriptionLinks$outboundSchema.parse(cancelSubscriptionLinks),
  );
}

export function cancelSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const CancelSubscriptionResponse$inboundSchema: z.ZodType<
  CancelSubscriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CancelSubscriptionMode$inboundSchema,
  status: CancelSubscriptionStatus$inboundSchema,
  amount: z.lazy(() => CancelSubscriptionAmount$inboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.number().int(),
  interval: CancelSubscriptionInterval$inboundSchema,
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(CancelSubscriptionMethod$inboundSchema),
  applicationFee: z.lazy(() => CancelSubscriptionApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CancelSubscriptionMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CancelSubscriptionLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CancelSubscriptionResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  status: string;
  amount: CancelSubscriptionAmount$Outbound;
  times: number | null;
  timesRemaining: number;
  interval: string;
  startDate: string;
  nextPaymentDate?: string | null | undefined;
  description: string;
  method: string | null;
  applicationFee?: CancelSubscriptionApplicationFee$Outbound | undefined;
  metadata: CancelSubscriptionMetadata$Outbound | string | Array<string> | null;
  webhookUrl: string;
  customerId: string;
  mandateId?: string | null | undefined;
  createdAt: string;
  canceledAt?: string | null | undefined;
  _links?: CancelSubscriptionLinks$Outbound | undefined;
};

/** @internal */
export const CancelSubscriptionResponse$outboundSchema: z.ZodType<
  CancelSubscriptionResponse$Outbound,
  z.ZodTypeDef,
  CancelSubscriptionResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: CancelSubscriptionMode$outboundSchema,
  status: CancelSubscriptionStatus$outboundSchema,
  amount: z.lazy(() => CancelSubscriptionAmount$outboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.number().int(),
  interval: CancelSubscriptionInterval$outboundSchema,
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(CancelSubscriptionMethod$outboundSchema),
  applicationFee: z.lazy(() => CancelSubscriptionApplicationFee$outboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => CancelSubscriptionMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => CancelSubscriptionLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelSubscriptionResponse$ {
  /** @deprecated use `CancelSubscriptionResponse$inboundSchema` instead. */
  export const inboundSchema = CancelSubscriptionResponse$inboundSchema;
  /** @deprecated use `CancelSubscriptionResponse$outboundSchema` instead. */
  export const outboundSchema = CancelSubscriptionResponse$outboundSchema;
  /** @deprecated use `CancelSubscriptionResponse$Outbound` instead. */
  export type Outbound = CancelSubscriptionResponse$Outbound;
}

export function cancelSubscriptionResponseToJSON(
  cancelSubscriptionResponse: CancelSubscriptionResponse,
): string {
  return JSON.stringify(
    CancelSubscriptionResponse$outboundSchema.parse(cancelSubscriptionResponse),
  );
}

export function cancelSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CancelSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelSubscriptionResponse' from JSON`,
  );
}
