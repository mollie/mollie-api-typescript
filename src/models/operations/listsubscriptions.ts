/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export const ListSubscriptionsSort = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export type ListSubscriptionsSort = ClosedEnum<typeof ListSubscriptionsSort>;

export type ListSubscriptionsRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
   *
   * @remarks
   * result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
   *
   * @remarks
   * newest to oldest.
   */
  sort?: ListSubscriptionsSort | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListSubscriptionsNotFoundDocumentation = {
  href: string;
  type: string;
};

export type ListSubscriptionsNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListSubscriptionsNotFoundDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListSubscriptionsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListSubscriptionsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListSubscriptionsBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListSubscriptionsMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListSubscriptionsMode = ClosedEnum<typeof ListSubscriptionsMode>;

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const ListSubscriptionsStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type ListSubscriptionsStatus = ClosedEnum<
  typeof ListSubscriptionsStatus
>;

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type ListSubscriptionsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export const ListSubscriptionsInterval = {
  DotDotDotDays: "... days",
  DotDotDotWeeks: "... weeks",
  DotDotDotMonths: "... months",
} as const;
/**
 * Interval to wait between payments, for example `1 month` or `14 days`.
 *
 * @remarks
 *
 * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
 */
export type ListSubscriptionsInterval = ClosedEnum<
  typeof ListSubscriptionsInterval
>;

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const ListSubscriptionsMethod = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type ListSubscriptionsMethod = ClosedEnum<
  typeof ListSubscriptionsMethod
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ListSubscriptionsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type ListSubscriptionsApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: ListSubscriptionsApplicationFeeAmount;
  description: string;
};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type ListSubscriptionsMetadata =
  | string
  | { [k: string]: any }
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionsSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type ListSubscriptionsCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type ListSubscriptionsMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type ListSubscriptionsProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
 *
 * @remarks
 * payments exist (yet).
 */
export type ListSubscriptionsPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionsSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionsSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListSubscriptionsSubscriptionSelf;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer: ListSubscriptionsCustomer | null;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: ListSubscriptionsMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile: ListSubscriptionsProfile | null;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
   *
   * @remarks
   * payments exist (yet).
   */
  payments?: ListSubscriptionsPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListSubscriptionsSubscriptionDocumentation;
};

export type ListSubscriptionsSubscription = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListSubscriptionsMode;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status: ListSubscriptionsStatus;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount: ListSubscriptionsAmount;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times: number | null;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining: number;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   */
  interval: ListSubscriptionsInterval;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate: string;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method: ListSubscriptionsMethod | null;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: ListSubscriptionsApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata: string | { [k: string]: any } | Array<string> | null;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl: string;
  /**
   * The customer this subscription belongs to.
   */
  customerId: string;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListSubscriptionsSubscriptionLinks | undefined;
};

export type ListSubscriptionsEmbedded = {
  /**
   * An array of subscription objects.
   */
  subscriptions?: Array<ListSubscriptionsSubscription> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListSubscriptionsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListSubscriptionsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListSubscriptionsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListSubscriptionsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListSubscriptionsLinks = {
  /**
   * The URL to the current set of items.
   */
  self: ListSubscriptionsSelf;
  /**
   * The previous set of items, if available.
   */
  previous: ListSubscriptionsPrevious | null;
  /**
   * The next set of items, if available.
   */
  next: ListSubscriptionsNext | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListSubscriptionsDocumentation;
};

/**
 * A list of subscription objects.
 */
export type ListSubscriptionsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListSubscriptionsEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListSubscriptionsLinks | undefined;
};

/** @internal */
export const ListSubscriptionsSort$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsSort
> = z.nativeEnum(ListSubscriptionsSort);

/** @internal */
export const ListSubscriptionsSort$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsSort
> = ListSubscriptionsSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSort$ {
  /** @deprecated use `ListSubscriptionsSort$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsSort$inboundSchema;
  /** @deprecated use `ListSubscriptionsSort$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsSort$outboundSchema;
}

/** @internal */
export const ListSubscriptionsRequest$inboundSchema: z.ZodType<
  ListSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListSubscriptionsSort$inboundSchema).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListSubscriptionsRequest$Outbound = {
  customerId: string;
  from?: string | undefined;
  limit?: number | null | undefined;
  sort?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListSubscriptionsRequest$outboundSchema: z.ZodType<
  ListSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsRequest
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListSubscriptionsSort$outboundSchema).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsRequest$ {
  /** @deprecated use `ListSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsRequest$inboundSchema;
  /** @deprecated use `ListSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsRequest$outboundSchema;
  /** @deprecated use `ListSubscriptionsRequest$Outbound` instead. */
  export type Outbound = ListSubscriptionsRequest$Outbound;
}

export function listSubscriptionsRequestToJSON(
  listSubscriptionsRequest: ListSubscriptionsRequest,
): string {
  return JSON.stringify(
    ListSubscriptionsRequest$outboundSchema.parse(listSubscriptionsRequest),
  );
}

export function listSubscriptionsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsRequest' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsNotFoundDocumentation$inboundSchema: z.ZodType<
  ListSubscriptionsNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionsNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsNotFoundDocumentation$outboundSchema: z.ZodType<
  ListSubscriptionsNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsNotFoundDocumentation$ {
  /** @deprecated use `ListSubscriptionsNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionsNotFoundDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionsNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsNotFoundDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionsNotFoundDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionsNotFoundDocumentation$Outbound;
}

export function listSubscriptionsNotFoundDocumentationToJSON(
  listSubscriptionsNotFoundDocumentation:
    ListSubscriptionsNotFoundDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionsNotFoundDocumentation$outboundSchema.parse(
      listSubscriptionsNotFoundDocumentation,
    ),
  );
}

export function listSubscriptionsNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionsNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsNotFoundLinks$inboundSchema: z.ZodType<
  ListSubscriptionsNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionsNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListSubscriptionsNotFoundLinks$Outbound = {
  documentation: ListSubscriptionsNotFoundDocumentation$Outbound;
};

/** @internal */
export const ListSubscriptionsNotFoundLinks$outboundSchema: z.ZodType<
  ListSubscriptionsNotFoundLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionsNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsNotFoundLinks$ {
  /** @deprecated use `ListSubscriptionsNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsNotFoundLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionsNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsNotFoundLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionsNotFoundLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionsNotFoundLinks$Outbound;
}

export function listSubscriptionsNotFoundLinksToJSON(
  listSubscriptionsNotFoundLinks: ListSubscriptionsNotFoundLinks,
): string {
  return JSON.stringify(
    ListSubscriptionsNotFoundLinks$outboundSchema.parse(
      listSubscriptionsNotFoundLinks,
    ),
  );
}

export function listSubscriptionsNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsBadRequestDocumentation$inboundSchema: z.ZodType<
  ListSubscriptionsBadRequestDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsBadRequestDocumentation$outboundSchema: z.ZodType<
  ListSubscriptionsBadRequestDocumentation$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsBadRequestDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsBadRequestDocumentation$ {
  /** @deprecated use `ListSubscriptionsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionsBadRequestDocumentation$Outbound;
}

export function listSubscriptionsBadRequestDocumentationToJSON(
  listSubscriptionsBadRequestDocumentation:
    ListSubscriptionsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionsBadRequestDocumentation$outboundSchema.parse(
      listSubscriptionsBadRequestDocumentation,
    ),
  );
}

export function listSubscriptionsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsBadRequestLinks$inboundSchema: z.ZodType<
  ListSubscriptionsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListSubscriptionsBadRequestLinks$Outbound = {
  documentation: ListSubscriptionsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListSubscriptionsBadRequestLinks$outboundSchema: z.ZodType<
  ListSubscriptionsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListSubscriptionsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsBadRequestLinks$ {
  /** @deprecated use `ListSubscriptionsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionsBadRequestLinks$Outbound;
}

export function listSubscriptionsBadRequestLinksToJSON(
  listSubscriptionsBadRequestLinks: ListSubscriptionsBadRequestLinks,
): string {
  return JSON.stringify(
    ListSubscriptionsBadRequestLinks$outboundSchema.parse(
      listSubscriptionsBadRequestLinks,
    ),
  );
}

export function listSubscriptionsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsMode
> = z.nativeEnum(ListSubscriptionsMode);

/** @internal */
export const ListSubscriptionsMode$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsMode
> = ListSubscriptionsMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsMode$ {
  /** @deprecated use `ListSubscriptionsMode$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsMode$inboundSchema;
  /** @deprecated use `ListSubscriptionsMode$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsMode$outboundSchema;
}

/** @internal */
export const ListSubscriptionsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsStatus
> = z.nativeEnum(ListSubscriptionsStatus);

/** @internal */
export const ListSubscriptionsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsStatus
> = ListSubscriptionsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsStatus$ {
  /** @deprecated use `ListSubscriptionsStatus$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsStatus$inboundSchema;
  /** @deprecated use `ListSubscriptionsStatus$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsStatus$outboundSchema;
}

/** @internal */
export const ListSubscriptionsAmount$inboundSchema: z.ZodType<
  ListSubscriptionsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionsAmount$outboundSchema: z.ZodType<
  ListSubscriptionsAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsAmount$ {
  /** @deprecated use `ListSubscriptionsAmount$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionsAmount$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionsAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionsAmount$Outbound;
}

export function listSubscriptionsAmountToJSON(
  listSubscriptionsAmount: ListSubscriptionsAmount,
): string {
  return JSON.stringify(
    ListSubscriptionsAmount$outboundSchema.parse(listSubscriptionsAmount),
  );
}

export function listSubscriptionsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsInterval$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsInterval
> = z.nativeEnum(ListSubscriptionsInterval);

/** @internal */
export const ListSubscriptionsInterval$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsInterval
> = ListSubscriptionsInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsInterval$ {
  /** @deprecated use `ListSubscriptionsInterval$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsInterval$inboundSchema;
  /** @deprecated use `ListSubscriptionsInterval$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsInterval$outboundSchema;
}

/** @internal */
export const ListSubscriptionsMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsMethod
> = z.nativeEnum(ListSubscriptionsMethod);

/** @internal */
export const ListSubscriptionsMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListSubscriptionsMethod
> = ListSubscriptionsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsMethod$ {
  /** @deprecated use `ListSubscriptionsMethod$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsMethod$inboundSchema;
  /** @deprecated use `ListSubscriptionsMethod$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsMethod$outboundSchema;
}

/** @internal */
export const ListSubscriptionsApplicationFeeAmount$inboundSchema: z.ZodType<
  ListSubscriptionsApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListSubscriptionsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListSubscriptionsApplicationFeeAmount$outboundSchema: z.ZodType<
  ListSubscriptionsApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsApplicationFeeAmount$ {
  /** @deprecated use `ListSubscriptionsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListSubscriptionsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListSubscriptionsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListSubscriptionsApplicationFeeAmount$Outbound;
}

export function listSubscriptionsApplicationFeeAmountToJSON(
  listSubscriptionsApplicationFeeAmount: ListSubscriptionsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListSubscriptionsApplicationFeeAmount$outboundSchema.parse(
      listSubscriptionsApplicationFeeAmount,
    ),
  );
}

export function listSubscriptionsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionsApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsApplicationFee$inboundSchema: z.ZodType<
  ListSubscriptionsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListSubscriptionsApplicationFeeAmount$inboundSchema),
  description: z.string(),
});

/** @internal */
export type ListSubscriptionsApplicationFee$Outbound = {
  amount: ListSubscriptionsApplicationFeeAmount$Outbound;
  description: string;
};

/** @internal */
export const ListSubscriptionsApplicationFee$outboundSchema: z.ZodType<
  ListSubscriptionsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsApplicationFee
> = z.object({
  amount: z.lazy(() => ListSubscriptionsApplicationFeeAmount$outboundSchema),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsApplicationFee$ {
  /** @deprecated use `ListSubscriptionsApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsApplicationFee$inboundSchema;
  /** @deprecated use `ListSubscriptionsApplicationFee$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsApplicationFee$outboundSchema;
  /** @deprecated use `ListSubscriptionsApplicationFee$Outbound` instead. */
  export type Outbound = ListSubscriptionsApplicationFee$Outbound;
}

export function listSubscriptionsApplicationFeeToJSON(
  listSubscriptionsApplicationFee: ListSubscriptionsApplicationFee,
): string {
  return JSON.stringify(
    ListSubscriptionsApplicationFee$outboundSchema.parse(
      listSubscriptionsApplicationFee,
    ),
  );
}

export function listSubscriptionsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsMetadata$inboundSchema: z.ZodType<
  ListSubscriptionsMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type ListSubscriptionsMetadata$Outbound =
  | string
  | { [k: string]: any }
  | Array<string>;

/** @internal */
export const ListSubscriptionsMetadata$outboundSchema: z.ZodType<
  ListSubscriptionsMetadata$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsMetadata
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsMetadata$ {
  /** @deprecated use `ListSubscriptionsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsMetadata$inboundSchema;
  /** @deprecated use `ListSubscriptionsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsMetadata$outboundSchema;
  /** @deprecated use `ListSubscriptionsMetadata$Outbound` instead. */
  export type Outbound = ListSubscriptionsMetadata$Outbound;
}

export function listSubscriptionsMetadataToJSON(
  listSubscriptionsMetadata: ListSubscriptionsMetadata,
): string {
  return JSON.stringify(
    ListSubscriptionsMetadata$outboundSchema.parse(listSubscriptionsMetadata),
  );
}

export function listSubscriptionsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsMetadata' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsSubscriptionSelf$inboundSchema: z.ZodType<
  ListSubscriptionsSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionsSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsSubscriptionSelf$outboundSchema: z.ZodType<
  ListSubscriptionsSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSubscriptionSelf$ {
  /** @deprecated use `ListSubscriptionsSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsSubscriptionSelf$inboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsSubscriptionSelf$outboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionSelf$Outbound` instead. */
  export type Outbound = ListSubscriptionsSubscriptionSelf$Outbound;
}

export function listSubscriptionsSubscriptionSelfToJSON(
  listSubscriptionsSubscriptionSelf: ListSubscriptionsSubscriptionSelf,
): string {
  return JSON.stringify(
    ListSubscriptionsSubscriptionSelf$outboundSchema.parse(
      listSubscriptionsSubscriptionSelf,
    ),
  );
}

export function listSubscriptionsSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsCustomer$inboundSchema: z.ZodType<
  ListSubscriptionsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsCustomer$outboundSchema: z.ZodType<
  ListSubscriptionsCustomer$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsCustomer$ {
  /** @deprecated use `ListSubscriptionsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsCustomer$inboundSchema;
  /** @deprecated use `ListSubscriptionsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsCustomer$outboundSchema;
  /** @deprecated use `ListSubscriptionsCustomer$Outbound` instead. */
  export type Outbound = ListSubscriptionsCustomer$Outbound;
}

export function listSubscriptionsCustomerToJSON(
  listSubscriptionsCustomer: ListSubscriptionsCustomer,
): string {
  return JSON.stringify(
    ListSubscriptionsCustomer$outboundSchema.parse(listSubscriptionsCustomer),
  );
}

export function listSubscriptionsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsCustomer' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsMandate$inboundSchema: z.ZodType<
  ListSubscriptionsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsMandate$outboundSchema: z.ZodType<
  ListSubscriptionsMandate$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsMandate$ {
  /** @deprecated use `ListSubscriptionsMandate$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsMandate$inboundSchema;
  /** @deprecated use `ListSubscriptionsMandate$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsMandate$outboundSchema;
  /** @deprecated use `ListSubscriptionsMandate$Outbound` instead. */
  export type Outbound = ListSubscriptionsMandate$Outbound;
}

export function listSubscriptionsMandateToJSON(
  listSubscriptionsMandate: ListSubscriptionsMandate,
): string {
  return JSON.stringify(
    ListSubscriptionsMandate$outboundSchema.parse(listSubscriptionsMandate),
  );
}

export function listSubscriptionsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsMandate' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsProfile$inboundSchema: z.ZodType<
  ListSubscriptionsProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsProfile$outboundSchema: z.ZodType<
  ListSubscriptionsProfile$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsProfile$ {
  /** @deprecated use `ListSubscriptionsProfile$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsProfile$inboundSchema;
  /** @deprecated use `ListSubscriptionsProfile$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsProfile$outboundSchema;
  /** @deprecated use `ListSubscriptionsProfile$Outbound` instead. */
  export type Outbound = ListSubscriptionsProfile$Outbound;
}

export function listSubscriptionsProfileToJSON(
  listSubscriptionsProfile: ListSubscriptionsProfile,
): string {
  return JSON.stringify(
    ListSubscriptionsProfile$outboundSchema.parse(listSubscriptionsProfile),
  );
}

export function listSubscriptionsProfileFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsProfile' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsPayments$inboundSchema: z.ZodType<
  ListSubscriptionsPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsPayments$outboundSchema: z.ZodType<
  ListSubscriptionsPayments$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsPayments$ {
  /** @deprecated use `ListSubscriptionsPayments$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsPayments$inboundSchema;
  /** @deprecated use `ListSubscriptionsPayments$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsPayments$outboundSchema;
  /** @deprecated use `ListSubscriptionsPayments$Outbound` instead. */
  export type Outbound = ListSubscriptionsPayments$Outbound;
}

export function listSubscriptionsPaymentsToJSON(
  listSubscriptionsPayments: ListSubscriptionsPayments,
): string {
  return JSON.stringify(
    ListSubscriptionsPayments$outboundSchema.parse(listSubscriptionsPayments),
  );
}

export function listSubscriptionsPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsPayments' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsSubscriptionDocumentation$inboundSchema:
  z.ZodType<ListSubscriptionsSubscriptionDocumentation, z.ZodTypeDef, unknown> =
    z.object({
      href: z.string(),
      type: z.string(),
    });

/** @internal */
export type ListSubscriptionsSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsSubscriptionDocumentation$outboundSchema:
  z.ZodType<
    ListSubscriptionsSubscriptionDocumentation$Outbound,
    z.ZodTypeDef,
    ListSubscriptionsSubscriptionDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSubscriptionDocumentation$ {
  /** @deprecated use `ListSubscriptionsSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListSubscriptionsSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionsSubscriptionDocumentation$Outbound;
}

export function listSubscriptionsSubscriptionDocumentationToJSON(
  listSubscriptionsSubscriptionDocumentation:
    ListSubscriptionsSubscriptionDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionsSubscriptionDocumentation$outboundSchema.parse(
      listSubscriptionsSubscriptionDocumentation,
    ),
  );
}

export function listSubscriptionsSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListSubscriptionsSubscriptionDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionsSubscriptionDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListSubscriptionsSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsSubscriptionLinks$inboundSchema: z.ZodType<
  ListSubscriptionsSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSubscriptionsSubscriptionSelf$inboundSchema),
  customer: z.nullable(z.lazy(() => ListSubscriptionsCustomer$inboundSchema)),
  mandate: z.nullable(z.lazy(() => ListSubscriptionsMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => ListSubscriptionsProfile$inboundSchema)),
  payments: z.nullable(z.lazy(() => ListSubscriptionsPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionsSubscriptionDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListSubscriptionsSubscriptionLinks$Outbound = {
  self: ListSubscriptionsSubscriptionSelf$Outbound;
  customer: ListSubscriptionsCustomer$Outbound | null;
  mandate?: ListSubscriptionsMandate$Outbound | null | undefined;
  profile: ListSubscriptionsProfile$Outbound | null;
  payments?: ListSubscriptionsPayments$Outbound | null | undefined;
  documentation: ListSubscriptionsSubscriptionDocumentation$Outbound;
};

/** @internal */
export const ListSubscriptionsSubscriptionLinks$outboundSchema: z.ZodType<
  ListSubscriptionsSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsSubscriptionLinks
> = z.object({
  self: z.lazy(() => ListSubscriptionsSubscriptionSelf$outboundSchema),
  customer: z.nullable(z.lazy(() => ListSubscriptionsCustomer$outboundSchema)),
  mandate: z.nullable(z.lazy(() => ListSubscriptionsMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => ListSubscriptionsProfile$outboundSchema)),
  payments: z.nullable(z.lazy(() => ListSubscriptionsPayments$outboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListSubscriptionsSubscriptionDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSubscriptionLinks$ {
  /** @deprecated use `ListSubscriptionsSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsSubscriptionLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListSubscriptionsSubscriptionLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionsSubscriptionLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionsSubscriptionLinks$Outbound;
}

export function listSubscriptionsSubscriptionLinksToJSON(
  listSubscriptionsSubscriptionLinks: ListSubscriptionsSubscriptionLinks,
): string {
  return JSON.stringify(
    ListSubscriptionsSubscriptionLinks$outboundSchema.parse(
      listSubscriptionsSubscriptionLinks,
    ),
  );
}

export function listSubscriptionsSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListSubscriptionsSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsSubscription$inboundSchema: z.ZodType<
  ListSubscriptionsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionsMode$inboundSchema,
  status: ListSubscriptionsStatus$inboundSchema,
  amount: z.lazy(() => ListSubscriptionsAmount$inboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.number().int(),
  interval: ListSubscriptionsInterval$inboundSchema,
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(ListSubscriptionsMethod$inboundSchema),
  applicationFee: z.lazy(() => ListSubscriptionsApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListSubscriptionsSubscriptionLinks$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListSubscriptionsSubscription$Outbound = {
  resource: string;
  id: string;
  mode: string;
  status: string;
  amount: ListSubscriptionsAmount$Outbound;
  times: number | null;
  timesRemaining: number;
  interval: string;
  startDate: string;
  nextPaymentDate?: string | null | undefined;
  description: string;
  method: string | null;
  applicationFee?: ListSubscriptionsApplicationFee$Outbound | undefined;
  metadata: string | { [k: string]: any } | Array<string> | null;
  webhookUrl: string;
  customerId: string;
  mandateId?: string | null | undefined;
  createdAt: string;
  canceledAt?: string | null | undefined;
  _links?: ListSubscriptionsSubscriptionLinks$Outbound | undefined;
};

/** @internal */
export const ListSubscriptionsSubscription$outboundSchema: z.ZodType<
  ListSubscriptionsSubscription$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsSubscription
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListSubscriptionsMode$outboundSchema,
  status: ListSubscriptionsStatus$outboundSchema,
  amount: z.lazy(() => ListSubscriptionsAmount$outboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.number().int(),
  interval: ListSubscriptionsInterval$outboundSchema,
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(ListSubscriptionsMethod$outboundSchema),
  applicationFee: z.lazy(() => ListSubscriptionsApplicationFee$outboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListSubscriptionsSubscriptionLinks$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSubscription$ {
  /** @deprecated use `ListSubscriptionsSubscription$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsSubscription$inboundSchema;
  /** @deprecated use `ListSubscriptionsSubscription$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsSubscription$outboundSchema;
  /** @deprecated use `ListSubscriptionsSubscription$Outbound` instead. */
  export type Outbound = ListSubscriptionsSubscription$Outbound;
}

export function listSubscriptionsSubscriptionToJSON(
  listSubscriptionsSubscription: ListSubscriptionsSubscription,
): string {
  return JSON.stringify(
    ListSubscriptionsSubscription$outboundSchema.parse(
      listSubscriptionsSubscription,
    ),
  );
}

export function listSubscriptionsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsSubscription' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsEmbedded$inboundSchema: z.ZodType<
  ListSubscriptionsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptions: z.array(
    z.lazy(() => ListSubscriptionsSubscription$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListSubscriptionsEmbedded$Outbound = {
  subscriptions?: Array<ListSubscriptionsSubscription$Outbound> | undefined;
};

/** @internal */
export const ListSubscriptionsEmbedded$outboundSchema: z.ZodType<
  ListSubscriptionsEmbedded$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsEmbedded
> = z.object({
  subscriptions: z.array(
    z.lazy(() => ListSubscriptionsSubscription$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsEmbedded$ {
  /** @deprecated use `ListSubscriptionsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsEmbedded$inboundSchema;
  /** @deprecated use `ListSubscriptionsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsEmbedded$outboundSchema;
  /** @deprecated use `ListSubscriptionsEmbedded$Outbound` instead. */
  export type Outbound = ListSubscriptionsEmbedded$Outbound;
}

export function listSubscriptionsEmbeddedToJSON(
  listSubscriptionsEmbedded: ListSubscriptionsEmbedded,
): string {
  return JSON.stringify(
    ListSubscriptionsEmbedded$outboundSchema.parse(listSubscriptionsEmbedded),
  );
}

export function listSubscriptionsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsSelf$inboundSchema: z.ZodType<
  ListSubscriptionsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsSelf$outboundSchema: z.ZodType<
  ListSubscriptionsSelf$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsSelf$ {
  /** @deprecated use `ListSubscriptionsSelf$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsSelf$inboundSchema;
  /** @deprecated use `ListSubscriptionsSelf$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsSelf$outboundSchema;
  /** @deprecated use `ListSubscriptionsSelf$Outbound` instead. */
  export type Outbound = ListSubscriptionsSelf$Outbound;
}

export function listSubscriptionsSelfToJSON(
  listSubscriptionsSelf: ListSubscriptionsSelf,
): string {
  return JSON.stringify(
    ListSubscriptionsSelf$outboundSchema.parse(listSubscriptionsSelf),
  );
}

export function listSubscriptionsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsSelf' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsPrevious$inboundSchema: z.ZodType<
  ListSubscriptionsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsPrevious$outboundSchema: z.ZodType<
  ListSubscriptionsPrevious$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsPrevious$ {
  /** @deprecated use `ListSubscriptionsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsPrevious$inboundSchema;
  /** @deprecated use `ListSubscriptionsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsPrevious$outboundSchema;
  /** @deprecated use `ListSubscriptionsPrevious$Outbound` instead. */
  export type Outbound = ListSubscriptionsPrevious$Outbound;
}

export function listSubscriptionsPreviousToJSON(
  listSubscriptionsPrevious: ListSubscriptionsPrevious,
): string {
  return JSON.stringify(
    ListSubscriptionsPrevious$outboundSchema.parse(listSubscriptionsPrevious),
  );
}

export function listSubscriptionsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsPrevious' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsNext$inboundSchema: z.ZodType<
  ListSubscriptionsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListSubscriptionsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListSubscriptionsNext$outboundSchema: z.ZodType<
  ListSubscriptionsNext$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsNext$ {
  /** @deprecated use `ListSubscriptionsNext$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsNext$inboundSchema;
  /** @deprecated use `ListSubscriptionsNext$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsNext$outboundSchema;
  /** @deprecated use `ListSubscriptionsNext$Outbound` instead. */
  export type Outbound = ListSubscriptionsNext$Outbound;
}

export function listSubscriptionsNextToJSON(
  listSubscriptionsNext: ListSubscriptionsNext,
): string {
  return JSON.stringify(
    ListSubscriptionsNext$outboundSchema.parse(listSubscriptionsNext),
  );
}

export function listSubscriptionsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsNext' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsDocumentation$inboundSchema: z.ZodType<
  ListSubscriptionsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListSubscriptionsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListSubscriptionsDocumentation$outboundSchema: z.ZodType<
  ListSubscriptionsDocumentation$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsDocumentation$ {
  /** @deprecated use `ListSubscriptionsDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsDocumentation$inboundSchema;
  /** @deprecated use `ListSubscriptionsDocumentation$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsDocumentation$outboundSchema;
  /** @deprecated use `ListSubscriptionsDocumentation$Outbound` instead. */
  export type Outbound = ListSubscriptionsDocumentation$Outbound;
}

export function listSubscriptionsDocumentationToJSON(
  listSubscriptionsDocumentation: ListSubscriptionsDocumentation,
): string {
  return JSON.stringify(
    ListSubscriptionsDocumentation$outboundSchema.parse(
      listSubscriptionsDocumentation,
    ),
  );
}

export function listSubscriptionsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsLinks$inboundSchema: z.ZodType<
  ListSubscriptionsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListSubscriptionsSelf$inboundSchema),
  previous: z.nullable(z.lazy(() => ListSubscriptionsPrevious$inboundSchema)),
  next: z.nullable(z.lazy(() => ListSubscriptionsNext$inboundSchema)),
  documentation: z.lazy(() => ListSubscriptionsDocumentation$inboundSchema),
});

/** @internal */
export type ListSubscriptionsLinks$Outbound = {
  self: ListSubscriptionsSelf$Outbound;
  previous: ListSubscriptionsPrevious$Outbound | null;
  next: ListSubscriptionsNext$Outbound | null;
  documentation: ListSubscriptionsDocumentation$Outbound;
};

/** @internal */
export const ListSubscriptionsLinks$outboundSchema: z.ZodType<
  ListSubscriptionsLinks$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsLinks
> = z.object({
  self: z.lazy(() => ListSubscriptionsSelf$outboundSchema),
  previous: z.nullable(z.lazy(() => ListSubscriptionsPrevious$outboundSchema)),
  next: z.nullable(z.lazy(() => ListSubscriptionsNext$outboundSchema)),
  documentation: z.lazy(() => ListSubscriptionsDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsLinks$ {
  /** @deprecated use `ListSubscriptionsLinks$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsLinks$inboundSchema;
  /** @deprecated use `ListSubscriptionsLinks$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsLinks$outboundSchema;
  /** @deprecated use `ListSubscriptionsLinks$Outbound` instead. */
  export type Outbound = ListSubscriptionsLinks$Outbound;
}

export function listSubscriptionsLinksToJSON(
  listSubscriptionsLinks: ListSubscriptionsLinks,
): string {
  return JSON.stringify(
    ListSubscriptionsLinks$outboundSchema.parse(listSubscriptionsLinks),
  );
}

export function listSubscriptionsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsLinks' from JSON`,
  );
}

/** @internal */
export const ListSubscriptionsResponse$inboundSchema: z.ZodType<
  ListSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListSubscriptionsEmbedded$inboundSchema).optional(),
  _links: z.lazy(() => ListSubscriptionsLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListSubscriptionsResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListSubscriptionsEmbedded$Outbound | undefined;
  _links?: ListSubscriptionsLinks$Outbound | undefined;
};

/** @internal */
export const ListSubscriptionsResponse$outboundSchema: z.ZodType<
  ListSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  ListSubscriptionsResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListSubscriptionsEmbedded$outboundSchema).optional(),
  links: z.lazy(() => ListSubscriptionsLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscriptionsResponse$ {
  /** @deprecated use `ListSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = ListSubscriptionsResponse$inboundSchema;
  /** @deprecated use `ListSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = ListSubscriptionsResponse$outboundSchema;
  /** @deprecated use `ListSubscriptionsResponse$Outbound` instead. */
  export type Outbound = ListSubscriptionsResponse$Outbound;
}

export function listSubscriptionsResponseToJSON(
  listSubscriptionsResponse: ListSubscriptionsResponse,
): string {
  return JSON.stringify(
    ListSubscriptionsResponse$outboundSchema.parse(listSubscriptionsResponse),
  );
}

export function listSubscriptionsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscriptionsResponse' from JSON`,
  );
}
