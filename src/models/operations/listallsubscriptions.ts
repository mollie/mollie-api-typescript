/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListAllSubscriptionsRequest = {
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
   *
   * @remarks
   * result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to retrieve subscriptions for.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` is already implied.
   *
   * To retrieve all subscriptions across the organization, use an organization-level API credential and omit the
   * `profileId` parameter.
   */
  profileId?: string | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListAllSubscriptionsNotFoundDocumentation = {
  href: string;
  type: string;
};

export type ListAllSubscriptionsNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListAllSubscriptionsNotFoundDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListAllSubscriptionsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListAllSubscriptionsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListAllSubscriptionsBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListAllSubscriptionsMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListAllSubscriptionsMode = ClosedEnum<
  typeof ListAllSubscriptionsMode
>;

/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export const ListAllSubscriptionsStatus = {
  Pending: "pending",
  Active: "active",
  Canceled: "canceled",
  Suspended: "suspended",
  Completed: "completed",
} as const;
/**
 * The subscription's current status is directly related to the status of the underlying customer or mandate that is
 *
 * @remarks
 * enabling the subscription.
 */
export type ListAllSubscriptionsStatus = ClosedEnum<
  typeof ListAllSubscriptionsStatus
>;

/**
 * The amount for each individual payment that is charged with this subscription. For example, for a monthly
 *
 * @remarks
 * subscription of €10, the subscription amount should be set to €10.
 */
export type ListAllSubscriptionsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export const ListAllSubscriptionsMethod = {
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Paypal: "paypal",
} as const;
/**
 * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
 */
export type ListAllSubscriptionsMethod = ClosedEnum<
  typeof ListAllSubscriptionsMethod
>;

/**
 * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
 */
export type ListAllSubscriptionsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
 *
 * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
 * information.
 */
export type ListAllSubscriptionsApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: ListAllSubscriptionsApplicationFeeAmount;
  description: string;
};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
 *
 * @remarks
 * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
 * 1kB.
 *
 * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
 */
export type ListAllSubscriptionsMetadata =
  | string
  | { [k: string]: any }
  | Array<string>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllSubscriptionsSubscriptionSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer) this subscription was created for.
 */
export type ListAllSubscriptionsCustomer = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [mandate](get-mandate) this subscription was created for.
 */
export type ListAllSubscriptionsMandate = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [profile](get-profile) this subscription was created for.
 */
export type ListAllSubscriptionsProfile = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
 *
 * @remarks
 * payments exist (yet).
 */
export type ListAllSubscriptionsPayments = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllSubscriptionsSubscriptionDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListAllSubscriptionsSubscriptionLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListAllSubscriptionsSubscriptionSelf;
  /**
   * The API resource URL of the [customer](get-customer) this subscription was created for.
   */
  customer: ListAllSubscriptionsCustomer | null;
  /**
   * The API resource URL of the [mandate](get-mandate) this subscription was created for.
   */
  mandate?: ListAllSubscriptionsMandate | null | undefined;
  /**
   * The API resource URL of the [profile](get-profile) this subscription was created for.
   */
  profile: ListAllSubscriptionsProfile | null;
  /**
   * The API resource URL of the [payments](list-payments) created for this subscription. Omitted if no such
   *
   * @remarks
   * payments exist (yet).
   */
  payments?: ListAllSubscriptionsPayments | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListAllSubscriptionsSubscriptionDocumentation;
};

export type ListAllSubscriptionsSubscription = {
  /**
   * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListAllSubscriptionsMode;
  /**
   * The subscription's current status is directly related to the status of the underlying customer or mandate that is
   *
   * @remarks
   * enabling the subscription.
   */
  status: ListAllSubscriptionsStatus;
  /**
   * The amount for each individual payment that is charged with this subscription. For example, for a monthly
   *
   * @remarks
   * subscription of €10, the subscription amount should be set to €10.
   */
  amount: ListAllSubscriptionsAmount;
  /**
   * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
   *
   * @remarks
   * considered completed.
   *
   * Test mode subscriptions will get canceled automatically after 10 payments.
   */
  times: number | null;
  /**
   * Number of payments left for the subscription.
   */
  timesRemaining: number | null;
  /**
   * Interval to wait between payments, for example `1 month` or `14 days`.
   *
   * @remarks
   *
   * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval: string;
  /**
   * The start date of the subscription in `YYYY-MM-DD` format.
   */
  startDate: string;
  /**
   * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
   *
   * @remarks
   * this parameter will not be returned.
   */
  nextPaymentDate?: string | null | undefined;
  /**
   * The subscription's description will be used as the description of the resulting individual payments and so showing
   *
   * @remarks
   * up on the bank statement of the consumer.
   *
   * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
   */
  description: string;
  /**
   * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
   */
  method: ListAllSubscriptionsMethod | null;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
   *
   * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
   * information.
   */
  applicationFee?: ListAllSubscriptionsApplicationFee | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
   *
   * @remarks
   * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
   * 1kB.
   *
   * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
   */
  metadata: string | { [k: string]: any } | Array<string> | null;
  /**
   * We will call this URL for any payment status changes of payments resulting from this subscription.
   *
   * @remarks
   *
   * This webhook will receive **all** events for the subscription's payments. This may include payment failures as
   * well. Be sure to verify the payment's subscription ID and its status.
   */
  webhookUrl: string;
  /**
   * The customer this subscription belongs to.
   */
  customerId: string;
  /**
   * The mandate used for this subscription, if any.
   */
  mandateId?: string | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
   *
   * @remarks
   * subscription is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListAllSubscriptionsSubscriptionLinks;
};

export type ListAllSubscriptionsEmbedded = {
  /**
   * A list of subscription objects.
   */
  subscriptions?: Array<ListAllSubscriptionsSubscription> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListAllSubscriptionsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListAllSubscriptionsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListAllSubscriptionsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListAllSubscriptionsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListAllSubscriptionsLinks = {
  /**
   * The URL to the current set of items.
   */
  self: ListAllSubscriptionsSelf;
  /**
   * The previous set of items, if available.
   */
  previous: ListAllSubscriptionsPrevious | null;
  /**
   * The next set of items, if available.
   */
  next: ListAllSubscriptionsNext | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListAllSubscriptionsDocumentation;
};

/**
 * A list of subscription objects.
 */
export type ListAllSubscriptionsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count: number;
  embedded: ListAllSubscriptionsEmbedded;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links: ListAllSubscriptionsLinks;
};

/** @internal */
export const ListAllSubscriptionsRequest$inboundSchema: z.ZodType<
  ListAllSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  profileId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListAllSubscriptionsRequest$Outbound = {
  from?: string | undefined;
  limit?: number | null | undefined;
  profileId?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListAllSubscriptionsRequest$outboundSchema: z.ZodType<
  ListAllSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsRequest
> = z.object({
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  profileId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsRequest$ {
  /** @deprecated use `ListAllSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsRequest$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsRequest$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsRequest$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsRequest$Outbound;
}

export function listAllSubscriptionsRequestToJSON(
  listAllSubscriptionsRequest: ListAllSubscriptionsRequest,
): string {
  return JSON.stringify(
    ListAllSubscriptionsRequest$outboundSchema.parse(
      listAllSubscriptionsRequest,
    ),
  );
}

export function listAllSubscriptionsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsRequest' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsNotFoundDocumentation$inboundSchema: z.ZodType<
  ListAllSubscriptionsNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllSubscriptionsNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsNotFoundDocumentation$outboundSchema:
  z.ZodType<
    ListAllSubscriptionsNotFoundDocumentation$Outbound,
    z.ZodTypeDef,
    ListAllSubscriptionsNotFoundDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsNotFoundDocumentation$ {
  /** @deprecated use `ListAllSubscriptionsNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsNotFoundDocumentation$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsNotFoundDocumentation$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsNotFoundDocumentation$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsNotFoundDocumentation$Outbound;
}

export function listAllSubscriptionsNotFoundDocumentationToJSON(
  listAllSubscriptionsNotFoundDocumentation:
    ListAllSubscriptionsNotFoundDocumentation,
): string {
  return JSON.stringify(
    ListAllSubscriptionsNotFoundDocumentation$outboundSchema.parse(
      listAllSubscriptionsNotFoundDocumentation,
    ),
  );
}

export function listAllSubscriptionsNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAllSubscriptionsNotFoundDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsNotFoundDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAllSubscriptionsNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsNotFoundLinks$inboundSchema: z.ZodType<
  ListAllSubscriptionsNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListAllSubscriptionsNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListAllSubscriptionsNotFoundLinks$Outbound = {
  documentation: ListAllSubscriptionsNotFoundDocumentation$Outbound;
};

/** @internal */
export const ListAllSubscriptionsNotFoundLinks$outboundSchema: z.ZodType<
  ListAllSubscriptionsNotFoundLinks$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    ListAllSubscriptionsNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsNotFoundLinks$ {
  /** @deprecated use `ListAllSubscriptionsNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsNotFoundLinks$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsNotFoundLinks$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsNotFoundLinks$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsNotFoundLinks$Outbound;
}

export function listAllSubscriptionsNotFoundLinksToJSON(
  listAllSubscriptionsNotFoundLinks: ListAllSubscriptionsNotFoundLinks,
): string {
  return JSON.stringify(
    ListAllSubscriptionsNotFoundLinks$outboundSchema.parse(
      listAllSubscriptionsNotFoundLinks,
    ),
  );
}

export function listAllSubscriptionsNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsBadRequestDocumentation$inboundSchema:
  z.ZodType<
    ListAllSubscriptionsBadRequestDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListAllSubscriptionsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsBadRequestDocumentation$outboundSchema:
  z.ZodType<
    ListAllSubscriptionsBadRequestDocumentation$Outbound,
    z.ZodTypeDef,
    ListAllSubscriptionsBadRequestDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsBadRequestDocumentation$ {
  /** @deprecated use `ListAllSubscriptionsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsBadRequestDocumentation$Outbound;
}

export function listAllSubscriptionsBadRequestDocumentationToJSON(
  listAllSubscriptionsBadRequestDocumentation:
    ListAllSubscriptionsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListAllSubscriptionsBadRequestDocumentation$outboundSchema.parse(
      listAllSubscriptionsBadRequestDocumentation,
    ),
  );
}

export function listAllSubscriptionsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAllSubscriptionsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAllSubscriptionsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsBadRequestLinks$inboundSchema: z.ZodType<
  ListAllSubscriptionsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListAllSubscriptionsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListAllSubscriptionsBadRequestLinks$Outbound = {
  documentation: ListAllSubscriptionsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListAllSubscriptionsBadRequestLinks$outboundSchema: z.ZodType<
  ListAllSubscriptionsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListAllSubscriptionsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsBadRequestLinks$ {
  /** @deprecated use `ListAllSubscriptionsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsBadRequestLinks$Outbound;
}

export function listAllSubscriptionsBadRequestLinksToJSON(
  listAllSubscriptionsBadRequestLinks: ListAllSubscriptionsBadRequestLinks,
): string {
  return JSON.stringify(
    ListAllSubscriptionsBadRequestLinks$outboundSchema.parse(
      listAllSubscriptionsBadRequestLinks,
    ),
  );
}

export function listAllSubscriptionsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsMode
> = z.nativeEnum(ListAllSubscriptionsMode);

/** @internal */
export const ListAllSubscriptionsMode$outboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsMode
> = ListAllSubscriptionsMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsMode$ {
  /** @deprecated use `ListAllSubscriptionsMode$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsMode$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsMode$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsMode$outboundSchema;
}

/** @internal */
export const ListAllSubscriptionsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsStatus
> = z.nativeEnum(ListAllSubscriptionsStatus);

/** @internal */
export const ListAllSubscriptionsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsStatus
> = ListAllSubscriptionsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsStatus$ {
  /** @deprecated use `ListAllSubscriptionsStatus$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsStatus$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsStatus$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsStatus$outboundSchema;
}

/** @internal */
export const ListAllSubscriptionsAmount$inboundSchema: z.ZodType<
  ListAllSubscriptionsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllSubscriptionsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllSubscriptionsAmount$outboundSchema: z.ZodType<
  ListAllSubscriptionsAmount$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsAmount$ {
  /** @deprecated use `ListAllSubscriptionsAmount$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsAmount$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsAmount$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsAmount$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsAmount$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsAmount$Outbound;
}

export function listAllSubscriptionsAmountToJSON(
  listAllSubscriptionsAmount: ListAllSubscriptionsAmount,
): string {
  return JSON.stringify(
    ListAllSubscriptionsAmount$outboundSchema.parse(listAllSubscriptionsAmount),
  );
}

export function listAllSubscriptionsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsAmount' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsMethod
> = z.nativeEnum(ListAllSubscriptionsMethod);

/** @internal */
export const ListAllSubscriptionsMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListAllSubscriptionsMethod
> = ListAllSubscriptionsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsMethod$ {
  /** @deprecated use `ListAllSubscriptionsMethod$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsMethod$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsMethod$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsMethod$outboundSchema;
}

/** @internal */
export const ListAllSubscriptionsApplicationFeeAmount$inboundSchema: z.ZodType<
  ListAllSubscriptionsApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListAllSubscriptionsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListAllSubscriptionsApplicationFeeAmount$outboundSchema: z.ZodType<
  ListAllSubscriptionsApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsApplicationFeeAmount$ {
  /** @deprecated use `ListAllSubscriptionsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsApplicationFeeAmount$Outbound;
}

export function listAllSubscriptionsApplicationFeeAmountToJSON(
  listAllSubscriptionsApplicationFeeAmount:
    ListAllSubscriptionsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListAllSubscriptionsApplicationFeeAmount$outboundSchema.parse(
      listAllSubscriptionsApplicationFeeAmount,
    ),
  );
}

export function listAllSubscriptionsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAllSubscriptionsApplicationFeeAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsApplicationFeeAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAllSubscriptionsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsApplicationFee$inboundSchema: z.ZodType<
  ListAllSubscriptionsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListAllSubscriptionsApplicationFeeAmount$inboundSchema),
  description: z.string(),
});

/** @internal */
export type ListAllSubscriptionsApplicationFee$Outbound = {
  amount: ListAllSubscriptionsApplicationFeeAmount$Outbound;
  description: string;
};

/** @internal */
export const ListAllSubscriptionsApplicationFee$outboundSchema: z.ZodType<
  ListAllSubscriptionsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsApplicationFee
> = z.object({
  amount: z.lazy(() => ListAllSubscriptionsApplicationFeeAmount$outboundSchema),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsApplicationFee$ {
  /** @deprecated use `ListAllSubscriptionsApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsApplicationFee$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsApplicationFee$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsApplicationFee$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsApplicationFee$Outbound;
}

export function listAllSubscriptionsApplicationFeeToJSON(
  listAllSubscriptionsApplicationFee: ListAllSubscriptionsApplicationFee,
): string {
  return JSON.stringify(
    ListAllSubscriptionsApplicationFee$outboundSchema.parse(
      listAllSubscriptionsApplicationFee,
    ),
  );
}

export function listAllSubscriptionsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsMetadata$inboundSchema: z.ZodType<
  ListAllSubscriptionsMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type ListAllSubscriptionsMetadata$Outbound = string | {
  [k: string]: any;
} | Array<string>;

/** @internal */
export const ListAllSubscriptionsMetadata$outboundSchema: z.ZodType<
  ListAllSubscriptionsMetadata$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsMetadata
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsMetadata$ {
  /** @deprecated use `ListAllSubscriptionsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsMetadata$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsMetadata$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsMetadata$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsMetadata$Outbound;
}

export function listAllSubscriptionsMetadataToJSON(
  listAllSubscriptionsMetadata: ListAllSubscriptionsMetadata,
): string {
  return JSON.stringify(
    ListAllSubscriptionsMetadata$outboundSchema.parse(
      listAllSubscriptionsMetadata,
    ),
  );
}

export function listAllSubscriptionsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsMetadata' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsSubscriptionSelf$inboundSchema: z.ZodType<
  ListAllSubscriptionsSubscriptionSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllSubscriptionsSubscriptionSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsSubscriptionSelf$outboundSchema: z.ZodType<
  ListAllSubscriptionsSubscriptionSelf$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsSubscriptionSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsSubscriptionSelf$ {
  /** @deprecated use `ListAllSubscriptionsSubscriptionSelf$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsSubscriptionSelf$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionSelf$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsSubscriptionSelf$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionSelf$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsSubscriptionSelf$Outbound;
}

export function listAllSubscriptionsSubscriptionSelfToJSON(
  listAllSubscriptionsSubscriptionSelf: ListAllSubscriptionsSubscriptionSelf,
): string {
  return JSON.stringify(
    ListAllSubscriptionsSubscriptionSelf$outboundSchema.parse(
      listAllSubscriptionsSubscriptionSelf,
    ),
  );
}

export function listAllSubscriptionsSubscriptionSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsSubscriptionSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsSubscriptionSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsSubscriptionSelf' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsCustomer$inboundSchema: z.ZodType<
  ListAllSubscriptionsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsCustomer$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsCustomer$outboundSchema: z.ZodType<
  ListAllSubscriptionsCustomer$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsCustomer
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsCustomer$ {
  /** @deprecated use `ListAllSubscriptionsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsCustomer$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsCustomer$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsCustomer$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsCustomer$Outbound;
}

export function listAllSubscriptionsCustomerToJSON(
  listAllSubscriptionsCustomer: ListAllSubscriptionsCustomer,
): string {
  return JSON.stringify(
    ListAllSubscriptionsCustomer$outboundSchema.parse(
      listAllSubscriptionsCustomer,
    ),
  );
}

export function listAllSubscriptionsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsCustomer' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsMandate$inboundSchema: z.ZodType<
  ListAllSubscriptionsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsMandate$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsMandate$outboundSchema: z.ZodType<
  ListAllSubscriptionsMandate$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsMandate
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsMandate$ {
  /** @deprecated use `ListAllSubscriptionsMandate$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsMandate$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsMandate$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsMandate$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsMandate$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsMandate$Outbound;
}

export function listAllSubscriptionsMandateToJSON(
  listAllSubscriptionsMandate: ListAllSubscriptionsMandate,
): string {
  return JSON.stringify(
    ListAllSubscriptionsMandate$outboundSchema.parse(
      listAllSubscriptionsMandate,
    ),
  );
}

export function listAllSubscriptionsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsMandate' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsProfile$inboundSchema: z.ZodType<
  ListAllSubscriptionsProfile,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsProfile$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsProfile$outboundSchema: z.ZodType<
  ListAllSubscriptionsProfile$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsProfile
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsProfile$ {
  /** @deprecated use `ListAllSubscriptionsProfile$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsProfile$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsProfile$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsProfile$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsProfile$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsProfile$Outbound;
}

export function listAllSubscriptionsProfileToJSON(
  listAllSubscriptionsProfile: ListAllSubscriptionsProfile,
): string {
  return JSON.stringify(
    ListAllSubscriptionsProfile$outboundSchema.parse(
      listAllSubscriptionsProfile,
    ),
  );
}

export function listAllSubscriptionsProfileFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsProfile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsProfile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsProfile' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsPayments$inboundSchema: z.ZodType<
  ListAllSubscriptionsPayments,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsPayments$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsPayments$outboundSchema: z.ZodType<
  ListAllSubscriptionsPayments$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsPayments
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsPayments$ {
  /** @deprecated use `ListAllSubscriptionsPayments$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsPayments$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsPayments$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsPayments$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsPayments$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsPayments$Outbound;
}

export function listAllSubscriptionsPaymentsToJSON(
  listAllSubscriptionsPayments: ListAllSubscriptionsPayments,
): string {
  return JSON.stringify(
    ListAllSubscriptionsPayments$outboundSchema.parse(
      listAllSubscriptionsPayments,
    ),
  );
}

export function listAllSubscriptionsPaymentsFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsPayments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsPayments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsPayments' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsSubscriptionDocumentation$inboundSchema:
  z.ZodType<
    ListAllSubscriptionsSubscriptionDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListAllSubscriptionsSubscriptionDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsSubscriptionDocumentation$outboundSchema:
  z.ZodType<
    ListAllSubscriptionsSubscriptionDocumentation$Outbound,
    z.ZodTypeDef,
    ListAllSubscriptionsSubscriptionDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsSubscriptionDocumentation$ {
  /** @deprecated use `ListAllSubscriptionsSubscriptionDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsSubscriptionDocumentation$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsSubscriptionDocumentation$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionDocumentation$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsSubscriptionDocumentation$Outbound;
}

export function listAllSubscriptionsSubscriptionDocumentationToJSON(
  listAllSubscriptionsSubscriptionDocumentation:
    ListAllSubscriptionsSubscriptionDocumentation,
): string {
  return JSON.stringify(
    ListAllSubscriptionsSubscriptionDocumentation$outboundSchema.parse(
      listAllSubscriptionsSubscriptionDocumentation,
    ),
  );
}

export function listAllSubscriptionsSubscriptionDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAllSubscriptionsSubscriptionDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsSubscriptionDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAllSubscriptionsSubscriptionDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsSubscriptionLinks$inboundSchema: z.ZodType<
  ListAllSubscriptionsSubscriptionLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListAllSubscriptionsSubscriptionSelf$inboundSchema),
  customer: z.nullable(
    z.lazy(() => ListAllSubscriptionsCustomer$inboundSchema),
  ),
  mandate: z.nullable(z.lazy(() => ListAllSubscriptionsMandate$inboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => ListAllSubscriptionsProfile$inboundSchema)),
  payments: z.nullable(z.lazy(() => ListAllSubscriptionsPayments$inboundSchema))
    .optional(),
  documentation: z.lazy(() =>
    ListAllSubscriptionsSubscriptionDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListAllSubscriptionsSubscriptionLinks$Outbound = {
  self: ListAllSubscriptionsSubscriptionSelf$Outbound;
  customer: ListAllSubscriptionsCustomer$Outbound | null;
  mandate?: ListAllSubscriptionsMandate$Outbound | null | undefined;
  profile: ListAllSubscriptionsProfile$Outbound | null;
  payments?: ListAllSubscriptionsPayments$Outbound | null | undefined;
  documentation: ListAllSubscriptionsSubscriptionDocumentation$Outbound;
};

/** @internal */
export const ListAllSubscriptionsSubscriptionLinks$outboundSchema: z.ZodType<
  ListAllSubscriptionsSubscriptionLinks$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsSubscriptionLinks
> = z.object({
  self: z.lazy(() => ListAllSubscriptionsSubscriptionSelf$outboundSchema),
  customer: z.nullable(
    z.lazy(() => ListAllSubscriptionsCustomer$outboundSchema),
  ),
  mandate: z.nullable(z.lazy(() => ListAllSubscriptionsMandate$outboundSchema))
    .optional(),
  profile: z.nullable(z.lazy(() => ListAllSubscriptionsProfile$outboundSchema)),
  payments: z.nullable(
    z.lazy(() => ListAllSubscriptionsPayments$outboundSchema),
  ).optional(),
  documentation: z.lazy(() =>
    ListAllSubscriptionsSubscriptionDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsSubscriptionLinks$ {
  /** @deprecated use `ListAllSubscriptionsSubscriptionLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListAllSubscriptionsSubscriptionLinks$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsSubscriptionLinks$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscriptionLinks$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsSubscriptionLinks$Outbound;
}

export function listAllSubscriptionsSubscriptionLinksToJSON(
  listAllSubscriptionsSubscriptionLinks: ListAllSubscriptionsSubscriptionLinks,
): string {
  return JSON.stringify(
    ListAllSubscriptionsSubscriptionLinks$outboundSchema.parse(
      listAllSubscriptionsSubscriptionLinks,
    ),
  );
}

export function listAllSubscriptionsSubscriptionLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsSubscriptionLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAllSubscriptionsSubscriptionLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsSubscriptionLinks' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsSubscription$inboundSchema: z.ZodType<
  ListAllSubscriptionsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListAllSubscriptionsMode$inboundSchema,
  status: ListAllSubscriptionsStatus$inboundSchema,
  amount: z.lazy(() => ListAllSubscriptionsAmount$inboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(ListAllSubscriptionsMethod$inboundSchema),
  applicationFee: z.lazy(() => ListAllSubscriptionsApplicationFee$inboundSchema)
    .optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListAllSubscriptionsSubscriptionLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListAllSubscriptionsSubscription$Outbound = {
  resource: string;
  id: string;
  mode: string;
  status: string;
  amount: ListAllSubscriptionsAmount$Outbound;
  times: number | null;
  timesRemaining: number | null;
  interval: string;
  startDate: string;
  nextPaymentDate?: string | null | undefined;
  description: string;
  method: string | null;
  applicationFee?: ListAllSubscriptionsApplicationFee$Outbound | undefined;
  metadata: string | { [k: string]: any } | Array<string> | null;
  webhookUrl: string;
  customerId: string;
  mandateId?: string | null | undefined;
  createdAt: string;
  canceledAt?: string | null | undefined;
  _links: ListAllSubscriptionsSubscriptionLinks$Outbound;
};

/** @internal */
export const ListAllSubscriptionsSubscription$outboundSchema: z.ZodType<
  ListAllSubscriptionsSubscription$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsSubscription
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListAllSubscriptionsMode$outboundSchema,
  status: ListAllSubscriptionsStatus$outboundSchema,
  amount: z.lazy(() => ListAllSubscriptionsAmount$outboundSchema),
  times: z.nullable(z.number().int()),
  timesRemaining: z.nullable(z.number().int()),
  interval: z.string(),
  startDate: z.string(),
  nextPaymentDate: z.nullable(z.string()).optional(),
  description: z.string(),
  method: z.nullable(ListAllSubscriptionsMethod$outboundSchema),
  applicationFee: z.lazy(() =>
    ListAllSubscriptionsApplicationFee$outboundSchema
  ).optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ),
  webhookUrl: z.string(),
  customerId: z.string(),
  mandateId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  canceledAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListAllSubscriptionsSubscriptionLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsSubscription$ {
  /** @deprecated use `ListAllSubscriptionsSubscription$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsSubscription$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscription$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsSubscription$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsSubscription$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsSubscription$Outbound;
}

export function listAllSubscriptionsSubscriptionToJSON(
  listAllSubscriptionsSubscription: ListAllSubscriptionsSubscription,
): string {
  return JSON.stringify(
    ListAllSubscriptionsSubscription$outboundSchema.parse(
      listAllSubscriptionsSubscription,
    ),
  );
}

export function listAllSubscriptionsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsSubscription' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsEmbedded$inboundSchema: z.ZodType<
  ListAllSubscriptionsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptions: z.array(
    z.lazy(() => ListAllSubscriptionsSubscription$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListAllSubscriptionsEmbedded$Outbound = {
  subscriptions?: Array<ListAllSubscriptionsSubscription$Outbound> | undefined;
};

/** @internal */
export const ListAllSubscriptionsEmbedded$outboundSchema: z.ZodType<
  ListAllSubscriptionsEmbedded$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsEmbedded
> = z.object({
  subscriptions: z.array(
    z.lazy(() => ListAllSubscriptionsSubscription$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsEmbedded$ {
  /** @deprecated use `ListAllSubscriptionsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsEmbedded$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsEmbedded$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsEmbedded$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsEmbedded$Outbound;
}

export function listAllSubscriptionsEmbeddedToJSON(
  listAllSubscriptionsEmbedded: ListAllSubscriptionsEmbedded,
): string {
  return JSON.stringify(
    ListAllSubscriptionsEmbedded$outboundSchema.parse(
      listAllSubscriptionsEmbedded,
    ),
  );
}

export function listAllSubscriptionsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsSelf$inboundSchema: z.ZodType<
  ListAllSubscriptionsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllSubscriptionsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsSelf$outboundSchema: z.ZodType<
  ListAllSubscriptionsSelf$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsSelf$ {
  /** @deprecated use `ListAllSubscriptionsSelf$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsSelf$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsSelf$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsSelf$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsSelf$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsSelf$Outbound;
}

export function listAllSubscriptionsSelfToJSON(
  listAllSubscriptionsSelf: ListAllSubscriptionsSelf,
): string {
  return JSON.stringify(
    ListAllSubscriptionsSelf$outboundSchema.parse(listAllSubscriptionsSelf),
  );
}

export function listAllSubscriptionsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsSelf' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsPrevious$inboundSchema: z.ZodType<
  ListAllSubscriptionsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsPrevious$outboundSchema: z.ZodType<
  ListAllSubscriptionsPrevious$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsPrevious$ {
  /** @deprecated use `ListAllSubscriptionsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsPrevious$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsPrevious$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsPrevious$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsPrevious$Outbound;
}

export function listAllSubscriptionsPreviousToJSON(
  listAllSubscriptionsPrevious: ListAllSubscriptionsPrevious,
): string {
  return JSON.stringify(
    ListAllSubscriptionsPrevious$outboundSchema.parse(
      listAllSubscriptionsPrevious,
    ),
  );
}

export function listAllSubscriptionsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsPrevious' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsNext$inboundSchema: z.ZodType<
  ListAllSubscriptionsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListAllSubscriptionsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListAllSubscriptionsNext$outboundSchema: z.ZodType<
  ListAllSubscriptionsNext$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsNext$ {
  /** @deprecated use `ListAllSubscriptionsNext$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsNext$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsNext$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsNext$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsNext$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsNext$Outbound;
}

export function listAllSubscriptionsNextToJSON(
  listAllSubscriptionsNext: ListAllSubscriptionsNext,
): string {
  return JSON.stringify(
    ListAllSubscriptionsNext$outboundSchema.parse(listAllSubscriptionsNext),
  );
}

export function listAllSubscriptionsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsNext' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsDocumentation$inboundSchema: z.ZodType<
  ListAllSubscriptionsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListAllSubscriptionsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListAllSubscriptionsDocumentation$outboundSchema: z.ZodType<
  ListAllSubscriptionsDocumentation$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsDocumentation$ {
  /** @deprecated use `ListAllSubscriptionsDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsDocumentation$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListAllSubscriptionsDocumentation$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsDocumentation$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsDocumentation$Outbound;
}

export function listAllSubscriptionsDocumentationToJSON(
  listAllSubscriptionsDocumentation: ListAllSubscriptionsDocumentation,
): string {
  return JSON.stringify(
    ListAllSubscriptionsDocumentation$outboundSchema.parse(
      listAllSubscriptionsDocumentation,
    ),
  );
}

export function listAllSubscriptionsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsLinks$inboundSchema: z.ZodType<
  ListAllSubscriptionsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListAllSubscriptionsSelf$inboundSchema),
  previous: z.nullable(
    z.lazy(() => ListAllSubscriptionsPrevious$inboundSchema),
  ),
  next: z.nullable(z.lazy(() => ListAllSubscriptionsNext$inboundSchema)),
  documentation: z.lazy(() => ListAllSubscriptionsDocumentation$inboundSchema),
});

/** @internal */
export type ListAllSubscriptionsLinks$Outbound = {
  self: ListAllSubscriptionsSelf$Outbound;
  previous: ListAllSubscriptionsPrevious$Outbound | null;
  next: ListAllSubscriptionsNext$Outbound | null;
  documentation: ListAllSubscriptionsDocumentation$Outbound;
};

/** @internal */
export const ListAllSubscriptionsLinks$outboundSchema: z.ZodType<
  ListAllSubscriptionsLinks$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsLinks
> = z.object({
  self: z.lazy(() => ListAllSubscriptionsSelf$outboundSchema),
  previous: z.nullable(
    z.lazy(() => ListAllSubscriptionsPrevious$outboundSchema),
  ),
  next: z.nullable(z.lazy(() => ListAllSubscriptionsNext$outboundSchema)),
  documentation: z.lazy(() => ListAllSubscriptionsDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsLinks$ {
  /** @deprecated use `ListAllSubscriptionsLinks$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsLinks$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsLinks$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsLinks$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsLinks$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsLinks$Outbound;
}

export function listAllSubscriptionsLinksToJSON(
  listAllSubscriptionsLinks: ListAllSubscriptionsLinks,
): string {
  return JSON.stringify(
    ListAllSubscriptionsLinks$outboundSchema.parse(listAllSubscriptionsLinks),
  );
}

export function listAllSubscriptionsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsLinks' from JSON`,
  );
}

/** @internal */
export const ListAllSubscriptionsResponse$inboundSchema: z.ZodType<
  ListAllSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int(),
  _embedded: z.lazy(() => ListAllSubscriptionsEmbedded$inboundSchema),
  _links: z.lazy(() => ListAllSubscriptionsLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListAllSubscriptionsResponse$Outbound = {
  count: number;
  _embedded: ListAllSubscriptionsEmbedded$Outbound;
  _links: ListAllSubscriptionsLinks$Outbound;
};

/** @internal */
export const ListAllSubscriptionsResponse$outboundSchema: z.ZodType<
  ListAllSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  ListAllSubscriptionsResponse
> = z.object({
  count: z.number().int(),
  embedded: z.lazy(() => ListAllSubscriptionsEmbedded$outboundSchema),
  links: z.lazy(() => ListAllSubscriptionsLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListAllSubscriptionsResponse$ {
  /** @deprecated use `ListAllSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = ListAllSubscriptionsResponse$inboundSchema;
  /** @deprecated use `ListAllSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = ListAllSubscriptionsResponse$outboundSchema;
  /** @deprecated use `ListAllSubscriptionsResponse$Outbound` instead. */
  export type Outbound = ListAllSubscriptionsResponse$Outbound;
}

export function listAllSubscriptionsResponseToJSON(
  listAllSubscriptionsResponse: ListAllSubscriptionsResponse,
): string {
  return JSON.stringify(
    ListAllSubscriptionsResponse$outboundSchema.parse(
      listAllSubscriptionsResponse,
    ),
  );
}

export function listAllSubscriptionsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListAllSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAllSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAllSubscriptionsResponse' from JSON`,
  );
}
