/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 */
export type ApplicationFee = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: models.Amount;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description: string;
};

export type CreatePaymentLinkRequestBody = {
  id?: string | undefined;
  /**
   * A short description of the payment link. The description is visible in the Dashboard and will be shown on the
   *
   * @remarks
   * customer's bank or card statement when possible.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: models.AmountNullable | null | undefined;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  minimumAmount?: models.AmountNullable | null | undefined;
  /**
   * The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,
   *
   * @remarks
   * the customer will be shown a generic message after completing the payment.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to any payments
   * resulting from the payment link.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<models.PaymentLineItem> | null | undefined;
  billingAddress?: models.PaymentAddress | undefined;
  shippingAddress?: models.PaymentAddress | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | null | undefined;
  /**
   * Indicates whether the payment link is reusable. If this field is set to `true`, customers can make multiple
   *
   * @remarks
   * payments using the same link.
   *
   * If no value is specified, the field defaults to `false`, allowing only a single payment per link.
   */
  reusable?: boolean | null | undefined;
  /**
   * The date and time the payment link is set to expire, in ISO 8601 format. If no expiry date was provided up front,
   *
   * @remarks
   * the payment link will not expire automatically.
   */
  expiresAt?: string | null | undefined;
  /**
   * An array of payment methods that are allowed to be used for this payment link. When this parameter is
   *
   * @remarks
   * not provided or is an empty array, all enabled payment methods will be available.
   *
   * Enum: 'applepay', 'bacs', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'billie', 'blik', 'creditcard', 'eps',
   * 'giftcard', 'ideal', 'in3', 'kbc', 'klarna', 'mbway', 'multibanco', 'mybank', 'paybybank', 'paypal', 'paysafecard',
   * 'pointofsale', 'przelewy24', 'riverty', 'satispay', 'swish', 'trustly', 'twint', 'voucher'.
   */
  allowedMethods?: Array<string> | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   */
  applicationFee?: ApplicationFee | undefined;
  sequenceType?: models.PaymentLinkSequenceType | undefined;
  /**
   * **Only relevant when `sequenceType` is set to `first`**
   *
   * @remarks
   *
   * The ID of the [customer](get-customer) the payment link is being created for. If a value is not provided,
   * the customer will be required to input relevant information which will be used to establish a mandate after
   * the payment is made.
   */
  customerId?: string | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

export type CreatePaymentLinkRequest = {
  /**
   * A unique key to ensure idempotent requests. This key should be a UUID v4 string.
   */
  idempotencyKey?: string | undefined;
  requestBody?: CreatePaymentLinkRequestBody | undefined;
};

/** @internal */
export const ApplicationFee$inboundSchema: z.ZodType<
  ApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: models.Amount$inboundSchema,
  description: z.string(),
});

/** @internal */
export type ApplicationFee$Outbound = {
  amount: models.Amount$Outbound;
  description: string;
};

/** @internal */
export const ApplicationFee$outboundSchema: z.ZodType<
  ApplicationFee$Outbound,
  z.ZodTypeDef,
  ApplicationFee
> = z.object({
  amount: models.Amount$outboundSchema,
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplicationFee$ {
  /** @deprecated use `ApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ApplicationFee$inboundSchema;
  /** @deprecated use `ApplicationFee$outboundSchema` instead. */
  export const outboundSchema = ApplicationFee$outboundSchema;
  /** @deprecated use `ApplicationFee$Outbound` instead. */
  export type Outbound = ApplicationFee$Outbound;
}

export function applicationFeeToJSON(applicationFee: ApplicationFee): string {
  return JSON.stringify(ApplicationFee$outboundSchema.parse(applicationFee));
}

export function applicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApplicationFee' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkRequestBody$inboundSchema: z.ZodType<
  CreatePaymentLinkRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  description: z.string(),
  amount: z.nullable(models.AmountNullable$inboundSchema).optional(),
  minimumAmount: z.nullable(models.AmountNullable$inboundSchema).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(models.PaymentLineItem$inboundSchema)).optional(),
  billingAddress: models.PaymentAddress$inboundSchema.optional(),
  shippingAddress: models.PaymentAddress$inboundSchema.optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() => ApplicationFee$inboundSchema).optional(),
  sequenceType: models.PaymentLinkSequenceType$inboundSchema.optional(),
  customerId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type CreatePaymentLinkRequestBody$Outbound = {
  id?: string | undefined;
  description: string;
  amount?: models.AmountNullable$Outbound | null | undefined;
  minimumAmount?: models.AmountNullable$Outbound | null | undefined;
  redirectUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<models.PaymentLineItem$Outbound> | null | undefined;
  billingAddress?: models.PaymentAddress$Outbound | undefined;
  shippingAddress?: models.PaymentAddress$Outbound | undefined;
  profileId?: string | null | undefined;
  reusable?: boolean | null | undefined;
  expiresAt?: string | null | undefined;
  allowedMethods?: Array<string> | null | undefined;
  applicationFee?: ApplicationFee$Outbound | undefined;
  sequenceType?: string | undefined;
  customerId?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const CreatePaymentLinkRequestBody$outboundSchema: z.ZodType<
  CreatePaymentLinkRequestBody$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkRequestBody
> = z.object({
  id: z.string().optional(),
  description: z.string(),
  amount: z.nullable(models.AmountNullable$outboundSchema).optional(),
  minimumAmount: z.nullable(models.AmountNullable$outboundSchema).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(models.PaymentLineItem$outboundSchema)).optional(),
  billingAddress: models.PaymentAddress$outboundSchema.optional(),
  shippingAddress: models.PaymentAddress$outboundSchema.optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() => ApplicationFee$outboundSchema).optional(),
  sequenceType: models.PaymentLinkSequenceType$outboundSchema.optional(),
  customerId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkRequestBody$ {
  /** @deprecated use `CreatePaymentLinkRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkRequestBody$inboundSchema;
  /** @deprecated use `CreatePaymentLinkRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkRequestBody$outboundSchema;
  /** @deprecated use `CreatePaymentLinkRequestBody$Outbound` instead. */
  export type Outbound = CreatePaymentLinkRequestBody$Outbound;
}

export function createPaymentLinkRequestBodyToJSON(
  createPaymentLinkRequestBody: CreatePaymentLinkRequestBody,
): string {
  return JSON.stringify(
    CreatePaymentLinkRequestBody$outboundSchema.parse(
      createPaymentLinkRequestBody,
    ),
  );
}

export function createPaymentLinkRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkRequestBody' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "idempotency-key": z.string().optional(),
  RequestBody: z.lazy(() => CreatePaymentLinkRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "idempotency-key": "idempotencyKey",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreatePaymentLinkRequest$Outbound = {
  "idempotency-key"?: string | undefined;
  RequestBody?: CreatePaymentLinkRequestBody$Outbound | undefined;
};

/** @internal */
export const CreatePaymentLinkRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkRequest
> = z.object({
  idempotencyKey: z.string().optional(),
  requestBody: z.lazy(() => CreatePaymentLinkRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    idempotencyKey: "idempotency-key",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkRequest$ {
  /** @deprecated use `CreatePaymentLinkRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkRequest$Outbound;
}

export function createPaymentLinkRequestToJSON(
  createPaymentLinkRequest: CreatePaymentLinkRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkRequest$outboundSchema.parse(createPaymentLinkRequest),
  );
}

export function createPaymentLinkRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkRequest' from JSON`,
  );
}
