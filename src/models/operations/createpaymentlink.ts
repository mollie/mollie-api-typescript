/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
 *
 * @remarks
 * amount.
 */
export type CreatePaymentLinkAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
 *
 * @remarks
 * customer will be prompted to enter a value greater than or equal to the minimum amount.
 */
export type CreatePaymentLinkMinimumAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreatePaymentLinkTypeRequest = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreatePaymentLinkTypeRequest = ClosedEnum<
  typeof CreatePaymentLinkTypeRequest
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreatePaymentLinkUnitPriceRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreatePaymentLinkDiscountAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreatePaymentLinkTotalAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreatePaymentLinkVatAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreatePaymentLinkCategoryRequest = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreatePaymentLinkCategoryRequest = ClosedEnum<
  typeof CreatePaymentLinkCategoryRequest
>;

export type CreatePaymentLinkLineRequest = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreatePaymentLinkTypeRequest | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreatePaymentLinkUnitPriceRequest;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreatePaymentLinkDiscountAmountRequest | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreatePaymentLinkTotalAmountRequest;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreatePaymentLinkVatAmountRequest | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreatePaymentLinkCategoryRequest> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreatePaymentLinkBillingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreatePaymentLinkShippingAddressRequest = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreatePaymentLinkApplicationFeeAmountRequest = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 */
export type CreatePaymentLinkApplicationFeeRequest = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount: CreatePaymentLinkApplicationFeeAmountRequest;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description: string;
};

/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export const CreatePaymentLinkSequenceTypeRequest = {
  Oneoff: "oneoff",
  First: "first",
} as const;
/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export type CreatePaymentLinkSequenceTypeRequest = ClosedEnum<
  typeof CreatePaymentLinkSequenceTypeRequest
>;

export type CreatePaymentLinkRequest = {
  /**
   * A short description of the payment link. The description is visible in the Dashboard and will be shown on the
   *
   * @remarks
   * customer's bank or card statement when possible.
   */
  description: string;
  /**
   * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
   *
   * @remarks
   * amount.
   */
  amount?: CreatePaymentLinkAmountRequest | null | undefined;
  /**
   * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
   *
   * @remarks
   * customer will be prompted to enter a value greater than or equal to the minimum amount.
   */
  minimumAmount?: CreatePaymentLinkMinimumAmountRequest | null | undefined;
  /**
   * The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,
   *
   * @remarks
   * the customer will be shown a generic message after completing the payment.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to any payments
   * resulting from the payment link.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreatePaymentLinkLineRequest> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreatePaymentLinkBillingAddressRequest | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreatePaymentLinkShippingAddressRequest | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId?: string | null | undefined;
  /**
   * Indicates whether the payment link is reusable. If this field is set to `true`, customers can make multiple
   *
   * @remarks
   * payments using the same link.
   *
   * If no value is specified, the field defaults to `false`, allowing only a single payment per link.
   */
  reusable?: boolean | null | undefined;
  /**
   * The date and time the payment link is set to expire, in ISO 8601 format. If no expiry date was provided up front,
   *
   * @remarks
   * the payment link will not expire automatically.
   */
  expiresAt?: string | null | undefined;
  /**
   * An array of payment methods that are allowed to be used for this payment link. When this parameter is
   *
   * @remarks
   * not provided or is an empty array, all enabled payment methods will be available.
   *
   * Enum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'blik', 'creditcard', 'eps', 'giftcard',
   * 'ideal', 'kbc', 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale', 'przelewy24', 'satispay', 'trustly', 'twint',
   * 'in3', 'riverty', 'klarna', 'billie'.
   */
  allowedMethods?: Array<string> | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   */
  applicationFee?: CreatePaymentLinkApplicationFeeRequest | undefined;
  /**
   * If set to `first`, a payment mandate is established right after a payment is made by the customer.
   *
   * @remarks
   *
   * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
   *
   * The mandate ID can be retrieved by making a call to the
   * [Payment Link Payments Endpoint](get-payment-link-payments).
   */
  sequenceType?: CreatePaymentLinkSequenceTypeRequest | null | undefined;
  /**
   * **Only relevant when `sequenceType` is set to `first`**
   *
   * @remarks
   *
   * The ID of the [customer](get-customer) the payment link is being created for. If a value is not provided,
   * the customer will be required to input relevant information which will be used to establish a mandate after
   * the payment is made.
   */
  customerId?: string | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreatePaymentLinkUnprocessableEntityDocumentation = {
  href: string;
  type: string;
};

export type CreatePaymentLinkUnprocessableEntityLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreatePaymentLinkUnprocessableEntityDocumentation;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type CreatePaymentLinkNotFoundDocumentation = {
  href: string;
  type: string;
};

export type CreatePaymentLinkNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: CreatePaymentLinkNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const CreatePaymentLinkMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type CreatePaymentLinkMode = ClosedEnum<typeof CreatePaymentLinkMode>;

/**
 * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
 *
 * @remarks
 * amount.
 */
export type CreatePaymentLinkAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
 *
 * @remarks
 * customer will be prompted to enter a value greater than or equal to the minimum amount.
 */
export type CreatePaymentLinkMinimumAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const CreatePaymentLinkTypeResponse = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type CreatePaymentLinkTypeResponse = ClosedEnum<
  typeof CreatePaymentLinkTypeResponse
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type CreatePaymentLinkUnitPriceResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type CreatePaymentLinkDiscountAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type CreatePaymentLinkTotalAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type CreatePaymentLinkVatAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const CreatePaymentLinkCategoryResponse = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type CreatePaymentLinkCategoryResponse = ClosedEnum<
  typeof CreatePaymentLinkCategoryResponse
>;

export type CreatePaymentLinkLineResponse = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: CreatePaymentLinkTypeResponse | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: CreatePaymentLinkUnitPriceResponse;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: CreatePaymentLinkDiscountAmountResponse | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: CreatePaymentLinkTotalAmountResponse;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: CreatePaymentLinkVatAmountResponse | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<CreatePaymentLinkCategoryResponse> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type CreatePaymentLinkBillingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type CreatePaymentLinkShippingAddressResponse = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type CreatePaymentLinkApplicationFeeAmountResponse = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 */
export type CreatePaymentLinkApplicationFeeResponse = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount: CreatePaymentLinkApplicationFeeAmountResponse;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description: string;
};

/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export const CreatePaymentLinkSequenceTypeResponse = {
  Oneoff: "oneoff",
  First: "first",
} as const;
/**
 * If set to `first`, a payment mandate is established right after a payment is made by the customer.
 *
 * @remarks
 *
 * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
 *
 * The mandate ID can be retrieved by making a call to the
 * [Payment Link Payments Endpoint](get-payment-link-payments).
 */
export type CreatePaymentLinkSequenceTypeResponse = ClosedEnum<
  typeof CreatePaymentLinkSequenceTypeResponse
>;

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type CreatePaymentLinkSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type CreatePaymentLinkPaymentLink = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type CreatePaymentLinkLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: CreatePaymentLinkSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  paymentLink: CreatePaymentLinkPaymentLink;
};

/**
 * The newly created payment link object.
 */
export type CreatePaymentLinkResponse = {
  /**
   * Indicates the response contains a payment link object. Will always contain the string `payment-link` for this
   *
   * @remarks
   * endpoint.
   */
  resource?: string | undefined;
  /**
   * The identifier uniquely referring to this payment link. Example: `pl_4Y0eZitmBnQ6IDoMqZQKh`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: CreatePaymentLinkMode;
  /**
   * A short description of the payment link. The description is visible in the Dashboard and will be shown on the
   *
   * @remarks
   * customer's bank or card statement when possible.
   */
  description: string;
  /**
   * The amount of the payment link. If no amount is provided initially, the customer will be prompted to enter an
   *
   * @remarks
   * amount.
   */
  amount: CreatePaymentLinkAmountResponse | null;
  /**
   * The minimum amount of the payment link. This property is only allowed when there is no amount provided. The
   *
   * @remarks
   * customer will be prompted to enter a value greater than or equal to the minimum amount.
   */
  minimumAmount?: CreatePaymentLinkMinimumAmountResponse | null | undefined;
  /**
   * Whether the payment link is archived. Customers will not be able to complete payments on archived payment links.
   */
  archived: boolean;
  /**
   * The URL your customer will be redirected to after completing the payment process. If no redirect URL is provided,
   *
   * @remarks
   * the customer will be shown a generic message after completing the payment.
   */
  redirectUrl: string | null;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to any payments
   * resulting from the payment link.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl: string | null;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<CreatePaymentLinkLineResponse> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: CreatePaymentLinkBillingAddressResponse | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: CreatePaymentLinkShippingAddressResponse | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
   * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
   * required.
   */
  profileId: string | null;
  /**
   * Indicates whether the payment link is reusable. If this field is set to `true`, customers can make multiple
   *
   * @remarks
   * payments using the same link.
   *
   * If no value is specified, the field defaults to `false`, allowing only a single payment per link.
   */
  reusable?: boolean | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment link became paid, in ISO 8601 format.
   */
  paidAt: string | null;
  /**
   * The date and time the payment link is set to expire, in ISO 8601 format. If no expiry date was provided up front,
   *
   * @remarks
   * the payment link will not expire automatically.
   */
  expiresAt: string | null;
  /**
   * An array of payment methods that are allowed to be used for this payment link. When this parameter is
   *
   * @remarks
   * not provided or is an empty array, all enabled payment methods will be available.
   *
   * Enum: 'applepay', 'bancomatpay', 'bancontact', 'banktransfer', 'belfius', 'blik', 'creditcard', 'eps', 'giftcard',
   * 'ideal', 'kbc', 'mybank', 'paybybank', 'paypal', 'paysafecard', 'pointofsale', 'przelewy24', 'satispay', 'trustly', 'twint',
   * 'in3', 'riverty', 'klarna', 'billie'.
   */
  allowedMethods: Array<string> | null;
  /**
   * With Mollie Connect you can charge fees on payment links that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payment links on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If a payment on the payment link succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   */
  applicationFee?: CreatePaymentLinkApplicationFeeResponse | undefined;
  /**
   * If set to `first`, a payment mandate is established right after a payment is made by the customer.
   *
   * @remarks
   *
   * Defaults to `oneoff`, which is a regular payment link and will not establish a mandate after payment.
   *
   * The mandate ID can be retrieved by making a call to the
   * [Payment Link Payments Endpoint](get-payment-link-payments).
   */
  sequenceType?: CreatePaymentLinkSequenceTypeResponse | null | undefined;
  /**
   * **Only relevant when `sequenceType` is set to `first`**
   *
   * @remarks
   *
   * The ID of the [customer](get-customer) the payment link is being created for. If a value is not provided,
   * the customer will be required to input relevant information which will be used to establish a mandate after
   * the payment is made.
   */
  customerId?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: CreatePaymentLinkLinks;
};

/** @internal */
export const CreatePaymentLinkAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkAmountRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkAmountRequest$Outbound;
}

export function createPaymentLinkAmountRequestToJSON(
  createPaymentLinkAmountRequest: CreatePaymentLinkAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkAmountRequest$outboundSchema.parse(
      createPaymentLinkAmountRequest,
    ),
  );
}

export function createPaymentLinkAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkMinimumAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkMinimumAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkMinimumAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkMinimumAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkMinimumAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkMinimumAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkMinimumAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkMinimumAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkMinimumAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkMinimumAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkMinimumAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkMinimumAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkMinimumAmountRequest$Outbound;
}

export function createPaymentLinkMinimumAmountRequestToJSON(
  createPaymentLinkMinimumAmountRequest: CreatePaymentLinkMinimumAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkMinimumAmountRequest$outboundSchema.parse(
      createPaymentLinkMinimumAmountRequest,
    ),
  );
}

export function createPaymentLinkMinimumAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkMinimumAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkMinimumAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkMinimumAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkTypeRequest
> = z.nativeEnum(CreatePaymentLinkTypeRequest);

/** @internal */
export const CreatePaymentLinkTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkTypeRequest
> = CreatePaymentLinkTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkTypeRequest$ {
  /** @deprecated use `CreatePaymentLinkTypeRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkTypeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkTypeRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkTypeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkUnitPriceRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkUnitPriceRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkUnitPriceRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkUnitPriceRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkUnitPriceRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkUnitPriceRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkUnitPriceRequest$ {
  /** @deprecated use `CreatePaymentLinkUnitPriceRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkUnitPriceRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkUnitPriceRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkUnitPriceRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkUnitPriceRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkUnitPriceRequest$Outbound;
}

export function createPaymentLinkUnitPriceRequestToJSON(
  createPaymentLinkUnitPriceRequest: CreatePaymentLinkUnitPriceRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkUnitPriceRequest$outboundSchema.parse(
      createPaymentLinkUnitPriceRequest,
    ),
  );
}

export function createPaymentLinkUnitPriceRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkUnitPriceRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkUnitPriceRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkUnitPriceRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkDiscountAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkDiscountAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkDiscountAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkDiscountAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkDiscountAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkDiscountAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkDiscountAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkDiscountAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkDiscountAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkDiscountAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkDiscountAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkDiscountAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkDiscountAmountRequest$Outbound;
}

export function createPaymentLinkDiscountAmountRequestToJSON(
  createPaymentLinkDiscountAmountRequest:
    CreatePaymentLinkDiscountAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkDiscountAmountRequest$outboundSchema.parse(
      createPaymentLinkDiscountAmountRequest,
    ),
  );
}

export function createPaymentLinkDiscountAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkDiscountAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkDiscountAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkDiscountAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkTotalAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkTotalAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkTotalAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkTotalAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkTotalAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkTotalAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkTotalAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkTotalAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkTotalAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkTotalAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkTotalAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkTotalAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkTotalAmountRequest$Outbound;
}

export function createPaymentLinkTotalAmountRequestToJSON(
  createPaymentLinkTotalAmountRequest: CreatePaymentLinkTotalAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkTotalAmountRequest$outboundSchema.parse(
      createPaymentLinkTotalAmountRequest,
    ),
  );
}

export function createPaymentLinkTotalAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkTotalAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkTotalAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkTotalAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkVatAmountRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkVatAmountRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkVatAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkVatAmountRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkVatAmountRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkVatAmountRequest
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkVatAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkVatAmountRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkVatAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkVatAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkVatAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkVatAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkVatAmountRequest$Outbound;
}

export function createPaymentLinkVatAmountRequestToJSON(
  createPaymentLinkVatAmountRequest: CreatePaymentLinkVatAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkVatAmountRequest$outboundSchema.parse(
      createPaymentLinkVatAmountRequest,
    ),
  );
}

export function createPaymentLinkVatAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkVatAmountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkVatAmountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkVatAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkCategoryRequest$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkCategoryRequest
> = z.nativeEnum(CreatePaymentLinkCategoryRequest);

/** @internal */
export const CreatePaymentLinkCategoryRequest$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkCategoryRequest
> = CreatePaymentLinkCategoryRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkCategoryRequest$ {
  /** @deprecated use `CreatePaymentLinkCategoryRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkCategoryRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkCategoryRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkCategoryRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkLineRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkLineRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentLinkTypeRequest$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentLinkUnitPriceRequest$inboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentLinkDiscountAmountRequest$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentLinkTotalAmountRequest$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentLinkVatAmountRequest$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentLinkCategoryRequest$inboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkLineRequest$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreatePaymentLinkUnitPriceRequest$Outbound;
  discountAmount?: CreatePaymentLinkDiscountAmountRequest$Outbound | undefined;
  totalAmount: CreatePaymentLinkTotalAmountRequest$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreatePaymentLinkVatAmountRequest$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkLineRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkLineRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkLineRequest
> = z.object({
  type: CreatePaymentLinkTypeRequest$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentLinkUnitPriceRequest$outboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentLinkDiscountAmountRequest$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentLinkTotalAmountRequest$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentLinkVatAmountRequest$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentLinkCategoryRequest$outboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkLineRequest$ {
  /** @deprecated use `CreatePaymentLinkLineRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkLineRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkLineRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkLineRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkLineRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkLineRequest$Outbound;
}

export function createPaymentLinkLineRequestToJSON(
  createPaymentLinkLineRequest: CreatePaymentLinkLineRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkLineRequest$outboundSchema.parse(
      createPaymentLinkLineRequest,
    ),
  );
}

export function createPaymentLinkLineRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkLineRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkLineRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkLineRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkBillingAddressRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkBillingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkBillingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkBillingAddressRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkBillingAddressRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkBillingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkBillingAddressRequest$ {
  /** @deprecated use `CreatePaymentLinkBillingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkBillingAddressRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkBillingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkBillingAddressRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkBillingAddressRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkBillingAddressRequest$Outbound;
}

export function createPaymentLinkBillingAddressRequestToJSON(
  createPaymentLinkBillingAddressRequest:
    CreatePaymentLinkBillingAddressRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkBillingAddressRequest$outboundSchema.parse(
      createPaymentLinkBillingAddressRequest,
    ),
  );
}

export function createPaymentLinkBillingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkBillingAddressRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkBillingAddressRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkBillingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkShippingAddressRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkShippingAddressRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkShippingAddressRequest$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkShippingAddressRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkShippingAddressRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkShippingAddressRequest
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkShippingAddressRequest$ {
  /** @deprecated use `CreatePaymentLinkShippingAddressRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkShippingAddressRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkShippingAddressRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkShippingAddressRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkShippingAddressRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkShippingAddressRequest$Outbound;
}

export function createPaymentLinkShippingAddressRequestToJSON(
  createPaymentLinkShippingAddressRequest:
    CreatePaymentLinkShippingAddressRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkShippingAddressRequest$outboundSchema.parse(
      createPaymentLinkShippingAddressRequest,
    ),
  );
}

export function createPaymentLinkShippingAddressRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkShippingAddressRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkShippingAddressRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkShippingAddressRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkApplicationFeeAmountRequest$inboundSchema:
  z.ZodType<
    CreatePaymentLinkApplicationFeeAmountRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreatePaymentLinkApplicationFeeAmountRequest$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkApplicationFeeAmountRequest$outboundSchema:
  z.ZodType<
    CreatePaymentLinkApplicationFeeAmountRequest$Outbound,
    z.ZodTypeDef,
    CreatePaymentLinkApplicationFeeAmountRequest
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkApplicationFeeAmountRequest$ {
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkApplicationFeeAmountRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkApplicationFeeAmountRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkApplicationFeeAmountRequest$Outbound;
}

export function createPaymentLinkApplicationFeeAmountRequestToJSON(
  createPaymentLinkApplicationFeeAmountRequest:
    CreatePaymentLinkApplicationFeeAmountRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkApplicationFeeAmountRequest$outboundSchema.parse(
      createPaymentLinkApplicationFeeAmountRequest,
    ),
  );
}

export function createPaymentLinkApplicationFeeAmountRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkApplicationFeeAmountRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkApplicationFeeAmountRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkApplicationFeeAmountRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkApplicationFeeRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkApplicationFeeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() =>
    CreatePaymentLinkApplicationFeeAmountRequest$inboundSchema
  ),
  description: z.string(),
});

/** @internal */
export type CreatePaymentLinkApplicationFeeRequest$Outbound = {
  amount: CreatePaymentLinkApplicationFeeAmountRequest$Outbound;
  description: string;
};

/** @internal */
export const CreatePaymentLinkApplicationFeeRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkApplicationFeeRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkApplicationFeeRequest
> = z.object({
  amount: z.lazy(() =>
    CreatePaymentLinkApplicationFeeAmountRequest$outboundSchema
  ),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkApplicationFeeRequest$ {
  /** @deprecated use `CreatePaymentLinkApplicationFeeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkApplicationFeeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkApplicationFeeRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkApplicationFeeRequest$Outbound;
}

export function createPaymentLinkApplicationFeeRequestToJSON(
  createPaymentLinkApplicationFeeRequest:
    CreatePaymentLinkApplicationFeeRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkApplicationFeeRequest$outboundSchema.parse(
      createPaymentLinkApplicationFeeRequest,
    ),
  );
}

export function createPaymentLinkApplicationFeeRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkApplicationFeeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkApplicationFeeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkApplicationFeeRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkSequenceTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof CreatePaymentLinkSequenceTypeRequest> = z.nativeEnum(
    CreatePaymentLinkSequenceTypeRequest,
  );

/** @internal */
export const CreatePaymentLinkSequenceTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof CreatePaymentLinkSequenceTypeRequest> =
    CreatePaymentLinkSequenceTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkSequenceTypeRequest$ {
  /** @deprecated use `CreatePaymentLinkSequenceTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkSequenceTypeRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkSequenceTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkSequenceTypeRequest$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkRequest$inboundSchema: z.ZodType<
  CreatePaymentLinkRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: z.nullable(z.lazy(() => CreatePaymentLinkAmountRequest$inboundSchema))
    .optional(),
  minimumAmount: z.nullable(
    z.lazy(() => CreatePaymentLinkMinimumAmountRequest$inboundSchema),
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLinkLineRequest$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentLinkBillingAddressRequest$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentLinkShippingAddressRequest$inboundSchema
  ).optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean().default(false)),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() =>
    CreatePaymentLinkApplicationFeeRequest$inboundSchema
  ).optional(),
  sequenceType: z.nullable(CreatePaymentLinkSequenceTypeRequest$inboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
});

/** @internal */
export type CreatePaymentLinkRequest$Outbound = {
  description: string;
  amount?: CreatePaymentLinkAmountRequest$Outbound | null | undefined;
  minimumAmount?:
    | CreatePaymentLinkMinimumAmountRequest$Outbound
    | null
    | undefined;
  redirectUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<CreatePaymentLinkLineRequest$Outbound> | null | undefined;
  billingAddress?: CreatePaymentLinkBillingAddressRequest$Outbound | undefined;
  shippingAddress?:
    | CreatePaymentLinkShippingAddressRequest$Outbound
    | undefined;
  profileId?: string | null | undefined;
  reusable: boolean | null;
  expiresAt?: string | null | undefined;
  allowedMethods?: Array<string> | null | undefined;
  applicationFee?: CreatePaymentLinkApplicationFeeRequest$Outbound | undefined;
  sequenceType?: string | null | undefined;
  customerId?: string | null | undefined;
};

/** @internal */
export const CreatePaymentLinkRequest$outboundSchema: z.ZodType<
  CreatePaymentLinkRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkRequest
> = z.object({
  description: z.string(),
  amount: z.nullable(
    z.lazy(() => CreatePaymentLinkAmountRequest$outboundSchema),
  ).optional(),
  minimumAmount: z.nullable(
    z.lazy(() => CreatePaymentLinkMinimumAmountRequest$outboundSchema),
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLinkLineRequest$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentLinkBillingAddressRequest$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentLinkShippingAddressRequest$outboundSchema
  ).optional(),
  profileId: z.nullable(z.string()).optional(),
  reusable: z.nullable(z.boolean().default(false)),
  expiresAt: z.nullable(z.string()).optional(),
  allowedMethods: z.nullable(z.array(z.string())).optional(),
  applicationFee: z.lazy(() =>
    CreatePaymentLinkApplicationFeeRequest$outboundSchema
  ).optional(),
  sequenceType: z.nullable(CreatePaymentLinkSequenceTypeRequest$outboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkRequest$ {
  /** @deprecated use `CreatePaymentLinkRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkRequest$inboundSchema;
  /** @deprecated use `CreatePaymentLinkRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkRequest$outboundSchema;
  /** @deprecated use `CreatePaymentLinkRequest$Outbound` instead. */
  export type Outbound = CreatePaymentLinkRequest$Outbound;
}

export function createPaymentLinkRequestToJSON(
  createPaymentLinkRequest: CreatePaymentLinkRequest,
): string {
  return JSON.stringify(
    CreatePaymentLinkRequest$outboundSchema.parse(createPaymentLinkRequest),
  );
}

export function createPaymentLinkRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkRequest' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkUnprocessableEntityDocumentation$inboundSchema:
  z.ZodType<
    CreatePaymentLinkUnprocessableEntityDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type CreatePaymentLinkUnprocessableEntityDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentLinkUnprocessableEntityDocumentation$outboundSchema:
  z.ZodType<
    CreatePaymentLinkUnprocessableEntityDocumentation$Outbound,
    z.ZodTypeDef,
    CreatePaymentLinkUnprocessableEntityDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkUnprocessableEntityDocumentation$ {
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkUnprocessableEntityDocumentation$inboundSchema;
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkUnprocessableEntityDocumentation$outboundSchema;
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityDocumentation$Outbound` instead. */
  export type Outbound =
    CreatePaymentLinkUnprocessableEntityDocumentation$Outbound;
}

export function createPaymentLinkUnprocessableEntityDocumentationToJSON(
  createPaymentLinkUnprocessableEntityDocumentation:
    CreatePaymentLinkUnprocessableEntityDocumentation,
): string {
  return JSON.stringify(
    CreatePaymentLinkUnprocessableEntityDocumentation$outboundSchema.parse(
      createPaymentLinkUnprocessableEntityDocumentation,
    ),
  );
}

export function createPaymentLinkUnprocessableEntityDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkUnprocessableEntityDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkUnprocessableEntityDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkUnprocessableEntityDocumentation' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkUnprocessableEntityLinks$inboundSchema: z.ZodType<
  CreatePaymentLinkUnprocessableEntityLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentLinkUnprocessableEntityDocumentation$inboundSchema
  ),
});

/** @internal */
export type CreatePaymentLinkUnprocessableEntityLinks$Outbound = {
  documentation: CreatePaymentLinkUnprocessableEntityDocumentation$Outbound;
};

/** @internal */
export const CreatePaymentLinkUnprocessableEntityLinks$outboundSchema:
  z.ZodType<
    CreatePaymentLinkUnprocessableEntityLinks$Outbound,
    z.ZodTypeDef,
    CreatePaymentLinkUnprocessableEntityLinks
  > = z.object({
    documentation: z.lazy(() =>
      CreatePaymentLinkUnprocessableEntityDocumentation$outboundSchema
    ),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkUnprocessableEntityLinks$ {
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityLinks$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkUnprocessableEntityLinks$inboundSchema;
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityLinks$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkUnprocessableEntityLinks$outboundSchema;
  /** @deprecated use `CreatePaymentLinkUnprocessableEntityLinks$Outbound` instead. */
  export type Outbound = CreatePaymentLinkUnprocessableEntityLinks$Outbound;
}

export function createPaymentLinkUnprocessableEntityLinksToJSON(
  createPaymentLinkUnprocessableEntityLinks:
    CreatePaymentLinkUnprocessableEntityLinks,
): string {
  return JSON.stringify(
    CreatePaymentLinkUnprocessableEntityLinks$outboundSchema.parse(
      createPaymentLinkUnprocessableEntityLinks,
    ),
  );
}

export function createPaymentLinkUnprocessableEntityLinksFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkUnprocessableEntityLinks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkUnprocessableEntityLinks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkUnprocessableEntityLinks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkNotFoundDocumentation$inboundSchema: z.ZodType<
  CreatePaymentLinkNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentLinkNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentLinkNotFoundDocumentation$outboundSchema: z.ZodType<
  CreatePaymentLinkNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkNotFoundDocumentation$ {
  /** @deprecated use `CreatePaymentLinkNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkNotFoundDocumentation$inboundSchema;
  /** @deprecated use `CreatePaymentLinkNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkNotFoundDocumentation$outboundSchema;
  /** @deprecated use `CreatePaymentLinkNotFoundDocumentation$Outbound` instead. */
  export type Outbound = CreatePaymentLinkNotFoundDocumentation$Outbound;
}

export function createPaymentLinkNotFoundDocumentationToJSON(
  createPaymentLinkNotFoundDocumentation:
    CreatePaymentLinkNotFoundDocumentation,
): string {
  return JSON.stringify(
    CreatePaymentLinkNotFoundDocumentation$outboundSchema.parse(
      createPaymentLinkNotFoundDocumentation,
    ),
  );
}

export function createPaymentLinkNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkNotFoundLinks$inboundSchema: z.ZodType<
  CreatePaymentLinkNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentLinkNotFoundDocumentation$inboundSchema
  ),
});

/** @internal */
export type CreatePaymentLinkNotFoundLinks$Outbound = {
  documentation: CreatePaymentLinkNotFoundDocumentation$Outbound;
};

/** @internal */
export const CreatePaymentLinkNotFoundLinks$outboundSchema: z.ZodType<
  CreatePaymentLinkNotFoundLinks$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkNotFoundLinks
> = z.object({
  documentation: z.lazy(() =>
    CreatePaymentLinkNotFoundDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkNotFoundLinks$ {
  /** @deprecated use `CreatePaymentLinkNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkNotFoundLinks$inboundSchema;
  /** @deprecated use `CreatePaymentLinkNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkNotFoundLinks$outboundSchema;
  /** @deprecated use `CreatePaymentLinkNotFoundLinks$Outbound` instead. */
  export type Outbound = CreatePaymentLinkNotFoundLinks$Outbound;
}

export function createPaymentLinkNotFoundLinksToJSON(
  createPaymentLinkNotFoundLinks: CreatePaymentLinkNotFoundLinks,
): string {
  return JSON.stringify(
    CreatePaymentLinkNotFoundLinks$outboundSchema.parse(
      createPaymentLinkNotFoundLinks,
    ),
  );
}

export function createPaymentLinkNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkMode$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkMode
> = z.nativeEnum(CreatePaymentLinkMode);

/** @internal */
export const CreatePaymentLinkMode$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkMode
> = CreatePaymentLinkMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkMode$ {
  /** @deprecated use `CreatePaymentLinkMode$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkMode$inboundSchema;
  /** @deprecated use `CreatePaymentLinkMode$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkMode$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkAmountResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkAmountResponse$Outbound;
}

export function createPaymentLinkAmountResponseToJSON(
  createPaymentLinkAmountResponse: CreatePaymentLinkAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkAmountResponse$outboundSchema.parse(
      createPaymentLinkAmountResponse,
    ),
  );
}

export function createPaymentLinkAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkMinimumAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkMinimumAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkMinimumAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkMinimumAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkMinimumAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkMinimumAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkMinimumAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkMinimumAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkMinimumAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkMinimumAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkMinimumAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkMinimumAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkMinimumAmountResponse$Outbound;
}

export function createPaymentLinkMinimumAmountResponseToJSON(
  createPaymentLinkMinimumAmountResponse:
    CreatePaymentLinkMinimumAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkMinimumAmountResponse$outboundSchema.parse(
      createPaymentLinkMinimumAmountResponse,
    ),
  );
}

export function createPaymentLinkMinimumAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkMinimumAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkMinimumAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkMinimumAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkTypeResponse
> = z.nativeEnum(CreatePaymentLinkTypeResponse);

/** @internal */
export const CreatePaymentLinkTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkTypeResponse
> = CreatePaymentLinkTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkTypeResponse$ {
  /** @deprecated use `CreatePaymentLinkTypeResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkTypeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkTypeResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkTypeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkUnitPriceResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkUnitPriceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkUnitPriceResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkUnitPriceResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkUnitPriceResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkUnitPriceResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkUnitPriceResponse$ {
  /** @deprecated use `CreatePaymentLinkUnitPriceResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkUnitPriceResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkUnitPriceResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkUnitPriceResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkUnitPriceResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkUnitPriceResponse$Outbound;
}

export function createPaymentLinkUnitPriceResponseToJSON(
  createPaymentLinkUnitPriceResponse: CreatePaymentLinkUnitPriceResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkUnitPriceResponse$outboundSchema.parse(
      createPaymentLinkUnitPriceResponse,
    ),
  );
}

export function createPaymentLinkUnitPriceResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkUnitPriceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkUnitPriceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkUnitPriceResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkDiscountAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkDiscountAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkDiscountAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkDiscountAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkDiscountAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkDiscountAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkDiscountAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkDiscountAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkDiscountAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkDiscountAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkDiscountAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkDiscountAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkDiscountAmountResponse$Outbound;
}

export function createPaymentLinkDiscountAmountResponseToJSON(
  createPaymentLinkDiscountAmountResponse:
    CreatePaymentLinkDiscountAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkDiscountAmountResponse$outboundSchema.parse(
      createPaymentLinkDiscountAmountResponse,
    ),
  );
}

export function createPaymentLinkDiscountAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkDiscountAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkDiscountAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkDiscountAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkTotalAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkTotalAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkTotalAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkTotalAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkTotalAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkTotalAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkTotalAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkTotalAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkTotalAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkTotalAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkTotalAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkTotalAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkTotalAmountResponse$Outbound;
}

export function createPaymentLinkTotalAmountResponseToJSON(
  createPaymentLinkTotalAmountResponse: CreatePaymentLinkTotalAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkTotalAmountResponse$outboundSchema.parse(
      createPaymentLinkTotalAmountResponse,
    ),
  );
}

export function createPaymentLinkTotalAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkTotalAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkTotalAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkTotalAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkVatAmountResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkVatAmountResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentLinkVatAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkVatAmountResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkVatAmountResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkVatAmountResponse
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkVatAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkVatAmountResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkVatAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkVatAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkVatAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkVatAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkVatAmountResponse$Outbound;
}

export function createPaymentLinkVatAmountResponseToJSON(
  createPaymentLinkVatAmountResponse: CreatePaymentLinkVatAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkVatAmountResponse$outboundSchema.parse(
      createPaymentLinkVatAmountResponse,
    ),
  );
}

export function createPaymentLinkVatAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkVatAmountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkVatAmountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkVatAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkCategoryResponse$inboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkCategoryResponse
> = z.nativeEnum(CreatePaymentLinkCategoryResponse);

/** @internal */
export const CreatePaymentLinkCategoryResponse$outboundSchema: z.ZodNativeEnum<
  typeof CreatePaymentLinkCategoryResponse
> = CreatePaymentLinkCategoryResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkCategoryResponse$ {
  /** @deprecated use `CreatePaymentLinkCategoryResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkCategoryResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkCategoryResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkCategoryResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkLineResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkLineResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePaymentLinkTypeResponse$inboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentLinkUnitPriceResponse$inboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentLinkDiscountAmountResponse$inboundSchema
  ).optional(),
  totalAmount: z.lazy(() => CreatePaymentLinkTotalAmountResponse$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentLinkVatAmountResponse$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentLinkCategoryResponse$inboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkLineResponse$Outbound = {
  type: string;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: CreatePaymentLinkUnitPriceResponse$Outbound;
  discountAmount?: CreatePaymentLinkDiscountAmountResponse$Outbound | undefined;
  totalAmount: CreatePaymentLinkTotalAmountResponse$Outbound;
  vatRate?: string | undefined;
  vatAmount?: CreatePaymentLinkVatAmountResponse$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkLineResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkLineResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkLineResponse
> = z.object({
  type: CreatePaymentLinkTypeResponse$outboundSchema.default("physical"),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => CreatePaymentLinkUnitPriceResponse$outboundSchema),
  discountAmount: z.lazy(() =>
    CreatePaymentLinkDiscountAmountResponse$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() =>
    CreatePaymentLinkTotalAmountResponse$outboundSchema
  ),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => CreatePaymentLinkVatAmountResponse$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(CreatePaymentLinkCategoryResponse$outboundSchema)
    .optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkLineResponse$ {
  /** @deprecated use `CreatePaymentLinkLineResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkLineResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkLineResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkLineResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkLineResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkLineResponse$Outbound;
}

export function createPaymentLinkLineResponseToJSON(
  createPaymentLinkLineResponse: CreatePaymentLinkLineResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkLineResponse$outboundSchema.parse(
      createPaymentLinkLineResponse,
    ),
  );
}

export function createPaymentLinkLineResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkLineResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkLineResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkLineResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkBillingAddressResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkBillingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkBillingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkBillingAddressResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkBillingAddressResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkBillingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkBillingAddressResponse$ {
  /** @deprecated use `CreatePaymentLinkBillingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkBillingAddressResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkBillingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkBillingAddressResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkBillingAddressResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkBillingAddressResponse$Outbound;
}

export function createPaymentLinkBillingAddressResponseToJSON(
  createPaymentLinkBillingAddressResponse:
    CreatePaymentLinkBillingAddressResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkBillingAddressResponse$outboundSchema.parse(
      createPaymentLinkBillingAddressResponse,
    ),
  );
}

export function createPaymentLinkBillingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkBillingAddressResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkBillingAddressResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkBillingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkShippingAddressResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkShippingAddressResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type CreatePaymentLinkShippingAddressResponse$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CreatePaymentLinkShippingAddressResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkShippingAddressResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkShippingAddressResponse
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkShippingAddressResponse$ {
  /** @deprecated use `CreatePaymentLinkShippingAddressResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkShippingAddressResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkShippingAddressResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkShippingAddressResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkShippingAddressResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkShippingAddressResponse$Outbound;
}

export function createPaymentLinkShippingAddressResponseToJSON(
  createPaymentLinkShippingAddressResponse:
    CreatePaymentLinkShippingAddressResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkShippingAddressResponse$outboundSchema.parse(
      createPaymentLinkShippingAddressResponse,
    ),
  );
}

export function createPaymentLinkShippingAddressResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkShippingAddressResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkShippingAddressResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkShippingAddressResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkApplicationFeeAmountResponse$inboundSchema:
  z.ZodType<
    CreatePaymentLinkApplicationFeeAmountResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type CreatePaymentLinkApplicationFeeAmountResponse$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentLinkApplicationFeeAmountResponse$outboundSchema:
  z.ZodType<
    CreatePaymentLinkApplicationFeeAmountResponse$Outbound,
    z.ZodTypeDef,
    CreatePaymentLinkApplicationFeeAmountResponse
  > = z.object({
    currency: z.string(),
    value: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkApplicationFeeAmountResponse$ {
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkApplicationFeeAmountResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkApplicationFeeAmountResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeAmountResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkApplicationFeeAmountResponse$Outbound;
}

export function createPaymentLinkApplicationFeeAmountResponseToJSON(
  createPaymentLinkApplicationFeeAmountResponse:
    CreatePaymentLinkApplicationFeeAmountResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkApplicationFeeAmountResponse$outboundSchema.parse(
      createPaymentLinkApplicationFeeAmountResponse,
    ),
  );
}

export function createPaymentLinkApplicationFeeAmountResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkApplicationFeeAmountResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkApplicationFeeAmountResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkApplicationFeeAmountResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkApplicationFeeResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkApplicationFeeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() =>
    CreatePaymentLinkApplicationFeeAmountResponse$inboundSchema
  ),
  description: z.string(),
});

/** @internal */
export type CreatePaymentLinkApplicationFeeResponse$Outbound = {
  amount: CreatePaymentLinkApplicationFeeAmountResponse$Outbound;
  description: string;
};

/** @internal */
export const CreatePaymentLinkApplicationFeeResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkApplicationFeeResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkApplicationFeeResponse
> = z.object({
  amount: z.lazy(() =>
    CreatePaymentLinkApplicationFeeAmountResponse$outboundSchema
  ),
  description: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkApplicationFeeResponse$ {
  /** @deprecated use `CreatePaymentLinkApplicationFeeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkApplicationFeeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkApplicationFeeResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkApplicationFeeResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkApplicationFeeResponse$Outbound;
}

export function createPaymentLinkApplicationFeeResponseToJSON(
  createPaymentLinkApplicationFeeResponse:
    CreatePaymentLinkApplicationFeeResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkApplicationFeeResponse$outboundSchema.parse(
      createPaymentLinkApplicationFeeResponse,
    ),
  );
}

export function createPaymentLinkApplicationFeeResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePaymentLinkApplicationFeeResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePaymentLinkApplicationFeeResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePaymentLinkApplicationFeeResponse' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkSequenceTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof CreatePaymentLinkSequenceTypeResponse> = z.nativeEnum(
    CreatePaymentLinkSequenceTypeResponse,
  );

/** @internal */
export const CreatePaymentLinkSequenceTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof CreatePaymentLinkSequenceTypeResponse> =
    CreatePaymentLinkSequenceTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkSequenceTypeResponse$ {
  /** @deprecated use `CreatePaymentLinkSequenceTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    CreatePaymentLinkSequenceTypeResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkSequenceTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    CreatePaymentLinkSequenceTypeResponse$outboundSchema;
}

/** @internal */
export const CreatePaymentLinkSelf$inboundSchema: z.ZodType<
  CreatePaymentLinkSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentLinkSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentLinkSelf$outboundSchema: z.ZodType<
  CreatePaymentLinkSelf$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkSelf$ {
  /** @deprecated use `CreatePaymentLinkSelf$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkSelf$inboundSchema;
  /** @deprecated use `CreatePaymentLinkSelf$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkSelf$outboundSchema;
  /** @deprecated use `CreatePaymentLinkSelf$Outbound` instead. */
  export type Outbound = CreatePaymentLinkSelf$Outbound;
}

export function createPaymentLinkSelfToJSON(
  createPaymentLinkSelf: CreatePaymentLinkSelf,
): string {
  return JSON.stringify(
    CreatePaymentLinkSelf$outboundSchema.parse(createPaymentLinkSelf),
  );
}

export function createPaymentLinkSelfFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkSelf' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkPaymentLink$inboundSchema: z.ZodType<
  CreatePaymentLinkPaymentLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type CreatePaymentLinkPaymentLink$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const CreatePaymentLinkPaymentLink$outboundSchema: z.ZodType<
  CreatePaymentLinkPaymentLink$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkPaymentLink
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkPaymentLink$ {
  /** @deprecated use `CreatePaymentLinkPaymentLink$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkPaymentLink$inboundSchema;
  /** @deprecated use `CreatePaymentLinkPaymentLink$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkPaymentLink$outboundSchema;
  /** @deprecated use `CreatePaymentLinkPaymentLink$Outbound` instead. */
  export type Outbound = CreatePaymentLinkPaymentLink$Outbound;
}

export function createPaymentLinkPaymentLinkToJSON(
  createPaymentLinkPaymentLink: CreatePaymentLinkPaymentLink,
): string {
  return JSON.stringify(
    CreatePaymentLinkPaymentLink$outboundSchema.parse(
      createPaymentLinkPaymentLink,
    ),
  );
}

export function createPaymentLinkPaymentLinkFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkPaymentLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkPaymentLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkPaymentLink' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkLinks$inboundSchema: z.ZodType<
  CreatePaymentLinkLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => CreatePaymentLinkSelf$inboundSchema),
  paymentLink: z.lazy(() => CreatePaymentLinkPaymentLink$inboundSchema),
});

/** @internal */
export type CreatePaymentLinkLinks$Outbound = {
  self: CreatePaymentLinkSelf$Outbound;
  paymentLink: CreatePaymentLinkPaymentLink$Outbound;
};

/** @internal */
export const CreatePaymentLinkLinks$outboundSchema: z.ZodType<
  CreatePaymentLinkLinks$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkLinks
> = z.object({
  self: z.lazy(() => CreatePaymentLinkSelf$outboundSchema),
  paymentLink: z.lazy(() => CreatePaymentLinkPaymentLink$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkLinks$ {
  /** @deprecated use `CreatePaymentLinkLinks$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkLinks$inboundSchema;
  /** @deprecated use `CreatePaymentLinkLinks$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkLinks$outboundSchema;
  /** @deprecated use `CreatePaymentLinkLinks$Outbound` instead. */
  export type Outbound = CreatePaymentLinkLinks$Outbound;
}

export function createPaymentLinkLinksToJSON(
  createPaymentLinkLinks: CreatePaymentLinkLinks,
): string {
  return JSON.stringify(
    CreatePaymentLinkLinks$outboundSchema.parse(createPaymentLinkLinks),
  );
}

export function createPaymentLinkLinksFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkLinks' from JSON`,
  );
}

/** @internal */
export const CreatePaymentLinkResponse$inboundSchema: z.ZodType<
  CreatePaymentLinkResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().default("payment-link"),
  id: z.string(),
  mode: CreatePaymentLinkMode$inboundSchema,
  description: z.string(),
  amount: z.nullable(
    z.lazy(() => CreatePaymentLinkAmountResponse$inboundSchema),
  ),
  minimumAmount: z.nullable(
    z.lazy(() => CreatePaymentLinkMinimumAmountResponse$inboundSchema),
  ).optional(),
  archived: z.boolean(),
  redirectUrl: z.nullable(z.string()),
  webhookUrl: z.nullable(z.string()),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLinkLineResponse$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentLinkBillingAddressResponse$inboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentLinkShippingAddressResponse$inboundSchema
  ).optional(),
  profileId: z.nullable(z.string()),
  reusable: z.nullable(z.boolean().default(false)),
  createdAt: z.string(),
  paidAt: z.nullable(z.string()),
  expiresAt: z.nullable(z.string()),
  allowedMethods: z.nullable(z.array(z.string())),
  applicationFee: z.lazy(() =>
    CreatePaymentLinkApplicationFeeResponse$inboundSchema
  ).optional(),
  sequenceType: z.nullable(CreatePaymentLinkSequenceTypeResponse$inboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
  _links: z.lazy(() => CreatePaymentLinkLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type CreatePaymentLinkResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: CreatePaymentLinkAmountResponse$Outbound | null;
  minimumAmount?:
    | CreatePaymentLinkMinimumAmountResponse$Outbound
    | null
    | undefined;
  archived: boolean;
  redirectUrl: string | null;
  webhookUrl: string | null;
  lines?: Array<CreatePaymentLinkLineResponse$Outbound> | null | undefined;
  billingAddress?: CreatePaymentLinkBillingAddressResponse$Outbound | undefined;
  shippingAddress?:
    | CreatePaymentLinkShippingAddressResponse$Outbound
    | undefined;
  profileId: string | null;
  reusable: boolean | null;
  createdAt: string;
  paidAt: string | null;
  expiresAt: string | null;
  allowedMethods: Array<string> | null;
  applicationFee?: CreatePaymentLinkApplicationFeeResponse$Outbound | undefined;
  sequenceType?: string | null | undefined;
  customerId?: string | null | undefined;
  _links: CreatePaymentLinkLinks$Outbound;
};

/** @internal */
export const CreatePaymentLinkResponse$outboundSchema: z.ZodType<
  CreatePaymentLinkResponse$Outbound,
  z.ZodTypeDef,
  CreatePaymentLinkResponse
> = z.object({
  resource: z.string().default("payment-link"),
  id: z.string(),
  mode: CreatePaymentLinkMode$outboundSchema,
  description: z.string(),
  amount: z.nullable(
    z.lazy(() => CreatePaymentLinkAmountResponse$outboundSchema),
  ),
  minimumAmount: z.nullable(
    z.lazy(() => CreatePaymentLinkMinimumAmountResponse$outboundSchema),
  ).optional(),
  archived: z.boolean(),
  redirectUrl: z.nullable(z.string()),
  webhookUrl: z.nullable(z.string()),
  lines: z.nullable(
    z.array(z.lazy(() => CreatePaymentLinkLineResponse$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    CreatePaymentLinkBillingAddressResponse$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    CreatePaymentLinkShippingAddressResponse$outboundSchema
  ).optional(),
  profileId: z.nullable(z.string()),
  reusable: z.nullable(z.boolean().default(false)),
  createdAt: z.string(),
  paidAt: z.nullable(z.string()),
  expiresAt: z.nullable(z.string()),
  allowedMethods: z.nullable(z.array(z.string())),
  applicationFee: z.lazy(() =>
    CreatePaymentLinkApplicationFeeResponse$outboundSchema
  ).optional(),
  sequenceType: z.nullable(CreatePaymentLinkSequenceTypeResponse$outboundSchema)
    .optional(),
  customerId: z.nullable(z.string()).optional(),
  links: z.lazy(() => CreatePaymentLinkLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentLinkResponse$ {
  /** @deprecated use `CreatePaymentLinkResponse$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentLinkResponse$inboundSchema;
  /** @deprecated use `CreatePaymentLinkResponse$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentLinkResponse$outboundSchema;
  /** @deprecated use `CreatePaymentLinkResponse$Outbound` instead. */
  export type Outbound = CreatePaymentLinkResponse$Outbound;
}

export function createPaymentLinkResponseToJSON(
  createPaymentLinkResponse: CreatePaymentLinkResponse,
): string {
  return JSON.stringify(
    CreatePaymentLinkResponse$outboundSchema.parse(createPaymentLinkResponse),
  );
}

export function createPaymentLinkResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreatePaymentLinkResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePaymentLinkResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePaymentLinkResponse' from JSON`,
  );
}
