/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListCustomerPaymentsRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from newest to oldest.
   *
   * @remarks
   *
   * Possible values: `asc` `desc` (default: `desc`)
   */
  sort?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to retrieve the resources for.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.
   *
   * @remarks
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListCustomerPaymentsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListCustomerPaymentsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListCustomerPaymentsBadRequestDocumentation;
};

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
 */
export type ListCustomerPaymentsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
 */
export type ListCustomerPaymentsAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type ListCustomerPaymentsAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type ListCustomerPaymentsAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
 */
export type ListCustomerPaymentsAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
 *
 * @remarks
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type ListCustomerPaymentsSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type ListCustomerPaymentsUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount type.
 */
export type ListCustomerPaymentsDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type ListCustomerPaymentsTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * @remarks
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type ListCustomerPaymentsVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const ListCustomerPaymentsCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type ListCustomerPaymentsCategory = ClosedEnum<
  typeof ListCustomerPaymentsCategory
>;

/**
 * Total amount and currency of the recurring item.
 */
export type ListCustomerPaymentsRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout to inform the shopper of the details for recurring products in the payments.
 */
export type ListCustomerPaymentsRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   *
   * @remarks
   *
   * Possible values: `... months` `... weeks` `... days`
   */
  interval: string;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: ListCustomerPaymentsRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type ListCustomerPaymentsLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   *
   * Possible values: `physical` `digital` `shipping_fee` `discount` `store_credit` `gift_card` `surcharge` `tip` (default: `physical`)
   */
  type?: string | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: ListCustomerPaymentsUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount type.
   */
  discountAmount?: ListCustomerPaymentsDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: ListCustomerPaymentsTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * @remarks
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: ListCustomerPaymentsVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<ListCustomerPaymentsCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: ListCustomerPaymentsRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
 *
 * @remarks
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListCustomerPaymentsBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only numbers.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only numbers.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
 *
 * @remarks
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
 */
export type ListCustomerPaymentsShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only numbers.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only numbers.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

export type ListCustomerPaymentsMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListCustomerPaymentsMetadataUnion =
  | ListCustomerPaymentsMetadata
  | string
  | Array<string>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge a €0.99 fee on a €1.00 payment.
 */
export type ListCustomerPaymentsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
 *
 * @remarks
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
 */
export type ListCustomerPaymentsApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge a €0.99 fee on a €1.00 payment.
   */
  amount?: ListCustomerPaymentsApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the connected merchant.
   */
  description?: string | undefined;
};

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type ListCustomerPaymentsRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The destination of this portion of the payment.
 */
export type ListCustomerPaymentsDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   *
   * @remarks
   *
   * Possible values: `organization`
   */
  type: string;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type ListCustomerPaymentsRoutingPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListCustomerPaymentsRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: ListCustomerPaymentsRoutingPayment;
};

export type ListCustomerPaymentsRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID. Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   *
   * @remarks
   *
   * Possible values: `live` `test`
   */
  mode: string;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: ListCustomerPaymentsRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: ListCustomerPaymentsDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The date must be given in `YYYY-MM-DD` format.
   *
   * @remarks
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListCustomerPaymentsRoutingLinks;
};

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
 *
 * @remarks
 *
 * You can find more information about the possible values of this object on [this page](status-reasons).**
 */
export type ListCustomerPaymentsStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsPaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type ListCustomerPaymentsCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type ListCustomerPaymentsMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different payment states.
 *
 * @remarks
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or chargeback for the test payment.
 */
export type ListCustomerPaymentsChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type ListCustomerPaymentsDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type ListCustomerPaymentsRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this payment.
 */
export type ListCustomerPaymentsChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type ListCustomerPaymentsCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with. Not present if not yet settled.
 */
export type ListCustomerPaymentsSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type ListCustomerPaymentsCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type ListCustomerPaymentsMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type ListCustomerPaymentsSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an order.
 */
export type ListCustomerPaymentsOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for point-of-sale payments.
 */
export type ListCustomerPaymentsTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsPaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListCustomerPaymentsPaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: ListCustomerPaymentsCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: ListCustomerPaymentsMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different payment states.
   *
   * @remarks
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or chargeback for the test payment.
   */
  changePaymentState?: ListCustomerPaymentsChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: ListCustomerPaymentsDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: ListCustomerPaymentsRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this payment.
   */
  chargebacks?: ListCustomerPaymentsChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: ListCustomerPaymentsCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with. Not present if not yet settled.
   */
  settlement?: ListCustomerPaymentsSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: ListCustomerPaymentsCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: ListCustomerPaymentsMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: ListCustomerPaymentsSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an order.
   */
  order?: ListCustomerPaymentsOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for point-of-sale payments.
   */
  terminal?: ListCustomerPaymentsTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListCustomerPaymentsPaymentDocumentation | undefined;
};

export type ListCustomerPaymentsPaymentOutput = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   *
   * @remarks
   *
   * Possible values: `live` `test`
   */
  mode: string;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
   *
   * @remarks
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
   */
  amount: ListCustomerPaymentsAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
   */
  amountRefunded?: ListCustomerPaymentsAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: ListCustomerPaymentsAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: ListCustomerPaymentsAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
   */
  amountChargedBack?: ListCustomerPaymentsAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
   *
   * @remarks
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: ListCustomerPaymentsSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * @remarks
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
   *
   * @remarks
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListCustomerPaymentsLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
   *
   * @remarks
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListCustomerPaymentsBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
   *
   * @remarks
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
   */
  shippingAddress?: ListCustomerPaymentsShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
   *
   * @remarks
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: string | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
   */
  method?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * @remarks
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?:
    | ListCustomerPaymentsMetadata
    | string
    | Array<string>
    | null
    | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
   *
   * @remarks
   *
   * This field needs to be set to `manual` for method `riverty`.
   *
   * Possible values: `automatic` `manual` (default: `automatic`)
   */
  captureMode?: string | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
   *
   * @remarks
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
   */
  applicationFee?: ListCustomerPaymentsApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
   */
  routing?: Array<ListCustomerPaymentsRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
   *
   * Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
   */
  sequenceType: string | null;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
   *
   * @remarks
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
   *
   * @remarks
   *
   * Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
   */
  status: string;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
   *
   * @remarks
   *
   * You can find more information about the possible values of this object on [this page](status-reasons).**
   */
  statusReason?: ListCustomerPaymentsStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListCustomerPaymentsPaymentLinks;
};

export type ListCustomerPaymentsEmbedded = {
  /**
   * An array of payment objects.
   */
  payments?: Array<ListCustomerPaymentsPaymentOutput> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListCustomerPaymentsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListCustomerPaymentsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListCustomerPaymentsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsLinks = {
  /**
   * The URL to the current set of items.
   */
  self?: ListCustomerPaymentsSelf | undefined;
  /**
   * The previous set of items, if available.
   */
  previous?: ListCustomerPaymentsPrevious | null | undefined;
  /**
   * The next set of items, if available.
   */
  next?: ListCustomerPaymentsNext | null | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListCustomerPaymentsDocumentation | undefined;
};

/**
 * A list of payment objects.
 */
export type ListCustomerPaymentsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result as well.
   *
   * @remarks
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default limit is 50 items.
   */
  count?: number | undefined;
  embedded?: ListCustomerPaymentsEmbedded | undefined;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links?: ListCustomerPaymentsLinks | undefined;
};

/** @internal */
export const ListCustomerPaymentsRequest$inboundSchema: z.ZodType<
  ListCustomerPaymentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListCustomerPaymentsRequest$Outbound = {
  customerId: string;
  from?: string | undefined;
  limit: number | null;
  sort?: string | null | undefined;
  profileId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListCustomerPaymentsRequest$outboundSchema: z.ZodType<
  ListCustomerPaymentsRequest$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRequest
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int().default(50)),
  sort: z.nullable(z.string()).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRequest$ {
  /** @deprecated use `ListCustomerPaymentsRequest$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRequest$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRequest$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRequest$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRequest$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRequest$Outbound;
}

export function listCustomerPaymentsRequestToJSON(
  listCustomerPaymentsRequest: ListCustomerPaymentsRequest,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRequest$outboundSchema.parse(
      listCustomerPaymentsRequest,
    ),
  );
}

export function listCustomerPaymentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRequest' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBadRequestDocumentation$inboundSchema:
  z.ZodType<
    ListCustomerPaymentsBadRequestDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListCustomerPaymentsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsBadRequestDocumentation$outboundSchema:
  z.ZodType<
    ListCustomerPaymentsBadRequestDocumentation$Outbound,
    z.ZodTypeDef,
    ListCustomerPaymentsBadRequestDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBadRequestDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBadRequestDocumentation$Outbound;
}

export function listCustomerPaymentsBadRequestDocumentationToJSON(
  listCustomerPaymentsBadRequestDocumentation:
    ListCustomerPaymentsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema.parse(
      listCustomerPaymentsBadRequestDocumentation,
    ),
  );
}

export function listCustomerPaymentsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBadRequestLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListCustomerPaymentsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListCustomerPaymentsBadRequestLinks$Outbound = {
  documentation: ListCustomerPaymentsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListCustomerPaymentsBadRequestLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBadRequestLinks$ {
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBadRequestLinks$Outbound;
}

export function listCustomerPaymentsBadRequestLinksToJSON(
  listCustomerPaymentsBadRequestLinks: ListCustomerPaymentsBadRequestLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBadRequestLinks$outboundSchema.parse(
      listCustomerPaymentsBadRequestLinks,
    ),
  );
}

export function listCustomerPaymentsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmount$ {
  /** @deprecated use `ListCustomerPaymentsAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmount$Outbound;
}

export function listCustomerPaymentsAmountToJSON(
  listCustomerPaymentsAmount: ListCustomerPaymentsAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmount$outboundSchema.parse(listCustomerPaymentsAmount),
  );
}

export function listCustomerPaymentsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountRefunded$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountRefunded$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRefunded$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountRefunded$ {
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmountRefunded$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountRefunded$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountRefunded$Outbound;
}

export function listCustomerPaymentsAmountRefundedToJSON(
  listCustomerPaymentsAmountRefunded: ListCustomerPaymentsAmountRefunded,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountRefunded$outboundSchema.parse(
      listCustomerPaymentsAmountRefunded,
    ),
  );
}

export function listCustomerPaymentsAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountRefunded' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountRemaining$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountRemaining$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRemaining$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountRemaining$ {
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsAmountRemaining$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountRemaining$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountRemaining$Outbound;
}

export function listCustomerPaymentsAmountRemainingToJSON(
  listCustomerPaymentsAmountRemaining: ListCustomerPaymentsAmountRemaining,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountRemaining$outboundSchema.parse(
      listCustomerPaymentsAmountRemaining,
    ),
  );
}

export function listCustomerPaymentsAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountRemaining' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountCaptured$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountCaptured$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountCaptured$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountCaptured$ {
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmountCaptured$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountCaptured$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountCaptured$Outbound;
}

export function listCustomerPaymentsAmountCapturedToJSON(
  listCustomerPaymentsAmountCaptured: ListCustomerPaymentsAmountCaptured,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountCaptured$outboundSchema.parse(
      listCustomerPaymentsAmountCaptured,
    ),
  );
}

export function listCustomerPaymentsAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountCaptured' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountChargedBack$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountChargedBack$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountChargedBack$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountChargedBack$ {
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsAmountChargedBack$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountChargedBack$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountChargedBack$Outbound;
}

export function listCustomerPaymentsAmountChargedBackToJSON(
  listCustomerPaymentsAmountChargedBack: ListCustomerPaymentsAmountChargedBack,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountChargedBack$outboundSchema.parse(
      listCustomerPaymentsAmountChargedBack,
    ),
  );
}

export function listCustomerPaymentsAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSettlementAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsSettlementAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsSettlementAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSettlementAmount$ {
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsSettlementAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsSettlementAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSettlementAmount$Outbound;
}

export function listCustomerPaymentsSettlementAmountToJSON(
  listCustomerPaymentsSettlementAmount: ListCustomerPaymentsSettlementAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSettlementAmount$outboundSchema.parse(
      listCustomerPaymentsSettlementAmount,
    ),
  );
}

export function listCustomerPaymentsSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsUnitPrice$inboundSchema: z.ZodType<
  ListCustomerPaymentsUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsUnitPrice$outboundSchema: z.ZodType<
  ListCustomerPaymentsUnitPrice$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsUnitPrice$ {
  /** @deprecated use `ListCustomerPaymentsUnitPrice$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsUnitPrice$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsUnitPrice$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsUnitPrice$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsUnitPrice$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsUnitPrice$Outbound;
}

export function listCustomerPaymentsUnitPriceToJSON(
  listCustomerPaymentsUnitPrice: ListCustomerPaymentsUnitPrice,
): string {
  return JSON.stringify(
    ListCustomerPaymentsUnitPrice$outboundSchema.parse(
      listCustomerPaymentsUnitPrice,
    ),
  );
}

export function listCustomerPaymentsUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsUnitPrice' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDiscountAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsDiscountAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsDiscountAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDiscountAmount$ {
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDiscountAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsDiscountAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDiscountAmount$Outbound;
}

export function listCustomerPaymentsDiscountAmountToJSON(
  listCustomerPaymentsDiscountAmount: ListCustomerPaymentsDiscountAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDiscountAmount$outboundSchema.parse(
      listCustomerPaymentsDiscountAmount,
    ),
  );
}

export function listCustomerPaymentsDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDiscountAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsTotalAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsTotalAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsTotalAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsTotalAmount$ {
  /** @deprecated use `ListCustomerPaymentsTotalAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsTotalAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsTotalAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsTotalAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsTotalAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsTotalAmount$Outbound;
}

export function listCustomerPaymentsTotalAmountToJSON(
  listCustomerPaymentsTotalAmount: ListCustomerPaymentsTotalAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsTotalAmount$outboundSchema.parse(
      listCustomerPaymentsTotalAmount,
    ),
  );
}

export function listCustomerPaymentsTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsVatAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsVatAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsVatAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsVatAmount$ {
  /** @deprecated use `ListCustomerPaymentsVatAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsVatAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsVatAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsVatAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsVatAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsVatAmount$Outbound;
}

export function listCustomerPaymentsVatAmountToJSON(
  listCustomerPaymentsVatAmount: ListCustomerPaymentsVatAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsVatAmount$outboundSchema.parse(
      listCustomerPaymentsVatAmount,
    ),
  );
}

export function listCustomerPaymentsVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsVatAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCategory$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCategory
> = z.nativeEnum(ListCustomerPaymentsCategory);

/** @internal */
export const ListCustomerPaymentsCategory$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCategory
> = ListCustomerPaymentsCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCategory$ {
  /** @deprecated use `ListCustomerPaymentsCategory$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCategory$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCategory$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCategory$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsRecurringAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsRecurringAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsRecurringAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRecurringAmount$ {
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsRecurringAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRecurringAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRecurringAmount$Outbound;
}

export function listCustomerPaymentsRecurringAmountToJSON(
  listCustomerPaymentsRecurringAmount: ListCustomerPaymentsRecurringAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRecurringAmount$outboundSchema.parse(
      listCustomerPaymentsRecurringAmount,
    ),
  );
}

export function listCustomerPaymentsRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRecurringAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsRecurringAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRecurringAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRecurring$inboundSchema: z.ZodType<
  ListCustomerPaymentsRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRecurringAmount$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListCustomerPaymentsRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: ListCustomerPaymentsRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const ListCustomerPaymentsRecurring$outboundSchema: z.ZodType<
  ListCustomerPaymentsRecurring$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRecurring
> = z.object({
  description: z.string().optional(),
  interval: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRecurringAmount$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRecurring$ {
  /** @deprecated use `ListCustomerPaymentsRecurring$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRecurring$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurring$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRecurring$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurring$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRecurring$Outbound;
}

export function listCustomerPaymentsRecurringToJSON(
  listCustomerPaymentsRecurring: ListCustomerPaymentsRecurring,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRecurring$outboundSchema.parse(
      listCustomerPaymentsRecurring,
    ),
  );
}

export function listCustomerPaymentsRecurringFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRecurring' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLine$inboundSchema: z.ZodType<
  ListCustomerPaymentsLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListCustomerPaymentsUnitPrice$inboundSchema),
  discountAmount: z.lazy(() => ListCustomerPaymentsDiscountAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => ListCustomerPaymentsTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListCustomerPaymentsVatAmount$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListCustomerPaymentsCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListCustomerPaymentsRecurring$inboundSchema)
    .optional(),
});

/** @internal */
export type ListCustomerPaymentsLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: ListCustomerPaymentsUnitPrice$Outbound;
  discountAmount?: ListCustomerPaymentsDiscountAmount$Outbound | undefined;
  totalAmount: ListCustomerPaymentsTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: ListCustomerPaymentsVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: ListCustomerPaymentsRecurring$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsLine$outboundSchema: z.ZodType<
  ListCustomerPaymentsLine$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsLine
> = z.object({
  type: z.string().optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListCustomerPaymentsUnitPrice$outboundSchema),
  discountAmount: z.lazy(() =>
    ListCustomerPaymentsDiscountAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListCustomerPaymentsTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListCustomerPaymentsVatAmount$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListCustomerPaymentsCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListCustomerPaymentsRecurring$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLine$ {
  /** @deprecated use `ListCustomerPaymentsLine$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLine$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLine$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLine$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsLine$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsLine$Outbound;
}

export function listCustomerPaymentsLineToJSON(
  listCustomerPaymentsLine: ListCustomerPaymentsLine,
): string {
  return JSON.stringify(
    ListCustomerPaymentsLine$outboundSchema.parse(listCustomerPaymentsLine),
  );
}

export function listCustomerPaymentsLineFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsLine' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBillingAddress$inboundSchema: z.ZodType<
  ListCustomerPaymentsBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsBillingAddress$outboundSchema: z.ZodType<
  ListCustomerPaymentsBillingAddress$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBillingAddress$ {
  /** @deprecated use `ListCustomerPaymentsBillingAddress$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsBillingAddress$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBillingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBillingAddress$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBillingAddress$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBillingAddress$Outbound;
}

export function listCustomerPaymentsBillingAddressToJSON(
  listCustomerPaymentsBillingAddress: ListCustomerPaymentsBillingAddress,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBillingAddress$outboundSchema.parse(
      listCustomerPaymentsBillingAddress,
    ),
  );
}

export function listCustomerPaymentsBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsShippingAddress$inboundSchema: z.ZodType<
  ListCustomerPaymentsShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsShippingAddress$outboundSchema: z.ZodType<
  ListCustomerPaymentsShippingAddress$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsShippingAddress$ {
  /** @deprecated use `ListCustomerPaymentsShippingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsShippingAddress$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsShippingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsShippingAddress$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsShippingAddress$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsShippingAddress$Outbound;
}

export function listCustomerPaymentsShippingAddressToJSON(
  listCustomerPaymentsShippingAddress: ListCustomerPaymentsShippingAddress,
): string {
  return JSON.stringify(
    ListCustomerPaymentsShippingAddress$outboundSchema.parse(
      listCustomerPaymentsShippingAddress,
    ),
  );
}

export function listCustomerPaymentsShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsShippingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsShippingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsShippingAddress' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMetadata$inboundSchema: z.ZodType<
  ListCustomerPaymentsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListCustomerPaymentsMetadata$Outbound = {};

/** @internal */
export const ListCustomerPaymentsMetadata$outboundSchema: z.ZodType<
  ListCustomerPaymentsMetadata$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMetadata$ {
  /** @deprecated use `ListCustomerPaymentsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMetadata$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMetadata$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadata$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMetadata$Outbound;
}

export function listCustomerPaymentsMetadataToJSON(
  listCustomerPaymentsMetadata: ListCustomerPaymentsMetadata,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMetadata$outboundSchema.parse(
      listCustomerPaymentsMetadata,
    ),
  );
}

export function listCustomerPaymentsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMetadata' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMetadataUnion$inboundSchema: z.ZodType<
  ListCustomerPaymentsMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListCustomerPaymentsMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type ListCustomerPaymentsMetadataUnion$Outbound =
  | ListCustomerPaymentsMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const ListCustomerPaymentsMetadataUnion$outboundSchema: z.ZodType<
  ListCustomerPaymentsMetadataUnion$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMetadataUnion
> = z.union([
  z.lazy(() => ListCustomerPaymentsMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMetadataUnion$ {
  /** @deprecated use `ListCustomerPaymentsMetadataUnion$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMetadataUnion$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadataUnion$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsMetadataUnion$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadataUnion$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMetadataUnion$Outbound;
}

export function listCustomerPaymentsMetadataUnionToJSON(
  listCustomerPaymentsMetadataUnion: ListCustomerPaymentsMetadataUnion,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMetadataUnion$outboundSchema.parse(
      listCustomerPaymentsMetadataUnion,
    ),
  );
}

export function listCustomerPaymentsMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMetadataUnion' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsApplicationFeeAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsApplicationFeeAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsApplicationFeeAmount$ {
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsApplicationFeeAmount$Outbound;
}

export function listCustomerPaymentsApplicationFeeAmountToJSON(
  listCustomerPaymentsApplicationFeeAmount:
    ListCustomerPaymentsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsApplicationFeeAmount$outboundSchema.parse(
      listCustomerPaymentsApplicationFeeAmount,
    ),
  );
}

export function listCustomerPaymentsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsApplicationFeeAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsApplicationFeeAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsApplicationFee$inboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListCustomerPaymentsApplicationFeeAmount$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsApplicationFee$Outbound = {
  amount?: ListCustomerPaymentsApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsApplicationFee$outboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsApplicationFee
> = z.object({
  amount: z.lazy(() => ListCustomerPaymentsApplicationFeeAmount$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsApplicationFee$ {
  /** @deprecated use `ListCustomerPaymentsApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsApplicationFee$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsApplicationFee$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFee$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsApplicationFee$Outbound;
}

export function listCustomerPaymentsApplicationFeeToJSON(
  listCustomerPaymentsApplicationFee: ListCustomerPaymentsApplicationFee,
): string {
  return JSON.stringify(
    ListCustomerPaymentsApplicationFee$outboundSchema.parse(
      listCustomerPaymentsApplicationFee,
    ),
  );
}

export function listCustomerPaymentsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingAmount$ {
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRoutingAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingAmount$Outbound;
}

export function listCustomerPaymentsRoutingAmountToJSON(
  listCustomerPaymentsRoutingAmount: ListCustomerPaymentsRoutingAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingAmount$outboundSchema.parse(
      listCustomerPaymentsRoutingAmount,
    ),
  );
}

export function listCustomerPaymentsRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDestination$inboundSchema: z.ZodType<
  ListCustomerPaymentsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  organizationId: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const ListCustomerPaymentsDestination$outboundSchema: z.ZodType<
  ListCustomerPaymentsDestination$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDestination
> = z.object({
  type: z.string(),
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDestination$ {
  /** @deprecated use `ListCustomerPaymentsDestination$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDestination$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDestination$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsDestination$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDestination$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDestination$Outbound;
}

export function listCustomerPaymentsDestinationToJSON(
  listCustomerPaymentsDestination: ListCustomerPaymentsDestination,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDestination$outboundSchema.parse(
      listCustomerPaymentsDestination,
    ),
  );
}

export function listCustomerPaymentsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDestination' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingSelf$ {
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingSelf$Outbound;
}

export function listCustomerPaymentsRoutingSelfToJSON(
  listCustomerPaymentsRoutingSelf: ListCustomerPaymentsRoutingSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingSelf$outboundSchema.parse(
      listCustomerPaymentsRoutingSelf,
    ),
  );
}

export function listCustomerPaymentsRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingPayment$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingPayment$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingPayment$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingPayment$ {
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingPayment$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRoutingPayment$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingPayment$Outbound;
}

export function listCustomerPaymentsRoutingPaymentToJSON(
  listCustomerPaymentsRoutingPayment: ListCustomerPaymentsRoutingPayment,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingPayment$outboundSchema.parse(
      listCustomerPaymentsRoutingPayment,
    ),
  );
}

export function listCustomerPaymentsRoutingPaymentFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsRoutingPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingPayment' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsRoutingSelf$inboundSchema),
  payment: z.lazy(() => ListCustomerPaymentsRoutingPayment$inboundSchema),
});

/** @internal */
export type ListCustomerPaymentsRoutingLinks$Outbound = {
  self: ListCustomerPaymentsRoutingSelf$Outbound;
  payment: ListCustomerPaymentsRoutingPayment$Outbound;
};

/** @internal */
export const ListCustomerPaymentsRoutingLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsRoutingSelf$outboundSchema),
  payment: z.lazy(() => ListCustomerPaymentsRoutingPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingLinks$ {
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingLinks$Outbound;
}

export function listCustomerPaymentsRoutingLinksToJSON(
  listCustomerPaymentsRoutingLinks: ListCustomerPaymentsRoutingLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingLinks$outboundSchema.parse(
      listCustomerPaymentsRoutingLinks,
    ),
  );
}

export function listCustomerPaymentsRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRouting$inboundSchema: z.ZodType<
  ListCustomerPaymentsRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRoutingAmount$inboundSchema),
  destination: z.lazy(() => ListCustomerPaymentsDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListCustomerPaymentsRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: ListCustomerPaymentsRoutingAmount$Outbound;
  destination: ListCustomerPaymentsDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: ListCustomerPaymentsRoutingLinks$Outbound;
};

/** @internal */
export const ListCustomerPaymentsRouting$outboundSchema: z.ZodType<
  ListCustomerPaymentsRouting$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRoutingAmount$outboundSchema),
  destination: z.lazy(() => ListCustomerPaymentsDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListCustomerPaymentsRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRouting$ {
  /** @deprecated use `ListCustomerPaymentsRouting$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRouting$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRouting$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRouting$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRouting$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRouting$Outbound;
}

export function listCustomerPaymentsRoutingToJSON(
  listCustomerPaymentsRouting: ListCustomerPaymentsRouting,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRouting$outboundSchema.parse(
      listCustomerPaymentsRouting,
    ),
  );
}

export function listCustomerPaymentsRoutingFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRouting' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsStatusReason$inboundSchema: z.ZodType<
  ListCustomerPaymentsStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type ListCustomerPaymentsStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const ListCustomerPaymentsStatusReason$outboundSchema: z.ZodType<
  ListCustomerPaymentsStatusReason$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsStatusReason$ {
  /** @deprecated use `ListCustomerPaymentsStatusReason$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsStatusReason$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsStatusReason$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsStatusReason$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsStatusReason$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsStatusReason$Outbound;
}

export function listCustomerPaymentsStatusReasonToJSON(
  listCustomerPaymentsStatusReason: ListCustomerPaymentsStatusReason,
): string {
  return JSON.stringify(
    ListCustomerPaymentsStatusReason$outboundSchema.parse(
      listCustomerPaymentsStatusReason,
    ),
  );
}

export function listCustomerPaymentsStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsStatusReason' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsPaymentSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentSelf$ {
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPaymentSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentSelf$Outbound;
}

export function listCustomerPaymentsPaymentSelfToJSON(
  listCustomerPaymentsPaymentSelf: ListCustomerPaymentsPaymentSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentSelf$outboundSchema.parse(
      listCustomerPaymentsPaymentSelf,
    ),
  );
}

export function listCustomerPaymentsPaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCheckout$inboundSchema: z.ZodType<
  ListCustomerPaymentsCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCheckout$outboundSchema: z.ZodType<
  ListCustomerPaymentsCheckout$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCheckout$ {
  /** @deprecated use `ListCustomerPaymentsCheckout$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCheckout$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCheckout$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCheckout$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCheckout$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCheckout$Outbound;
}

export function listCustomerPaymentsCheckoutToJSON(
  listCustomerPaymentsCheckout: ListCustomerPaymentsCheckout,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCheckout$outboundSchema.parse(
      listCustomerPaymentsCheckout,
    ),
  );
}

export function listCustomerPaymentsCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCheckout' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMobileAppCheckout$inboundSchema: z.ZodType<
  ListCustomerPaymentsMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsMobileAppCheckout$outboundSchema: z.ZodType<
  ListCustomerPaymentsMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMobileAppCheckout$ {
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsMobileAppCheckout$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsMobileAppCheckout$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMobileAppCheckout$Outbound;
}

export function listCustomerPaymentsMobileAppCheckoutToJSON(
  listCustomerPaymentsMobileAppCheckout: ListCustomerPaymentsMobileAppCheckout,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMobileAppCheckout$outboundSchema.parse(
      listCustomerPaymentsMobileAppCheckout,
    ),
  );
}

export function listCustomerPaymentsMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsChangePaymentState$inboundSchema: z.ZodType<
  ListCustomerPaymentsChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsChangePaymentState$outboundSchema: z.ZodType<
  ListCustomerPaymentsChangePaymentState$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsChangePaymentState$ {
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsChangePaymentState$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsChangePaymentState$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsChangePaymentState$Outbound;
}

export function listCustomerPaymentsChangePaymentStateToJSON(
  listCustomerPaymentsChangePaymentState:
    ListCustomerPaymentsChangePaymentState,
): string {
  return JSON.stringify(
    ListCustomerPaymentsChangePaymentState$outboundSchema.parse(
      listCustomerPaymentsChangePaymentState,
    ),
  );
}

export function listCustomerPaymentsChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsChangePaymentState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsChangePaymentState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsChangePaymentState' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDashboard$inboundSchema: z.ZodType<
  ListCustomerPaymentsDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsDashboard$outboundSchema: z.ZodType<
  ListCustomerPaymentsDashboard$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDashboard$ {
  /** @deprecated use `ListCustomerPaymentsDashboard$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDashboard$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDashboard$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsDashboard$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDashboard$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDashboard$Outbound;
}

export function listCustomerPaymentsDashboardToJSON(
  listCustomerPaymentsDashboard: ListCustomerPaymentsDashboard,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDashboard$outboundSchema.parse(
      listCustomerPaymentsDashboard,
    ),
  );
}

export function listCustomerPaymentsDashboardFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDashboard' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRefunds$inboundSchema: z.ZodType<
  ListCustomerPaymentsRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRefunds$outboundSchema: z.ZodType<
  ListCustomerPaymentsRefunds$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRefunds$ {
  /** @deprecated use `ListCustomerPaymentsRefunds$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRefunds$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRefunds$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRefunds$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRefunds$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRefunds$Outbound;
}

export function listCustomerPaymentsRefundsToJSON(
  listCustomerPaymentsRefunds: ListCustomerPaymentsRefunds,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRefunds$outboundSchema.parse(
      listCustomerPaymentsRefunds,
    ),
  );
}

export function listCustomerPaymentsRefundsFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRefunds' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsChargebacks$inboundSchema: z.ZodType<
  ListCustomerPaymentsChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsChargebacks$outboundSchema: z.ZodType<
  ListCustomerPaymentsChargebacks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsChargebacks$ {
  /** @deprecated use `ListCustomerPaymentsChargebacks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsChargebacks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsChargebacks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsChargebacks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsChargebacks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsChargebacks$Outbound;
}

export function listCustomerPaymentsChargebacksToJSON(
  listCustomerPaymentsChargebacks: ListCustomerPaymentsChargebacks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsChargebacks$outboundSchema.parse(
      listCustomerPaymentsChargebacks,
    ),
  );
}

export function listCustomerPaymentsChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsChargebacks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCaptures$inboundSchema: z.ZodType<
  ListCustomerPaymentsCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCaptures$outboundSchema: z.ZodType<
  ListCustomerPaymentsCaptures$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCaptures$ {
  /** @deprecated use `ListCustomerPaymentsCaptures$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCaptures$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCaptures$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCaptures$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCaptures$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCaptures$Outbound;
}

export function listCustomerPaymentsCapturesToJSON(
  listCustomerPaymentsCaptures: ListCustomerPaymentsCaptures,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCaptures$outboundSchema.parse(
      listCustomerPaymentsCaptures,
    ),
  );
}

export function listCustomerPaymentsCapturesFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCaptures' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSettlement$inboundSchema: z.ZodType<
  ListCustomerPaymentsSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSettlement$outboundSchema: z.ZodType<
  ListCustomerPaymentsSettlement$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSettlement$ {
  /** @deprecated use `ListCustomerPaymentsSettlement$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSettlement$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlement$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSettlement$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlement$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSettlement$Outbound;
}

export function listCustomerPaymentsSettlementToJSON(
  listCustomerPaymentsSettlement: ListCustomerPaymentsSettlement,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSettlement$outboundSchema.parse(
      listCustomerPaymentsSettlement,
    ),
  );
}

export function listCustomerPaymentsSettlementFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSettlement' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCustomer$inboundSchema: z.ZodType<
  ListCustomerPaymentsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCustomer$outboundSchema: z.ZodType<
  ListCustomerPaymentsCustomer$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCustomer$ {
  /** @deprecated use `ListCustomerPaymentsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCustomer$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCustomer$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCustomer$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCustomer$Outbound;
}

export function listCustomerPaymentsCustomerToJSON(
  listCustomerPaymentsCustomer: ListCustomerPaymentsCustomer,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCustomer$outboundSchema.parse(
      listCustomerPaymentsCustomer,
    ),
  );
}

export function listCustomerPaymentsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCustomer' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMandate$inboundSchema: z.ZodType<
  ListCustomerPaymentsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsMandate$outboundSchema: z.ZodType<
  ListCustomerPaymentsMandate$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMandate$ {
  /** @deprecated use `ListCustomerPaymentsMandate$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMandate$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMandate$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMandate$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMandate$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMandate$Outbound;
}

export function listCustomerPaymentsMandateToJSON(
  listCustomerPaymentsMandate: ListCustomerPaymentsMandate,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMandate$outboundSchema.parse(
      listCustomerPaymentsMandate,
    ),
  );
}

export function listCustomerPaymentsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMandate' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSubscription$inboundSchema: z.ZodType<
  ListCustomerPaymentsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSubscription$outboundSchema: z.ZodType<
  ListCustomerPaymentsSubscription$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSubscription$ {
  /** @deprecated use `ListCustomerPaymentsSubscription$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSubscription$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSubscription$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSubscription$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSubscription$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSubscription$Outbound;
}

export function listCustomerPaymentsSubscriptionToJSON(
  listCustomerPaymentsSubscription: ListCustomerPaymentsSubscription,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSubscription$outboundSchema.parse(
      listCustomerPaymentsSubscription,
    ),
  );
}

export function listCustomerPaymentsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSubscription' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsOrder$inboundSchema: z.ZodType<
  ListCustomerPaymentsOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsOrder$outboundSchema: z.ZodType<
  ListCustomerPaymentsOrder$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsOrder$ {
  /** @deprecated use `ListCustomerPaymentsOrder$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsOrder$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsOrder$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsOrder$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsOrder$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsOrder$Outbound;
}

export function listCustomerPaymentsOrderToJSON(
  listCustomerPaymentsOrder: ListCustomerPaymentsOrder,
): string {
  return JSON.stringify(
    ListCustomerPaymentsOrder$outboundSchema.parse(listCustomerPaymentsOrder),
  );
}

export function listCustomerPaymentsOrderFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsOrder' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsTerminal$inboundSchema: z.ZodType<
  ListCustomerPaymentsTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsTerminal$outboundSchema: z.ZodType<
  ListCustomerPaymentsTerminal$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsTerminal$ {
  /** @deprecated use `ListCustomerPaymentsTerminal$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsTerminal$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsTerminal$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsTerminal$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsTerminal$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsTerminal$Outbound;
}

export function listCustomerPaymentsTerminalToJSON(
  listCustomerPaymentsTerminal: ListCustomerPaymentsTerminal,
): string {
  return JSON.stringify(
    ListCustomerPaymentsTerminal$outboundSchema.parse(
      listCustomerPaymentsTerminal,
    ),
  );
}

export function listCustomerPaymentsTerminalFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsTerminal' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentDocumentation$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsPaymentDocumentation$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsPaymentDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsPaymentDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentDocumentation$Outbound;
}

export function listCustomerPaymentsPaymentDocumentationToJSON(
  listCustomerPaymentsPaymentDocumentation:
    ListCustomerPaymentsPaymentDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentDocumentation$outboundSchema.parse(
      listCustomerPaymentsPaymentDocumentation,
    ),
  );
}

export function listCustomerPaymentsPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsPaymentDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsPaymentDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsPaymentSelf$inboundSchema),
  checkout: z.lazy(() => ListCustomerPaymentsCheckout$inboundSchema).optional(),
  mobileAppCheckout: z.lazy(() =>
    ListCustomerPaymentsMobileAppCheckout$inboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListCustomerPaymentsChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListCustomerPaymentsDashboard$inboundSchema),
  refunds: z.lazy(() => ListCustomerPaymentsRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => ListCustomerPaymentsChargebacks$inboundSchema)
    .optional(),
  captures: z.lazy(() => ListCustomerPaymentsCaptures$inboundSchema).optional(),
  settlement: z.lazy(() => ListCustomerPaymentsSettlement$inboundSchema)
    .optional(),
  customer: z.lazy(() => ListCustomerPaymentsCustomer$inboundSchema).optional(),
  mandate: z.lazy(() => ListCustomerPaymentsMandate$inboundSchema).optional(),
  subscription: z.lazy(() => ListCustomerPaymentsSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => ListCustomerPaymentsOrder$inboundSchema).optional(),
  terminal: z.lazy(() => ListCustomerPaymentsTerminal$inboundSchema).optional(),
  documentation: z.lazy(() =>
    ListCustomerPaymentsPaymentDocumentation$inboundSchema
  ).optional(),
});

/** @internal */
export type ListCustomerPaymentsPaymentLinks$Outbound = {
  self: ListCustomerPaymentsPaymentSelf$Outbound;
  checkout?: ListCustomerPaymentsCheckout$Outbound | undefined;
  mobileAppCheckout?:
    | ListCustomerPaymentsMobileAppCheckout$Outbound
    | undefined;
  changePaymentState?:
    | ListCustomerPaymentsChangePaymentState$Outbound
    | undefined;
  dashboard: ListCustomerPaymentsDashboard$Outbound;
  refunds?: ListCustomerPaymentsRefunds$Outbound | undefined;
  chargebacks?: ListCustomerPaymentsChargebacks$Outbound | undefined;
  captures?: ListCustomerPaymentsCaptures$Outbound | undefined;
  settlement?: ListCustomerPaymentsSettlement$Outbound | undefined;
  customer?: ListCustomerPaymentsCustomer$Outbound | undefined;
  mandate?: ListCustomerPaymentsMandate$Outbound | undefined;
  subscription?: ListCustomerPaymentsSubscription$Outbound | undefined;
  order?: ListCustomerPaymentsOrder$Outbound | undefined;
  terminal?: ListCustomerPaymentsTerminal$Outbound | undefined;
  documentation?: ListCustomerPaymentsPaymentDocumentation$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsPaymentLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsPaymentSelf$outboundSchema),
  checkout: z.lazy(() => ListCustomerPaymentsCheckout$outboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListCustomerPaymentsMobileAppCheckout$outboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListCustomerPaymentsChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListCustomerPaymentsDashboard$outboundSchema),
  refunds: z.lazy(() => ListCustomerPaymentsRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => ListCustomerPaymentsChargebacks$outboundSchema)
    .optional(),
  captures: z.lazy(() => ListCustomerPaymentsCaptures$outboundSchema)
    .optional(),
  settlement: z.lazy(() => ListCustomerPaymentsSettlement$outboundSchema)
    .optional(),
  customer: z.lazy(() => ListCustomerPaymentsCustomer$outboundSchema)
    .optional(),
  mandate: z.lazy(() => ListCustomerPaymentsMandate$outboundSchema).optional(),
  subscription: z.lazy(() => ListCustomerPaymentsSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => ListCustomerPaymentsOrder$outboundSchema).optional(),
  terminal: z.lazy(() => ListCustomerPaymentsTerminal$outboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListCustomerPaymentsPaymentDocumentation$outboundSchema
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentLinks$ {
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPaymentLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentLinks$Outbound;
}

export function listCustomerPaymentsPaymentLinksToJSON(
  listCustomerPaymentsPaymentLinks: ListCustomerPaymentsPaymentLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentLinks$outboundSchema.parse(
      listCustomerPaymentsPaymentLinks,
    ),
  );
}

export function listCustomerPaymentsPaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentOutput$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: z.string(),
  description: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsAmount$inboundSchema),
  amountRefunded: z.lazy(() => ListCustomerPaymentsAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() =>
    ListCustomerPaymentsAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() => ListCustomerPaymentsAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() =>
    ListCustomerPaymentsAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListCustomerPaymentsSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsLine$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() => ListCustomerPaymentsBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() =>
    ListCustomerPaymentsShippingAddress$inboundSchema
  ).optional(),
  locale: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListCustomerPaymentsMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(z.string()).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsRouting$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(z.string()),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: z.string(),
  statusReason: z.nullable(
    z.lazy(() => ListCustomerPaymentsStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListCustomerPaymentsPaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsPaymentOutput$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: ListCustomerPaymentsAmount$Outbound;
  amountRefunded?: ListCustomerPaymentsAmountRefunded$Outbound | undefined;
  amountRemaining?: ListCustomerPaymentsAmountRemaining$Outbound | undefined;
  amountCaptured?: ListCustomerPaymentsAmountCaptured$Outbound | undefined;
  amountChargedBack?:
    | ListCustomerPaymentsAmountChargedBack$Outbound
    | undefined;
  settlementAmount?: ListCustomerPaymentsSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<ListCustomerPaymentsLine$Outbound> | null | undefined;
  billingAddress?: ListCustomerPaymentsBillingAddress$Outbound | undefined;
  shippingAddress?: ListCustomerPaymentsShippingAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | ListCustomerPaymentsMetadata$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | ListCustomerPaymentsApplicationFee$Outbound
    | null
    | undefined;
  routing?: Array<ListCustomerPaymentsRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: ListCustomerPaymentsStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: ListCustomerPaymentsPaymentLinks$Outbound;
};

/** @internal */
export const ListCustomerPaymentsPaymentOutput$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentOutput$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentOutput
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: z.string(),
  description: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsAmount$outboundSchema),
  amountRefunded: z.lazy(() =>
    ListCustomerPaymentsAmountRefunded$outboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListCustomerPaymentsAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListCustomerPaymentsAmountCaptured$outboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListCustomerPaymentsAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListCustomerPaymentsSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsLine$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListCustomerPaymentsBillingAddress$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListCustomerPaymentsShippingAddress$outboundSchema
  ).optional(),
  locale: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => ListCustomerPaymentsMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(z.string()).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsRouting$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(z.string()),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: z.string(),
  statusReason: z.nullable(
    z.lazy(() => ListCustomerPaymentsStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListCustomerPaymentsPaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentOutput$ {
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentOutput$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsPaymentOutput$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentOutput$Outbound;
}

export function listCustomerPaymentsPaymentOutputToJSON(
  listCustomerPaymentsPaymentOutput: ListCustomerPaymentsPaymentOutput,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentOutput$outboundSchema.parse(
      listCustomerPaymentsPaymentOutput,
    ),
  );
}

export function listCustomerPaymentsPaymentOutputFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentOutput' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsEmbedded$inboundSchema: z.ZodType<
  ListCustomerPaymentsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  payments: z.array(
    z.lazy(() => ListCustomerPaymentsPaymentOutput$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListCustomerPaymentsEmbedded$Outbound = {
  payments?: Array<ListCustomerPaymentsPaymentOutput$Outbound> | undefined;
};

/** @internal */
export const ListCustomerPaymentsEmbedded$outboundSchema: z.ZodType<
  ListCustomerPaymentsEmbedded$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsEmbedded
> = z.object({
  payments: z.array(
    z.lazy(() => ListCustomerPaymentsPaymentOutput$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsEmbedded$ {
  /** @deprecated use `ListCustomerPaymentsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsEmbedded$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsEmbedded$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsEmbedded$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsEmbedded$Outbound;
}

export function listCustomerPaymentsEmbeddedToJSON(
  listCustomerPaymentsEmbedded: ListCustomerPaymentsEmbedded,
): string {
  return JSON.stringify(
    ListCustomerPaymentsEmbedded$outboundSchema.parse(
      listCustomerPaymentsEmbedded,
    ),
  );
}

export function listCustomerPaymentsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSelf$ {
  /** @deprecated use `ListCustomerPaymentsSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSelf$Outbound;
}

export function listCustomerPaymentsSelfToJSON(
  listCustomerPaymentsSelf: ListCustomerPaymentsSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSelf$outboundSchema.parse(listCustomerPaymentsSelf),
  );
}

export function listCustomerPaymentsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPrevious$inboundSchema: z.ZodType<
  ListCustomerPaymentsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsPrevious$outboundSchema: z.ZodType<
  ListCustomerPaymentsPrevious$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPrevious$ {
  /** @deprecated use `ListCustomerPaymentsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPrevious$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPrevious$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPrevious$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPrevious$Outbound;
}

export function listCustomerPaymentsPreviousToJSON(
  listCustomerPaymentsPrevious: ListCustomerPaymentsPrevious,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPrevious$outboundSchema.parse(
      listCustomerPaymentsPrevious,
    ),
  );
}

export function listCustomerPaymentsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPrevious' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsNext$inboundSchema: z.ZodType<
  ListCustomerPaymentsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsNext$outboundSchema: z.ZodType<
  ListCustomerPaymentsNext$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsNext$ {
  /** @deprecated use `ListCustomerPaymentsNext$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsNext$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsNext$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsNext$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsNext$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsNext$Outbound;
}

export function listCustomerPaymentsNextToJSON(
  listCustomerPaymentsNext: ListCustomerPaymentsNext,
): string {
  return JSON.stringify(
    ListCustomerPaymentsNext$outboundSchema.parse(listCustomerPaymentsNext),
  );
}

export function listCustomerPaymentsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsNext' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDocumentation$inboundSchema: z.ZodType<
  ListCustomerPaymentsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsDocumentation$outboundSchema: z.ZodType<
  ListCustomerPaymentsDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDocumentation$Outbound;
}

export function listCustomerPaymentsDocumentationToJSON(
  listCustomerPaymentsDocumentation: ListCustomerPaymentsDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDocumentation$outboundSchema.parse(
      listCustomerPaymentsDocumentation,
    ),
  );
}

export function listCustomerPaymentsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsSelf$inboundSchema).optional(),
  previous: z.nullable(z.lazy(() => ListCustomerPaymentsPrevious$inboundSchema))
    .optional(),
  next: z.nullable(z.lazy(() => ListCustomerPaymentsNext$inboundSchema))
    .optional(),
  documentation: z.lazy(() => ListCustomerPaymentsDocumentation$inboundSchema)
    .optional(),
});

/** @internal */
export type ListCustomerPaymentsLinks$Outbound = {
  self?: ListCustomerPaymentsSelf$Outbound | undefined;
  previous?: ListCustomerPaymentsPrevious$Outbound | null | undefined;
  next?: ListCustomerPaymentsNext$Outbound | null | undefined;
  documentation?: ListCustomerPaymentsDocumentation$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsSelf$outboundSchema).optional(),
  previous: z.nullable(
    z.lazy(() => ListCustomerPaymentsPrevious$outboundSchema),
  ).optional(),
  next: z.nullable(z.lazy(() => ListCustomerPaymentsNext$outboundSchema))
    .optional(),
  documentation: z.lazy(() => ListCustomerPaymentsDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLinks$ {
  /** @deprecated use `ListCustomerPaymentsLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsLinks$Outbound;
}

export function listCustomerPaymentsLinksToJSON(
  listCustomerPaymentsLinks: ListCustomerPaymentsLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsLinks$outboundSchema.parse(listCustomerPaymentsLinks),
  );
}

export function listCustomerPaymentsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsResponse$inboundSchema: z.ZodType<
  ListCustomerPaymentsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  _embedded: z.lazy(() => ListCustomerPaymentsEmbedded$inboundSchema)
    .optional(),
  _links: z.lazy(() => ListCustomerPaymentsLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsResponse$Outbound = {
  count?: number | undefined;
  _embedded?: ListCustomerPaymentsEmbedded$Outbound | undefined;
  _links?: ListCustomerPaymentsLinks$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsResponse$outboundSchema: z.ZodType<
  ListCustomerPaymentsResponse$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsResponse
> = z.object({
  count: z.number().int().optional(),
  embedded: z.lazy(() => ListCustomerPaymentsEmbedded$outboundSchema)
    .optional(),
  links: z.lazy(() => ListCustomerPaymentsLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsResponse$ {
  /** @deprecated use `ListCustomerPaymentsResponse$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsResponse$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsResponse$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsResponse$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsResponse$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsResponse$Outbound;
}

export function listCustomerPaymentsResponseToJSON(
  listCustomerPaymentsResponse: ListCustomerPaymentsResponse,
): string {
  return JSON.stringify(
    ListCustomerPaymentsResponse$outboundSchema.parse(
      listCustomerPaymentsResponse,
    ),
  );
}

export function listCustomerPaymentsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsResponse' from JSON`,
  );
}
