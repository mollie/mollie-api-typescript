/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export const ListCustomerPaymentsSort = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
 *
 * @remarks
 * newest to oldest.
 */
export type ListCustomerPaymentsSort = ClosedEnum<
  typeof ListCustomerPaymentsSort
>;

export type ListCustomerPaymentsRequest = {
  /**
   * Provide the ID of the related customer.
   */
  customerId: string;
  /**
   * Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate
   *
   * @remarks
   * the result set.
   */
  from?: string | undefined;
  /**
   * The maximum number of items to return. Defaults to 50 items.
   */
  limit?: number | null | undefined;
  /**
   * Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from
   *
   * @remarks
   * newest to oldest.
   */
  sort?: ListCustomerPaymentsSort | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) you wish to
   *
   * @remarks
   * retrieve the resources for.
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted. For
   * organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type ListCustomerPaymentsBadRequestDocumentation = {
  href: string;
  type: string;
};

export type ListCustomerPaymentsBadRequestLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: ListCustomerPaymentsBadRequestDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListCustomerPaymentsMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListCustomerPaymentsMode = ClosedEnum<
  typeof ListCustomerPaymentsMode
>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type ListCustomerPaymentsAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type ListCustomerPaymentsAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type ListCustomerPaymentsAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type ListCustomerPaymentsAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type ListCustomerPaymentsAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type ListCustomerPaymentsSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const ListCustomerPaymentsLineType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type ListCustomerPaymentsLineType = ClosedEnum<
  typeof ListCustomerPaymentsLineType
>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type ListCustomerPaymentsUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type ListCustomerPaymentsDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type ListCustomerPaymentsTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type ListCustomerPaymentsVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const ListCustomerPaymentsCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type ListCustomerPaymentsCategory = ClosedEnum<
  typeof ListCustomerPaymentsCategory
>;

/**
 * Total amount and currency of the recurring item.
 */
export type ListCustomerPaymentsRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type ListCustomerPaymentsRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   *
   * @remarks
   *
   * Possible values: `... days`, `... weeks`, `... months`.
   */
  interval: string;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: ListCustomerPaymentsRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type ListCustomerPaymentsLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: ListCustomerPaymentsLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: ListCustomerPaymentsUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: ListCustomerPaymentsDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: ListCustomerPaymentsTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: ListCustomerPaymentsVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](https://docs.mollie.com/docs/integrating-vouchers/) guide for more information.
   */
  categories?: Array<ListCustomerPaymentsCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: ListCustomerPaymentsRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type ListCustomerPaymentsBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type ListCustomerPaymentsShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const ListCustomerPaymentsLocale = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type ListCustomerPaymentsLocale = ClosedEnum<
  typeof ListCustomerPaymentsLocale
>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const ListCustomerPaymentsMethod = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Klarnapaylater: "klarnapaylater",
  Klarnapaynow: "klarnapaynow",
  Klarnasliceit: "klarnasliceit",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type ListCustomerPaymentsMethod = ClosedEnum<
  typeof ListCustomerPaymentsMethod
>;

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type ListCustomerPaymentsMetadata =
  | string
  | { [k: string]: any }
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const ListCustomerPaymentsCaptureMode = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type ListCustomerPaymentsCaptureMode = ClosedEnum<
  typeof ListCustomerPaymentsCaptureMode
>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type ListCustomerPaymentsApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type ListCustomerPaymentsApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: ListCustomerPaymentsApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const ListCustomerPaymentsRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type ListCustomerPaymentsRoutingMode = ClosedEnum<
  typeof ListCustomerPaymentsRoutingMode
>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type ListCustomerPaymentsRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const ListCustomerPaymentsRoutingType = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type ListCustomerPaymentsRoutingType = ClosedEnum<
  typeof ListCustomerPaymentsRoutingType
>;

/**
 * The destination of this portion of the payment.
 */
export type ListCustomerPaymentsDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: ListCustomerPaymentsRoutingType;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type ListCustomerPaymentsRoutingPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListCustomerPaymentsRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: ListCustomerPaymentsRoutingPayment;
};

export type ListCustomerPaymentsRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListCustomerPaymentsRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: ListCustomerPaymentsRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: ListCustomerPaymentsDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListCustomerPaymentsRoutingLinks;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const ListCustomerPaymentsSequenceType = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type ListCustomerPaymentsSequenceType = ClosedEnum<
  typeof ListCustomerPaymentsSequenceType
>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const ListCustomerPaymentsStatusEnum = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type ListCustomerPaymentsStatusEnum = ClosedEnum<
  typeof ListCustomerPaymentsStatusEnum
>;

/**
 * A machine-readable code that indicates the reason for the payment's status.
 */
export const ListCustomerPaymentsCode = {
  ApprovedOrCompletedSuccessfully: "approved_or_completed_successfully",
  ReferToCardIssuer: "refer_to_card_issuer",
  InvalidMerchant: "invalid_merchant",
  CaptureCard: "capture_card",
  DoNotHonor: "do_not_honor",
  Error: "error",
  PartialApproval: "partial_approval",
  InvalidTransaction: "invalid_transaction",
  InvalidAmount: "invalid_amount",
  InvalidIssuer: "invalid_issuer",
  LostCard: "lost_card",
  StolenCard: "stolen_card",
  InsufficientFunds: "insufficient_funds",
  ExpiredCard: "expired_card",
  InvalidPin: "invalid_pin",
  TransactionNotPermittedToCardholder:
    "transaction_not_permitted_to_cardholder",
  TransactionNotAllowedAtTerminal: "transaction_not_allowed_at_terminal",
  ExceedsWithdrawalAmountLimit: "exceeds_withdrawal_amount_limit",
  RestrictedCard: "restricted_card",
  SecurityViolation: "security_violation",
  ExceedsWithdrawalCountLimit: "exceeds_withdrawal_count_limit",
  AllowableNumberOfPinTriesExceeded: "allowable_number_of_pin_tries_exceeded",
  NoReasonToDecline: "no_reason_to_decline",
  CannotVerifyPin: "cannot_verify_pin",
  IssuerUnavailable: "issuer_unavailable",
  UnableToRouteTransaction: "unable_to_route_transaction",
  DuplicateTransaction: "duplicate_transaction",
  SystemMalfunction: "system_malfunction",
  HonorWithId: "honor_with_id",
  InvalidCardNumber: "invalid_card_number",
  FormatError: "format_error",
  ContactCardIssuer: "contact_card_issuer",
  PinNotChanged: "pin_not_changed",
  InvalidNonexistentToAccountSpecified:
    "invalid_nonexistent_to_account_specified",
  InvalidNonexistentFromAccountSpecified:
    "invalid_nonexistent_from_account_specified",
  InvalidNonexistentAccountSpecified: "invalid_nonexistent_account_specified",
  LifecycleRelated: "lifecycle_related",
  DomesticDebitTransactionNotAllowed: "domestic_debit_transaction_not_allowed",
  PolicyRelated: "policy_related",
  FraudSecurityRelated: "fraud_security_related",
  InvalidAuthorizationLifeCycle: "invalid_authorization_life_cycle",
  PurchaseAmountOnlyNoCashBackAllowed:
    "purchase_amount_only_no_cash_back_allowed",
  CryptographicFailure: "cryptographic_failure",
  UnacceptablePin: "unacceptable_pin",
  ReferToCardIssuerSpecialCondition: "refer_to_card_issuer_special_condition",
  PickUpCardSpecialCondition: "pick_up_card_special_condition",
  VipApproval: "vip_approval",
  InvalidAccountNumber: "invalid_account_number",
  ReEnterTransaction: "re_enter_transaction",
  NoActionTaken: "no_action_taken",
  UnableToLocateRecord: "unable_to_locate_record",
  FileTemporarilyUnavailable: "file_temporarily_unavailable",
  NoCreditAccount: "no_credit_account",
  ClosedAccount: "closed_account",
  NoCheckingAccount: "no_checking_account",
  NoSavingsAccount: "no_savings_account",
  SuspectedFraud: "suspected_fraud",
  TransactionDoesNotFulfillAmlRequirement:
    "transaction_does_not_fulfill_aml_requirement",
  PinDataRequired: "pin_data_required",
  UnableToLocatePreviousMessage: "unable_to_locate_previous_message",
  PreviousMessageLocatedInconsistentData:
    "previous_message_located_inconsistent_data",
  BlockedFirstUsed: "blocked_first_used",
  TransactionReversed: "transaction_reversed",
  CreditIssuerUnavailable: "credit_issuer_unavailable",
  PinCryptographicErrorFound: "pin_cryptographic_error_found",
  NegativeOnlineCamResult: "negative_online_cam_result",
  ViolationOfLaw: "violation_of_law",
  ForceStip: "force_stip",
  CashServiceNotAvailable: "cash_service_not_available",
  CashbackRequestExceedsIssuerLimit: "cashback_request_exceeds_issuer_limit",
  DeclineForCvv2Failure: "decline_for_cvv2_failure",
  TransactionAmountExceedsPreAuthorizedAmount:
    "transaction_amount_exceeds_pre_authorized_amount",
  InvalidBillerInformation: "invalid_biller_information",
  PinChangeUnblockRequestDeclined: "pin_change_unblock_request_declined",
  UnsafePin: "unsafe_pin",
  CardAuthenticationFailed: "card_authentication_failed",
  StopPaymentOrder: "stop_payment_order",
  RevocationOfAuthorization: "revocation_of_authorization",
  RevocationOfAllAuthorizations: "revocation_of_all_authorizations",
  ForwardToIssuerXa: "forward_to_issuer_xa",
  ForwardToIssuerXd: "forward_to_issuer_xd",
  UnableToGoOnline: "unable_to_go_online",
  AdditionalCustomerAuthenticationRequired:
    "additional_customer_authentication_required",
  MerchantIdNotFound: "merchant_id_not_found",
  MerchantAccountClosed: "merchant_account_closed",
  TerminalIdNotFound: "terminal_id_not_found",
  TerminalClosed: "terminal_closed",
  InvalidCategoryCode: "invalid_category_code",
  InvalidCurrency: "invalid_currency",
  MissingCvv2Cvc2: "missing_cvv2_cvc2",
  Cvv2NotAllowed: "cvv2_not_allowed",
  MerchantNotRegisteredVbv: "merchant_not_registered_vbv",
  MerchantNotRegisteredForAmex: "merchant_not_registered_for_amex",
  TransactionNotPermittedAtTerminal: "transaction_not_permitted_at_terminal",
  AgreementTerminalNotRelated: "agreement_terminal_not_related",
  InvalidProcessorId: "invalid_processor_id",
  InvalidMerchantData: "invalid_merchant_data",
  SubMerchantAccountClosed: "sub_merchant_account_closed",
  TerminalBusy: "terminal_busy",
  TerminalUnreachable: "terminal_unreachable",
  ServiceFailed: "service_failed",
  InvalidOperation: "invalid_operation",
  AuthorizationError: "authorization_error",
  LoginFailedWithoutReason: "login_failed_without_reason",
  InvalidRetailer: "invalid_retailer",
  CardDoesNotExist: "card_does_not_exist",
  CardIsBlocked: "card_is_blocked",
  InvalidCardId: "invalid_card_id",
  CardIsTransferred: "card_is_transferred",
  CardIsNotActive: "card_is_not_active",
  IncorrectPurchaseValue: "incorrect_purchase_value",
  CardNotAvailable: "card_not_available",
  WrongCurrency: "wrong_currency",
  LoginFailedUnknownUser: "login_failed_unknown_user",
  LoginFailedInvalidPassword: "login_failed_invalid_password",
  InvalidEanCode: "invalid_ean_code",
} as const;
/**
 * A machine-readable code that indicates the reason for the payment's status.
 */
export type ListCustomerPaymentsCode = ClosedEnum<
  typeof ListCustomerPaymentsCode
>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type ListCustomerPaymentsStatusReason = {
  code: ListCustomerPaymentsCode;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * The card's target audience, if known.
 */
export const ListCustomerPaymentsCardAudition = {
  Consumer: "consumer",
  Business: "business",
} as const;
/**
 * The card's target audience, if known.
 */
export type ListCustomerPaymentsCardAudition = ClosedEnum<
  typeof ListCustomerPaymentsCardAudition
>;

/**
 * The card's label, if known.
 */
export const ListCustomerPaymentsCardLabel = {
  AmericanExpress: "American Express",
  CartaSi: "Carta Si",
  CarteBleue: "Carte Bleue",
  Dankort: "Dankort",
  DinersClub: "Diners Club",
  Discover: "Discover",
  Jcb: "JCB",
  Laser: "Laser",
  Maestro: "Maestro",
  Mastercard: "Mastercard",
  Unionpay: "Unionpay",
  Visa: "Visa",
  Vpay: "Vpay",
} as const;
/**
 * The card's label, if known.
 */
export type ListCustomerPaymentsCardLabel = ClosedEnum<
  typeof ListCustomerPaymentsCardLabel
>;

/**
 * The card type.
 */
export const ListCustomerPaymentsCardFunding = {
  Debit: "debit",
  Credit: "credit",
  Prepaid: "prepaid",
  DeferredDebit: "deferred-debit",
} as const;
/**
 * The card type.
 */
export type ListCustomerPaymentsCardFunding = ClosedEnum<
  typeof ListCustomerPaymentsCardFunding
>;

/**
 * The level of security applied during card processing.
 */
export const ListCustomerPaymentsCardSecurity = {
  Normal: "normal",
  Threedsecure: "3dsecure",
} as const;
/**
 * The level of security applied during card processing.
 */
export type ListCustomerPaymentsCardSecurity = ClosedEnum<
  typeof ListCustomerPaymentsCardSecurity
>;

/**
 * The applicable card fee region.
 */
export const ListCustomerPaymentsFeeRegion = {
  AmericanExpress: "american-express",
  AmexIntraEea: "amex-intra-eea",
  CarteBancaire: "carte-bancaire",
  IntraEu: "intra-eu",
  IntraEuCorporate: "intra-eu-corporate",
  Domestic: "domestic",
  Maestro: "maestro",
  Other: "other",
  Inter: "inter",
  IntraEea: "intra-eea",
} as const;
/**
 * The applicable card fee region.
 */
export type ListCustomerPaymentsFeeRegion = ClosedEnum<
  typeof ListCustomerPaymentsFeeRegion
>;

/**
 * A failure code to help understand why the payment failed.
 */
export const ListCustomerPaymentsFailureReason = {
  AuthenticationAbandoned: "authentication_abandoned",
  AuthenticationFailed: "authentication_failed",
  AuthenticationRequired: "authentication_required",
  AuthenticationUnavailableAcs: "authentication_unavailable_acs",
  CardDeclined: "card_declined",
  CardExpired: "card_expired",
  InactiveCard: "inactive_card",
  InsufficientFunds: "insufficient_funds",
  InvalidCvv: "invalid_cvv",
  InvalidCardHolderName: "invalid_card_holder_name",
  InvalidCardNumber: "invalid_card_number",
  InvalidCardType: "invalid_card_type",
  PossibleFraud: "possible_fraud",
  RefusedByIssuer: "refused_by_issuer",
  UnknownReason: "unknown_reason",
} as const;
/**
 * A failure code to help understand why the payment failed.
 */
export type ListCustomerPaymentsFailureReason = ClosedEnum<
  typeof ListCustomerPaymentsFailureReason
>;

/**
 * The wallet used when creating the payment.
 */
export const ListCustomerPaymentsWallet = {
  Applepay: "applepay",
} as const;
/**
 * The wallet used when creating the payment.
 */
export type ListCustomerPaymentsWallet = ClosedEnum<
  typeof ListCustomerPaymentsWallet
>;

/**
 * Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
 *
 * @remarks
 * payments, and if the information is made available by PayPal.
 */
export const ListCustomerPaymentsSellerProtection = {
  Eligible: "Eligible",
  Ineligible: "Ineligible",
  PartiallyEligibleINROnly: "Partially Eligible - INR Only",
  PartiallyEligibleUnauthOnly: "Partially Eligible - Unauth Only",
  PartiallyEligible: "Partially Eligible",
  None: "None",
  Active: "Active",
  FraudControlUnauthPremiumEligible: "Fraud Control - Unauth Premium Eligible",
} as const;
/**
 * Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
 *
 * @remarks
 * payments, and if the information is made available by PayPal.
 */
export type ListCustomerPaymentsSellerProtection = ClosedEnum<
  typeof ListCustomerPaymentsSellerProtection
>;

/**
 * An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
 *
 * @remarks
 * PayPal will not charge a fee for this transaction.
 */
export type ListCustomerPaymentsPaypalFee = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The method by which the card was read by the terminal.
 */
export const ListCustomerPaymentsCardReadMethod = {
  Chip: "chip",
  MagneticStripe: "magnetic-stripe",
  NearFieldCommunication: "near-field-communication",
  Contactless: "contactless",
  Moto: "moto",
} as const;
/**
 * The method by which the card was read by the terminal.
 */
export type ListCustomerPaymentsCardReadMethod = ClosedEnum<
  typeof ListCustomerPaymentsCardReadMethod
>;

/**
 * The method used to verify the cardholder's identity.
 */
export const ListCustomerPaymentsCardVerificationMethod = {
  NoCvmRequired: "no-cvm-required",
  OnlinePin: "online-pin",
  OfflinePin: "offline-pin",
  ConsumerDevice: "consumer-device",
  Signature: "signature",
  SignatureAndOnlinePin: "signature-and-online-pin",
  OnlinePinAndSignature: "online-pin-and-signature",
  None: "none",
  Failed: "failed",
} as const;
/**
 * The method used to verify the cardholder's identity.
 */
export type ListCustomerPaymentsCardVerificationMethod = ClosedEnum<
  typeof ListCustomerPaymentsCardVerificationMethod
>;

/**
 * The Point of sale receipt object.
 */
export type ListCustomerPaymentsReceipt = {
  /**
   * A unique code provided by the cardholder’s bank to confirm that the transaction was successfully approved.
   */
  authorizationCode?: string | null | undefined;
  /**
   * The unique number that identifies a specific payment application on a chip card.
   */
  applicationIdentifier?: string | null | undefined;
  /**
   * The method by which the card was read by the terminal.
   */
  cardReadMethod?: ListCustomerPaymentsCardReadMethod | null | undefined;
  /**
   * The method used to verify the cardholder's identity.
   */
  cardVerificationMethod?:
    | ListCustomerPaymentsCardVerificationMethod
    | null
    | undefined;
};

/**
 * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
 *
 * @remarks
 * the QR code details will be available in this object.
 *
 * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
 * Bancontact QR payments can be completed by the customer using the Bancontact app.
 */
export type ListCustomerPaymentsQrCode = {
  /**
   * The height of the QR code image in pixels.
   */
  height?: number | undefined;
  /**
   * The width of the QR code image in pixels.
   */
  width?: number | undefined;
  /**
   * The URL to the QR code image. The image is a PNG file, and can be displayed directly in the browser or
   *
   * @remarks
   * downloaded.
   */
  src?: string | undefined;
};

/**
 * An amount object for the amount that remained after all gift cards or vouchers were applied.
 */
export type ListCustomerPaymentsRemainderAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * An object containing payment details collected during the payment process. For example, details may include the
 *
 * @remarks
 * customer's card or bank details and a payment reference. For the full list of details, please refer to the
 * [method-specific parameters](extra-payment-parameters) guide.
 */
export type ListCustomerPaymentsDetails = {
  /**
   * The customer's name, if made available by the payment method. For card payments, refer to details.cardHolder.
   */
  consumerName?: string | null | undefined;
  /**
   * The customer's account reference.
   *
   * @remarks
   *
   * For banking-based payment methods — such as iDEAL — this is normally either an IBAN or a domestic bank account
   * number.
   *
   * For PayPal, the account reference is an email address.
   *
   * For card and Bancontact payments, refer to details.cardNumber.
   */
  consumerAccount?: string | null | undefined;
  /**
   * The BIC of the customer's bank account, if applicable.
   */
  consumerBic?: string | null | undefined;
  /**
   * For wallet payment methods — such as Apple Pay and PayPal — the shipping address is often already known by the
   *
   * @remarks
   * wallet provider. In these cases the shipping address may be available as a payment detail.
   */
  shippingAddress?: { [k: string]: any } | null | undefined;
  /**
   * For bancontact, it will be the customer's masked card number. For cards, it will be the last 4-digit of the
   *
   * @remarks
   * PAN. For Point-of-sale, it will be the the last 4 digits of the customer's masked card number.
   */
  cardNumber?: string | null | undefined;
  /**
   * The name of the bank that the customer will need to make the bank transfer payment towards.
   */
  bankName?: string | undefined;
  /**
   * The bank account number the customer will need to make the bank transfer payment towards.
   */
  bankAccount?: string | undefined;
  /**
   * The BIC of the bank the customer will need to make the bank transfer payment towards.
   */
  bankBic?: string | undefined;
  /**
   * The Mollie-generated reference the customer needs to use when transfering the amount. Do not apply any
   *
   * @remarks
   * formatting here; show it to the customer as-is.
   */
  transferReference?: string | null | undefined;
  /**
   * A unique fingerprint for a specific card. Can be used to identify returning customers.
   *
   * @remarks
   *
   * In the case of Point-of-sale payments, it's a unique identifier assigned to a cardholder's payment account,
   * linking multiple transactions from wallets and physical card to a single account, also across payment methods
   * or when the card is reissued.
   */
  cardFingerprint?: string | null | undefined;
  /**
   * The customer's name as shown on their card.
   */
  cardHolder?: string | null | undefined;
  /**
   * The card's target audience, if known.
   */
  cardAudition?: ListCustomerPaymentsCardAudition | null | undefined;
  /**
   * The card's label, if known.
   */
  cardLabel?: ListCustomerPaymentsCardLabel | null | undefined;
  /**
   * The ISO 3166-1 alpha-2 country code of the country the card was issued in.
   */
  cardCountryCode?: string | null | undefined;
  /**
   * The expiry date (MM/YY) of the card as displayed on the card.
   */
  cardExpiryDate?: string | null | undefined;
  /**
   * The card type.
   */
  cardFunding?: ListCustomerPaymentsCardFunding | null | undefined;
  /**
   * The level of security applied during card processing.
   */
  cardSecurity?: ListCustomerPaymentsCardSecurity | null | undefined;
  /**
   * The applicable card fee region.
   */
  feeRegion?: ListCustomerPaymentsFeeRegion | null | undefined;
  /**
   * The first 6 and last 4 digits of the card number.
   */
  cardMaskedNumber?: string | null | undefined;
  /**
   * The outcome of authentication attempted on transactions enforced by 3DS (ie valid only for oneoff and first).
   */
  card3dsEci?: string | null | undefined;
  /**
   * The first 6 digit of the card bank identification number.
   */
  cardBin?: string | null | undefined;
  /**
   * The issuer of the Card.
   */
  cardIssuer?: string | null | undefined;
  /**
   * A failure code to help understand why the payment failed.
   */
  failureReason?: ListCustomerPaymentsFailureReason | null | undefined;
  /**
   * A human-friendly failure message that can be shown to the customer. The message is translated in accordance
   *
   * @remarks
   * with the payment's locale setting.
   */
  failureMessage?: string | null | undefined;
  /**
   * The wallet used when creating the payment.
   */
  wallet?: ListCustomerPaymentsWallet | null | undefined;
  /**
   * PayPal's reference for the payment.
   */
  paypalReference?: string | null | undefined;
  /**
   * ID of the customer's PayPal account.
   */
  paypalPayerId?: string | null | undefined;
  /**
   * Indicates to what extent the payment is eligible for PayPal's Seller Protection. Only available for PayPal
   *
   * @remarks
   * payments, and if the information is made available by PayPal.
   */
  sellerProtection?: ListCustomerPaymentsSellerProtection | null | undefined;
  /**
   * An amount object containing the fee PayPal will charge for this transaction. The field may be omitted if
   *
   * @remarks
   * PayPal will not charge a fee for this transaction.
   */
  paypalFee?: ListCustomerPaymentsPaypalFee | null | undefined;
  /**
   * The paysafecard customer reference either provided via the API or otherwise auto-generated by Mollie.
   */
  customerReference?: string | undefined;
  /**
   * The ID of the terminal device where the payment took place on.
   */
  terminalId?: string | undefined;
  /**
   * The first 6 digits & last 4 digits of the customer's masked card number.
   */
  maskedNumber?: string | null | undefined;
  /**
   * The Point of sale receipt object.
   */
  receipt?: ListCustomerPaymentsReceipt | undefined;
  /**
   * The creditor identifier indicates who is authorized to execute the payment. In this case, it is a
   *
   * @remarks
   * reference to Mollie.
   */
  creditorIdentifier?: string | null | undefined;
  /**
   * Estimated date the payment is debited from the customer's bank account, in YYYY-MM-DD format.
   */
  dueDate?: RFCDate | null | undefined;
  /**
   * Date the payment has been signed by the customer, in YYYY-MM-DD format. Only available if the payment
   *
   * @remarks
   * has been signed.
   */
  signatureDate?: RFCDate | null | undefined;
  /**
   * The official reason why this payment has failed. A detailed description of each reason is available on the
   *
   * @remarks
   * website of the European Payments Council.
   */
  bankReasonCode?: string | null | undefined;
  /**
   * A human-friendly description of the failure reason.
   */
  bankReason?: string | null | undefined;
  /**
   * The end-to-end identifier you provided in the batch file.
   */
  endToEndIdentifier?: string | null | undefined;
  /**
   * The mandate reference you provided in the batch file.
   */
  mandateReference?: string | null | undefined;
  /**
   * The batch reference you provided in the batch file.
   */
  batchReference?: string | null | undefined;
  /**
   * The file reference you provided in the batch file.
   */
  fileReference?: string | null | undefined;
  /**
   * Optional include. If a QR code was requested during payment creation for a QR-compatible payment method,
   *
   * @remarks
   * the QR code details will be available in this object.
   *
   * The QR code can be scanned by the customer to complete the payment on their mobile device. For example,
   * Bancontact QR payments can be completed by the customer using the Bancontact app.
   */
  qrCode?: ListCustomerPaymentsQrCode | undefined;
  /**
   * For payments with gift cards: the masked gift card number of the first gift card applied to the payment.
   */
  voucherNumber?: string | undefined;
  /**
   * An array of detail objects for each gift card that was used on this payment, if any.
   */
  giftcards?: Array<{ [k: string]: any }> | undefined;
  /**
   * For payments with vouchers: the brand name of the first voucher applied.
   */
  issuer?: string | undefined;
  /**
   * An array of detail objects for each voucher that was used on this payment, if any.
   */
  vouchers?: Array<{ [k: string]: any }> | undefined;
  /**
   * An amount object for the amount that remained after all gift cards or vouchers were applied.
   */
  remainderAmount?: ListCustomerPaymentsRemainderAmount | undefined;
  /**
   * The payment method used to pay the remainder amount, after all gift cards or vouchers were applied.
   */
  remainderMethod?: string | undefined;
  /**
   * Optional include. The full payment method details of the remainder payment.
   */
  remainderDetails?: { [k: string]: any } | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsPaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type ListCustomerPaymentsCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type ListCustomerPaymentsMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type ListCustomerPaymentsChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type ListCustomerPaymentsDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type ListCustomerPaymentsRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type ListCustomerPaymentsChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type ListCustomerPaymentsCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type ListCustomerPaymentsSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type ListCustomerPaymentsCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type ListCustomerPaymentsMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type ListCustomerPaymentsSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type ListCustomerPaymentsOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type ListCustomerPaymentsTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
 *
 * @remarks
 * successful).
 */
export type ListCustomerPaymentsLinksStatus = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
 *
 * @remarks
 * bank transfer.
 */
export type ListCustomerPaymentsPayOnline = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsPaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: ListCustomerPaymentsPaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: ListCustomerPaymentsCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: ListCustomerPaymentsMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: ListCustomerPaymentsChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: ListCustomerPaymentsDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: ListCustomerPaymentsRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: ListCustomerPaymentsChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: ListCustomerPaymentsCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: ListCustomerPaymentsSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: ListCustomerPaymentsCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: ListCustomerPaymentsMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: ListCustomerPaymentsSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: ListCustomerPaymentsOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: ListCustomerPaymentsTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: ListCustomerPaymentsPaymentDocumentation | undefined;
  /**
   * Link to customer-facing page showing the status of the bank transfer (to verify if the transaction was
   *
   * @remarks
   * successful).
   */
  status?: ListCustomerPaymentsLinksStatus | undefined;
  /**
   * Link to Mollie Checkout page allowing customers to select a different payment method instead of legacy
   *
   * @remarks
   * bank transfer.
   */
  payOnline?: ListCustomerPaymentsPayOnline | undefined;
};

export type ListCustomerPaymentsPaymentOutput = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: ListCustomerPaymentsMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: ListCustomerPaymentsAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: ListCustomerPaymentsAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: ListCustomerPaymentsAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: ListCustomerPaymentsAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: ListCustomerPaymentsAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: ListCustomerPaymentsSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<ListCustomerPaymentsLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: ListCustomerPaymentsBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: ListCustomerPaymentsShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: ListCustomerPaymentsLocale | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: ListCustomerPaymentsMethod | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: ListCustomerPaymentsCaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: ListCustomerPaymentsApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<ListCustomerPaymentsRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType: ListCustomerPaymentsSequenceType | null;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: ListCustomerPaymentsStatusEnum;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: ListCustomerPaymentsStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: ListCustomerPaymentsDetails | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: ListCustomerPaymentsPaymentLinks;
};

export type ListCustomerPaymentsEmbedded = {
  /**
   * An array of payment objects.
   */
  payments?: Array<ListCustomerPaymentsPaymentOutput> | undefined;
};

/**
 * The URL to the current set of items.
 */
export type ListCustomerPaymentsSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The previous set of items, if available.
 */
export type ListCustomerPaymentsPrevious = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * The next set of items, if available.
 */
export type ListCustomerPaymentsNext = {
  /**
   * The actual URL string.
   */
  href?: string | undefined;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type?: string | undefined;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type ListCustomerPaymentsDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
 */
export type ListCustomerPaymentsLinks = {
  /**
   * The URL to the current set of items.
   */
  self: ListCustomerPaymentsSelf;
  /**
   * The previous set of items, if available.
   */
  previous: ListCustomerPaymentsPrevious | null;
  /**
   * The next set of items, if available.
   */
  next: ListCustomerPaymentsNext | null;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation: ListCustomerPaymentsDocumentation;
};

/**
 * A list of payment objects.
 */
export type ListCustomerPaymentsResponse = {
  /**
   * The number of items in this result set. If more items are available, a `_links.next` URL will be present in the result
   *
   * @remarks
   * as well.
   *
   * The maximum number of items per result set is controlled by the `limit` property provided in the request. The default
   * limit is 50 items.
   */
  count: number;
  embedded: ListCustomerPaymentsEmbedded;
  /**
   * Links to help navigate through the lists of items. Every URL object will contain an `href` and a `type` field.
   */
  links: ListCustomerPaymentsLinks;
};

/** @internal */
export const ListCustomerPaymentsSort$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsSort
> = z.nativeEnum(ListCustomerPaymentsSort);

/** @internal */
export const ListCustomerPaymentsSort$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsSort
> = ListCustomerPaymentsSort$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSort$ {
  /** @deprecated use `ListCustomerPaymentsSort$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSort$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSort$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSort$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsRequest$inboundSchema: z.ZodType<
  ListCustomerPaymentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListCustomerPaymentsSort$inboundSchema).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type ListCustomerPaymentsRequest$Outbound = {
  customerId: string;
  from?: string | undefined;
  limit?: number | null | undefined;
  sort?: string | null | undefined;
  profileId?: string | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const ListCustomerPaymentsRequest$outboundSchema: z.ZodType<
  ListCustomerPaymentsRequest$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRequest
> = z.object({
  customerId: z.string(),
  from: z.string().optional(),
  limit: z.nullable(z.number().int()).optional(),
  sort: z.nullable(ListCustomerPaymentsSort$outboundSchema).optional(),
  profileId: z.string().optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRequest$ {
  /** @deprecated use `ListCustomerPaymentsRequest$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRequest$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRequest$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRequest$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRequest$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRequest$Outbound;
}

export function listCustomerPaymentsRequestToJSON(
  listCustomerPaymentsRequest: ListCustomerPaymentsRequest,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRequest$outboundSchema.parse(
      listCustomerPaymentsRequest,
    ),
  );
}

export function listCustomerPaymentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRequest' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBadRequestDocumentation$inboundSchema:
  z.ZodType<
    ListCustomerPaymentsBadRequestDocumentation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/** @internal */
export type ListCustomerPaymentsBadRequestDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsBadRequestDocumentation$outboundSchema:
  z.ZodType<
    ListCustomerPaymentsBadRequestDocumentation$Outbound,
    z.ZodTypeDef,
    ListCustomerPaymentsBadRequestDocumentation
  > = z.object({
    href: z.string(),
    type: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBadRequestDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsBadRequestDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBadRequestDocumentation$Outbound;
}

export function listCustomerPaymentsBadRequestDocumentationToJSON(
  listCustomerPaymentsBadRequestDocumentation:
    ListCustomerPaymentsBadRequestDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema.parse(
      listCustomerPaymentsBadRequestDocumentation,
    ),
  );
}

export function listCustomerPaymentsBadRequestDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsBadRequestDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBadRequestDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsBadRequestDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBadRequestLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsBadRequestLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() =>
    ListCustomerPaymentsBadRequestDocumentation$inboundSchema
  ),
});

/** @internal */
export type ListCustomerPaymentsBadRequestLinks$Outbound = {
  documentation: ListCustomerPaymentsBadRequestDocumentation$Outbound;
};

/** @internal */
export const ListCustomerPaymentsBadRequestLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsBadRequestLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsBadRequestLinks
> = z.object({
  documentation: z.lazy(() =>
    ListCustomerPaymentsBadRequestDocumentation$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBadRequestLinks$ {
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsBadRequestLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBadRequestLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBadRequestLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBadRequestLinks$Outbound;
}

export function listCustomerPaymentsBadRequestLinksToJSON(
  listCustomerPaymentsBadRequestLinks: ListCustomerPaymentsBadRequestLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBadRequestLinks$outboundSchema.parse(
      listCustomerPaymentsBadRequestLinks,
    ),
  );
}

export function listCustomerPaymentsBadRequestLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsBadRequestLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBadRequestLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsBadRequestLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsMode
> = z.nativeEnum(ListCustomerPaymentsMode);

/** @internal */
export const ListCustomerPaymentsMode$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsMode
> = ListCustomerPaymentsMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMode$ {
  /** @deprecated use `ListCustomerPaymentsMode$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMode$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMode$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMode$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmount$ {
  /** @deprecated use `ListCustomerPaymentsAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmount$Outbound;
}

export function listCustomerPaymentsAmountToJSON(
  listCustomerPaymentsAmount: ListCustomerPaymentsAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmount$outboundSchema.parse(listCustomerPaymentsAmount),
  );
}

export function listCustomerPaymentsAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountRefunded$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountRefunded$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRefunded$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountRefunded$ {
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmountRefunded$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountRefunded$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRefunded$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountRefunded$Outbound;
}

export function listCustomerPaymentsAmountRefundedToJSON(
  listCustomerPaymentsAmountRefunded: ListCustomerPaymentsAmountRefunded,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountRefunded$outboundSchema.parse(
      listCustomerPaymentsAmountRefunded,
    ),
  );
}

export function listCustomerPaymentsAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountRefunded' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountRemaining$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountRemaining$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountRemaining$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountRemaining$ {
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsAmountRemaining$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountRemaining$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountRemaining$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountRemaining$Outbound;
}

export function listCustomerPaymentsAmountRemainingToJSON(
  listCustomerPaymentsAmountRemaining: ListCustomerPaymentsAmountRemaining,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountRemaining$outboundSchema.parse(
      listCustomerPaymentsAmountRemaining,
    ),
  );
}

export function listCustomerPaymentsAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountRemaining' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountCaptured$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountCaptured$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountCaptured$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountCaptured$ {
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsAmountCaptured$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountCaptured$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountCaptured$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountCaptured$Outbound;
}

export function listCustomerPaymentsAmountCapturedToJSON(
  listCustomerPaymentsAmountCaptured: ListCustomerPaymentsAmountCaptured,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountCaptured$outboundSchema.parse(
      listCustomerPaymentsAmountCaptured,
    ),
  );
}

export function listCustomerPaymentsAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountCaptured' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsAmountChargedBack$inboundSchema: z.ZodType<
  ListCustomerPaymentsAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsAmountChargedBack$outboundSchema: z.ZodType<
  ListCustomerPaymentsAmountChargedBack$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsAmountChargedBack$ {
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsAmountChargedBack$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsAmountChargedBack$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsAmountChargedBack$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsAmountChargedBack$Outbound;
}

export function listCustomerPaymentsAmountChargedBackToJSON(
  listCustomerPaymentsAmountChargedBack: ListCustomerPaymentsAmountChargedBack,
): string {
  return JSON.stringify(
    ListCustomerPaymentsAmountChargedBack$outboundSchema.parse(
      listCustomerPaymentsAmountChargedBack,
    ),
  );
}

export function listCustomerPaymentsAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSettlementAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsSettlementAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsSettlementAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSettlementAmount$ {
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsSettlementAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsSettlementAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlementAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSettlementAmount$Outbound;
}

export function listCustomerPaymentsSettlementAmountToJSON(
  listCustomerPaymentsSettlementAmount: ListCustomerPaymentsSettlementAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSettlementAmount$outboundSchema.parse(
      listCustomerPaymentsSettlementAmount,
    ),
  );
}

export function listCustomerPaymentsSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSettlementAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLineType$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsLineType
> = z.nativeEnum(ListCustomerPaymentsLineType);

/** @internal */
export const ListCustomerPaymentsLineType$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsLineType
> = ListCustomerPaymentsLineType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLineType$ {
  /** @deprecated use `ListCustomerPaymentsLineType$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLineType$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLineType$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLineType$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsUnitPrice$inboundSchema: z.ZodType<
  ListCustomerPaymentsUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsUnitPrice$outboundSchema: z.ZodType<
  ListCustomerPaymentsUnitPrice$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsUnitPrice$ {
  /** @deprecated use `ListCustomerPaymentsUnitPrice$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsUnitPrice$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsUnitPrice$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsUnitPrice$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsUnitPrice$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsUnitPrice$Outbound;
}

export function listCustomerPaymentsUnitPriceToJSON(
  listCustomerPaymentsUnitPrice: ListCustomerPaymentsUnitPrice,
): string {
  return JSON.stringify(
    ListCustomerPaymentsUnitPrice$outboundSchema.parse(
      listCustomerPaymentsUnitPrice,
    ),
  );
}

export function listCustomerPaymentsUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsUnitPrice' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDiscountAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsDiscountAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsDiscountAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDiscountAmount$ {
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDiscountAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsDiscountAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDiscountAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDiscountAmount$Outbound;
}

export function listCustomerPaymentsDiscountAmountToJSON(
  listCustomerPaymentsDiscountAmount: ListCustomerPaymentsDiscountAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDiscountAmount$outboundSchema.parse(
      listCustomerPaymentsDiscountAmount,
    ),
  );
}

export function listCustomerPaymentsDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDiscountAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsTotalAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsTotalAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsTotalAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsTotalAmount$ {
  /** @deprecated use `ListCustomerPaymentsTotalAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsTotalAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsTotalAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsTotalAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsTotalAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsTotalAmount$Outbound;
}

export function listCustomerPaymentsTotalAmountToJSON(
  listCustomerPaymentsTotalAmount: ListCustomerPaymentsTotalAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsTotalAmount$outboundSchema.parse(
      listCustomerPaymentsTotalAmount,
    ),
  );
}

export function listCustomerPaymentsTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsTotalAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsVatAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsVatAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsVatAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsVatAmount$ {
  /** @deprecated use `ListCustomerPaymentsVatAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsVatAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsVatAmount$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsVatAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsVatAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsVatAmount$Outbound;
}

export function listCustomerPaymentsVatAmountToJSON(
  listCustomerPaymentsVatAmount: ListCustomerPaymentsVatAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsVatAmount$outboundSchema.parse(
      listCustomerPaymentsVatAmount,
    ),
  );
}

export function listCustomerPaymentsVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsVatAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCategory$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCategory
> = z.nativeEnum(ListCustomerPaymentsCategory);

/** @internal */
export const ListCustomerPaymentsCategory$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCategory
> = ListCustomerPaymentsCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCategory$ {
  /** @deprecated use `ListCustomerPaymentsCategory$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCategory$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCategory$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCategory$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsRecurringAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsRecurringAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsRecurringAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRecurringAmount$ {
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsRecurringAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRecurringAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurringAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRecurringAmount$Outbound;
}

export function listCustomerPaymentsRecurringAmountToJSON(
  listCustomerPaymentsRecurringAmount: ListCustomerPaymentsRecurringAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRecurringAmount$outboundSchema.parse(
      listCustomerPaymentsRecurringAmount,
    ),
  );
}

export function listCustomerPaymentsRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRecurringAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsRecurringAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRecurringAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRecurring$inboundSchema: z.ZodType<
  ListCustomerPaymentsRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRecurringAmount$inboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListCustomerPaymentsRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: ListCustomerPaymentsRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const ListCustomerPaymentsRecurring$outboundSchema: z.ZodType<
  ListCustomerPaymentsRecurring$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRecurring
> = z.object({
  description: z.string().optional(),
  interval: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsRecurringAmount$outboundSchema)
    .optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRecurring$ {
  /** @deprecated use `ListCustomerPaymentsRecurring$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRecurring$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurring$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRecurring$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRecurring$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRecurring$Outbound;
}

export function listCustomerPaymentsRecurringToJSON(
  listCustomerPaymentsRecurring: ListCustomerPaymentsRecurring,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRecurring$outboundSchema.parse(
      listCustomerPaymentsRecurring,
    ),
  );
}

export function listCustomerPaymentsRecurringFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRecurring' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLine$inboundSchema: z.ZodType<
  ListCustomerPaymentsLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListCustomerPaymentsLineType$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListCustomerPaymentsUnitPrice$inboundSchema),
  discountAmount: z.lazy(() => ListCustomerPaymentsDiscountAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => ListCustomerPaymentsTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListCustomerPaymentsVatAmount$inboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListCustomerPaymentsCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListCustomerPaymentsRecurring$inboundSchema)
    .optional(),
});

/** @internal */
export type ListCustomerPaymentsLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: ListCustomerPaymentsUnitPrice$Outbound;
  discountAmount?: ListCustomerPaymentsDiscountAmount$Outbound | undefined;
  totalAmount: ListCustomerPaymentsTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: ListCustomerPaymentsVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: ListCustomerPaymentsRecurring$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsLine$outboundSchema: z.ZodType<
  ListCustomerPaymentsLine$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsLine
> = z.object({
  type: ListCustomerPaymentsLineType$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => ListCustomerPaymentsUnitPrice$outboundSchema),
  discountAmount: z.lazy(() =>
    ListCustomerPaymentsDiscountAmount$outboundSchema
  ).optional(),
  totalAmount: z.lazy(() => ListCustomerPaymentsTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => ListCustomerPaymentsVatAmount$outboundSchema)
    .optional(),
  sku: z.string().optional(),
  categories: z.array(ListCustomerPaymentsCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => ListCustomerPaymentsRecurring$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLine$ {
  /** @deprecated use `ListCustomerPaymentsLine$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLine$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLine$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLine$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsLine$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsLine$Outbound;
}

export function listCustomerPaymentsLineToJSON(
  listCustomerPaymentsLine: ListCustomerPaymentsLine,
): string {
  return JSON.stringify(
    ListCustomerPaymentsLine$outboundSchema.parse(listCustomerPaymentsLine),
  );
}

export function listCustomerPaymentsLineFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsLine' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsBillingAddress$inboundSchema: z.ZodType<
  ListCustomerPaymentsBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsBillingAddress$outboundSchema: z.ZodType<
  ListCustomerPaymentsBillingAddress$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsBillingAddress$ {
  /** @deprecated use `ListCustomerPaymentsBillingAddress$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsBillingAddress$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsBillingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsBillingAddress$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsBillingAddress$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsBillingAddress$Outbound;
}

export function listCustomerPaymentsBillingAddressToJSON(
  listCustomerPaymentsBillingAddress: ListCustomerPaymentsBillingAddress,
): string {
  return JSON.stringify(
    ListCustomerPaymentsBillingAddress$outboundSchema.parse(
      listCustomerPaymentsBillingAddress,
    ),
  );
}

export function listCustomerPaymentsBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsBillingAddress' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsShippingAddress$inboundSchema: z.ZodType<
  ListCustomerPaymentsShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsShippingAddress$outboundSchema: z.ZodType<
  ListCustomerPaymentsShippingAddress$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsShippingAddress$ {
  /** @deprecated use `ListCustomerPaymentsShippingAddress$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsShippingAddress$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsShippingAddress$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsShippingAddress$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsShippingAddress$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsShippingAddress$Outbound;
}

export function listCustomerPaymentsShippingAddressToJSON(
  listCustomerPaymentsShippingAddress: ListCustomerPaymentsShippingAddress,
): string {
  return JSON.stringify(
    ListCustomerPaymentsShippingAddress$outboundSchema.parse(
      listCustomerPaymentsShippingAddress,
    ),
  );
}

export function listCustomerPaymentsShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsShippingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsShippingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsShippingAddress' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLocale$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsLocale
> = z.nativeEnum(ListCustomerPaymentsLocale);

/** @internal */
export const ListCustomerPaymentsLocale$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsLocale
> = ListCustomerPaymentsLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLocale$ {
  /** @deprecated use `ListCustomerPaymentsLocale$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLocale$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLocale$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLocale$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsMethod
> = z.nativeEnum(ListCustomerPaymentsMethod);

/** @internal */
export const ListCustomerPaymentsMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsMethod
> = ListCustomerPaymentsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMethod$ {
  /** @deprecated use `ListCustomerPaymentsMethod$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMethod$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMethod$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMethod$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsMetadata$inboundSchema: z.ZodType<
  ListCustomerPaymentsMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/** @internal */
export type ListCustomerPaymentsMetadata$Outbound = string | {
  [k: string]: any;
} | Array<string>;

/** @internal */
export const ListCustomerPaymentsMetadata$outboundSchema: z.ZodType<
  ListCustomerPaymentsMetadata$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMetadata
> = z.union([z.string(), z.record(z.any()), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMetadata$ {
  /** @deprecated use `ListCustomerPaymentsMetadata$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMetadata$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadata$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMetadata$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMetadata$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMetadata$Outbound;
}

export function listCustomerPaymentsMetadataToJSON(
  listCustomerPaymentsMetadata: ListCustomerPaymentsMetadata,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMetadata$outboundSchema.parse(
      listCustomerPaymentsMetadata,
    ),
  );
}

export function listCustomerPaymentsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMetadata' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCaptureMode$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCaptureMode
> = z.nativeEnum(ListCustomerPaymentsCaptureMode);

/** @internal */
export const ListCustomerPaymentsCaptureMode$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCaptureMode
> = ListCustomerPaymentsCaptureMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCaptureMode$ {
  /** @deprecated use `ListCustomerPaymentsCaptureMode$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCaptureMode$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCaptureMode$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCaptureMode$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsApplicationFeeAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsApplicationFeeAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsApplicationFeeAmount$ {
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsApplicationFeeAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsApplicationFeeAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFeeAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsApplicationFeeAmount$Outbound;
}

export function listCustomerPaymentsApplicationFeeAmountToJSON(
  listCustomerPaymentsApplicationFeeAmount:
    ListCustomerPaymentsApplicationFeeAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsApplicationFeeAmount$outboundSchema.parse(
      listCustomerPaymentsApplicationFeeAmount,
    ),
  );
}

export function listCustomerPaymentsApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsApplicationFeeAmount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsApplicationFeeAmount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsApplicationFee$inboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => ListCustomerPaymentsApplicationFeeAmount$inboundSchema)
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsApplicationFee$Outbound = {
  amount?: ListCustomerPaymentsApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsApplicationFee$outboundSchema: z.ZodType<
  ListCustomerPaymentsApplicationFee$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsApplicationFee
> = z.object({
  amount: z.lazy(() => ListCustomerPaymentsApplicationFeeAmount$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsApplicationFee$ {
  /** @deprecated use `ListCustomerPaymentsApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsApplicationFee$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFee$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsApplicationFee$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsApplicationFee$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsApplicationFee$Outbound;
}

export function listCustomerPaymentsApplicationFeeToJSON(
  listCustomerPaymentsApplicationFee: ListCustomerPaymentsApplicationFee,
): string {
  return JSON.stringify(
    ListCustomerPaymentsApplicationFee$outboundSchema.parse(
      listCustomerPaymentsApplicationFee,
    ),
  );
}

export function listCustomerPaymentsApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsApplicationFee' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsRoutingMode
> = z.nativeEnum(ListCustomerPaymentsRoutingMode);

/** @internal */
export const ListCustomerPaymentsRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsRoutingMode
> = ListCustomerPaymentsRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingMode$ {
  /** @deprecated use `ListCustomerPaymentsRoutingMode$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingMode$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingMode$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingMode$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsRoutingAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingAmount$ {
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRoutingAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingAmount$Outbound;
}

export function listCustomerPaymentsRoutingAmountToJSON(
  listCustomerPaymentsRoutingAmount: ListCustomerPaymentsRoutingAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingAmount$outboundSchema.parse(
      listCustomerPaymentsRoutingAmount,
    ),
  );
}

export function listCustomerPaymentsRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsRoutingType
> = z.nativeEnum(ListCustomerPaymentsRoutingType);

/** @internal */
export const ListCustomerPaymentsRoutingType$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsRoutingType
> = ListCustomerPaymentsRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingType$ {
  /** @deprecated use `ListCustomerPaymentsRoutingType$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingType$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingType$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingType$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsDestination$inboundSchema: z.ZodType<
  ListCustomerPaymentsDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListCustomerPaymentsRoutingType$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const ListCustomerPaymentsDestination$outboundSchema: z.ZodType<
  ListCustomerPaymentsDestination$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDestination
> = z.object({
  type: ListCustomerPaymentsRoutingType$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDestination$ {
  /** @deprecated use `ListCustomerPaymentsDestination$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDestination$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDestination$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsDestination$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDestination$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDestination$Outbound;
}

export function listCustomerPaymentsDestinationToJSON(
  listCustomerPaymentsDestination: ListCustomerPaymentsDestination,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDestination$outboundSchema.parse(
      listCustomerPaymentsDestination,
    ),
  );
}

export function listCustomerPaymentsDestinationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDestination' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingSelf$ {
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingSelf$Outbound;
}

export function listCustomerPaymentsRoutingSelfToJSON(
  listCustomerPaymentsRoutingSelf: ListCustomerPaymentsRoutingSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingSelf$outboundSchema.parse(
      listCustomerPaymentsRoutingSelf,
    ),
  );
}

export function listCustomerPaymentsRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingPayment$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRoutingPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRoutingPayment$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingPayment$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingPayment$ {
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingPayment$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRoutingPayment$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingPayment$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingPayment$Outbound;
}

export function listCustomerPaymentsRoutingPaymentToJSON(
  listCustomerPaymentsRoutingPayment: ListCustomerPaymentsRoutingPayment,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingPayment$outboundSchema.parse(
      listCustomerPaymentsRoutingPayment,
    ),
  );
}

export function listCustomerPaymentsRoutingPaymentFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsRoutingPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingPayment' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRoutingLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsRoutingSelf$inboundSchema),
  payment: z.lazy(() => ListCustomerPaymentsRoutingPayment$inboundSchema),
});

/** @internal */
export type ListCustomerPaymentsRoutingLinks$Outbound = {
  self: ListCustomerPaymentsRoutingSelf$Outbound;
  payment: ListCustomerPaymentsRoutingPayment$Outbound;
};

/** @internal */
export const ListCustomerPaymentsRoutingLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsRoutingLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRoutingLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsRoutingSelf$outboundSchema),
  payment: z.lazy(() => ListCustomerPaymentsRoutingPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRoutingLinks$ {
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRoutingLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRoutingLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRoutingLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRoutingLinks$Outbound;
}

export function listCustomerPaymentsRoutingLinksToJSON(
  listCustomerPaymentsRoutingLinks: ListCustomerPaymentsRoutingLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRoutingLinks$outboundSchema.parse(
      listCustomerPaymentsRoutingLinks,
    ),
  );
}

export function listCustomerPaymentsRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRoutingLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRouting$inboundSchema: z.ZodType<
  ListCustomerPaymentsRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListCustomerPaymentsRoutingMode$inboundSchema,
  amount: z.lazy(() => ListCustomerPaymentsRoutingAmount$inboundSchema),
  destination: z.lazy(() => ListCustomerPaymentsDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListCustomerPaymentsRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: ListCustomerPaymentsRoutingAmount$Outbound;
  destination: ListCustomerPaymentsDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: ListCustomerPaymentsRoutingLinks$Outbound;
};

/** @internal */
export const ListCustomerPaymentsRouting$outboundSchema: z.ZodType<
  ListCustomerPaymentsRouting$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListCustomerPaymentsRoutingMode$outboundSchema,
  amount: z.lazy(() => ListCustomerPaymentsRoutingAmount$outboundSchema),
  destination: z.lazy(() => ListCustomerPaymentsDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListCustomerPaymentsRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRouting$ {
  /** @deprecated use `ListCustomerPaymentsRouting$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRouting$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRouting$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRouting$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRouting$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRouting$Outbound;
}

export function listCustomerPaymentsRoutingToJSON(
  listCustomerPaymentsRouting: ListCustomerPaymentsRouting,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRouting$outboundSchema.parse(
      listCustomerPaymentsRouting,
    ),
  );
}

export function listCustomerPaymentsRoutingFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRouting' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSequenceType$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsSequenceType
> = z.nativeEnum(ListCustomerPaymentsSequenceType);

/** @internal */
export const ListCustomerPaymentsSequenceType$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsSequenceType
> = ListCustomerPaymentsSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSequenceType$ {
  /** @deprecated use `ListCustomerPaymentsSequenceType$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSequenceType$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSequenceType$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSequenceType$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsStatusEnum$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsStatusEnum
> = z.nativeEnum(ListCustomerPaymentsStatusEnum);

/** @internal */
export const ListCustomerPaymentsStatusEnum$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsStatusEnum
> = ListCustomerPaymentsStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsStatusEnum$ {
  /** @deprecated use `ListCustomerPaymentsStatusEnum$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsStatusEnum$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsStatusEnum$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsStatusEnum$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsCode$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCode
> = z.nativeEnum(ListCustomerPaymentsCode);

/** @internal */
export const ListCustomerPaymentsCode$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCode
> = ListCustomerPaymentsCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCode$ {
  /** @deprecated use `ListCustomerPaymentsCode$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCode$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCode$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCode$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsStatusReason$inboundSchema: z.ZodType<
  ListCustomerPaymentsStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: ListCustomerPaymentsCode$inboundSchema,
  message: z.string(),
});

/** @internal */
export type ListCustomerPaymentsStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const ListCustomerPaymentsStatusReason$outboundSchema: z.ZodType<
  ListCustomerPaymentsStatusReason$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsStatusReason
> = z.object({
  code: ListCustomerPaymentsCode$outboundSchema,
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsStatusReason$ {
  /** @deprecated use `ListCustomerPaymentsStatusReason$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsStatusReason$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsStatusReason$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsStatusReason$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsStatusReason$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsStatusReason$Outbound;
}

export function listCustomerPaymentsStatusReasonToJSON(
  listCustomerPaymentsStatusReason: ListCustomerPaymentsStatusReason,
): string {
  return JSON.stringify(
    ListCustomerPaymentsStatusReason$outboundSchema.parse(
      listCustomerPaymentsStatusReason,
    ),
  );
}

export function listCustomerPaymentsStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsStatusReason' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCardAudition$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardAudition
> = z.nativeEnum(ListCustomerPaymentsCardAudition);

/** @internal */
export const ListCustomerPaymentsCardAudition$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardAudition
> = ListCustomerPaymentsCardAudition$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardAudition$ {
  /** @deprecated use `ListCustomerPaymentsCardAudition$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCardAudition$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardAudition$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCardAudition$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsCardLabel$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardLabel
> = z.nativeEnum(ListCustomerPaymentsCardLabel);

/** @internal */
export const ListCustomerPaymentsCardLabel$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardLabel
> = ListCustomerPaymentsCardLabel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardLabel$ {
  /** @deprecated use `ListCustomerPaymentsCardLabel$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCardLabel$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardLabel$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCardLabel$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsCardFunding$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardFunding
> = z.nativeEnum(ListCustomerPaymentsCardFunding);

/** @internal */
export const ListCustomerPaymentsCardFunding$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardFunding
> = ListCustomerPaymentsCardFunding$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardFunding$ {
  /** @deprecated use `ListCustomerPaymentsCardFunding$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCardFunding$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardFunding$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCardFunding$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsCardSecurity$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardSecurity
> = z.nativeEnum(ListCustomerPaymentsCardSecurity);

/** @internal */
export const ListCustomerPaymentsCardSecurity$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardSecurity
> = ListCustomerPaymentsCardSecurity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardSecurity$ {
  /** @deprecated use `ListCustomerPaymentsCardSecurity$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCardSecurity$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardSecurity$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCardSecurity$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsFeeRegion$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsFeeRegion
> = z.nativeEnum(ListCustomerPaymentsFeeRegion);

/** @internal */
export const ListCustomerPaymentsFeeRegion$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsFeeRegion
> = ListCustomerPaymentsFeeRegion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsFeeRegion$ {
  /** @deprecated use `ListCustomerPaymentsFeeRegion$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsFeeRegion$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsFeeRegion$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsFeeRegion$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsFailureReason$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsFailureReason
> = z.nativeEnum(ListCustomerPaymentsFailureReason);

/** @internal */
export const ListCustomerPaymentsFailureReason$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsFailureReason
> = ListCustomerPaymentsFailureReason$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsFailureReason$ {
  /** @deprecated use `ListCustomerPaymentsFailureReason$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsFailureReason$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsFailureReason$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsFailureReason$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsWallet$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsWallet
> = z.nativeEnum(ListCustomerPaymentsWallet);

/** @internal */
export const ListCustomerPaymentsWallet$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsWallet
> = ListCustomerPaymentsWallet$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsWallet$ {
  /** @deprecated use `ListCustomerPaymentsWallet$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsWallet$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsWallet$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsWallet$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsSellerProtection$inboundSchema:
  z.ZodNativeEnum<typeof ListCustomerPaymentsSellerProtection> = z.nativeEnum(
    ListCustomerPaymentsSellerProtection,
  );

/** @internal */
export const ListCustomerPaymentsSellerProtection$outboundSchema:
  z.ZodNativeEnum<typeof ListCustomerPaymentsSellerProtection> =
    ListCustomerPaymentsSellerProtection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSellerProtection$ {
  /** @deprecated use `ListCustomerPaymentsSellerProtection$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsSellerProtection$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSellerProtection$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsSellerProtection$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsPaypalFee$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaypalFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPaypalFee$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsPaypalFee$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaypalFee$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaypalFee
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaypalFee$ {
  /** @deprecated use `ListCustomerPaymentsPaypalFee$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaypalFee$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaypalFee$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPaypalFee$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaypalFee$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaypalFee$Outbound;
}

export function listCustomerPaymentsPaypalFeeToJSON(
  listCustomerPaymentsPaypalFee: ListCustomerPaymentsPaypalFee,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaypalFee$outboundSchema.parse(
      listCustomerPaymentsPaypalFee,
    ),
  );
}

export function listCustomerPaymentsPaypalFeeFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaypalFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaypalFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaypalFee' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCardReadMethod$inboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardReadMethod
> = z.nativeEnum(ListCustomerPaymentsCardReadMethod);

/** @internal */
export const ListCustomerPaymentsCardReadMethod$outboundSchema: z.ZodNativeEnum<
  typeof ListCustomerPaymentsCardReadMethod
> = ListCustomerPaymentsCardReadMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardReadMethod$ {
  /** @deprecated use `ListCustomerPaymentsCardReadMethod$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCardReadMethod$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardReadMethod$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsCardReadMethod$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsCardVerificationMethod$inboundSchema:
  z.ZodNativeEnum<typeof ListCustomerPaymentsCardVerificationMethod> = z
    .nativeEnum(ListCustomerPaymentsCardVerificationMethod);

/** @internal */
export const ListCustomerPaymentsCardVerificationMethod$outboundSchema:
  z.ZodNativeEnum<typeof ListCustomerPaymentsCardVerificationMethod> =
    ListCustomerPaymentsCardVerificationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCardVerificationMethod$ {
  /** @deprecated use `ListCustomerPaymentsCardVerificationMethod$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsCardVerificationMethod$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCardVerificationMethod$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsCardVerificationMethod$outboundSchema;
}

/** @internal */
export const ListCustomerPaymentsReceipt$inboundSchema: z.ZodType<
  ListCustomerPaymentsReceipt,
  z.ZodTypeDef,
  unknown
> = z.object({
  authorizationCode: z.nullable(z.string()).optional(),
  applicationIdentifier: z.nullable(z.string()).optional(),
  cardReadMethod: z.nullable(ListCustomerPaymentsCardReadMethod$inboundSchema)
    .optional(),
  cardVerificationMethod: z.nullable(
    ListCustomerPaymentsCardVerificationMethod$inboundSchema,
  ).optional(),
});

/** @internal */
export type ListCustomerPaymentsReceipt$Outbound = {
  authorizationCode?: string | null | undefined;
  applicationIdentifier?: string | null | undefined;
  cardReadMethod?: string | null | undefined;
  cardVerificationMethod?: string | null | undefined;
};

/** @internal */
export const ListCustomerPaymentsReceipt$outboundSchema: z.ZodType<
  ListCustomerPaymentsReceipt$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsReceipt
> = z.object({
  authorizationCode: z.nullable(z.string()).optional(),
  applicationIdentifier: z.nullable(z.string()).optional(),
  cardReadMethod: z.nullable(ListCustomerPaymentsCardReadMethod$outboundSchema)
    .optional(),
  cardVerificationMethod: z.nullable(
    ListCustomerPaymentsCardVerificationMethod$outboundSchema,
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsReceipt$ {
  /** @deprecated use `ListCustomerPaymentsReceipt$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsReceipt$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsReceipt$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsReceipt$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsReceipt$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsReceipt$Outbound;
}

export function listCustomerPaymentsReceiptToJSON(
  listCustomerPaymentsReceipt: ListCustomerPaymentsReceipt,
): string {
  return JSON.stringify(
    ListCustomerPaymentsReceipt$outboundSchema.parse(
      listCustomerPaymentsReceipt,
    ),
  );
}

export function listCustomerPaymentsReceiptFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsReceipt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsReceipt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsReceipt' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsQrCode$inboundSchema: z.ZodType<
  ListCustomerPaymentsQrCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  height: z.number().int().optional(),
  width: z.number().int().optional(),
  src: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsQrCode$Outbound = {
  height?: number | undefined;
  width?: number | undefined;
  src?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsQrCode$outboundSchema: z.ZodType<
  ListCustomerPaymentsQrCode$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsQrCode
> = z.object({
  height: z.number().int().optional(),
  width: z.number().int().optional(),
  src: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsQrCode$ {
  /** @deprecated use `ListCustomerPaymentsQrCode$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsQrCode$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsQrCode$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsQrCode$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsQrCode$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsQrCode$Outbound;
}

export function listCustomerPaymentsQrCodeToJSON(
  listCustomerPaymentsQrCode: ListCustomerPaymentsQrCode,
): string {
  return JSON.stringify(
    ListCustomerPaymentsQrCode$outboundSchema.parse(listCustomerPaymentsQrCode),
  );
}

export function listCustomerPaymentsQrCodeFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsQrCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsQrCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsQrCode' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRemainderAmount$inboundSchema: z.ZodType<
  ListCustomerPaymentsRemainderAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRemainderAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const ListCustomerPaymentsRemainderAmount$outboundSchema: z.ZodType<
  ListCustomerPaymentsRemainderAmount$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRemainderAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRemainderAmount$ {
  /** @deprecated use `ListCustomerPaymentsRemainderAmount$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsRemainderAmount$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRemainderAmount$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsRemainderAmount$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRemainderAmount$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRemainderAmount$Outbound;
}

export function listCustomerPaymentsRemainderAmountToJSON(
  listCustomerPaymentsRemainderAmount: ListCustomerPaymentsRemainderAmount,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRemainderAmount$outboundSchema.parse(
      listCustomerPaymentsRemainderAmount,
    ),
  );
}

export function listCustomerPaymentsRemainderAmountFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRemainderAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsRemainderAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRemainderAmount' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDetails$inboundSchema: z.ZodType<
  ListCustomerPaymentsDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(ListCustomerPaymentsCardAudition$inboundSchema)
    .optional(),
  cardLabel: z.nullable(ListCustomerPaymentsCardLabel$inboundSchema).optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(ListCustomerPaymentsCardFunding$inboundSchema)
    .optional(),
  cardSecurity: z.nullable(ListCustomerPaymentsCardSecurity$inboundSchema)
    .optional(),
  feeRegion: z.nullable(ListCustomerPaymentsFeeRegion$inboundSchema).optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(ListCustomerPaymentsFailureReason$inboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(ListCustomerPaymentsWallet$inboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    ListCustomerPaymentsSellerProtection$inboundSchema,
  ).optional(),
  paypalFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsPaypalFee$inboundSchema),
  ).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => ListCustomerPaymentsReceipt$inboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.string().transform(v => new RFCDate(v))).optional(),
  signatureDate: z.nullable(z.string().transform(v => new RFCDate(v)))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => ListCustomerPaymentsQrCode$inboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: z.lazy(() =>
    ListCustomerPaymentsRemainderAmount$inboundSchema
  ).optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
});

/** @internal */
export type ListCustomerPaymentsDetails$Outbound = {
  consumerName?: string | null | undefined;
  consumerAccount?: string | null | undefined;
  consumerBic?: string | null | undefined;
  shippingAddress?: { [k: string]: any } | null | undefined;
  cardNumber?: string | null | undefined;
  bankName?: string | undefined;
  bankAccount?: string | undefined;
  bankBic?: string | undefined;
  transferReference?: string | null | undefined;
  cardFingerprint?: string | null | undefined;
  cardHolder?: string | null | undefined;
  cardAudition?: string | null | undefined;
  cardLabel?: string | null | undefined;
  cardCountryCode?: string | null | undefined;
  cardExpiryDate?: string | null | undefined;
  cardFunding?: string | null | undefined;
  cardSecurity?: string | null | undefined;
  feeRegion?: string | null | undefined;
  cardMaskedNumber?: string | null | undefined;
  card3dsEci?: string | null | undefined;
  cardBin?: string | null | undefined;
  cardIssuer?: string | null | undefined;
  failureReason?: string | null | undefined;
  failureMessage?: string | null | undefined;
  wallet?: string | null | undefined;
  paypalReference?: string | null | undefined;
  paypalPayerId?: string | null | undefined;
  sellerProtection?: string | null | undefined;
  paypalFee?: ListCustomerPaymentsPaypalFee$Outbound | null | undefined;
  customerReference?: string | undefined;
  terminalId?: string | undefined;
  maskedNumber?: string | null | undefined;
  receipt?: ListCustomerPaymentsReceipt$Outbound | undefined;
  creditorIdentifier?: string | null | undefined;
  dueDate?: string | null | undefined;
  signatureDate?: string | null | undefined;
  bankReasonCode?: string | null | undefined;
  bankReason?: string | null | undefined;
  endToEndIdentifier?: string | null | undefined;
  mandateReference?: string | null | undefined;
  batchReference?: string | null | undefined;
  fileReference?: string | null | undefined;
  qrCode?: ListCustomerPaymentsQrCode$Outbound | undefined;
  voucherNumber?: string | undefined;
  giftcards?: Array<{ [k: string]: any }> | undefined;
  issuer?: string | undefined;
  vouchers?: Array<{ [k: string]: any }> | undefined;
  remainderAmount?: ListCustomerPaymentsRemainderAmount$Outbound | undefined;
  remainderMethod?: string | undefined;
  remainderDetails?: { [k: string]: any } | undefined;
};

/** @internal */
export const ListCustomerPaymentsDetails$outboundSchema: z.ZodType<
  ListCustomerPaymentsDetails$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDetails
> = z.object({
  consumerName: z.nullable(z.string()).optional(),
  consumerAccount: z.nullable(z.string()).optional(),
  consumerBic: z.nullable(z.string()).optional(),
  shippingAddress: z.nullable(z.record(z.any())).optional(),
  cardNumber: z.nullable(z.string()).optional(),
  bankName: z.string().optional(),
  bankAccount: z.string().optional(),
  bankBic: z.string().optional(),
  transferReference: z.nullable(z.string()).optional(),
  cardFingerprint: z.nullable(z.string()).optional(),
  cardHolder: z.nullable(z.string()).optional(),
  cardAudition: z.nullable(ListCustomerPaymentsCardAudition$outboundSchema)
    .optional(),
  cardLabel: z.nullable(ListCustomerPaymentsCardLabel$outboundSchema)
    .optional(),
  cardCountryCode: z.nullable(z.string()).optional(),
  cardExpiryDate: z.nullable(z.string()).optional(),
  cardFunding: z.nullable(ListCustomerPaymentsCardFunding$outboundSchema)
    .optional(),
  cardSecurity: z.nullable(ListCustomerPaymentsCardSecurity$outboundSchema)
    .optional(),
  feeRegion: z.nullable(ListCustomerPaymentsFeeRegion$outboundSchema)
    .optional(),
  cardMaskedNumber: z.nullable(z.string()).optional(),
  card3dsEci: z.nullable(z.string()).optional(),
  cardBin: z.nullable(z.string()).optional(),
  cardIssuer: z.nullable(z.string()).optional(),
  failureReason: z.nullable(ListCustomerPaymentsFailureReason$outboundSchema)
    .optional(),
  failureMessage: z.nullable(z.string()).optional(),
  wallet: z.nullable(ListCustomerPaymentsWallet$outboundSchema).optional(),
  paypalReference: z.nullable(z.string()).optional(),
  paypalPayerId: z.nullable(z.string()).optional(),
  sellerProtection: z.nullable(
    ListCustomerPaymentsSellerProtection$outboundSchema,
  ).optional(),
  paypalFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsPaypalFee$outboundSchema),
  ).optional(),
  customerReference: z.string().optional(),
  terminalId: z.string().optional(),
  maskedNumber: z.nullable(z.string()).optional(),
  receipt: z.lazy(() => ListCustomerPaymentsReceipt$outboundSchema).optional(),
  creditorIdentifier: z.nullable(z.string()).optional(),
  dueDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  signatureDate: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  bankReasonCode: z.nullable(z.string()).optional(),
  bankReason: z.nullable(z.string()).optional(),
  endToEndIdentifier: z.nullable(z.string()).optional(),
  mandateReference: z.nullable(z.string()).optional(),
  batchReference: z.nullable(z.string()).optional(),
  fileReference: z.nullable(z.string()).optional(),
  qrCode: z.lazy(() => ListCustomerPaymentsQrCode$outboundSchema).optional(),
  voucherNumber: z.string().optional(),
  giftcards: z.array(z.record(z.any())).optional(),
  issuer: z.string().optional(),
  vouchers: z.array(z.record(z.any())).optional(),
  remainderAmount: z.lazy(() =>
    ListCustomerPaymentsRemainderAmount$outboundSchema
  ).optional(),
  remainderMethod: z.string().optional(),
  remainderDetails: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDetails$ {
  /** @deprecated use `ListCustomerPaymentsDetails$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDetails$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDetails$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsDetails$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDetails$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDetails$Outbound;
}

export function listCustomerPaymentsDetailsToJSON(
  listCustomerPaymentsDetails: ListCustomerPaymentsDetails,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDetails$outboundSchema.parse(
      listCustomerPaymentsDetails,
    ),
  );
}

export function listCustomerPaymentsDetailsFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDetails' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsPaymentSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentSelf$ {
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPaymentSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentSelf$Outbound;
}

export function listCustomerPaymentsPaymentSelfToJSON(
  listCustomerPaymentsPaymentSelf: ListCustomerPaymentsPaymentSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentSelf$outboundSchema.parse(
      listCustomerPaymentsPaymentSelf,
    ),
  );
}

export function listCustomerPaymentsPaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCheckout$inboundSchema: z.ZodType<
  ListCustomerPaymentsCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCheckout$outboundSchema: z.ZodType<
  ListCustomerPaymentsCheckout$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCheckout$ {
  /** @deprecated use `ListCustomerPaymentsCheckout$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCheckout$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCheckout$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCheckout$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCheckout$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCheckout$Outbound;
}

export function listCustomerPaymentsCheckoutToJSON(
  listCustomerPaymentsCheckout: ListCustomerPaymentsCheckout,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCheckout$outboundSchema.parse(
      listCustomerPaymentsCheckout,
    ),
  );
}

export function listCustomerPaymentsCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCheckout' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMobileAppCheckout$inboundSchema: z.ZodType<
  ListCustomerPaymentsMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsMobileAppCheckout$outboundSchema: z.ZodType<
  ListCustomerPaymentsMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMobileAppCheckout$ {
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsMobileAppCheckout$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsMobileAppCheckout$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMobileAppCheckout$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMobileAppCheckout$Outbound;
}

export function listCustomerPaymentsMobileAppCheckoutToJSON(
  listCustomerPaymentsMobileAppCheckout: ListCustomerPaymentsMobileAppCheckout,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMobileAppCheckout$outboundSchema.parse(
      listCustomerPaymentsMobileAppCheckout,
    ),
  );
}

export function listCustomerPaymentsMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsChangePaymentState$inboundSchema: z.ZodType<
  ListCustomerPaymentsChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsChangePaymentState$outboundSchema: z.ZodType<
  ListCustomerPaymentsChangePaymentState$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsChangePaymentState$ {
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsChangePaymentState$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsChangePaymentState$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsChangePaymentState$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsChangePaymentState$Outbound;
}

export function listCustomerPaymentsChangePaymentStateToJSON(
  listCustomerPaymentsChangePaymentState:
    ListCustomerPaymentsChangePaymentState,
): string {
  return JSON.stringify(
    ListCustomerPaymentsChangePaymentState$outboundSchema.parse(
      listCustomerPaymentsChangePaymentState,
    ),
  );
}

export function listCustomerPaymentsChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsChangePaymentState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsChangePaymentState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsChangePaymentState' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDashboard$inboundSchema: z.ZodType<
  ListCustomerPaymentsDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsDashboard$outboundSchema: z.ZodType<
  ListCustomerPaymentsDashboard$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDashboard$ {
  /** @deprecated use `ListCustomerPaymentsDashboard$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDashboard$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDashboard$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsDashboard$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDashboard$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDashboard$Outbound;
}

export function listCustomerPaymentsDashboardToJSON(
  listCustomerPaymentsDashboard: ListCustomerPaymentsDashboard,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDashboard$outboundSchema.parse(
      listCustomerPaymentsDashboard,
    ),
  );
}

export function listCustomerPaymentsDashboardFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDashboard' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsRefunds$inboundSchema: z.ZodType<
  ListCustomerPaymentsRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsRefunds$outboundSchema: z.ZodType<
  ListCustomerPaymentsRefunds$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsRefunds$ {
  /** @deprecated use `ListCustomerPaymentsRefunds$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsRefunds$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsRefunds$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsRefunds$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsRefunds$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsRefunds$Outbound;
}

export function listCustomerPaymentsRefundsToJSON(
  listCustomerPaymentsRefunds: ListCustomerPaymentsRefunds,
): string {
  return JSON.stringify(
    ListCustomerPaymentsRefunds$outboundSchema.parse(
      listCustomerPaymentsRefunds,
    ),
  );
}

export function listCustomerPaymentsRefundsFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsRefunds' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsChargebacks$inboundSchema: z.ZodType<
  ListCustomerPaymentsChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsChargebacks$outboundSchema: z.ZodType<
  ListCustomerPaymentsChargebacks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsChargebacks$ {
  /** @deprecated use `ListCustomerPaymentsChargebacks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsChargebacks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsChargebacks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsChargebacks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsChargebacks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsChargebacks$Outbound;
}

export function listCustomerPaymentsChargebacksToJSON(
  listCustomerPaymentsChargebacks: ListCustomerPaymentsChargebacks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsChargebacks$outboundSchema.parse(
      listCustomerPaymentsChargebacks,
    ),
  );
}

export function listCustomerPaymentsChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsChargebacks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCaptures$inboundSchema: z.ZodType<
  ListCustomerPaymentsCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCaptures$outboundSchema: z.ZodType<
  ListCustomerPaymentsCaptures$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCaptures$ {
  /** @deprecated use `ListCustomerPaymentsCaptures$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCaptures$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCaptures$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCaptures$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCaptures$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCaptures$Outbound;
}

export function listCustomerPaymentsCapturesToJSON(
  listCustomerPaymentsCaptures: ListCustomerPaymentsCaptures,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCaptures$outboundSchema.parse(
      listCustomerPaymentsCaptures,
    ),
  );
}

export function listCustomerPaymentsCapturesFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCaptures' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSettlement$inboundSchema: z.ZodType<
  ListCustomerPaymentsSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSettlement$outboundSchema: z.ZodType<
  ListCustomerPaymentsSettlement$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSettlement$ {
  /** @deprecated use `ListCustomerPaymentsSettlement$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSettlement$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlement$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSettlement$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSettlement$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSettlement$Outbound;
}

export function listCustomerPaymentsSettlementToJSON(
  listCustomerPaymentsSettlement: ListCustomerPaymentsSettlement,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSettlement$outboundSchema.parse(
      listCustomerPaymentsSettlement,
    ),
  );
}

export function listCustomerPaymentsSettlementFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSettlement' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsCustomer$inboundSchema: z.ZodType<
  ListCustomerPaymentsCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsCustomer$outboundSchema: z.ZodType<
  ListCustomerPaymentsCustomer$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsCustomer$ {
  /** @deprecated use `ListCustomerPaymentsCustomer$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsCustomer$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsCustomer$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsCustomer$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsCustomer$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsCustomer$Outbound;
}

export function listCustomerPaymentsCustomerToJSON(
  listCustomerPaymentsCustomer: ListCustomerPaymentsCustomer,
): string {
  return JSON.stringify(
    ListCustomerPaymentsCustomer$outboundSchema.parse(
      listCustomerPaymentsCustomer,
    ),
  );
}

export function listCustomerPaymentsCustomerFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsCustomer' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsMandate$inboundSchema: z.ZodType<
  ListCustomerPaymentsMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsMandate$outboundSchema: z.ZodType<
  ListCustomerPaymentsMandate$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsMandate$ {
  /** @deprecated use `ListCustomerPaymentsMandate$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsMandate$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsMandate$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsMandate$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsMandate$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsMandate$Outbound;
}

export function listCustomerPaymentsMandateToJSON(
  listCustomerPaymentsMandate: ListCustomerPaymentsMandate,
): string {
  return JSON.stringify(
    ListCustomerPaymentsMandate$outboundSchema.parse(
      listCustomerPaymentsMandate,
    ),
  );
}

export function listCustomerPaymentsMandateFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsMandate' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSubscription$inboundSchema: z.ZodType<
  ListCustomerPaymentsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSubscription$outboundSchema: z.ZodType<
  ListCustomerPaymentsSubscription$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSubscription$ {
  /** @deprecated use `ListCustomerPaymentsSubscription$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSubscription$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSubscription$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSubscription$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSubscription$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSubscription$Outbound;
}

export function listCustomerPaymentsSubscriptionToJSON(
  listCustomerPaymentsSubscription: ListCustomerPaymentsSubscription,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSubscription$outboundSchema.parse(
      listCustomerPaymentsSubscription,
    ),
  );
}

export function listCustomerPaymentsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSubscription' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsOrder$inboundSchema: z.ZodType<
  ListCustomerPaymentsOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsOrder$outboundSchema: z.ZodType<
  ListCustomerPaymentsOrder$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsOrder$ {
  /** @deprecated use `ListCustomerPaymentsOrder$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsOrder$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsOrder$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsOrder$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsOrder$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsOrder$Outbound;
}

export function listCustomerPaymentsOrderToJSON(
  listCustomerPaymentsOrder: ListCustomerPaymentsOrder,
): string {
  return JSON.stringify(
    ListCustomerPaymentsOrder$outboundSchema.parse(listCustomerPaymentsOrder),
  );
}

export function listCustomerPaymentsOrderFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsOrder' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsTerminal$inboundSchema: z.ZodType<
  ListCustomerPaymentsTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsTerminal$outboundSchema: z.ZodType<
  ListCustomerPaymentsTerminal$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsTerminal$ {
  /** @deprecated use `ListCustomerPaymentsTerminal$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsTerminal$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsTerminal$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsTerminal$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsTerminal$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsTerminal$Outbound;
}

export function listCustomerPaymentsTerminalToJSON(
  listCustomerPaymentsTerminal: ListCustomerPaymentsTerminal,
): string {
  return JSON.stringify(
    ListCustomerPaymentsTerminal$outboundSchema.parse(
      listCustomerPaymentsTerminal,
    ),
  );
}

export function listCustomerPaymentsTerminalFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsTerminal' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentDocumentation$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsPaymentDocumentation$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema =
    ListCustomerPaymentsPaymentDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsPaymentDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentDocumentation$Outbound;
}

export function listCustomerPaymentsPaymentDocumentationToJSON(
  listCustomerPaymentsPaymentDocumentation:
    ListCustomerPaymentsPaymentDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentDocumentation$outboundSchema.parse(
      listCustomerPaymentsPaymentDocumentation,
    ),
  );
}

export function listCustomerPaymentsPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<
  ListCustomerPaymentsPaymentDocumentation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListCustomerPaymentsPaymentDocumentation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListCustomerPaymentsPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLinksStatus$inboundSchema: z.ZodType<
  ListCustomerPaymentsLinksStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsLinksStatus$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsLinksStatus$outboundSchema: z.ZodType<
  ListCustomerPaymentsLinksStatus$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsLinksStatus
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLinksStatus$ {
  /** @deprecated use `ListCustomerPaymentsLinksStatus$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLinksStatus$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinksStatus$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLinksStatus$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinksStatus$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsLinksStatus$Outbound;
}

export function listCustomerPaymentsLinksStatusToJSON(
  listCustomerPaymentsLinksStatus: ListCustomerPaymentsLinksStatus,
): string {
  return JSON.stringify(
    ListCustomerPaymentsLinksStatus$outboundSchema.parse(
      listCustomerPaymentsLinksStatus,
    ),
  );
}

export function listCustomerPaymentsLinksStatusFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsLinksStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsLinksStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsLinksStatus' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPayOnline$inboundSchema: z.ZodType<
  ListCustomerPaymentsPayOnline,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsPayOnline$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsPayOnline$outboundSchema: z.ZodType<
  ListCustomerPaymentsPayOnline$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPayOnline
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPayOnline$ {
  /** @deprecated use `ListCustomerPaymentsPayOnline$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPayOnline$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPayOnline$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPayOnline$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPayOnline$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPayOnline$Outbound;
}

export function listCustomerPaymentsPayOnlineToJSON(
  listCustomerPaymentsPayOnline: ListCustomerPaymentsPayOnline,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPayOnline$outboundSchema.parse(
      listCustomerPaymentsPayOnline,
    ),
  );
}

export function listCustomerPaymentsPayOnlineFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPayOnline, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPayOnline$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPayOnline' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsPaymentSelf$inboundSchema),
  checkout: z.lazy(() => ListCustomerPaymentsCheckout$inboundSchema).optional(),
  mobileAppCheckout: z.lazy(() =>
    ListCustomerPaymentsMobileAppCheckout$inboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListCustomerPaymentsChangePaymentState$inboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListCustomerPaymentsDashboard$inboundSchema),
  refunds: z.lazy(() => ListCustomerPaymentsRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => ListCustomerPaymentsChargebacks$inboundSchema)
    .optional(),
  captures: z.lazy(() => ListCustomerPaymentsCaptures$inboundSchema).optional(),
  settlement: z.lazy(() => ListCustomerPaymentsSettlement$inboundSchema)
    .optional(),
  customer: z.lazy(() => ListCustomerPaymentsCustomer$inboundSchema).optional(),
  mandate: z.lazy(() => ListCustomerPaymentsMandate$inboundSchema).optional(),
  subscription: z.lazy(() => ListCustomerPaymentsSubscription$inboundSchema)
    .optional(),
  order: z.lazy(() => ListCustomerPaymentsOrder$inboundSchema).optional(),
  terminal: z.lazy(() => ListCustomerPaymentsTerminal$inboundSchema).optional(),
  documentation: z.lazy(() =>
    ListCustomerPaymentsPaymentDocumentation$inboundSchema
  ).optional(),
  status: z.lazy(() => ListCustomerPaymentsLinksStatus$inboundSchema)
    .optional(),
  payOnline: z.lazy(() => ListCustomerPaymentsPayOnline$inboundSchema)
    .optional(),
});

/** @internal */
export type ListCustomerPaymentsPaymentLinks$Outbound = {
  self: ListCustomerPaymentsPaymentSelf$Outbound;
  checkout?: ListCustomerPaymentsCheckout$Outbound | undefined;
  mobileAppCheckout?:
    | ListCustomerPaymentsMobileAppCheckout$Outbound
    | undefined;
  changePaymentState?:
    | ListCustomerPaymentsChangePaymentState$Outbound
    | undefined;
  dashboard: ListCustomerPaymentsDashboard$Outbound;
  refunds?: ListCustomerPaymentsRefunds$Outbound | undefined;
  chargebacks?: ListCustomerPaymentsChargebacks$Outbound | undefined;
  captures?: ListCustomerPaymentsCaptures$Outbound | undefined;
  settlement?: ListCustomerPaymentsSettlement$Outbound | undefined;
  customer?: ListCustomerPaymentsCustomer$Outbound | undefined;
  mandate?: ListCustomerPaymentsMandate$Outbound | undefined;
  subscription?: ListCustomerPaymentsSubscription$Outbound | undefined;
  order?: ListCustomerPaymentsOrder$Outbound | undefined;
  terminal?: ListCustomerPaymentsTerminal$Outbound | undefined;
  documentation?: ListCustomerPaymentsPaymentDocumentation$Outbound | undefined;
  status?: ListCustomerPaymentsLinksStatus$Outbound | undefined;
  payOnline?: ListCustomerPaymentsPayOnline$Outbound | undefined;
};

/** @internal */
export const ListCustomerPaymentsPaymentLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsPaymentSelf$outboundSchema),
  checkout: z.lazy(() => ListCustomerPaymentsCheckout$outboundSchema)
    .optional(),
  mobileAppCheckout: z.lazy(() =>
    ListCustomerPaymentsMobileAppCheckout$outboundSchema
  ).optional(),
  changePaymentState: z.lazy(() =>
    ListCustomerPaymentsChangePaymentState$outboundSchema
  ).optional(),
  dashboard: z.lazy(() => ListCustomerPaymentsDashboard$outboundSchema),
  refunds: z.lazy(() => ListCustomerPaymentsRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => ListCustomerPaymentsChargebacks$outboundSchema)
    .optional(),
  captures: z.lazy(() => ListCustomerPaymentsCaptures$outboundSchema)
    .optional(),
  settlement: z.lazy(() => ListCustomerPaymentsSettlement$outboundSchema)
    .optional(),
  customer: z.lazy(() => ListCustomerPaymentsCustomer$outboundSchema)
    .optional(),
  mandate: z.lazy(() => ListCustomerPaymentsMandate$outboundSchema).optional(),
  subscription: z.lazy(() => ListCustomerPaymentsSubscription$outboundSchema)
    .optional(),
  order: z.lazy(() => ListCustomerPaymentsOrder$outboundSchema).optional(),
  terminal: z.lazy(() => ListCustomerPaymentsTerminal$outboundSchema)
    .optional(),
  documentation: z.lazy(() =>
    ListCustomerPaymentsPaymentDocumentation$outboundSchema
  ).optional(),
  status: z.lazy(() => ListCustomerPaymentsLinksStatus$outboundSchema)
    .optional(),
  payOnline: z.lazy(() => ListCustomerPaymentsPayOnline$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentLinks$ {
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPaymentLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentLinks$Outbound;
}

export function listCustomerPaymentsPaymentLinksToJSON(
  listCustomerPaymentsPaymentLinks: ListCustomerPaymentsPaymentLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentLinks$outboundSchema.parse(
      listCustomerPaymentsPaymentLinks,
    ),
  );
}

export function listCustomerPaymentsPaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPaymentOutput$inboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListCustomerPaymentsMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsAmount$inboundSchema),
  amountRefunded: z.lazy(() => ListCustomerPaymentsAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() =>
    ListCustomerPaymentsAmountRemaining$inboundSchema
  ).optional(),
  amountCaptured: z.lazy(() => ListCustomerPaymentsAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() =>
    ListCustomerPaymentsAmountChargedBack$inboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListCustomerPaymentsSettlementAmount$inboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsLine$inboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() => ListCustomerPaymentsBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() =>
    ListCustomerPaymentsShippingAddress$inboundSchema
  ).optional(),
  locale: z.nullable(ListCustomerPaymentsLocale$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListCustomerPaymentsMethod$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  captureMode: z.nullable(ListCustomerPaymentsCaptureMode$inboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsRouting$inboundSchema)),
  ).optional(),
  sequenceType: z.nullable(ListCustomerPaymentsSequenceType$inboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListCustomerPaymentsStatusEnum$inboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListCustomerPaymentsStatusReason$inboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => ListCustomerPaymentsDetails$inboundSchema))
    .optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => ListCustomerPaymentsPaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsPaymentOutput$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: ListCustomerPaymentsAmount$Outbound;
  amountRefunded?: ListCustomerPaymentsAmountRefunded$Outbound | undefined;
  amountRemaining?: ListCustomerPaymentsAmountRemaining$Outbound | undefined;
  amountCaptured?: ListCustomerPaymentsAmountCaptured$Outbound | undefined;
  amountChargedBack?:
    | ListCustomerPaymentsAmountChargedBack$Outbound
    | undefined;
  settlementAmount?: ListCustomerPaymentsSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<ListCustomerPaymentsLine$Outbound> | null | undefined;
  billingAddress?: ListCustomerPaymentsBillingAddress$Outbound | undefined;
  shippingAddress?: ListCustomerPaymentsShippingAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: string | { [k: string]: any } | Array<string> | null | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?:
    | ListCustomerPaymentsApplicationFee$Outbound
    | null
    | undefined;
  routing?: Array<ListCustomerPaymentsRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: ListCustomerPaymentsStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: ListCustomerPaymentsDetails$Outbound | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: ListCustomerPaymentsPaymentLinks$Outbound;
};

/** @internal */
export const ListCustomerPaymentsPaymentOutput$outboundSchema: z.ZodType<
  ListCustomerPaymentsPaymentOutput$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPaymentOutput
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: ListCustomerPaymentsMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => ListCustomerPaymentsAmount$outboundSchema),
  amountRefunded: z.lazy(() =>
    ListCustomerPaymentsAmountRefunded$outboundSchema
  ).optional(),
  amountRemaining: z.lazy(() =>
    ListCustomerPaymentsAmountRemaining$outboundSchema
  ).optional(),
  amountCaptured: z.lazy(() =>
    ListCustomerPaymentsAmountCaptured$outboundSchema
  ).optional(),
  amountChargedBack: z.lazy(() =>
    ListCustomerPaymentsAmountChargedBack$outboundSchema
  ).optional(),
  settlementAmount: z.lazy(() =>
    ListCustomerPaymentsSettlementAmount$outboundSchema
  ).optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsLine$outboundSchema)),
  ).optional(),
  billingAddress: z.lazy(() =>
    ListCustomerPaymentsBillingAddress$outboundSchema
  ).optional(),
  shippingAddress: z.lazy(() =>
    ListCustomerPaymentsShippingAddress$outboundSchema
  ).optional(),
  locale: z.nullable(ListCustomerPaymentsLocale$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(ListCustomerPaymentsMethod$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([z.string(), z.record(z.any()), z.array(z.string())]),
  ).optional(),
  captureMode: z.nullable(ListCustomerPaymentsCaptureMode$outboundSchema)
    .optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => ListCustomerPaymentsApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(
    z.array(z.lazy(() => ListCustomerPaymentsRouting$outboundSchema)),
  ).optional(),
  sequenceType: z.nullable(ListCustomerPaymentsSequenceType$outboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: ListCustomerPaymentsStatusEnum$outboundSchema,
  statusReason: z.nullable(
    z.lazy(() => ListCustomerPaymentsStatusReason$outboundSchema),
  ).optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.lazy(() => ListCustomerPaymentsDetails$outboundSchema))
    .optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => ListCustomerPaymentsPaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPaymentOutput$ {
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPaymentOutput$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsPaymentOutput$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPaymentOutput$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPaymentOutput$Outbound;
}

export function listCustomerPaymentsPaymentOutputToJSON(
  listCustomerPaymentsPaymentOutput: ListCustomerPaymentsPaymentOutput,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPaymentOutput$outboundSchema.parse(
      listCustomerPaymentsPaymentOutput,
    ),
  );
}

export function listCustomerPaymentsPaymentOutputFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPaymentOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPaymentOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPaymentOutput' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsEmbedded$inboundSchema: z.ZodType<
  ListCustomerPaymentsEmbedded,
  z.ZodTypeDef,
  unknown
> = z.object({
  payments: z.array(
    z.lazy(() => ListCustomerPaymentsPaymentOutput$inboundSchema),
  ).optional(),
});

/** @internal */
export type ListCustomerPaymentsEmbedded$Outbound = {
  payments?: Array<ListCustomerPaymentsPaymentOutput$Outbound> | undefined;
};

/** @internal */
export const ListCustomerPaymentsEmbedded$outboundSchema: z.ZodType<
  ListCustomerPaymentsEmbedded$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsEmbedded
> = z.object({
  payments: z.array(
    z.lazy(() => ListCustomerPaymentsPaymentOutput$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsEmbedded$ {
  /** @deprecated use `ListCustomerPaymentsEmbedded$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsEmbedded$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsEmbedded$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsEmbedded$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsEmbedded$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsEmbedded$Outbound;
}

export function listCustomerPaymentsEmbeddedToJSON(
  listCustomerPaymentsEmbedded: ListCustomerPaymentsEmbedded,
): string {
  return JSON.stringify(
    ListCustomerPaymentsEmbedded$outboundSchema.parse(
      listCustomerPaymentsEmbedded,
    ),
  );
}

export function listCustomerPaymentsEmbeddedFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsEmbedded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsEmbedded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsEmbedded' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsSelf$inboundSchema: z.ZodType<
  ListCustomerPaymentsSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsSelf$outboundSchema: z.ZodType<
  ListCustomerPaymentsSelf$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsSelf$ {
  /** @deprecated use `ListCustomerPaymentsSelf$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsSelf$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsSelf$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsSelf$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsSelf$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsSelf$Outbound;
}

export function listCustomerPaymentsSelfToJSON(
  listCustomerPaymentsSelf: ListCustomerPaymentsSelf,
): string {
  return JSON.stringify(
    ListCustomerPaymentsSelf$outboundSchema.parse(listCustomerPaymentsSelf),
  );
}

export function listCustomerPaymentsSelfFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsSelf' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsPrevious$inboundSchema: z.ZodType<
  ListCustomerPaymentsPrevious,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsPrevious$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsPrevious$outboundSchema: z.ZodType<
  ListCustomerPaymentsPrevious$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsPrevious
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsPrevious$ {
  /** @deprecated use `ListCustomerPaymentsPrevious$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsPrevious$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsPrevious$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsPrevious$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsPrevious$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsPrevious$Outbound;
}

export function listCustomerPaymentsPreviousToJSON(
  listCustomerPaymentsPrevious: ListCustomerPaymentsPrevious,
): string {
  return JSON.stringify(
    ListCustomerPaymentsPrevious$outboundSchema.parse(
      listCustomerPaymentsPrevious,
    ),
  );
}

export function listCustomerPaymentsPreviousFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsPrevious, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsPrevious$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsPrevious' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsNext$inboundSchema: z.ZodType<
  ListCustomerPaymentsNext,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/** @internal */
export type ListCustomerPaymentsNext$Outbound = {
  href?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ListCustomerPaymentsNext$outboundSchema: z.ZodType<
  ListCustomerPaymentsNext$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsNext
> = z.object({
  href: z.string().optional(),
  type: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsNext$ {
  /** @deprecated use `ListCustomerPaymentsNext$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsNext$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsNext$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsNext$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsNext$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsNext$Outbound;
}

export function listCustomerPaymentsNextToJSON(
  listCustomerPaymentsNext: ListCustomerPaymentsNext,
): string {
  return JSON.stringify(
    ListCustomerPaymentsNext$outboundSchema.parse(listCustomerPaymentsNext),
  );
}

export function listCustomerPaymentsNextFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsNext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsNext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsNext' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsDocumentation$inboundSchema: z.ZodType<
  ListCustomerPaymentsDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type ListCustomerPaymentsDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const ListCustomerPaymentsDocumentation$outboundSchema: z.ZodType<
  ListCustomerPaymentsDocumentation$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsDocumentation$ {
  /** @deprecated use `ListCustomerPaymentsDocumentation$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsDocumentation$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsDocumentation$outboundSchema` instead. */
  export const outboundSchema =
    ListCustomerPaymentsDocumentation$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsDocumentation$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsDocumentation$Outbound;
}

export function listCustomerPaymentsDocumentationToJSON(
  listCustomerPaymentsDocumentation: ListCustomerPaymentsDocumentation,
): string {
  return JSON.stringify(
    ListCustomerPaymentsDocumentation$outboundSchema.parse(
      listCustomerPaymentsDocumentation,
    ),
  );
}

export function listCustomerPaymentsDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsDocumentation' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsLinks$inboundSchema: z.ZodType<
  ListCustomerPaymentsLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsSelf$inboundSchema),
  previous: z.nullable(
    z.lazy(() => ListCustomerPaymentsPrevious$inboundSchema),
  ),
  next: z.nullable(z.lazy(() => ListCustomerPaymentsNext$inboundSchema)),
  documentation: z.lazy(() => ListCustomerPaymentsDocumentation$inboundSchema),
});

/** @internal */
export type ListCustomerPaymentsLinks$Outbound = {
  self: ListCustomerPaymentsSelf$Outbound;
  previous: ListCustomerPaymentsPrevious$Outbound | null;
  next: ListCustomerPaymentsNext$Outbound | null;
  documentation: ListCustomerPaymentsDocumentation$Outbound;
};

/** @internal */
export const ListCustomerPaymentsLinks$outboundSchema: z.ZodType<
  ListCustomerPaymentsLinks$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsLinks
> = z.object({
  self: z.lazy(() => ListCustomerPaymentsSelf$outboundSchema),
  previous: z.nullable(
    z.lazy(() => ListCustomerPaymentsPrevious$outboundSchema),
  ),
  next: z.nullable(z.lazy(() => ListCustomerPaymentsNext$outboundSchema)),
  documentation: z.lazy(() => ListCustomerPaymentsDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsLinks$ {
  /** @deprecated use `ListCustomerPaymentsLinks$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsLinks$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinks$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsLinks$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsLinks$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsLinks$Outbound;
}

export function listCustomerPaymentsLinksToJSON(
  listCustomerPaymentsLinks: ListCustomerPaymentsLinks,
): string {
  return JSON.stringify(
    ListCustomerPaymentsLinks$outboundSchema.parse(listCustomerPaymentsLinks),
  );
}

export function listCustomerPaymentsLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsLinks' from JSON`,
  );
}

/** @internal */
export const ListCustomerPaymentsResponse$inboundSchema: z.ZodType<
  ListCustomerPaymentsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int(),
  _embedded: z.lazy(() => ListCustomerPaymentsEmbedded$inboundSchema),
  _links: z.lazy(() => ListCustomerPaymentsLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_embedded": "embedded",
    "_links": "links",
  });
});

/** @internal */
export type ListCustomerPaymentsResponse$Outbound = {
  count: number;
  _embedded: ListCustomerPaymentsEmbedded$Outbound;
  _links: ListCustomerPaymentsLinks$Outbound;
};

/** @internal */
export const ListCustomerPaymentsResponse$outboundSchema: z.ZodType<
  ListCustomerPaymentsResponse$Outbound,
  z.ZodTypeDef,
  ListCustomerPaymentsResponse
> = z.object({
  count: z.number().int(),
  embedded: z.lazy(() => ListCustomerPaymentsEmbedded$outboundSchema),
  links: z.lazy(() => ListCustomerPaymentsLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    embedded: "_embedded",
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListCustomerPaymentsResponse$ {
  /** @deprecated use `ListCustomerPaymentsResponse$inboundSchema` instead. */
  export const inboundSchema = ListCustomerPaymentsResponse$inboundSchema;
  /** @deprecated use `ListCustomerPaymentsResponse$outboundSchema` instead. */
  export const outboundSchema = ListCustomerPaymentsResponse$outboundSchema;
  /** @deprecated use `ListCustomerPaymentsResponse$Outbound` instead. */
  export type Outbound = ListCustomerPaymentsResponse$Outbound;
}

export function listCustomerPaymentsResponseToJSON(
  listCustomerPaymentsResponse: ListCustomerPaymentsResponse,
): string {
  return JSON.stringify(
    ListCustomerPaymentsResponse$outboundSchema.parse(
      listCustomerPaymentsResponse,
    ),
  );
}

export function listCustomerPaymentsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListCustomerPaymentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCustomerPaymentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCustomerPaymentsResponse' from JSON`,
  );
}
