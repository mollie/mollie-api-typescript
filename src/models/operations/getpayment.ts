/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export const GetPaymentInclude = {
  DetailsQrCode: "details.qrCode",
  DetailsRemainderDetails: "details.remainderDetails",
} as const;
/**
 * This endpoint allows you to include additional information via the `include` query string parameter.
 */
export type GetPaymentInclude = ClosedEnum<typeof GetPaymentInclude>;

/**
 * This endpoint allows embedding related API items by appending the
 *
 * @remarks
 * following values via the `embed` query string parameter.
 */
export const GetPaymentEmbed = {
  Captures: "captures",
  Refunds: "refunds",
  Chargebacks: "chargebacks",
} as const;
/**
 * This endpoint allows embedding related API items by appending the
 *
 * @remarks
 * following values via the `embed` query string parameter.
 */
export type GetPaymentEmbed = ClosedEnum<typeof GetPaymentEmbed>;

export type GetPaymentRequest = {
  /**
   * Provide the ID of the related payment.
   */
  paymentId: string;
  /**
   * This endpoint allows you to include additional information via the `include` query string parameter.
   */
  include?: GetPaymentInclude | null | undefined;
  /**
   * This endpoint allows embedding related API items by appending the
   *
   * @remarks
   * following values via the `embed` query string parameter.
   */
  embed?: GetPaymentEmbed | null | undefined;
  /**
   * Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
   *
   * @remarks
   * parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
   * setting the `testmode` query parameter to `true`.
   *
   * Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
   */
  testmode?: boolean | null | undefined;
};

/**
 * The URL to the generic Mollie API error handling guide.
 */
export type GetPaymentNotFoundDocumentation = {
  href: string;
  type: string;
};

export type GetPaymentNotFoundLinks = {
  /**
   * The URL to the generic Mollie API error handling guide.
   */
  documentation: GetPaymentNotFoundDocumentation;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const GetPaymentMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type GetPaymentMode = ClosedEnum<typeof GetPaymentMode>;

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
 * retrieved using the Get method endpoint.
 *
 * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
 * tip amount.
 */
export type GetPaymentAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already refunded. Only available when refunds are available for this payment. For some
 *
 * @remarks
 * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
 * costs for a return shipment to the customer.
 */
export type GetPaymentAmountRefunded = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The remaining amount that can be refunded. Only available when refunds are available for this payment.
 */
export type GetPaymentAmountRemaining = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that is already captured for this payment. Only available when this payment supports captures.
 */
export type GetPaymentAmountCaptured = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount that was charged back for this payment. Only available when the total charged back amount is not
 *
 * @remarks
 * zero.
 */
export type GetPaymentAmountChargedBack = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * This optional field will contain the approximate amount that will be settled to your account, converted to the
 *
 * @remarks
 * currency your account is settled in.
 *
 * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
 * settled by Mollie the `settlementAmount` is omitted from the response.
 *
 * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
 * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
 */
export type GetPaymentSettlementAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export const GetPaymentLineType = {
  Physical: "physical",
  Digital: "digital",
  ShippingFee: "shipping_fee",
  Discount: "discount",
  StoreCredit: "store_credit",
  GiftCard: "gift_card",
  Surcharge: "surcharge",
  Tip: "tip",
} as const;
/**
 * The type of product purchased. For example, a physical or a digital product.
 *
 * @remarks
 *
 * The `tip` payment line type is not available when creating a payment.
 */
export type GetPaymentLineType = ClosedEnum<typeof GetPaymentLineType>;

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type GetPaymentUnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
 *
 * @remarks
 * type.
 */
export type GetPaymentDiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type GetPaymentTotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
 *
 * @remarks
 * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
 * `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type GetPaymentVatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export const GetPaymentCategory = {
  Meal: "meal",
  Eco: "eco",
  Gift: "gift",
  SportCulture: "sport_culture",
} as const;
export type GetPaymentCategory = ClosedEnum<typeof GetPaymentCategory>;

/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export const GetPaymentInterval = {
  DotDotDotMonths: "... months",
  DotDotDotWeeks: "... weeks",
  DotDotDotDays: "... days",
} as const;
/**
 * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
 */
export type GetPaymentInterval = ClosedEnum<typeof GetPaymentInterval>;

/**
 * Total amount and currency of the recurring item.
 */
export type GetPaymentRecurringAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
 *
 * @remarks
 * to inform the shopper of the details for recurring products in the payments.
 */
export type GetPaymentRecurring = {
  /**
   * A description of the recurring item. If not present, the main description of the item will be used.
   */
  description?: string | undefined;
  /**
   * Cadence unit of the recurring item. For example: `12 months`, `52 weeks` or `365 days`.
   */
  interval: GetPaymentInterval;
  /**
   * Total amount and currency of the recurring item.
   */
  amount?: GetPaymentRecurringAmount | undefined;
  /**
   * Total number of charges for the subscription to complete. Leave empty for ongoing subscription.
   */
  times?: number | undefined;
  /**
   * The start date of the subscription if it does not start right away (format `YYYY-MM-DD`)
   */
  startDate?: string | null | undefined;
};

export type GetPaymentLine = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * The `tip` payment line type is not available when creating a payment.
   */
  type?: GetPaymentLineType | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: GetPaymentUnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount
   *
   * @remarks
   * type.
   */
  discountAmount?: GetPaymentDiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: GetPaymentTotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and
   *
   * @remarks
   * not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be
   *
   * @remarks
   * calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of
   * `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: GetPaymentVatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * An array with the voucher categories, in case of a line eligible for a voucher. See the
   *
   * @remarks
   * [Integrating Vouchers](integrating-vouchers) guide for more information.
   */
  categories?: Array<GetPaymentCategory> | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
  /**
   * The details of subsequent recurring billing cycles. These parameters are used in the Mollie Checkout
   *
   * @remarks
   * to inform the shopper of the details for recurring products in the payments.
   */
  recurring?: GetPaymentRecurring | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 *
 * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
 */
export type GetPaymentBillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and
 *
 * @remarks
 * conversion.
 *
 * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
 * `country`.
 */
export type GetPaymentShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only
   *
   * @remarks
   * numbers.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  streetAndNumber?: string | undefined;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  postalCode?: string | undefined;
  /**
   * A valid e-mail address.
   *
   * @remarks
   *
   * If you provide the email address for a `banktransfer` payment, we will automatically send the instructions
   * email upon payment creation. The language of the email will follow the locale parameter of the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  /**
   * A city name.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  city?: string | undefined;
  /**
   * The top-level administrative subdivision of the country. For example: Noord-Holland.
   */
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   *
   * @remarks
   *
   * Required for payment methods `billie`, `in3`, `klarna` and `riverty`.
   */
  country?: string | undefined;
};

/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export const GetPaymentLocale = {
  EnUS: "en_US",
  EnGB: "en_GB",
  NLNL: "nl_NL",
  NlBE: "nl_BE",
  DEDE: "de_DE",
  DeAT: "de_AT",
  DeCH: "de_CH",
  FRFR: "fr_FR",
  FrBE: "fr_BE",
  ESES: "es_ES",
  CaES: "ca_ES",
  PTPT: "pt_PT",
  ITIT: "it_IT",
  NbNO: "nb_NO",
  SvSE: "sv_SE",
  FIFI: "fi_FI",
  DaDK: "da_DK",
  ISIS: "is_IS",
  HUHU: "hu_HU",
  PLPL: "pl_PL",
  LVLV: "lv_LV",
  LTLT: "lt_LT",
} as const;
/**
 * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
 *
 * @remarks
 * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
 * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
 * locale, but our hosted payment pages currently only support the specified languages.
 *
 * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
 * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
 * customer use a local bank account greatly increases the conversion and speed of payment.
 */
export type GetPaymentLocale = ClosedEnum<typeof GetPaymentLocale>;

/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export const GetPaymentMethod = {
  Alma: "alma",
  Applepay: "applepay",
  Bacs: "bacs",
  Bancomatpay: "bancomatpay",
  Bancontact: "bancontact",
  Banktransfer: "banktransfer",
  Belfius: "belfius",
  Billie: "billie",
  Bizum: "bizum",
  Blik: "blik",
  Creditcard: "creditcard",
  Directdebit: "directdebit",
  Eps: "eps",
  Giftcard: "giftcard",
  Ideal: "ideal",
  In3: "in3",
  Kbc: "kbc",
  Klarna: "klarna",
  Klarnapaylater: "klarnapaylater",
  Klarnapaynow: "klarnapaynow",
  Klarnasliceit: "klarnasliceit",
  Mbway: "mbway",
  Multibanco: "multibanco",
  Mybank: "mybank",
  Paybybank: "paybybank",
  Payconiq: "payconiq",
  Paypal: "paypal",
  Paysafecard: "paysafecard",
  Pointofsale: "pointofsale",
  Przelewy24: "przelewy24",
  Riverty: "riverty",
  Satispay: "satispay",
  Swish: "swish",
  Trustly: "trustly",
  Twint: "twint",
  Voucher: "voucher",
} as const;
/**
 * The payment method used for this transaction. If a specific method was selected during payment initialization,
 *
 * @remarks
 * this field reflects that choice.
 */
export type GetPaymentMethod = ClosedEnum<typeof GetPaymentMethod>;

export type GetPaymentMetadata = {};

/**
 * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
 *
 * @remarks
 * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
 */
export type GetPaymentMetadataUnion =
  | GetPaymentMetadata
  | string
  | Array<string>;

/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export const GetPaymentCaptureMode = {
  Automatic: "automatic",
  Manual: "manual",
} as const;
/**
 * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
 *
 * @remarks
 * and capture at a later time.
 *
 * This field needs to be set to `manual` for method `riverty`.
 */
export type GetPaymentCaptureMode = ClosedEnum<typeof GetPaymentCaptureMode>;

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
 * a €0.99 fee on a €1.00 payment.
 */
export type GetPaymentApplicationFeeAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
 *
 * @remarks
 * merchants.
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
 * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
 * to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
 * `routing` parameter.
 */
export type GetPaymentApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge
   * a €0.99 fee on a €1.00 payment.
   */
  amount?: GetPaymentApplicationFeeAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the
   *
   * @remarks
   * connected merchant.
   */
  description?: string | undefined;
};

/**
 * Whether this entity was created in live mode or in test mode.
 */
export const GetPaymentRoutingMode = {
  Live: "live",
  Test: "test",
} as const;
/**
 * Whether this entity was created in live mode or in test mode.
 */
export type GetPaymentRoutingMode = ClosedEnum<typeof GetPaymentRoutingMode>;

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type GetPaymentRoutingAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export const GetPaymentRoutingType = {
  Organization: "organization",
} as const;
/**
 * The type of destination. Currently only the destination type `organization` is supported.
 */
export type GetPaymentRoutingType = ClosedEnum<typeof GetPaymentRoutingType>;

/**
 * The destination of this portion of the payment.
 */
export type GetPaymentDestination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   */
  type: GetPaymentRoutingType;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be
   *
   * @remarks
   * routed to.
   */
  organizationId: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type GetPaymentRoutingSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [payment](get-payment) that belong to this route.
 */
export type GetPaymentPayment = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type GetPaymentRoutingLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: GetPaymentRoutingSelf;
  /**
   * The API resource URL of the [payment](get-payment) that belong to this route.
   */
  payment: GetPaymentPayment;
};

export type GetPaymentRouting = {
  /**
   * Indicates the response contains a route object. Will always contain the string `route` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this route. Mollie will always refer to the route by this ID.
   *
   * @remarks
   * Example: `rt_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: GetPaymentRoutingMode;
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount: GetPaymentRoutingAmount;
  /**
   * The destination of this portion of the payment.
   */
  destination: GetPaymentDestination;
  /**
   * The date and time when the route was created. The date is given in ISO 8601 format.
   */
  createdAt: string;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The
   *
   * @remarks
   * date must be given in `YYYY-MM-DD` format.
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: GetPaymentRoutingLinks;
};

/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export const GetPaymentSequenceType = {
  Oneoff: "oneoff",
  First: "first",
  Recurring: "recurring",
} as const;
/**
 * **Only relevant for recurring payments.**
 *
 * @remarks
 *
 * Indicate which part of a recurring sequence this payment is for.
 *
 * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
 * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
 * on their account in the future.
 *
 * If set to `recurring`, the customer's card is charged automatically.
 *
 * Defaults to `oneoff`, which is a regular non-recurring payment.
 *
 * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
 * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
 * are set up correctly for recurring payments.
 */
export type GetPaymentSequenceType = ClosedEnum<typeof GetPaymentSequenceType>;

/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export const GetPaymentStatus = {
  Open: "open",
  Pending: "pending",
  Authorized: "authorized",
  Paid: "paid",
  Canceled: "canceled",
  Expired: "expired",
  Failed: "failed",
} as const;
/**
 * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
 *
 * @remarks
 * statuses occur at what point.
 */
export type GetPaymentStatus = ClosedEnum<typeof GetPaymentStatus>;

/**
 * This object offers details about the status of a payment. Currently it is only available for point-of-sale
 *
 * @remarks
 * payments.
 *
 * You can find more information about the possible values of this object on
 * [this page](status-reasons).**
 */
export type GetPaymentStatusReason = {
  /**
   * A machine-readable code that indicates the reason for the payment's status.
   */
  code: string;
  /**
   * A description of the status reason, localized according to the payment `locale`.
   */
  message: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type GetPaymentSelf = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
 */
export type GetPaymentCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
 */
export type GetPaymentMobileAppCheckout = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * For test mode payments in certain scenarios, a hosted interface is available to help you test different
 *
 * @remarks
 * payment states.
 *
 * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
 * payments are executed without any user interaction.
 *
 * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
 * chargeback for the test payment.
 */
export type GetPaymentChangePaymentState = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * Direct link to the payment in the Mollie Dashboard.
 */
export type GetPaymentDashboard = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
 */
export type GetPaymentRefunds = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
 *
 * @remarks
 * payment.
 */
export type GetPaymentChargebacks = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
 */
export type GetPaymentCaptures = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
 *
 * @remarks
 * Not present if not yet settled.
 */
export type GetPaymentSettlement = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [customer](get-customer).
 */
export type GetPaymentCustomer = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [mandate](get-mandate).
 */
export type GetPaymentMandate = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [subscription](get-subscription).
 */
export type GetPaymentSubscription = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
 *
 * @remarks
 * order.
 */
export type GetPaymentOrder = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
 *
 * @remarks
 * point-of-sale payments.
 */
export type GetPaymentTerminal = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
 */
export type GetPaymentDocumentation = {
  /**
   * The actual URL string.
   */
  href: string;
  /**
   * The content type of the page or endpoint the URL points to.
   */
  type: string;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type GetPaymentLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: GetPaymentSelf;
  /**
   * The URL your customer should visit to make the payment. This is where you should redirect the customer to.
   */
  checkout?: GetPaymentCheckout | undefined;
  /**
   * The deeplink URL to the app of the payment method. Currently only available for `bancontact`.
   */
  mobileAppCheckout?: GetPaymentMobileAppCheckout | undefined;
  /**
   * For test mode payments in certain scenarios, a hosted interface is available to help you test different
   *
   * @remarks
   * payment states.
   *
   * Firstly, for recurring test mode payments. Recurring payments do not have a checkout URL, because these
   * payments are executed without any user interaction.
   *
   * Secondly, for paid test mode payments. The payment state screen will then allow you to create a refund or
   * chargeback for the test payment.
   */
  changePaymentState?: GetPaymentChangePaymentState | undefined;
  /**
   * Direct link to the payment in the Mollie Dashboard.
   */
  dashboard: GetPaymentDashboard;
  /**
   * The API resource URL of the [refunds](list-payment-refunds) that belong to this payment.
   */
  refunds?: GetPaymentRefunds | undefined;
  /**
   * The API resource URL of the [chargebacks](list-payment-chargebacks) that belong to this
   *
   * @remarks
   * payment.
   */
  chargebacks?: GetPaymentChargebacks | undefined;
  /**
   * The API resource URL of the [captures](list-payment-captures) that belong to this payment.
   */
  captures?: GetPaymentCaptures | undefined;
  /**
   * The API resource URL of the [settlement](get-settlement) this payment has been settled with.
   *
   * @remarks
   * Not present if not yet settled.
   */
  settlement?: GetPaymentSettlement | undefined;
  /**
   * The API resource URL of the [customer](get-customer).
   */
  customer?: GetPaymentCustomer | undefined;
  /**
   * The API resource URL of the [mandate](get-mandate).
   */
  mandate?: GetPaymentMandate | undefined;
  /**
   * The API resource URL of the [subscription](get-subscription).
   */
  subscription?: GetPaymentSubscription | undefined;
  /**
   * The API resource URL of the [order](get-order) this payment was created for. Not present if not created for an
   *
   * @remarks
   * order.
   */
  order?: GetPaymentOrder | undefined;
  /**
   * The API resource URL of the [terminal](get-terminal) this payment was created for. Only present for
   *
   * @remarks
   * point-of-sale payments.
   */
  terminal?: GetPaymentTerminal | undefined;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: GetPaymentDocumentation | undefined;
};

/**
 * The payment object.
 */
export type GetPaymentResponse = {
  /**
   * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
   */
  resource: string;
  /**
   * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
   *
   * @remarks
   * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
   */
  id: string;
  /**
   * Whether this entity was created in live mode or in test mode.
   */
  mode: GetPaymentMode;
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
   *
   * @remarks
   * We truncate the description automatically according to the limits of the used payment method. The description is
   * also visible in any exports you generate.
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
   * This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255
   * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
   * retrieved using the Get method endpoint.
   *
   * If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
   * tip amount.
   */
  amount: GetPaymentAmount;
  /**
   * The total amount that is already refunded. Only available when refunds are available for this payment. For some
   *
   * @remarks
   * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
   * costs for a return shipment to the customer.
   */
  amountRefunded?: GetPaymentAmountRefunded | undefined;
  /**
   * The remaining amount that can be refunded. Only available when refunds are available for this payment.
   */
  amountRemaining?: GetPaymentAmountRemaining | undefined;
  /**
   * The total amount that is already captured for this payment. Only available when this payment supports captures.
   */
  amountCaptured?: GetPaymentAmountCaptured | undefined;
  /**
   * The total amount that was charged back for this payment. Only available when the total charged back amount is not
   *
   * @remarks
   * zero.
   */
  amountChargedBack?: GetPaymentAmountChargedBack | undefined;
  /**
   * This optional field will contain the approximate amount that will be settled to your account, converted to the
   *
   * @remarks
   * currency your account is settled in.
   *
   * Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
   * settled by Mollie the `settlementAmount` is omitted from the response.
   *
   * Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
   * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
   */
  settlementAmount?: GetPaymentSettlementAmount | undefined;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
   * right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
   * Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl?: string | null | undefined;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
   *
   * @remarks
   * provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
   * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
   * payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
   * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
   * local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
   *
   * @remarks
   * ordered and its price.
   *
   * All lines must have the same currency as the payment.
   *
   * Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
   */
  lines?: Array<GetPaymentLine> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   *
   * Required for payment method `in3`, `klarna`, `billie` and `riverty`.
   */
  billingAddress?: GetPaymentBillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and
   *
   * @remarks
   * conversion.
   *
   * Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
   * `country`.
   */
  shippingAddress?: GetPaymentShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
   *
   * @remarks
   * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
   * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
   * locale, but our hosted payment pages currently only support the specified languages.
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to
   * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
   * customer use a local bank account greatly increases the conversion and speed of payment.
   */
  locale?: GetPaymentLocale | null | undefined;
  /**
   * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
   *
   * @remarks
   * field is omitted if the country code was not detected.
   */
  countryCode?: string | null | undefined;
  /**
   * The payment method used for this transaction. If a specific method was selected during payment initialization,
   *
   * @remarks
   * this field reflects that choice.
   */
  method?: GetPaymentMethod | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
   *
   * @remarks
   * rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: GetPaymentMetadata | string | Array<string> | null | undefined;
  /**
   * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
   *
   * @remarks
   * and capture at a later time.
   *
   * This field needs to be set to `manual` for method `riverty`.
   */
  captureMode?: GetPaymentCaptureMode | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
   * later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
   * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
   * example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `... hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
   *
   * @remarks
   * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
   */
  captureBefore?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   *
   * @remarks
   * merchants.
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
   * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
   * to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
   * `routing` parameter.
   */
  applicationFee?: GetPaymentApplicationFee | null | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected
   * merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a
   * specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
   * payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
   * parameter.
   */
  routing?: Array<GetPaymentRouting> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
   * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
   * on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
   * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
   * are set up correctly for recurring payments.
   */
  sequenceType: GetPaymentSequenceType | null;
  /**
   * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
   *
   * @remarks
   * be added to the response.
   */
  subscriptionId?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
   * the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
   *
   * @remarks
   * payments, but can also be used on regular payments to enable single-click payments.
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
   * Organization tokens, the `profileId` is required.
   *
   * For more information, see [Authentication](authentication).
   */
  profileId: string;
  /**
   * The identifier referring to the [settlement](get-settlement) this payment was settled with.
   */
  settlementId?: string | null | undefined;
  /**
   * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
   */
  orderId?: string | null | undefined;
  /**
   * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
   *
   * @remarks
   * statuses occur at what point.
   */
  status: GetPaymentStatus;
  /**
   * This object offers details about the status of a payment. Currently it is only available for point-of-sale
   *
   * @remarks
   * payments.
   *
   * You can find more information about the possible values of this object on
   * [this page](status-reasons).**
   */
  statusReason?: GetPaymentStatusReason | null | undefined;
  /**
   * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
   */
  isCancelable?: boolean | null | undefined;
  /**
   * An object containing payment details collected during the payment process. For example, details may include the
   *
   * @remarks
   * customer's card or bank details and a payment reference. For the full list of details, please refer to the
   * [method-specific parameters](extra-payment-parameters) guide.
   */
  details?: { [k: string]: any } | null | undefined;
  /**
   * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  createdAt: string;
  /**
   * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
   *
   * @remarks
   * not authorized (yet).
   */
  authorizedAt?: string | null | undefined;
  /**
   * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * completed (yet).
   */
  paidAt?: string | null | undefined;
  /**
   * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
   *
   * @remarks
   * canceled (yet).
   */
  canceledAt?: string | null | undefined;
  /**
   * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
   *
   * @remarks
   * longer expire.
   */
  expiresAt?: string | null | undefined;
  /**
   * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
   *
   * @remarks
   * expire (yet).
   */
  expiredAt?: string | null | undefined;
  /**
   * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
   *
   * @remarks
   * (yet).
   */
  failedAt?: string | null | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: GetPaymentLinks;
};

/** @internal */
export const GetPaymentInclude$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentInclude
> = z.nativeEnum(GetPaymentInclude);

/** @internal */
export const GetPaymentInclude$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentInclude
> = GetPaymentInclude$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentInclude$ {
  /** @deprecated use `GetPaymentInclude$inboundSchema` instead. */
  export const inboundSchema = GetPaymentInclude$inboundSchema;
  /** @deprecated use `GetPaymentInclude$outboundSchema` instead. */
  export const outboundSchema = GetPaymentInclude$outboundSchema;
}

/** @internal */
export const GetPaymentEmbed$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentEmbed
> = z.nativeEnum(GetPaymentEmbed);

/** @internal */
export const GetPaymentEmbed$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentEmbed
> = GetPaymentEmbed$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentEmbed$ {
  /** @deprecated use `GetPaymentEmbed$inboundSchema` instead. */
  export const inboundSchema = GetPaymentEmbed$inboundSchema;
  /** @deprecated use `GetPaymentEmbed$outboundSchema` instead. */
  export const outboundSchema = GetPaymentEmbed$outboundSchema;
}

/** @internal */
export const GetPaymentRequest$inboundSchema: z.ZodType<
  GetPaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  paymentId: z.string(),
  include: z.nullable(GetPaymentInclude$inboundSchema).optional(),
  embed: z.nullable(GetPaymentEmbed$inboundSchema).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type GetPaymentRequest$Outbound = {
  paymentId: string;
  include?: string | null | undefined;
  embed?: string | null | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const GetPaymentRequest$outboundSchema: z.ZodType<
  GetPaymentRequest$Outbound,
  z.ZodTypeDef,
  GetPaymentRequest
> = z.object({
  paymentId: z.string(),
  include: z.nullable(GetPaymentInclude$outboundSchema).optional(),
  embed: z.nullable(GetPaymentEmbed$outboundSchema).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRequest$ {
  /** @deprecated use `GetPaymentRequest$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRequest$inboundSchema;
  /** @deprecated use `GetPaymentRequest$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRequest$outboundSchema;
  /** @deprecated use `GetPaymentRequest$Outbound` instead. */
  export type Outbound = GetPaymentRequest$Outbound;
}

export function getPaymentRequestToJSON(
  getPaymentRequest: GetPaymentRequest,
): string {
  return JSON.stringify(
    GetPaymentRequest$outboundSchema.parse(getPaymentRequest),
  );
}

export function getPaymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRequest' from JSON`,
  );
}

/** @internal */
export const GetPaymentNotFoundDocumentation$inboundSchema: z.ZodType<
  GetPaymentNotFoundDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentNotFoundDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentNotFoundDocumentation$outboundSchema: z.ZodType<
  GetPaymentNotFoundDocumentation$Outbound,
  z.ZodTypeDef,
  GetPaymentNotFoundDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentNotFoundDocumentation$ {
  /** @deprecated use `GetPaymentNotFoundDocumentation$inboundSchema` instead. */
  export const inboundSchema = GetPaymentNotFoundDocumentation$inboundSchema;
  /** @deprecated use `GetPaymentNotFoundDocumentation$outboundSchema` instead. */
  export const outboundSchema = GetPaymentNotFoundDocumentation$outboundSchema;
  /** @deprecated use `GetPaymentNotFoundDocumentation$Outbound` instead. */
  export type Outbound = GetPaymentNotFoundDocumentation$Outbound;
}

export function getPaymentNotFoundDocumentationToJSON(
  getPaymentNotFoundDocumentation: GetPaymentNotFoundDocumentation,
): string {
  return JSON.stringify(
    GetPaymentNotFoundDocumentation$outboundSchema.parse(
      getPaymentNotFoundDocumentation,
    ),
  );
}

export function getPaymentNotFoundDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentNotFoundDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentNotFoundDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentNotFoundDocumentation' from JSON`,
  );
}

/** @internal */
export const GetPaymentNotFoundLinks$inboundSchema: z.ZodType<
  GetPaymentNotFoundLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  documentation: z.lazy(() => GetPaymentNotFoundDocumentation$inboundSchema),
});

/** @internal */
export type GetPaymentNotFoundLinks$Outbound = {
  documentation: GetPaymentNotFoundDocumentation$Outbound;
};

/** @internal */
export const GetPaymentNotFoundLinks$outboundSchema: z.ZodType<
  GetPaymentNotFoundLinks$Outbound,
  z.ZodTypeDef,
  GetPaymentNotFoundLinks
> = z.object({
  documentation: z.lazy(() => GetPaymentNotFoundDocumentation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentNotFoundLinks$ {
  /** @deprecated use `GetPaymentNotFoundLinks$inboundSchema` instead. */
  export const inboundSchema = GetPaymentNotFoundLinks$inboundSchema;
  /** @deprecated use `GetPaymentNotFoundLinks$outboundSchema` instead. */
  export const outboundSchema = GetPaymentNotFoundLinks$outboundSchema;
  /** @deprecated use `GetPaymentNotFoundLinks$Outbound` instead. */
  export type Outbound = GetPaymentNotFoundLinks$Outbound;
}

export function getPaymentNotFoundLinksToJSON(
  getPaymentNotFoundLinks: GetPaymentNotFoundLinks,
): string {
  return JSON.stringify(
    GetPaymentNotFoundLinks$outboundSchema.parse(getPaymentNotFoundLinks),
  );
}

export function getPaymentNotFoundLinksFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentNotFoundLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentNotFoundLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentNotFoundLinks' from JSON`,
  );
}

/** @internal */
export const GetPaymentMode$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentMode
> = z.nativeEnum(GetPaymentMode);

/** @internal */
export const GetPaymentMode$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentMode
> = GetPaymentMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMode$ {
  /** @deprecated use `GetPaymentMode$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMode$inboundSchema;
  /** @deprecated use `GetPaymentMode$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMode$outboundSchema;
}

/** @internal */
export const GetPaymentAmount$inboundSchema: z.ZodType<
  GetPaymentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentAmount$outboundSchema: z.ZodType<
  GetPaymentAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentAmount$ {
  /** @deprecated use `GetPaymentAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentAmount$inboundSchema;
  /** @deprecated use `GetPaymentAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentAmount$outboundSchema;
  /** @deprecated use `GetPaymentAmount$Outbound` instead. */
  export type Outbound = GetPaymentAmount$Outbound;
}

export function getPaymentAmountToJSON(
  getPaymentAmount: GetPaymentAmount,
): string {
  return JSON.stringify(
    GetPaymentAmount$outboundSchema.parse(getPaymentAmount),
  );
}

export function getPaymentAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentAmountRefunded$inboundSchema: z.ZodType<
  GetPaymentAmountRefunded,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentAmountRefunded$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentAmountRefunded$outboundSchema: z.ZodType<
  GetPaymentAmountRefunded$Outbound,
  z.ZodTypeDef,
  GetPaymentAmountRefunded
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentAmountRefunded$ {
  /** @deprecated use `GetPaymentAmountRefunded$inboundSchema` instead. */
  export const inboundSchema = GetPaymentAmountRefunded$inboundSchema;
  /** @deprecated use `GetPaymentAmountRefunded$outboundSchema` instead. */
  export const outboundSchema = GetPaymentAmountRefunded$outboundSchema;
  /** @deprecated use `GetPaymentAmountRefunded$Outbound` instead. */
  export type Outbound = GetPaymentAmountRefunded$Outbound;
}

export function getPaymentAmountRefundedToJSON(
  getPaymentAmountRefunded: GetPaymentAmountRefunded,
): string {
  return JSON.stringify(
    GetPaymentAmountRefunded$outboundSchema.parse(getPaymentAmountRefunded),
  );
}

export function getPaymentAmountRefundedFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentAmountRefunded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentAmountRefunded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentAmountRefunded' from JSON`,
  );
}

/** @internal */
export const GetPaymentAmountRemaining$inboundSchema: z.ZodType<
  GetPaymentAmountRemaining,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentAmountRemaining$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentAmountRemaining$outboundSchema: z.ZodType<
  GetPaymentAmountRemaining$Outbound,
  z.ZodTypeDef,
  GetPaymentAmountRemaining
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentAmountRemaining$ {
  /** @deprecated use `GetPaymentAmountRemaining$inboundSchema` instead. */
  export const inboundSchema = GetPaymentAmountRemaining$inboundSchema;
  /** @deprecated use `GetPaymentAmountRemaining$outboundSchema` instead. */
  export const outboundSchema = GetPaymentAmountRemaining$outboundSchema;
  /** @deprecated use `GetPaymentAmountRemaining$Outbound` instead. */
  export type Outbound = GetPaymentAmountRemaining$Outbound;
}

export function getPaymentAmountRemainingToJSON(
  getPaymentAmountRemaining: GetPaymentAmountRemaining,
): string {
  return JSON.stringify(
    GetPaymentAmountRemaining$outboundSchema.parse(getPaymentAmountRemaining),
  );
}

export function getPaymentAmountRemainingFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentAmountRemaining, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentAmountRemaining$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentAmountRemaining' from JSON`,
  );
}

/** @internal */
export const GetPaymentAmountCaptured$inboundSchema: z.ZodType<
  GetPaymentAmountCaptured,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentAmountCaptured$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentAmountCaptured$outboundSchema: z.ZodType<
  GetPaymentAmountCaptured$Outbound,
  z.ZodTypeDef,
  GetPaymentAmountCaptured
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentAmountCaptured$ {
  /** @deprecated use `GetPaymentAmountCaptured$inboundSchema` instead. */
  export const inboundSchema = GetPaymentAmountCaptured$inboundSchema;
  /** @deprecated use `GetPaymentAmountCaptured$outboundSchema` instead. */
  export const outboundSchema = GetPaymentAmountCaptured$outboundSchema;
  /** @deprecated use `GetPaymentAmountCaptured$Outbound` instead. */
  export type Outbound = GetPaymentAmountCaptured$Outbound;
}

export function getPaymentAmountCapturedToJSON(
  getPaymentAmountCaptured: GetPaymentAmountCaptured,
): string {
  return JSON.stringify(
    GetPaymentAmountCaptured$outboundSchema.parse(getPaymentAmountCaptured),
  );
}

export function getPaymentAmountCapturedFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentAmountCaptured, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentAmountCaptured$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentAmountCaptured' from JSON`,
  );
}

/** @internal */
export const GetPaymentAmountChargedBack$inboundSchema: z.ZodType<
  GetPaymentAmountChargedBack,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentAmountChargedBack$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentAmountChargedBack$outboundSchema: z.ZodType<
  GetPaymentAmountChargedBack$Outbound,
  z.ZodTypeDef,
  GetPaymentAmountChargedBack
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentAmountChargedBack$ {
  /** @deprecated use `GetPaymentAmountChargedBack$inboundSchema` instead. */
  export const inboundSchema = GetPaymentAmountChargedBack$inboundSchema;
  /** @deprecated use `GetPaymentAmountChargedBack$outboundSchema` instead. */
  export const outboundSchema = GetPaymentAmountChargedBack$outboundSchema;
  /** @deprecated use `GetPaymentAmountChargedBack$Outbound` instead. */
  export type Outbound = GetPaymentAmountChargedBack$Outbound;
}

export function getPaymentAmountChargedBackToJSON(
  getPaymentAmountChargedBack: GetPaymentAmountChargedBack,
): string {
  return JSON.stringify(
    GetPaymentAmountChargedBack$outboundSchema.parse(
      getPaymentAmountChargedBack,
    ),
  );
}

export function getPaymentAmountChargedBackFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentAmountChargedBack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentAmountChargedBack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentAmountChargedBack' from JSON`,
  );
}

/** @internal */
export const GetPaymentSettlementAmount$inboundSchema: z.ZodType<
  GetPaymentSettlementAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentSettlementAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentSettlementAmount$outboundSchema: z.ZodType<
  GetPaymentSettlementAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentSettlementAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentSettlementAmount$ {
  /** @deprecated use `GetPaymentSettlementAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentSettlementAmount$inboundSchema;
  /** @deprecated use `GetPaymentSettlementAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentSettlementAmount$outboundSchema;
  /** @deprecated use `GetPaymentSettlementAmount$Outbound` instead. */
  export type Outbound = GetPaymentSettlementAmount$Outbound;
}

export function getPaymentSettlementAmountToJSON(
  getPaymentSettlementAmount: GetPaymentSettlementAmount,
): string {
  return JSON.stringify(
    GetPaymentSettlementAmount$outboundSchema.parse(getPaymentSettlementAmount),
  );
}

export function getPaymentSettlementAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentSettlementAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentSettlementAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentSettlementAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentLineType$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentLineType
> = z.nativeEnum(GetPaymentLineType);

/** @internal */
export const GetPaymentLineType$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentLineType
> = GetPaymentLineType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentLineType$ {
  /** @deprecated use `GetPaymentLineType$inboundSchema` instead. */
  export const inboundSchema = GetPaymentLineType$inboundSchema;
  /** @deprecated use `GetPaymentLineType$outboundSchema` instead. */
  export const outboundSchema = GetPaymentLineType$outboundSchema;
}

/** @internal */
export const GetPaymentUnitPrice$inboundSchema: z.ZodType<
  GetPaymentUnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentUnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentUnitPrice$outboundSchema: z.ZodType<
  GetPaymentUnitPrice$Outbound,
  z.ZodTypeDef,
  GetPaymentUnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentUnitPrice$ {
  /** @deprecated use `GetPaymentUnitPrice$inboundSchema` instead. */
  export const inboundSchema = GetPaymentUnitPrice$inboundSchema;
  /** @deprecated use `GetPaymentUnitPrice$outboundSchema` instead. */
  export const outboundSchema = GetPaymentUnitPrice$outboundSchema;
  /** @deprecated use `GetPaymentUnitPrice$Outbound` instead. */
  export type Outbound = GetPaymentUnitPrice$Outbound;
}

export function getPaymentUnitPriceToJSON(
  getPaymentUnitPrice: GetPaymentUnitPrice,
): string {
  return JSON.stringify(
    GetPaymentUnitPrice$outboundSchema.parse(getPaymentUnitPrice),
  );
}

export function getPaymentUnitPriceFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentUnitPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentUnitPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentUnitPrice' from JSON`,
  );
}

/** @internal */
export const GetPaymentDiscountAmount$inboundSchema: z.ZodType<
  GetPaymentDiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentDiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentDiscountAmount$outboundSchema: z.ZodType<
  GetPaymentDiscountAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentDiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentDiscountAmount$ {
  /** @deprecated use `GetPaymentDiscountAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentDiscountAmount$inboundSchema;
  /** @deprecated use `GetPaymentDiscountAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentDiscountAmount$outboundSchema;
  /** @deprecated use `GetPaymentDiscountAmount$Outbound` instead. */
  export type Outbound = GetPaymentDiscountAmount$Outbound;
}

export function getPaymentDiscountAmountToJSON(
  getPaymentDiscountAmount: GetPaymentDiscountAmount,
): string {
  return JSON.stringify(
    GetPaymentDiscountAmount$outboundSchema.parse(getPaymentDiscountAmount),
  );
}

export function getPaymentDiscountAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentDiscountAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentDiscountAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentDiscountAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentTotalAmount$inboundSchema: z.ZodType<
  GetPaymentTotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentTotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentTotalAmount$outboundSchema: z.ZodType<
  GetPaymentTotalAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentTotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentTotalAmount$ {
  /** @deprecated use `GetPaymentTotalAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentTotalAmount$inboundSchema;
  /** @deprecated use `GetPaymentTotalAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentTotalAmount$outboundSchema;
  /** @deprecated use `GetPaymentTotalAmount$Outbound` instead. */
  export type Outbound = GetPaymentTotalAmount$Outbound;
}

export function getPaymentTotalAmountToJSON(
  getPaymentTotalAmount: GetPaymentTotalAmount,
): string {
  return JSON.stringify(
    GetPaymentTotalAmount$outboundSchema.parse(getPaymentTotalAmount),
  );
}

export function getPaymentTotalAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentTotalAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentTotalAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentTotalAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentVatAmount$inboundSchema: z.ZodType<
  GetPaymentVatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentVatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentVatAmount$outboundSchema: z.ZodType<
  GetPaymentVatAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentVatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentVatAmount$ {
  /** @deprecated use `GetPaymentVatAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentVatAmount$inboundSchema;
  /** @deprecated use `GetPaymentVatAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentVatAmount$outboundSchema;
  /** @deprecated use `GetPaymentVatAmount$Outbound` instead. */
  export type Outbound = GetPaymentVatAmount$Outbound;
}

export function getPaymentVatAmountToJSON(
  getPaymentVatAmount: GetPaymentVatAmount,
): string {
  return JSON.stringify(
    GetPaymentVatAmount$outboundSchema.parse(getPaymentVatAmount),
  );
}

export function getPaymentVatAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentVatAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentVatAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentVatAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentCategory$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentCategory
> = z.nativeEnum(GetPaymentCategory);

/** @internal */
export const GetPaymentCategory$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentCategory
> = GetPaymentCategory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentCategory$ {
  /** @deprecated use `GetPaymentCategory$inboundSchema` instead. */
  export const inboundSchema = GetPaymentCategory$inboundSchema;
  /** @deprecated use `GetPaymentCategory$outboundSchema` instead. */
  export const outboundSchema = GetPaymentCategory$outboundSchema;
}

/** @internal */
export const GetPaymentInterval$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentInterval
> = z.nativeEnum(GetPaymentInterval);

/** @internal */
export const GetPaymentInterval$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentInterval
> = GetPaymentInterval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentInterval$ {
  /** @deprecated use `GetPaymentInterval$inboundSchema` instead. */
  export const inboundSchema = GetPaymentInterval$inboundSchema;
  /** @deprecated use `GetPaymentInterval$outboundSchema` instead. */
  export const outboundSchema = GetPaymentInterval$outboundSchema;
}

/** @internal */
export const GetPaymentRecurringAmount$inboundSchema: z.ZodType<
  GetPaymentRecurringAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentRecurringAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentRecurringAmount$outboundSchema: z.ZodType<
  GetPaymentRecurringAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentRecurringAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRecurringAmount$ {
  /** @deprecated use `GetPaymentRecurringAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRecurringAmount$inboundSchema;
  /** @deprecated use `GetPaymentRecurringAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRecurringAmount$outboundSchema;
  /** @deprecated use `GetPaymentRecurringAmount$Outbound` instead. */
  export type Outbound = GetPaymentRecurringAmount$Outbound;
}

export function getPaymentRecurringAmountToJSON(
  getPaymentRecurringAmount: GetPaymentRecurringAmount,
): string {
  return JSON.stringify(
    GetPaymentRecurringAmount$outboundSchema.parse(getPaymentRecurringAmount),
  );
}

export function getPaymentRecurringAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRecurringAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRecurringAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRecurringAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentRecurring$inboundSchema: z.ZodType<
  GetPaymentRecurring,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  interval: GetPaymentInterval$inboundSchema,
  amount: z.lazy(() => GetPaymentRecurringAmount$inboundSchema).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/** @internal */
export type GetPaymentRecurring$Outbound = {
  description?: string | undefined;
  interval: string;
  amount?: GetPaymentRecurringAmount$Outbound | undefined;
  times?: number | undefined;
  startDate?: string | null | undefined;
};

/** @internal */
export const GetPaymentRecurring$outboundSchema: z.ZodType<
  GetPaymentRecurring$Outbound,
  z.ZodTypeDef,
  GetPaymentRecurring
> = z.object({
  description: z.string().optional(),
  interval: GetPaymentInterval$outboundSchema,
  amount: z.lazy(() => GetPaymentRecurringAmount$outboundSchema).optional(),
  times: z.number().int().optional(),
  startDate: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRecurring$ {
  /** @deprecated use `GetPaymentRecurring$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRecurring$inboundSchema;
  /** @deprecated use `GetPaymentRecurring$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRecurring$outboundSchema;
  /** @deprecated use `GetPaymentRecurring$Outbound` instead. */
  export type Outbound = GetPaymentRecurring$Outbound;
}

export function getPaymentRecurringToJSON(
  getPaymentRecurring: GetPaymentRecurring,
): string {
  return JSON.stringify(
    GetPaymentRecurring$outboundSchema.parse(getPaymentRecurring),
  );
}

export function getPaymentRecurringFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRecurring, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRecurring$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRecurring' from JSON`,
  );
}

/** @internal */
export const GetPaymentLine$inboundSchema: z.ZodType<
  GetPaymentLine,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetPaymentLineType$inboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => GetPaymentUnitPrice$inboundSchema),
  discountAmount: z.lazy(() => GetPaymentDiscountAmount$inboundSchema)
    .optional(),
  totalAmount: z.lazy(() => GetPaymentTotalAmount$inboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => GetPaymentVatAmount$inboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(GetPaymentCategory$inboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => GetPaymentRecurring$inboundSchema).optional(),
});

/** @internal */
export type GetPaymentLine$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: GetPaymentUnitPrice$Outbound;
  discountAmount?: GetPaymentDiscountAmount$Outbound | undefined;
  totalAmount: GetPaymentTotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: GetPaymentVatAmount$Outbound | undefined;
  sku?: string | undefined;
  categories?: Array<string> | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
  recurring?: GetPaymentRecurring$Outbound | undefined;
};

/** @internal */
export const GetPaymentLine$outboundSchema: z.ZodType<
  GetPaymentLine$Outbound,
  z.ZodTypeDef,
  GetPaymentLine
> = z.object({
  type: GetPaymentLineType$outboundSchema.optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => GetPaymentUnitPrice$outboundSchema),
  discountAmount: z.lazy(() => GetPaymentDiscountAmount$outboundSchema)
    .optional(),
  totalAmount: z.lazy(() => GetPaymentTotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => GetPaymentVatAmount$outboundSchema).optional(),
  sku: z.string().optional(),
  categories: z.array(GetPaymentCategory$outboundSchema).optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
  recurring: z.lazy(() => GetPaymentRecurring$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentLine$ {
  /** @deprecated use `GetPaymentLine$inboundSchema` instead. */
  export const inboundSchema = GetPaymentLine$inboundSchema;
  /** @deprecated use `GetPaymentLine$outboundSchema` instead. */
  export const outboundSchema = GetPaymentLine$outboundSchema;
  /** @deprecated use `GetPaymentLine$Outbound` instead. */
  export type Outbound = GetPaymentLine$Outbound;
}

export function getPaymentLineToJSON(getPaymentLine: GetPaymentLine): string {
  return JSON.stringify(GetPaymentLine$outboundSchema.parse(getPaymentLine));
}

export function getPaymentLineFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentLine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentLine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentLine' from JSON`,
  );
}

/** @internal */
export const GetPaymentBillingAddress$inboundSchema: z.ZodType<
  GetPaymentBillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type GetPaymentBillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const GetPaymentBillingAddress$outboundSchema: z.ZodType<
  GetPaymentBillingAddress$Outbound,
  z.ZodTypeDef,
  GetPaymentBillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentBillingAddress$ {
  /** @deprecated use `GetPaymentBillingAddress$inboundSchema` instead. */
  export const inboundSchema = GetPaymentBillingAddress$inboundSchema;
  /** @deprecated use `GetPaymentBillingAddress$outboundSchema` instead. */
  export const outboundSchema = GetPaymentBillingAddress$outboundSchema;
  /** @deprecated use `GetPaymentBillingAddress$Outbound` instead. */
  export type Outbound = GetPaymentBillingAddress$Outbound;
}

export function getPaymentBillingAddressToJSON(
  getPaymentBillingAddress: GetPaymentBillingAddress,
): string {
  return JSON.stringify(
    GetPaymentBillingAddress$outboundSchema.parse(getPaymentBillingAddress),
  );
}

export function getPaymentBillingAddressFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentBillingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentBillingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentBillingAddress' from JSON`,
  );
}

/** @internal */
export const GetPaymentShippingAddress$inboundSchema: z.ZodType<
  GetPaymentShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/** @internal */
export type GetPaymentShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber?: string | undefined;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const GetPaymentShippingAddress$outboundSchema: z.ZodType<
  GetPaymentShippingAddress$Outbound,
  z.ZodTypeDef,
  GetPaymentShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string().optional(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string().optional(),
  region: z.string().optional(),
  country: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentShippingAddress$ {
  /** @deprecated use `GetPaymentShippingAddress$inboundSchema` instead. */
  export const inboundSchema = GetPaymentShippingAddress$inboundSchema;
  /** @deprecated use `GetPaymentShippingAddress$outboundSchema` instead. */
  export const outboundSchema = GetPaymentShippingAddress$outboundSchema;
  /** @deprecated use `GetPaymentShippingAddress$Outbound` instead. */
  export type Outbound = GetPaymentShippingAddress$Outbound;
}

export function getPaymentShippingAddressToJSON(
  getPaymentShippingAddress: GetPaymentShippingAddress,
): string {
  return JSON.stringify(
    GetPaymentShippingAddress$outboundSchema.parse(getPaymentShippingAddress),
  );
}

export function getPaymentShippingAddressFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentShippingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentShippingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentShippingAddress' from JSON`,
  );
}

/** @internal */
export const GetPaymentLocale$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentLocale
> = z.nativeEnum(GetPaymentLocale);

/** @internal */
export const GetPaymentLocale$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentLocale
> = GetPaymentLocale$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentLocale$ {
  /** @deprecated use `GetPaymentLocale$inboundSchema` instead. */
  export const inboundSchema = GetPaymentLocale$inboundSchema;
  /** @deprecated use `GetPaymentLocale$outboundSchema` instead. */
  export const outboundSchema = GetPaymentLocale$outboundSchema;
}

/** @internal */
export const GetPaymentMethod$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentMethod
> = z.nativeEnum(GetPaymentMethod);

/** @internal */
export const GetPaymentMethod$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentMethod
> = GetPaymentMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMethod$ {
  /** @deprecated use `GetPaymentMethod$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMethod$inboundSchema;
  /** @deprecated use `GetPaymentMethod$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMethod$outboundSchema;
}

/** @internal */
export const GetPaymentMetadata$inboundSchema: z.ZodType<
  GetPaymentMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type GetPaymentMetadata$Outbound = {};

/** @internal */
export const GetPaymentMetadata$outboundSchema: z.ZodType<
  GetPaymentMetadata$Outbound,
  z.ZodTypeDef,
  GetPaymentMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMetadata$ {
  /** @deprecated use `GetPaymentMetadata$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMetadata$inboundSchema;
  /** @deprecated use `GetPaymentMetadata$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMetadata$outboundSchema;
  /** @deprecated use `GetPaymentMetadata$Outbound` instead. */
  export type Outbound = GetPaymentMetadata$Outbound;
}

export function getPaymentMetadataToJSON(
  getPaymentMetadata: GetPaymentMetadata,
): string {
  return JSON.stringify(
    GetPaymentMetadata$outboundSchema.parse(getPaymentMetadata),
  );
}

export function getPaymentMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentMetadata' from JSON`,
  );
}

/** @internal */
export const GetPaymentMetadataUnion$inboundSchema: z.ZodType<
  GetPaymentMetadataUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetPaymentMetadata$inboundSchema),
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type GetPaymentMetadataUnion$Outbound =
  | GetPaymentMetadata$Outbound
  | string
  | Array<string>;

/** @internal */
export const GetPaymentMetadataUnion$outboundSchema: z.ZodType<
  GetPaymentMetadataUnion$Outbound,
  z.ZodTypeDef,
  GetPaymentMetadataUnion
> = z.union([
  z.lazy(() => GetPaymentMetadata$outboundSchema),
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMetadataUnion$ {
  /** @deprecated use `GetPaymentMetadataUnion$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMetadataUnion$inboundSchema;
  /** @deprecated use `GetPaymentMetadataUnion$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMetadataUnion$outboundSchema;
  /** @deprecated use `GetPaymentMetadataUnion$Outbound` instead. */
  export type Outbound = GetPaymentMetadataUnion$Outbound;
}

export function getPaymentMetadataUnionToJSON(
  getPaymentMetadataUnion: GetPaymentMetadataUnion,
): string {
  return JSON.stringify(
    GetPaymentMetadataUnion$outboundSchema.parse(getPaymentMetadataUnion),
  );
}

export function getPaymentMetadataUnionFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentMetadataUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentMetadataUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentMetadataUnion' from JSON`,
  );
}

/** @internal */
export const GetPaymentCaptureMode$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentCaptureMode
> = z.nativeEnum(GetPaymentCaptureMode);

/** @internal */
export const GetPaymentCaptureMode$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentCaptureMode
> = GetPaymentCaptureMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentCaptureMode$ {
  /** @deprecated use `GetPaymentCaptureMode$inboundSchema` instead. */
  export const inboundSchema = GetPaymentCaptureMode$inboundSchema;
  /** @deprecated use `GetPaymentCaptureMode$outboundSchema` instead. */
  export const outboundSchema = GetPaymentCaptureMode$outboundSchema;
}

/** @internal */
export const GetPaymentApplicationFeeAmount$inboundSchema: z.ZodType<
  GetPaymentApplicationFeeAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentApplicationFeeAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentApplicationFeeAmount$outboundSchema: z.ZodType<
  GetPaymentApplicationFeeAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentApplicationFeeAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentApplicationFeeAmount$ {
  /** @deprecated use `GetPaymentApplicationFeeAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentApplicationFeeAmount$inboundSchema;
  /** @deprecated use `GetPaymentApplicationFeeAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentApplicationFeeAmount$outboundSchema;
  /** @deprecated use `GetPaymentApplicationFeeAmount$Outbound` instead. */
  export type Outbound = GetPaymentApplicationFeeAmount$Outbound;
}

export function getPaymentApplicationFeeAmountToJSON(
  getPaymentApplicationFeeAmount: GetPaymentApplicationFeeAmount,
): string {
  return JSON.stringify(
    GetPaymentApplicationFeeAmount$outboundSchema.parse(
      getPaymentApplicationFeeAmount,
    ),
  );
}

export function getPaymentApplicationFeeAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentApplicationFeeAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentApplicationFeeAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentApplicationFeeAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentApplicationFee$inboundSchema: z.ZodType<
  GetPaymentApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => GetPaymentApplicationFeeAmount$inboundSchema).optional(),
  description: z.string().optional(),
});

/** @internal */
export type GetPaymentApplicationFee$Outbound = {
  amount?: GetPaymentApplicationFeeAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const GetPaymentApplicationFee$outboundSchema: z.ZodType<
  GetPaymentApplicationFee$Outbound,
  z.ZodTypeDef,
  GetPaymentApplicationFee
> = z.object({
  amount: z.lazy(() => GetPaymentApplicationFeeAmount$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentApplicationFee$ {
  /** @deprecated use `GetPaymentApplicationFee$inboundSchema` instead. */
  export const inboundSchema = GetPaymentApplicationFee$inboundSchema;
  /** @deprecated use `GetPaymentApplicationFee$outboundSchema` instead. */
  export const outboundSchema = GetPaymentApplicationFee$outboundSchema;
  /** @deprecated use `GetPaymentApplicationFee$Outbound` instead. */
  export type Outbound = GetPaymentApplicationFee$Outbound;
}

export function getPaymentApplicationFeeToJSON(
  getPaymentApplicationFee: GetPaymentApplicationFee,
): string {
  return JSON.stringify(
    GetPaymentApplicationFee$outboundSchema.parse(getPaymentApplicationFee),
  );
}

export function getPaymentApplicationFeeFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentApplicationFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentApplicationFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentApplicationFee' from JSON`,
  );
}

/** @internal */
export const GetPaymentRoutingMode$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentRoutingMode
> = z.nativeEnum(GetPaymentRoutingMode);

/** @internal */
export const GetPaymentRoutingMode$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentRoutingMode
> = GetPaymentRoutingMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRoutingMode$ {
  /** @deprecated use `GetPaymentRoutingMode$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRoutingMode$inboundSchema;
  /** @deprecated use `GetPaymentRoutingMode$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRoutingMode$outboundSchema;
}

/** @internal */
export const GetPaymentRoutingAmount$inboundSchema: z.ZodType<
  GetPaymentRoutingAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type GetPaymentRoutingAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const GetPaymentRoutingAmount$outboundSchema: z.ZodType<
  GetPaymentRoutingAmount$Outbound,
  z.ZodTypeDef,
  GetPaymentRoutingAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRoutingAmount$ {
  /** @deprecated use `GetPaymentRoutingAmount$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRoutingAmount$inboundSchema;
  /** @deprecated use `GetPaymentRoutingAmount$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRoutingAmount$outboundSchema;
  /** @deprecated use `GetPaymentRoutingAmount$Outbound` instead. */
  export type Outbound = GetPaymentRoutingAmount$Outbound;
}

export function getPaymentRoutingAmountToJSON(
  getPaymentRoutingAmount: GetPaymentRoutingAmount,
): string {
  return JSON.stringify(
    GetPaymentRoutingAmount$outboundSchema.parse(getPaymentRoutingAmount),
  );
}

export function getPaymentRoutingAmountFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRoutingAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRoutingAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRoutingAmount' from JSON`,
  );
}

/** @internal */
export const GetPaymentRoutingType$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentRoutingType
> = z.nativeEnum(GetPaymentRoutingType);

/** @internal */
export const GetPaymentRoutingType$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentRoutingType
> = GetPaymentRoutingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRoutingType$ {
  /** @deprecated use `GetPaymentRoutingType$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRoutingType$inboundSchema;
  /** @deprecated use `GetPaymentRoutingType$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRoutingType$outboundSchema;
}

/** @internal */
export const GetPaymentDestination$inboundSchema: z.ZodType<
  GetPaymentDestination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetPaymentRoutingType$inboundSchema,
  organizationId: z.string(),
});

/** @internal */
export type GetPaymentDestination$Outbound = {
  type: string;
  organizationId: string;
};

/** @internal */
export const GetPaymentDestination$outboundSchema: z.ZodType<
  GetPaymentDestination$Outbound,
  z.ZodTypeDef,
  GetPaymentDestination
> = z.object({
  type: GetPaymentRoutingType$outboundSchema,
  organizationId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentDestination$ {
  /** @deprecated use `GetPaymentDestination$inboundSchema` instead. */
  export const inboundSchema = GetPaymentDestination$inboundSchema;
  /** @deprecated use `GetPaymentDestination$outboundSchema` instead. */
  export const outboundSchema = GetPaymentDestination$outboundSchema;
  /** @deprecated use `GetPaymentDestination$Outbound` instead. */
  export type Outbound = GetPaymentDestination$Outbound;
}

export function getPaymentDestinationToJSON(
  getPaymentDestination: GetPaymentDestination,
): string {
  return JSON.stringify(
    GetPaymentDestination$outboundSchema.parse(getPaymentDestination),
  );
}

export function getPaymentDestinationFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentDestination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentDestination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentDestination' from JSON`,
  );
}

/** @internal */
export const GetPaymentRoutingSelf$inboundSchema: z.ZodType<
  GetPaymentRoutingSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentRoutingSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentRoutingSelf$outboundSchema: z.ZodType<
  GetPaymentRoutingSelf$Outbound,
  z.ZodTypeDef,
  GetPaymentRoutingSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRoutingSelf$ {
  /** @deprecated use `GetPaymentRoutingSelf$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRoutingSelf$inboundSchema;
  /** @deprecated use `GetPaymentRoutingSelf$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRoutingSelf$outboundSchema;
  /** @deprecated use `GetPaymentRoutingSelf$Outbound` instead. */
  export type Outbound = GetPaymentRoutingSelf$Outbound;
}

export function getPaymentRoutingSelfToJSON(
  getPaymentRoutingSelf: GetPaymentRoutingSelf,
): string {
  return JSON.stringify(
    GetPaymentRoutingSelf$outboundSchema.parse(getPaymentRoutingSelf),
  );
}

export function getPaymentRoutingSelfFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRoutingSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRoutingSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRoutingSelf' from JSON`,
  );
}

/** @internal */
export const GetPaymentPayment$inboundSchema: z.ZodType<
  GetPaymentPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentPayment$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentPayment$outboundSchema: z.ZodType<
  GetPaymentPayment$Outbound,
  z.ZodTypeDef,
  GetPaymentPayment
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentPayment$ {
  /** @deprecated use `GetPaymentPayment$inboundSchema` instead. */
  export const inboundSchema = GetPaymentPayment$inboundSchema;
  /** @deprecated use `GetPaymentPayment$outboundSchema` instead. */
  export const outboundSchema = GetPaymentPayment$outboundSchema;
  /** @deprecated use `GetPaymentPayment$Outbound` instead. */
  export type Outbound = GetPaymentPayment$Outbound;
}

export function getPaymentPaymentToJSON(
  getPaymentPayment: GetPaymentPayment,
): string {
  return JSON.stringify(
    GetPaymentPayment$outboundSchema.parse(getPaymentPayment),
  );
}

export function getPaymentPaymentFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentPayment' from JSON`,
  );
}

/** @internal */
export const GetPaymentRoutingLinks$inboundSchema: z.ZodType<
  GetPaymentRoutingLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => GetPaymentRoutingSelf$inboundSchema),
  payment: z.lazy(() => GetPaymentPayment$inboundSchema),
});

/** @internal */
export type GetPaymentRoutingLinks$Outbound = {
  self: GetPaymentRoutingSelf$Outbound;
  payment: GetPaymentPayment$Outbound;
};

/** @internal */
export const GetPaymentRoutingLinks$outboundSchema: z.ZodType<
  GetPaymentRoutingLinks$Outbound,
  z.ZodTypeDef,
  GetPaymentRoutingLinks
> = z.object({
  self: z.lazy(() => GetPaymentRoutingSelf$outboundSchema),
  payment: z.lazy(() => GetPaymentPayment$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRoutingLinks$ {
  /** @deprecated use `GetPaymentRoutingLinks$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRoutingLinks$inboundSchema;
  /** @deprecated use `GetPaymentRoutingLinks$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRoutingLinks$outboundSchema;
  /** @deprecated use `GetPaymentRoutingLinks$Outbound` instead. */
  export type Outbound = GetPaymentRoutingLinks$Outbound;
}

export function getPaymentRoutingLinksToJSON(
  getPaymentRoutingLinks: GetPaymentRoutingLinks,
): string {
  return JSON.stringify(
    GetPaymentRoutingLinks$outboundSchema.parse(getPaymentRoutingLinks),
  );
}

export function getPaymentRoutingLinksFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRoutingLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRoutingLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRoutingLinks' from JSON`,
  );
}

/** @internal */
export const GetPaymentRouting$inboundSchema: z.ZodType<
  GetPaymentRouting,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: GetPaymentRoutingMode$inboundSchema,
  amount: z.lazy(() => GetPaymentRoutingAmount$inboundSchema),
  destination: z.lazy(() => GetPaymentDestination$inboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  _links: z.lazy(() => GetPaymentRoutingLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type GetPaymentRouting$Outbound = {
  resource: string;
  id: string;
  mode: string;
  amount: GetPaymentRoutingAmount$Outbound;
  destination: GetPaymentDestination$Outbound;
  createdAt: string;
  releaseDate?: string | null | undefined;
  _links: GetPaymentRoutingLinks$Outbound;
};

/** @internal */
export const GetPaymentRouting$outboundSchema: z.ZodType<
  GetPaymentRouting$Outbound,
  z.ZodTypeDef,
  GetPaymentRouting
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: GetPaymentRoutingMode$outboundSchema,
  amount: z.lazy(() => GetPaymentRoutingAmount$outboundSchema),
  destination: z.lazy(() => GetPaymentDestination$outboundSchema),
  createdAt: z.string(),
  releaseDate: z.nullable(z.string()).optional(),
  links: z.lazy(() => GetPaymentRoutingLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRouting$ {
  /** @deprecated use `GetPaymentRouting$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRouting$inboundSchema;
  /** @deprecated use `GetPaymentRouting$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRouting$outboundSchema;
  /** @deprecated use `GetPaymentRouting$Outbound` instead. */
  export type Outbound = GetPaymentRouting$Outbound;
}

export function getPaymentRoutingToJSON(
  getPaymentRouting: GetPaymentRouting,
): string {
  return JSON.stringify(
    GetPaymentRouting$outboundSchema.parse(getPaymentRouting),
  );
}

export function getPaymentRoutingFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRouting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRouting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRouting' from JSON`,
  );
}

/** @internal */
export const GetPaymentSequenceType$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentSequenceType
> = z.nativeEnum(GetPaymentSequenceType);

/** @internal */
export const GetPaymentSequenceType$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentSequenceType
> = GetPaymentSequenceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentSequenceType$ {
  /** @deprecated use `GetPaymentSequenceType$inboundSchema` instead. */
  export const inboundSchema = GetPaymentSequenceType$inboundSchema;
  /** @deprecated use `GetPaymentSequenceType$outboundSchema` instead. */
  export const outboundSchema = GetPaymentSequenceType$outboundSchema;
}

/** @internal */
export const GetPaymentStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetPaymentStatus
> = z.nativeEnum(GetPaymentStatus);

/** @internal */
export const GetPaymentStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetPaymentStatus
> = GetPaymentStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentStatus$ {
  /** @deprecated use `GetPaymentStatus$inboundSchema` instead. */
  export const inboundSchema = GetPaymentStatus$inboundSchema;
  /** @deprecated use `GetPaymentStatus$outboundSchema` instead. */
  export const outboundSchema = GetPaymentStatus$outboundSchema;
}

/** @internal */
export const GetPaymentStatusReason$inboundSchema: z.ZodType<
  GetPaymentStatusReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type GetPaymentStatusReason$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const GetPaymentStatusReason$outboundSchema: z.ZodType<
  GetPaymentStatusReason$Outbound,
  z.ZodTypeDef,
  GetPaymentStatusReason
> = z.object({
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentStatusReason$ {
  /** @deprecated use `GetPaymentStatusReason$inboundSchema` instead. */
  export const inboundSchema = GetPaymentStatusReason$inboundSchema;
  /** @deprecated use `GetPaymentStatusReason$outboundSchema` instead. */
  export const outboundSchema = GetPaymentStatusReason$outboundSchema;
  /** @deprecated use `GetPaymentStatusReason$Outbound` instead. */
  export type Outbound = GetPaymentStatusReason$Outbound;
}

export function getPaymentStatusReasonToJSON(
  getPaymentStatusReason: GetPaymentStatusReason,
): string {
  return JSON.stringify(
    GetPaymentStatusReason$outboundSchema.parse(getPaymentStatusReason),
  );
}

export function getPaymentStatusReasonFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentStatusReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentStatusReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentStatusReason' from JSON`,
  );
}

/** @internal */
export const GetPaymentSelf$inboundSchema: z.ZodType<
  GetPaymentSelf,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentSelf$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentSelf$outboundSchema: z.ZodType<
  GetPaymentSelf$Outbound,
  z.ZodTypeDef,
  GetPaymentSelf
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentSelf$ {
  /** @deprecated use `GetPaymentSelf$inboundSchema` instead. */
  export const inboundSchema = GetPaymentSelf$inboundSchema;
  /** @deprecated use `GetPaymentSelf$outboundSchema` instead. */
  export const outboundSchema = GetPaymentSelf$outboundSchema;
  /** @deprecated use `GetPaymentSelf$Outbound` instead. */
  export type Outbound = GetPaymentSelf$Outbound;
}

export function getPaymentSelfToJSON(getPaymentSelf: GetPaymentSelf): string {
  return JSON.stringify(GetPaymentSelf$outboundSchema.parse(getPaymentSelf));
}

export function getPaymentSelfFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentSelf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentSelf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentSelf' from JSON`,
  );
}

/** @internal */
export const GetPaymentCheckout$inboundSchema: z.ZodType<
  GetPaymentCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentCheckout$outboundSchema: z.ZodType<
  GetPaymentCheckout$Outbound,
  z.ZodTypeDef,
  GetPaymentCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentCheckout$ {
  /** @deprecated use `GetPaymentCheckout$inboundSchema` instead. */
  export const inboundSchema = GetPaymentCheckout$inboundSchema;
  /** @deprecated use `GetPaymentCheckout$outboundSchema` instead. */
  export const outboundSchema = GetPaymentCheckout$outboundSchema;
  /** @deprecated use `GetPaymentCheckout$Outbound` instead. */
  export type Outbound = GetPaymentCheckout$Outbound;
}

export function getPaymentCheckoutToJSON(
  getPaymentCheckout: GetPaymentCheckout,
): string {
  return JSON.stringify(
    GetPaymentCheckout$outboundSchema.parse(getPaymentCheckout),
  );
}

export function getPaymentCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentCheckout' from JSON`,
  );
}

/** @internal */
export const GetPaymentMobileAppCheckout$inboundSchema: z.ZodType<
  GetPaymentMobileAppCheckout,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentMobileAppCheckout$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentMobileAppCheckout$outboundSchema: z.ZodType<
  GetPaymentMobileAppCheckout$Outbound,
  z.ZodTypeDef,
  GetPaymentMobileAppCheckout
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMobileAppCheckout$ {
  /** @deprecated use `GetPaymentMobileAppCheckout$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMobileAppCheckout$inboundSchema;
  /** @deprecated use `GetPaymentMobileAppCheckout$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMobileAppCheckout$outboundSchema;
  /** @deprecated use `GetPaymentMobileAppCheckout$Outbound` instead. */
  export type Outbound = GetPaymentMobileAppCheckout$Outbound;
}

export function getPaymentMobileAppCheckoutToJSON(
  getPaymentMobileAppCheckout: GetPaymentMobileAppCheckout,
): string {
  return JSON.stringify(
    GetPaymentMobileAppCheckout$outboundSchema.parse(
      getPaymentMobileAppCheckout,
    ),
  );
}

export function getPaymentMobileAppCheckoutFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentMobileAppCheckout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentMobileAppCheckout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentMobileAppCheckout' from JSON`,
  );
}

/** @internal */
export const GetPaymentChangePaymentState$inboundSchema: z.ZodType<
  GetPaymentChangePaymentState,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentChangePaymentState$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentChangePaymentState$outboundSchema: z.ZodType<
  GetPaymentChangePaymentState$Outbound,
  z.ZodTypeDef,
  GetPaymentChangePaymentState
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentChangePaymentState$ {
  /** @deprecated use `GetPaymentChangePaymentState$inboundSchema` instead. */
  export const inboundSchema = GetPaymentChangePaymentState$inboundSchema;
  /** @deprecated use `GetPaymentChangePaymentState$outboundSchema` instead. */
  export const outboundSchema = GetPaymentChangePaymentState$outboundSchema;
  /** @deprecated use `GetPaymentChangePaymentState$Outbound` instead. */
  export type Outbound = GetPaymentChangePaymentState$Outbound;
}

export function getPaymentChangePaymentStateToJSON(
  getPaymentChangePaymentState: GetPaymentChangePaymentState,
): string {
  return JSON.stringify(
    GetPaymentChangePaymentState$outboundSchema.parse(
      getPaymentChangePaymentState,
    ),
  );
}

export function getPaymentChangePaymentStateFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentChangePaymentState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentChangePaymentState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentChangePaymentState' from JSON`,
  );
}

/** @internal */
export const GetPaymentDashboard$inboundSchema: z.ZodType<
  GetPaymentDashboard,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentDashboard$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentDashboard$outboundSchema: z.ZodType<
  GetPaymentDashboard$Outbound,
  z.ZodTypeDef,
  GetPaymentDashboard
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentDashboard$ {
  /** @deprecated use `GetPaymentDashboard$inboundSchema` instead. */
  export const inboundSchema = GetPaymentDashboard$inboundSchema;
  /** @deprecated use `GetPaymentDashboard$outboundSchema` instead. */
  export const outboundSchema = GetPaymentDashboard$outboundSchema;
  /** @deprecated use `GetPaymentDashboard$Outbound` instead. */
  export type Outbound = GetPaymentDashboard$Outbound;
}

export function getPaymentDashboardToJSON(
  getPaymentDashboard: GetPaymentDashboard,
): string {
  return JSON.stringify(
    GetPaymentDashboard$outboundSchema.parse(getPaymentDashboard),
  );
}

export function getPaymentDashboardFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentDashboard, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentDashboard$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentDashboard' from JSON`,
  );
}

/** @internal */
export const GetPaymentRefunds$inboundSchema: z.ZodType<
  GetPaymentRefunds,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentRefunds$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentRefunds$outboundSchema: z.ZodType<
  GetPaymentRefunds$Outbound,
  z.ZodTypeDef,
  GetPaymentRefunds
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentRefunds$ {
  /** @deprecated use `GetPaymentRefunds$inboundSchema` instead. */
  export const inboundSchema = GetPaymentRefunds$inboundSchema;
  /** @deprecated use `GetPaymentRefunds$outboundSchema` instead. */
  export const outboundSchema = GetPaymentRefunds$outboundSchema;
  /** @deprecated use `GetPaymentRefunds$Outbound` instead. */
  export type Outbound = GetPaymentRefunds$Outbound;
}

export function getPaymentRefundsToJSON(
  getPaymentRefunds: GetPaymentRefunds,
): string {
  return JSON.stringify(
    GetPaymentRefunds$outboundSchema.parse(getPaymentRefunds),
  );
}

export function getPaymentRefundsFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentRefunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentRefunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentRefunds' from JSON`,
  );
}

/** @internal */
export const GetPaymentChargebacks$inboundSchema: z.ZodType<
  GetPaymentChargebacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentChargebacks$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentChargebacks$outboundSchema: z.ZodType<
  GetPaymentChargebacks$Outbound,
  z.ZodTypeDef,
  GetPaymentChargebacks
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentChargebacks$ {
  /** @deprecated use `GetPaymentChargebacks$inboundSchema` instead. */
  export const inboundSchema = GetPaymentChargebacks$inboundSchema;
  /** @deprecated use `GetPaymentChargebacks$outboundSchema` instead. */
  export const outboundSchema = GetPaymentChargebacks$outboundSchema;
  /** @deprecated use `GetPaymentChargebacks$Outbound` instead. */
  export type Outbound = GetPaymentChargebacks$Outbound;
}

export function getPaymentChargebacksToJSON(
  getPaymentChargebacks: GetPaymentChargebacks,
): string {
  return JSON.stringify(
    GetPaymentChargebacks$outboundSchema.parse(getPaymentChargebacks),
  );
}

export function getPaymentChargebacksFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentChargebacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentChargebacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentChargebacks' from JSON`,
  );
}

/** @internal */
export const GetPaymentCaptures$inboundSchema: z.ZodType<
  GetPaymentCaptures,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentCaptures$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentCaptures$outboundSchema: z.ZodType<
  GetPaymentCaptures$Outbound,
  z.ZodTypeDef,
  GetPaymentCaptures
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentCaptures$ {
  /** @deprecated use `GetPaymentCaptures$inboundSchema` instead. */
  export const inboundSchema = GetPaymentCaptures$inboundSchema;
  /** @deprecated use `GetPaymentCaptures$outboundSchema` instead. */
  export const outboundSchema = GetPaymentCaptures$outboundSchema;
  /** @deprecated use `GetPaymentCaptures$Outbound` instead. */
  export type Outbound = GetPaymentCaptures$Outbound;
}

export function getPaymentCapturesToJSON(
  getPaymentCaptures: GetPaymentCaptures,
): string {
  return JSON.stringify(
    GetPaymentCaptures$outboundSchema.parse(getPaymentCaptures),
  );
}

export function getPaymentCapturesFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentCaptures, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentCaptures$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentCaptures' from JSON`,
  );
}

/** @internal */
export const GetPaymentSettlement$inboundSchema: z.ZodType<
  GetPaymentSettlement,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentSettlement$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentSettlement$outboundSchema: z.ZodType<
  GetPaymentSettlement$Outbound,
  z.ZodTypeDef,
  GetPaymentSettlement
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentSettlement$ {
  /** @deprecated use `GetPaymentSettlement$inboundSchema` instead. */
  export const inboundSchema = GetPaymentSettlement$inboundSchema;
  /** @deprecated use `GetPaymentSettlement$outboundSchema` instead. */
  export const outboundSchema = GetPaymentSettlement$outboundSchema;
  /** @deprecated use `GetPaymentSettlement$Outbound` instead. */
  export type Outbound = GetPaymentSettlement$Outbound;
}

export function getPaymentSettlementToJSON(
  getPaymentSettlement: GetPaymentSettlement,
): string {
  return JSON.stringify(
    GetPaymentSettlement$outboundSchema.parse(getPaymentSettlement),
  );
}

export function getPaymentSettlementFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentSettlement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentSettlement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentSettlement' from JSON`,
  );
}

/** @internal */
export const GetPaymentCustomer$inboundSchema: z.ZodType<
  GetPaymentCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentCustomer$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentCustomer$outboundSchema: z.ZodType<
  GetPaymentCustomer$Outbound,
  z.ZodTypeDef,
  GetPaymentCustomer
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentCustomer$ {
  /** @deprecated use `GetPaymentCustomer$inboundSchema` instead. */
  export const inboundSchema = GetPaymentCustomer$inboundSchema;
  /** @deprecated use `GetPaymentCustomer$outboundSchema` instead. */
  export const outboundSchema = GetPaymentCustomer$outboundSchema;
  /** @deprecated use `GetPaymentCustomer$Outbound` instead. */
  export type Outbound = GetPaymentCustomer$Outbound;
}

export function getPaymentCustomerToJSON(
  getPaymentCustomer: GetPaymentCustomer,
): string {
  return JSON.stringify(
    GetPaymentCustomer$outboundSchema.parse(getPaymentCustomer),
  );
}

export function getPaymentCustomerFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentCustomer' from JSON`,
  );
}

/** @internal */
export const GetPaymentMandate$inboundSchema: z.ZodType<
  GetPaymentMandate,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentMandate$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentMandate$outboundSchema: z.ZodType<
  GetPaymentMandate$Outbound,
  z.ZodTypeDef,
  GetPaymentMandate
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentMandate$ {
  /** @deprecated use `GetPaymentMandate$inboundSchema` instead. */
  export const inboundSchema = GetPaymentMandate$inboundSchema;
  /** @deprecated use `GetPaymentMandate$outboundSchema` instead. */
  export const outboundSchema = GetPaymentMandate$outboundSchema;
  /** @deprecated use `GetPaymentMandate$Outbound` instead. */
  export type Outbound = GetPaymentMandate$Outbound;
}

export function getPaymentMandateToJSON(
  getPaymentMandate: GetPaymentMandate,
): string {
  return JSON.stringify(
    GetPaymentMandate$outboundSchema.parse(getPaymentMandate),
  );
}

export function getPaymentMandateFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentMandate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentMandate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentMandate' from JSON`,
  );
}

/** @internal */
export const GetPaymentSubscription$inboundSchema: z.ZodType<
  GetPaymentSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentSubscription$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentSubscription$outboundSchema: z.ZodType<
  GetPaymentSubscription$Outbound,
  z.ZodTypeDef,
  GetPaymentSubscription
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentSubscription$ {
  /** @deprecated use `GetPaymentSubscription$inboundSchema` instead. */
  export const inboundSchema = GetPaymentSubscription$inboundSchema;
  /** @deprecated use `GetPaymentSubscription$outboundSchema` instead. */
  export const outboundSchema = GetPaymentSubscription$outboundSchema;
  /** @deprecated use `GetPaymentSubscription$Outbound` instead. */
  export type Outbound = GetPaymentSubscription$Outbound;
}

export function getPaymentSubscriptionToJSON(
  getPaymentSubscription: GetPaymentSubscription,
): string {
  return JSON.stringify(
    GetPaymentSubscription$outboundSchema.parse(getPaymentSubscription),
  );
}

export function getPaymentSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentSubscription' from JSON`,
  );
}

/** @internal */
export const GetPaymentOrder$inboundSchema: z.ZodType<
  GetPaymentOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentOrder$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentOrder$outboundSchema: z.ZodType<
  GetPaymentOrder$Outbound,
  z.ZodTypeDef,
  GetPaymentOrder
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentOrder$ {
  /** @deprecated use `GetPaymentOrder$inboundSchema` instead. */
  export const inboundSchema = GetPaymentOrder$inboundSchema;
  /** @deprecated use `GetPaymentOrder$outboundSchema` instead. */
  export const outboundSchema = GetPaymentOrder$outboundSchema;
  /** @deprecated use `GetPaymentOrder$Outbound` instead. */
  export type Outbound = GetPaymentOrder$Outbound;
}

export function getPaymentOrderToJSON(
  getPaymentOrder: GetPaymentOrder,
): string {
  return JSON.stringify(GetPaymentOrder$outboundSchema.parse(getPaymentOrder));
}

export function getPaymentOrderFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentOrder' from JSON`,
  );
}

/** @internal */
export const GetPaymentTerminal$inboundSchema: z.ZodType<
  GetPaymentTerminal,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentTerminal$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentTerminal$outboundSchema: z.ZodType<
  GetPaymentTerminal$Outbound,
  z.ZodTypeDef,
  GetPaymentTerminal
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentTerminal$ {
  /** @deprecated use `GetPaymentTerminal$inboundSchema` instead. */
  export const inboundSchema = GetPaymentTerminal$inboundSchema;
  /** @deprecated use `GetPaymentTerminal$outboundSchema` instead. */
  export const outboundSchema = GetPaymentTerminal$outboundSchema;
  /** @deprecated use `GetPaymentTerminal$Outbound` instead. */
  export type Outbound = GetPaymentTerminal$Outbound;
}

export function getPaymentTerminalToJSON(
  getPaymentTerminal: GetPaymentTerminal,
): string {
  return JSON.stringify(
    GetPaymentTerminal$outboundSchema.parse(getPaymentTerminal),
  );
}

export function getPaymentTerminalFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentTerminal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentTerminal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentTerminal' from JSON`,
  );
}

/** @internal */
export const GetPaymentDocumentation$inboundSchema: z.ZodType<
  GetPaymentDocumentation,
  z.ZodTypeDef,
  unknown
> = z.object({
  href: z.string(),
  type: z.string(),
});

/** @internal */
export type GetPaymentDocumentation$Outbound = {
  href: string;
  type: string;
};

/** @internal */
export const GetPaymentDocumentation$outboundSchema: z.ZodType<
  GetPaymentDocumentation$Outbound,
  z.ZodTypeDef,
  GetPaymentDocumentation
> = z.object({
  href: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentDocumentation$ {
  /** @deprecated use `GetPaymentDocumentation$inboundSchema` instead. */
  export const inboundSchema = GetPaymentDocumentation$inboundSchema;
  /** @deprecated use `GetPaymentDocumentation$outboundSchema` instead. */
  export const outboundSchema = GetPaymentDocumentation$outboundSchema;
  /** @deprecated use `GetPaymentDocumentation$Outbound` instead. */
  export type Outbound = GetPaymentDocumentation$Outbound;
}

export function getPaymentDocumentationToJSON(
  getPaymentDocumentation: GetPaymentDocumentation,
): string {
  return JSON.stringify(
    GetPaymentDocumentation$outboundSchema.parse(getPaymentDocumentation),
  );
}

export function getPaymentDocumentationFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentDocumentation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentDocumentation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentDocumentation' from JSON`,
  );
}

/** @internal */
export const GetPaymentLinks$inboundSchema: z.ZodType<
  GetPaymentLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: z.lazy(() => GetPaymentSelf$inboundSchema),
  checkout: z.lazy(() => GetPaymentCheckout$inboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => GetPaymentMobileAppCheckout$inboundSchema)
    .optional(),
  changePaymentState: z.lazy(() => GetPaymentChangePaymentState$inboundSchema)
    .optional(),
  dashboard: z.lazy(() => GetPaymentDashboard$inboundSchema),
  refunds: z.lazy(() => GetPaymentRefunds$inboundSchema).optional(),
  chargebacks: z.lazy(() => GetPaymentChargebacks$inboundSchema).optional(),
  captures: z.lazy(() => GetPaymentCaptures$inboundSchema).optional(),
  settlement: z.lazy(() => GetPaymentSettlement$inboundSchema).optional(),
  customer: z.lazy(() => GetPaymentCustomer$inboundSchema).optional(),
  mandate: z.lazy(() => GetPaymentMandate$inboundSchema).optional(),
  subscription: z.lazy(() => GetPaymentSubscription$inboundSchema).optional(),
  order: z.lazy(() => GetPaymentOrder$inboundSchema).optional(),
  terminal: z.lazy(() => GetPaymentTerminal$inboundSchema).optional(),
  documentation: z.lazy(() => GetPaymentDocumentation$inboundSchema).optional(),
});

/** @internal */
export type GetPaymentLinks$Outbound = {
  self: GetPaymentSelf$Outbound;
  checkout?: GetPaymentCheckout$Outbound | undefined;
  mobileAppCheckout?: GetPaymentMobileAppCheckout$Outbound | undefined;
  changePaymentState?: GetPaymentChangePaymentState$Outbound | undefined;
  dashboard: GetPaymentDashboard$Outbound;
  refunds?: GetPaymentRefunds$Outbound | undefined;
  chargebacks?: GetPaymentChargebacks$Outbound | undefined;
  captures?: GetPaymentCaptures$Outbound | undefined;
  settlement?: GetPaymentSettlement$Outbound | undefined;
  customer?: GetPaymentCustomer$Outbound | undefined;
  mandate?: GetPaymentMandate$Outbound | undefined;
  subscription?: GetPaymentSubscription$Outbound | undefined;
  order?: GetPaymentOrder$Outbound | undefined;
  terminal?: GetPaymentTerminal$Outbound | undefined;
  documentation?: GetPaymentDocumentation$Outbound | undefined;
};

/** @internal */
export const GetPaymentLinks$outboundSchema: z.ZodType<
  GetPaymentLinks$Outbound,
  z.ZodTypeDef,
  GetPaymentLinks
> = z.object({
  self: z.lazy(() => GetPaymentSelf$outboundSchema),
  checkout: z.lazy(() => GetPaymentCheckout$outboundSchema).optional(),
  mobileAppCheckout: z.lazy(() => GetPaymentMobileAppCheckout$outboundSchema)
    .optional(),
  changePaymentState: z.lazy(() => GetPaymentChangePaymentState$outboundSchema)
    .optional(),
  dashboard: z.lazy(() => GetPaymentDashboard$outboundSchema),
  refunds: z.lazy(() => GetPaymentRefunds$outboundSchema).optional(),
  chargebacks: z.lazy(() => GetPaymentChargebacks$outboundSchema).optional(),
  captures: z.lazy(() => GetPaymentCaptures$outboundSchema).optional(),
  settlement: z.lazy(() => GetPaymentSettlement$outboundSchema).optional(),
  customer: z.lazy(() => GetPaymentCustomer$outboundSchema).optional(),
  mandate: z.lazy(() => GetPaymentMandate$outboundSchema).optional(),
  subscription: z.lazy(() => GetPaymentSubscription$outboundSchema).optional(),
  order: z.lazy(() => GetPaymentOrder$outboundSchema).optional(),
  terminal: z.lazy(() => GetPaymentTerminal$outboundSchema).optional(),
  documentation: z.lazy(() => GetPaymentDocumentation$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentLinks$ {
  /** @deprecated use `GetPaymentLinks$inboundSchema` instead. */
  export const inboundSchema = GetPaymentLinks$inboundSchema;
  /** @deprecated use `GetPaymentLinks$outboundSchema` instead. */
  export const outboundSchema = GetPaymentLinks$outboundSchema;
  /** @deprecated use `GetPaymentLinks$Outbound` instead. */
  export type Outbound = GetPaymentLinks$Outbound;
}

export function getPaymentLinksToJSON(
  getPaymentLinks: GetPaymentLinks,
): string {
  return JSON.stringify(GetPaymentLinks$outboundSchema.parse(getPaymentLinks));
}

export function getPaymentLinksFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentLinks' from JSON`,
  );
}

/** @internal */
export const GetPaymentResponse$inboundSchema: z.ZodType<
  GetPaymentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: GetPaymentMode$inboundSchema,
  description: z.string(),
  amount: z.lazy(() => GetPaymentAmount$inboundSchema),
  amountRefunded: z.lazy(() => GetPaymentAmountRefunded$inboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => GetPaymentAmountRemaining$inboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => GetPaymentAmountCaptured$inboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => GetPaymentAmountChargedBack$inboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => GetPaymentSettlementAmount$inboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => GetPaymentLine$inboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => GetPaymentBillingAddress$inboundSchema)
    .optional(),
  shippingAddress: z.lazy(() => GetPaymentShippingAddress$inboundSchema)
    .optional(),
  locale: z.nullable(GetPaymentLocale$inboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(GetPaymentMethod$inboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => GetPaymentMetadata$inboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(GetPaymentCaptureMode$inboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => GetPaymentApplicationFee$inboundSchema),
  ).optional(),
  routing: z.nullable(z.array(z.lazy(() => GetPaymentRouting$inboundSchema)))
    .optional(),
  sequenceType: z.nullable(GetPaymentSequenceType$inboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: GetPaymentStatus$inboundSchema,
  statusReason: z.nullable(z.lazy(() => GetPaymentStatusReason$inboundSchema))
    .optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  _links: z.lazy(() => GetPaymentLinks$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type GetPaymentResponse$Outbound = {
  resource: string;
  id: string;
  mode: string;
  description: string;
  amount: GetPaymentAmount$Outbound;
  amountRefunded?: GetPaymentAmountRefunded$Outbound | undefined;
  amountRemaining?: GetPaymentAmountRemaining$Outbound | undefined;
  amountCaptured?: GetPaymentAmountCaptured$Outbound | undefined;
  amountChargedBack?: GetPaymentAmountChargedBack$Outbound | undefined;
  settlementAmount?: GetPaymentSettlementAmount$Outbound | undefined;
  redirectUrl?: string | null | undefined;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<GetPaymentLine$Outbound> | null | undefined;
  billingAddress?: GetPaymentBillingAddress$Outbound | undefined;
  shippingAddress?: GetPaymentShippingAddress$Outbound | undefined;
  locale?: string | null | undefined;
  countryCode?: string | null | undefined;
  method?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?:
    | GetPaymentMetadata$Outbound
    | string
    | Array<string>
    | null
    | undefined;
  captureMode?: string | null | undefined;
  captureDelay?: string | null | undefined;
  captureBefore?: string | null | undefined;
  applicationFee?: GetPaymentApplicationFee$Outbound | null | undefined;
  routing?: Array<GetPaymentRouting$Outbound> | null | undefined;
  sequenceType: string | null;
  subscriptionId?: string | null | undefined;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId: string;
  settlementId?: string | null | undefined;
  orderId?: string | null | undefined;
  status: string;
  statusReason?: GetPaymentStatusReason$Outbound | null | undefined;
  isCancelable?: boolean | null | undefined;
  details?: { [k: string]: any } | null | undefined;
  createdAt: string;
  authorizedAt?: string | null | undefined;
  paidAt?: string | null | undefined;
  canceledAt?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredAt?: string | null | undefined;
  failedAt?: string | null | undefined;
  _links: GetPaymentLinks$Outbound;
};

/** @internal */
export const GetPaymentResponse$outboundSchema: z.ZodType<
  GetPaymentResponse$Outbound,
  z.ZodTypeDef,
  GetPaymentResponse
> = z.object({
  resource: z.string(),
  id: z.string(),
  mode: GetPaymentMode$outboundSchema,
  description: z.string(),
  amount: z.lazy(() => GetPaymentAmount$outboundSchema),
  amountRefunded: z.lazy(() => GetPaymentAmountRefunded$outboundSchema)
    .optional(),
  amountRemaining: z.lazy(() => GetPaymentAmountRemaining$outboundSchema)
    .optional(),
  amountCaptured: z.lazy(() => GetPaymentAmountCaptured$outboundSchema)
    .optional(),
  amountChargedBack: z.lazy(() => GetPaymentAmountChargedBack$outboundSchema)
    .optional(),
  settlementAmount: z.lazy(() => GetPaymentSettlementAmount$outboundSchema)
    .optional(),
  redirectUrl: z.nullable(z.string()).optional(),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => GetPaymentLine$outboundSchema)))
    .optional(),
  billingAddress: z.lazy(() => GetPaymentBillingAddress$outboundSchema)
    .optional(),
  shippingAddress: z.lazy(() => GetPaymentShippingAddress$outboundSchema)
    .optional(),
  locale: z.nullable(GetPaymentLocale$outboundSchema).optional(),
  countryCode: z.nullable(z.string()).optional(),
  method: z.nullable(GetPaymentMethod$outboundSchema).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(
    z.union([
      z.lazy(() => GetPaymentMetadata$outboundSchema),
      z.string(),
      z.array(z.string()),
    ]),
  ).optional(),
  captureMode: z.nullable(GetPaymentCaptureMode$outboundSchema).optional(),
  captureDelay: z.nullable(z.string()).optional(),
  captureBefore: z.nullable(z.string()).optional(),
  applicationFee: z.nullable(
    z.lazy(() => GetPaymentApplicationFee$outboundSchema),
  ).optional(),
  routing: z.nullable(z.array(z.lazy(() => GetPaymentRouting$outboundSchema)))
    .optional(),
  sequenceType: z.nullable(GetPaymentSequenceType$outboundSchema),
  subscriptionId: z.nullable(z.string()).optional(),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.string(),
  settlementId: z.nullable(z.string()).optional(),
  orderId: z.nullable(z.string()).optional(),
  status: GetPaymentStatus$outboundSchema,
  statusReason: z.nullable(z.lazy(() => GetPaymentStatusReason$outboundSchema))
    .optional(),
  isCancelable: z.nullable(z.boolean()).optional(),
  details: z.nullable(z.record(z.any())).optional(),
  createdAt: z.string(),
  authorizedAt: z.nullable(z.string()).optional(),
  paidAt: z.nullable(z.string()).optional(),
  canceledAt: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredAt: z.nullable(z.string()).optional(),
  failedAt: z.nullable(z.string()).optional(),
  links: z.lazy(() => GetPaymentLinks$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPaymentResponse$ {
  /** @deprecated use `GetPaymentResponse$inboundSchema` instead. */
  export const inboundSchema = GetPaymentResponse$inboundSchema;
  /** @deprecated use `GetPaymentResponse$outboundSchema` instead. */
  export const outboundSchema = GetPaymentResponse$outboundSchema;
  /** @deprecated use `GetPaymentResponse$Outbound` instead. */
  export type Outbound = GetPaymentResponse$Outbound;
}

export function getPaymentResponseToJSON(
  getPaymentResponse: GetPaymentResponse,
): string {
  return JSON.stringify(
    GetPaymentResponse$outboundSchema.parse(getPaymentResponse),
  );
}

export function getPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPaymentResponse' from JSON`,
  );
}
