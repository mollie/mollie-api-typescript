/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MethodResponse,
  MethodResponse$inboundSchema,
  MethodResponse$outboundSchema,
} from "./methodresponse.js";
import {
  MethodStatus,
  MethodStatus$inboundSchema,
  MethodStatus$outboundSchema,
} from "./methodstatus.js";
import {
  Url,
  Url$inboundSchema,
  Url$Outbound,
  Url$outboundSchema,
} from "./url.js";

/**
 * URLs of images representing the payment method.
 */
export type EntityMethodAllImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x: string;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x: string;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can
   *
   * @remarks
   * scale to any desired size without compromising visual quality.
   */
  svg: string;
};

/**
 * URLs of images representing the issuer.
 *
 * @remarks
 * required:
 *   - size1x
 *   - size2x
 *   - svg
 */
export type EntityMethodAllIssuerImage = {
  /**
   * The URL pointing to an icon of 32 by 24 pixels.
   */
  size1x?: string | undefined;
  /**
   * The URL pointing to an icon of 64 by 48 pixels.
   */
  size2x?: string | undefined;
  /**
   * The URL pointing to a vector version of the icon. Usage of this format is preferred, since the icon can
   *
   * @remarks
   * scale to any desired size without compromising visual quality.
   */
  svg?: string | undefined;
};

export type EntityMethodAllIssuer = {
  resource: string;
  id: string;
  /**
   * The full name of the issuer.
   */
  name: string;
  /**
   * URLs of images representing the issuer.
   *
   * @remarks
   * required:
   *   - size1x
   *   - size2x
   *   - svg
   */
  image: EntityMethodAllIssuerImage;
};

/**
 * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
 */
export type EntityMethodAllLinks = {
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  self: Url;
  /**
   * In v2 endpoints, URLs are commonly represented as objects with an `href` and `type` field.
   */
  documentation?: Url | undefined;
};

export type Pricing = {
  /**
   * A description of what the pricing applies to. For example, a specific country (`The Netherlands`) or a
   *
   * @remarks
   * category of cards (`American Express`). If a `locale` is provided, the description may be translated.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  fixed: Amount;
  /**
   * The variable price charged per payment, as a percentage string.
   */
  variable: string;
  /**
   * Only present for credit card pricing. It will correspond with the `feeRegion` of credit card payments as
   *
   * @remarks
   * returned in the [Payments API](get-payment).
   */
  feeRegion?: string | null | undefined;
};

export type EntityMethodAll = {
  /**
   * Indicates the response contains a payment method object. Will always contain the string `method` for this
   *
   * @remarks
   * endpoint.
   */
  resource: string;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
   *
   * @remarks
   * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
   * parameter enables you to fully integrate the payment method selection into your website.
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen
   * but will only show the methods specified in the array. For example, you can use this functionality to only show
   * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   */
  id: MethodResponse | null;
  /**
   * The full name of the payment method.
   *
   * @remarks
   *
   * If a `locale` parameter is provided, the name is translated to the given locale if possible.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  minimumAmount: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  maximumAmount: AmountNullable | null;
  /**
   * URLs of images representing the payment method.
   */
  image: EntityMethodAllImage;
  /**
   * The payment method's activation status for this profile.
   */
  status: MethodStatus;
  /**
   * **Optional include.** Array of objects for each 'issuer' that is available for this payment method. Only relevant
   *
   * @remarks
   * for iDEAL, KBC/CBC, gift cards, and vouchers.
   */
  issuers?: Array<EntityMethodAllIssuer> | undefined;
  /**
   * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
   */
  links: EntityMethodAllLinks;
  /**
   * **Optional include.** Array of objects describing the pricing configuration applicable for this payment method on
   *
   * @remarks
   * your account.
   */
  pricing?: Array<Pricing> | undefined;
};

/** @internal */
export const EntityMethodAllImage$inboundSchema: z.ZodType<
  EntityMethodAllImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});

/** @internal */
export type EntityMethodAllImage$Outbound = {
  size1x: string;
  size2x: string;
  svg: string;
};

/** @internal */
export const EntityMethodAllImage$outboundSchema: z.ZodType<
  EntityMethodAllImage$Outbound,
  z.ZodTypeDef,
  EntityMethodAllImage
> = z.object({
  size1x: z.string(),
  size2x: z.string(),
  svg: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityMethodAllImage$ {
  /** @deprecated use `EntityMethodAllImage$inboundSchema` instead. */
  export const inboundSchema = EntityMethodAllImage$inboundSchema;
  /** @deprecated use `EntityMethodAllImage$outboundSchema` instead. */
  export const outboundSchema = EntityMethodAllImage$outboundSchema;
  /** @deprecated use `EntityMethodAllImage$Outbound` instead. */
  export type Outbound = EntityMethodAllImage$Outbound;
}

export function entityMethodAllImageToJSON(
  entityMethodAllImage: EntityMethodAllImage,
): string {
  return JSON.stringify(
    EntityMethodAllImage$outboundSchema.parse(entityMethodAllImage),
  );
}

export function entityMethodAllImageFromJSON(
  jsonString: string,
): SafeParseResult<EntityMethodAllImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityMethodAllImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityMethodAllImage' from JSON`,
  );
}

/** @internal */
export const EntityMethodAllIssuerImage$inboundSchema: z.ZodType<
  EntityMethodAllIssuerImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});

/** @internal */
export type EntityMethodAllIssuerImage$Outbound = {
  size1x?: string | undefined;
  size2x?: string | undefined;
  svg?: string | undefined;
};

/** @internal */
export const EntityMethodAllIssuerImage$outboundSchema: z.ZodType<
  EntityMethodAllIssuerImage$Outbound,
  z.ZodTypeDef,
  EntityMethodAllIssuerImage
> = z.object({
  size1x: z.string().optional(),
  size2x: z.string().optional(),
  svg: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityMethodAllIssuerImage$ {
  /** @deprecated use `EntityMethodAllIssuerImage$inboundSchema` instead. */
  export const inboundSchema = EntityMethodAllIssuerImage$inboundSchema;
  /** @deprecated use `EntityMethodAllIssuerImage$outboundSchema` instead. */
  export const outboundSchema = EntityMethodAllIssuerImage$outboundSchema;
  /** @deprecated use `EntityMethodAllIssuerImage$Outbound` instead. */
  export type Outbound = EntityMethodAllIssuerImage$Outbound;
}

export function entityMethodAllIssuerImageToJSON(
  entityMethodAllIssuerImage: EntityMethodAllIssuerImage,
): string {
  return JSON.stringify(
    EntityMethodAllIssuerImage$outboundSchema.parse(entityMethodAllIssuerImage),
  );
}

export function entityMethodAllIssuerImageFromJSON(
  jsonString: string,
): SafeParseResult<EntityMethodAllIssuerImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityMethodAllIssuerImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityMethodAllIssuerImage' from JSON`,
  );
}

/** @internal */
export const EntityMethodAllIssuer$inboundSchema: z.ZodType<
  EntityMethodAllIssuer,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => EntityMethodAllIssuerImage$inboundSchema),
});

/** @internal */
export type EntityMethodAllIssuer$Outbound = {
  resource: string;
  id: string;
  name: string;
  image: EntityMethodAllIssuerImage$Outbound;
};

/** @internal */
export const EntityMethodAllIssuer$outboundSchema: z.ZodType<
  EntityMethodAllIssuer$Outbound,
  z.ZodTypeDef,
  EntityMethodAllIssuer
> = z.object({
  resource: z.string(),
  id: z.string(),
  name: z.string(),
  image: z.lazy(() => EntityMethodAllIssuerImage$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityMethodAllIssuer$ {
  /** @deprecated use `EntityMethodAllIssuer$inboundSchema` instead. */
  export const inboundSchema = EntityMethodAllIssuer$inboundSchema;
  /** @deprecated use `EntityMethodAllIssuer$outboundSchema` instead. */
  export const outboundSchema = EntityMethodAllIssuer$outboundSchema;
  /** @deprecated use `EntityMethodAllIssuer$Outbound` instead. */
  export type Outbound = EntityMethodAllIssuer$Outbound;
}

export function entityMethodAllIssuerToJSON(
  entityMethodAllIssuer: EntityMethodAllIssuer,
): string {
  return JSON.stringify(
    EntityMethodAllIssuer$outboundSchema.parse(entityMethodAllIssuer),
  );
}

export function entityMethodAllIssuerFromJSON(
  jsonString: string,
): SafeParseResult<EntityMethodAllIssuer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityMethodAllIssuer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityMethodAllIssuer' from JSON`,
  );
}

/** @internal */
export const EntityMethodAllLinks$inboundSchema: z.ZodType<
  EntityMethodAllLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  self: Url$inboundSchema,
  documentation: Url$inboundSchema.optional(),
});

/** @internal */
export type EntityMethodAllLinks$Outbound = {
  self: Url$Outbound;
  documentation?: Url$Outbound | undefined;
};

/** @internal */
export const EntityMethodAllLinks$outboundSchema: z.ZodType<
  EntityMethodAllLinks$Outbound,
  z.ZodTypeDef,
  EntityMethodAllLinks
> = z.object({
  self: Url$outboundSchema,
  documentation: Url$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityMethodAllLinks$ {
  /** @deprecated use `EntityMethodAllLinks$inboundSchema` instead. */
  export const inboundSchema = EntityMethodAllLinks$inboundSchema;
  /** @deprecated use `EntityMethodAllLinks$outboundSchema` instead. */
  export const outboundSchema = EntityMethodAllLinks$outboundSchema;
  /** @deprecated use `EntityMethodAllLinks$Outbound` instead. */
  export type Outbound = EntityMethodAllLinks$Outbound;
}

export function entityMethodAllLinksToJSON(
  entityMethodAllLinks: EntityMethodAllLinks,
): string {
  return JSON.stringify(
    EntityMethodAllLinks$outboundSchema.parse(entityMethodAllLinks),
  );
}

export function entityMethodAllLinksFromJSON(
  jsonString: string,
): SafeParseResult<EntityMethodAllLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityMethodAllLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityMethodAllLinks' from JSON`,
  );
}

/** @internal */
export const Pricing$inboundSchema: z.ZodType<Pricing, z.ZodTypeDef, unknown> =
  z.object({
    description: z.string(),
    fixed: Amount$inboundSchema,
    variable: z.string(),
    feeRegion: z.nullable(z.string()).optional(),
  });

/** @internal */
export type Pricing$Outbound = {
  description: string;
  fixed: Amount$Outbound;
  variable: string;
  feeRegion?: string | null | undefined;
};

/** @internal */
export const Pricing$outboundSchema: z.ZodType<
  Pricing$Outbound,
  z.ZodTypeDef,
  Pricing
> = z.object({
  description: z.string(),
  fixed: Amount$outboundSchema,
  variable: z.string(),
  feeRegion: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Pricing$ {
  /** @deprecated use `Pricing$inboundSchema` instead. */
  export const inboundSchema = Pricing$inboundSchema;
  /** @deprecated use `Pricing$outboundSchema` instead. */
  export const outboundSchema = Pricing$outboundSchema;
  /** @deprecated use `Pricing$Outbound` instead. */
  export type Outbound = Pricing$Outbound;
}

export function pricingToJSON(pricing: Pricing): string {
  return JSON.stringify(Pricing$outboundSchema.parse(pricing));
}

export function pricingFromJSON(
  jsonString: string,
): SafeParseResult<Pricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pricing' from JSON`,
  );
}

/** @internal */
export const EntityMethodAll$inboundSchema: z.ZodType<
  EntityMethodAll,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string(),
  id: z.nullable(MethodResponse$inboundSchema),
  description: z.string(),
  minimumAmount: Amount$inboundSchema,
  maximumAmount: z.nullable(AmountNullable$inboundSchema),
  image: z.lazy(() => EntityMethodAllImage$inboundSchema),
  status: MethodStatus$inboundSchema,
  issuers: z.array(z.lazy(() => EntityMethodAllIssuer$inboundSchema))
    .optional(),
  _links: z.lazy(() => EntityMethodAllLinks$inboundSchema),
  pricing: z.array(z.lazy(() => Pricing$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
  });
});

/** @internal */
export type EntityMethodAll$Outbound = {
  resource: string;
  id: string | null;
  description: string;
  minimumAmount: Amount$Outbound;
  maximumAmount: AmountNullable$Outbound | null;
  image: EntityMethodAllImage$Outbound;
  status: string;
  issuers?: Array<EntityMethodAllIssuer$Outbound> | undefined;
  _links: EntityMethodAllLinks$Outbound;
  pricing?: Array<Pricing$Outbound> | undefined;
};

/** @internal */
export const EntityMethodAll$outboundSchema: z.ZodType<
  EntityMethodAll$Outbound,
  z.ZodTypeDef,
  EntityMethodAll
> = z.object({
  resource: z.string(),
  id: z.nullable(MethodResponse$outboundSchema),
  description: z.string(),
  minimumAmount: Amount$outboundSchema,
  maximumAmount: z.nullable(AmountNullable$outboundSchema),
  image: z.lazy(() => EntityMethodAllImage$outboundSchema),
  status: MethodStatus$outboundSchema,
  issuers: z.array(z.lazy(() => EntityMethodAllIssuer$outboundSchema))
    .optional(),
  links: z.lazy(() => EntityMethodAllLinks$outboundSchema),
  pricing: z.array(z.lazy(() => Pricing$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityMethodAll$ {
  /** @deprecated use `EntityMethodAll$inboundSchema` instead. */
  export const inboundSchema = EntityMethodAll$inboundSchema;
  /** @deprecated use `EntityMethodAll$outboundSchema` instead. */
  export const outboundSchema = EntityMethodAll$outboundSchema;
  /** @deprecated use `EntityMethodAll$Outbound` instead. */
  export type Outbound = EntityMethodAll$Outbound;
}

export function entityMethodAllToJSON(
  entityMethodAll: EntityMethodAll,
): string {
  return JSON.stringify(EntityMethodAll$outboundSchema.parse(entityMethodAll));
}

export function entityMethodAllFromJSON(
  jsonString: string,
): SafeParseResult<EntityMethodAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityMethodAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityMethodAll' from JSON`,
  );
}
