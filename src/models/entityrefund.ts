/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Amount,
  Amount$inboundSchema,
  Amount$Outbound,
  Amount$outboundSchema,
} from "./amount.js";
import {
  AmountNullable,
  AmountNullable$inboundSchema,
  AmountNullable$Outbound,
  AmountNullable$outboundSchema,
} from "./amountnullable.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";

/**
 * Specifies the reference type
 */
export const EntityRefundTypeAcquirerReference = {
  AcquirerReference: "acquirer-reference",
} as const;
/**
 * Specifies the reference type
 */
export type EntityRefundTypeAcquirerReference = ClosedEnum<
  typeof EntityRefundTypeAcquirerReference
>;

export type EntityRefundExternalReference = {
  /**
   * Specifies the reference type
   */
  type?: EntityRefundTypeAcquirerReference | undefined;
  /**
   * Unique reference from the payment provider
   */
  id?: string | undefined;
};

/**
 * The type of source. Currently only the source type `organization` is supported.
 */
export const RoutingReversalType = {
  Organization: "organization",
} as const;
/**
 * The type of source. Currently only the source type `organization` is supported.
 */
export type RoutingReversalType = ClosedEnum<typeof RoutingReversalType>;

/**
 * Where the funds will be pulled back from.
 */
export type EntityRefundSource = {
  /**
   * The type of source. Currently only the source type `organization` is supported.
   */
  type?: RoutingReversalType | undefined;
  organizationId?: string | undefined;
};

export type EntityRefundRoutingReversal = {
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount?: Amount | undefined;
  /**
   * Where the funds will be pulled back from.
   */
  source?: EntityRefundSource | undefined;
};

export type EntityRefund = {
  id: string;
  /**
   * The description of the refund that may be shown to your customer, depending on the payment method used.
   */
  description: string;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  amount: Amount;
  /**
   * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
   */
  settlementAmount?: AmountNullable | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
   *
   * @remarks
   * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata: Metadata | null;
  paymentId?: string | undefined;
  settlementId?: string | undefined;
  externalReference?: EntityRefundExternalReference | undefined;
  /**
   * *This feature is only available to marketplace operators.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
   * merchants, by providing the `routing` object during [payment creation](create-payment).
   *
   * When creating refunds for these *routed* payments, by default the full amount is deducted from your balance.
   *
   * If you want to pull back the funds that were routed to the connected merchant(s), you can set this parameter to
   * `true` when issuing a full refund.
   *
   * For more fine-grained control and for partial refunds, use the `routingReversals` parameter instead.
   */
  reverseRouting?: boolean | null | undefined;
  /**
   * *This feature is only available to marketplace operators.*
   *
   * @remarks
   *
   * When creating refunds for *routed* payments, by default the full amount is deducted from your balance.
   *
   * If you want to pull back funds from the connected merchant(s), you can use this parameter to specify what amount
   * needs to be reversed from which merchant(s).
   *
   * If you simply want to fully reverse the routed funds, you can also use the `reverseRouting` parameter instead.
   */
  routingReversals?: Array<EntityRefundRoutingReversal> | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
   * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
   * `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

/** @internal */
export const EntityRefundTypeAcquirerReference$inboundSchema: z.ZodNativeEnum<
  typeof EntityRefundTypeAcquirerReference
> = z.nativeEnum(EntityRefundTypeAcquirerReference);

/** @internal */
export const EntityRefundTypeAcquirerReference$outboundSchema: z.ZodNativeEnum<
  typeof EntityRefundTypeAcquirerReference
> = EntityRefundTypeAcquirerReference$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityRefundTypeAcquirerReference$ {
  /** @deprecated use `EntityRefundTypeAcquirerReference$inboundSchema` instead. */
  export const inboundSchema = EntityRefundTypeAcquirerReference$inboundSchema;
  /** @deprecated use `EntityRefundTypeAcquirerReference$outboundSchema` instead. */
  export const outboundSchema =
    EntityRefundTypeAcquirerReference$outboundSchema;
}

/** @internal */
export const EntityRefundExternalReference$inboundSchema: z.ZodType<
  EntityRefundExternalReference,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: EntityRefundTypeAcquirerReference$inboundSchema.optional(),
  id: z.string().optional(),
});

/** @internal */
export type EntityRefundExternalReference$Outbound = {
  type?: string | undefined;
  id?: string | undefined;
};

/** @internal */
export const EntityRefundExternalReference$outboundSchema: z.ZodType<
  EntityRefundExternalReference$Outbound,
  z.ZodTypeDef,
  EntityRefundExternalReference
> = z.object({
  type: EntityRefundTypeAcquirerReference$outboundSchema.optional(),
  id: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityRefundExternalReference$ {
  /** @deprecated use `EntityRefundExternalReference$inboundSchema` instead. */
  export const inboundSchema = EntityRefundExternalReference$inboundSchema;
  /** @deprecated use `EntityRefundExternalReference$outboundSchema` instead. */
  export const outboundSchema = EntityRefundExternalReference$outboundSchema;
  /** @deprecated use `EntityRefundExternalReference$Outbound` instead. */
  export type Outbound = EntityRefundExternalReference$Outbound;
}

export function entityRefundExternalReferenceToJSON(
  entityRefundExternalReference: EntityRefundExternalReference,
): string {
  return JSON.stringify(
    EntityRefundExternalReference$outboundSchema.parse(
      entityRefundExternalReference,
    ),
  );
}

export function entityRefundExternalReferenceFromJSON(
  jsonString: string,
): SafeParseResult<EntityRefundExternalReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityRefundExternalReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityRefundExternalReference' from JSON`,
  );
}

/** @internal */
export const RoutingReversalType$inboundSchema: z.ZodNativeEnum<
  typeof RoutingReversalType
> = z.nativeEnum(RoutingReversalType);

/** @internal */
export const RoutingReversalType$outboundSchema: z.ZodNativeEnum<
  typeof RoutingReversalType
> = RoutingReversalType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RoutingReversalType$ {
  /** @deprecated use `RoutingReversalType$inboundSchema` instead. */
  export const inboundSchema = RoutingReversalType$inboundSchema;
  /** @deprecated use `RoutingReversalType$outboundSchema` instead. */
  export const outboundSchema = RoutingReversalType$outboundSchema;
}

/** @internal */
export const EntityRefundSource$inboundSchema: z.ZodType<
  EntityRefundSource,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RoutingReversalType$inboundSchema.optional(),
  organizationId: z.string().optional(),
});

/** @internal */
export type EntityRefundSource$Outbound = {
  type?: string | undefined;
  organizationId?: string | undefined;
};

/** @internal */
export const EntityRefundSource$outboundSchema: z.ZodType<
  EntityRefundSource$Outbound,
  z.ZodTypeDef,
  EntityRefundSource
> = z.object({
  type: RoutingReversalType$outboundSchema.optional(),
  organizationId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityRefundSource$ {
  /** @deprecated use `EntityRefundSource$inboundSchema` instead. */
  export const inboundSchema = EntityRefundSource$inboundSchema;
  /** @deprecated use `EntityRefundSource$outboundSchema` instead. */
  export const outboundSchema = EntityRefundSource$outboundSchema;
  /** @deprecated use `EntityRefundSource$Outbound` instead. */
  export type Outbound = EntityRefundSource$Outbound;
}

export function entityRefundSourceToJSON(
  entityRefundSource: EntityRefundSource,
): string {
  return JSON.stringify(
    EntityRefundSource$outboundSchema.parse(entityRefundSource),
  );
}

export function entityRefundSourceFromJSON(
  jsonString: string,
): SafeParseResult<EntityRefundSource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityRefundSource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityRefundSource' from JSON`,
  );
}

/** @internal */
export const EntityRefundRoutingReversal$inboundSchema: z.ZodType<
  EntityRefundRoutingReversal,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: Amount$inboundSchema.optional(),
  source: z.lazy(() => EntityRefundSource$inboundSchema).optional(),
});

/** @internal */
export type EntityRefundRoutingReversal$Outbound = {
  amount?: Amount$Outbound | undefined;
  source?: EntityRefundSource$Outbound | undefined;
};

/** @internal */
export const EntityRefundRoutingReversal$outboundSchema: z.ZodType<
  EntityRefundRoutingReversal$Outbound,
  z.ZodTypeDef,
  EntityRefundRoutingReversal
> = z.object({
  amount: Amount$outboundSchema.optional(),
  source: z.lazy(() => EntityRefundSource$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityRefundRoutingReversal$ {
  /** @deprecated use `EntityRefundRoutingReversal$inboundSchema` instead. */
  export const inboundSchema = EntityRefundRoutingReversal$inboundSchema;
  /** @deprecated use `EntityRefundRoutingReversal$outboundSchema` instead. */
  export const outboundSchema = EntityRefundRoutingReversal$outboundSchema;
  /** @deprecated use `EntityRefundRoutingReversal$Outbound` instead. */
  export type Outbound = EntityRefundRoutingReversal$Outbound;
}

export function entityRefundRoutingReversalToJSON(
  entityRefundRoutingReversal: EntityRefundRoutingReversal,
): string {
  return JSON.stringify(
    EntityRefundRoutingReversal$outboundSchema.parse(
      entityRefundRoutingReversal,
    ),
  );
}

export function entityRefundRoutingReversalFromJSON(
  jsonString: string,
): SafeParseResult<EntityRefundRoutingReversal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityRefundRoutingReversal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityRefundRoutingReversal' from JSON`,
  );
}

/** @internal */
export const EntityRefund$inboundSchema: z.ZodType<
  EntityRefund,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  description: z.string(),
  amount: Amount$inboundSchema,
  settlementAmount: z.nullable(AmountNullable$inboundSchema).optional(),
  metadata: z.nullable(Metadata$inboundSchema),
  paymentId: z.string().optional(),
  settlementId: z.string().optional(),
  externalReference: z.lazy(() => EntityRefundExternalReference$inboundSchema)
    .optional(),
  reverseRouting: z.nullable(z.boolean()).optional(),
  routingReversals: z.nullable(
    z.array(z.lazy(() => EntityRefundRoutingReversal$inboundSchema)),
  ).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/** @internal */
export type EntityRefund$Outbound = {
  id: string;
  description: string;
  amount: Amount$Outbound;
  settlementAmount?: AmountNullable$Outbound | null | undefined;
  metadata: Metadata$Outbound | null;
  paymentId?: string | undefined;
  settlementId?: string | undefined;
  externalReference?: EntityRefundExternalReference$Outbound | undefined;
  reverseRouting?: boolean | null | undefined;
  routingReversals?:
    | Array<EntityRefundRoutingReversal$Outbound>
    | null
    | undefined;
  testmode?: boolean | null | undefined;
};

/** @internal */
export const EntityRefund$outboundSchema: z.ZodType<
  EntityRefund$Outbound,
  z.ZodTypeDef,
  EntityRefund
> = z.object({
  id: z.string(),
  description: z.string(),
  amount: Amount$outboundSchema,
  settlementAmount: z.nullable(AmountNullable$outboundSchema).optional(),
  metadata: z.nullable(Metadata$outboundSchema),
  paymentId: z.string().optional(),
  settlementId: z.string().optional(),
  externalReference: z.lazy(() => EntityRefundExternalReference$outboundSchema)
    .optional(),
  reverseRouting: z.nullable(z.boolean()).optional(),
  routingReversals: z.nullable(
    z.array(z.lazy(() => EntityRefundRoutingReversal$outboundSchema)),
  ).optional(),
  testmode: z.nullable(z.boolean()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityRefund$ {
  /** @deprecated use `EntityRefund$inboundSchema` instead. */
  export const inboundSchema = EntityRefund$inboundSchema;
  /** @deprecated use `EntityRefund$outboundSchema` instead. */
  export const outboundSchema = EntityRefund$outboundSchema;
  /** @deprecated use `EntityRefund$Outbound` instead. */
  export type Outbound = EntityRefund$Outbound;
}

export function entityRefundToJSON(entityRefund: EntityRefund): string {
  return JSON.stringify(EntityRefund$outboundSchema.parse(entityRefund));
}

export function entityRefundFromJSON(
  jsonString: string,
): SafeParseResult<EntityRefund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntityRefund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntityRefund' from JSON`,
  );
}
