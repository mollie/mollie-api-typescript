/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscriptionsAll } from "../funcs/subscriptionsAll.js";
import { subscriptionsCancel } from "../funcs/subscriptionsCancel.js";
import { subscriptionsCreate } from "../funcs/subscriptionsCreate.js";
import { subscriptionsGet } from "../funcs/subscriptionsGet.js";
import { subscriptionsList } from "../funcs/subscriptionsList.js";
import { subscriptionsListPayments } from "../funcs/subscriptionsListPayments.js";
import { subscriptionsUpdate } from "../funcs/subscriptionsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Subscriptions extends ClientSDK {
  /**
   * Create subscription
   *
   * @remarks
   * With subscriptions, you can schedule recurring payments to take place at regular intervals.
   *
   * For example, by simply specifying an `amount` and an `interval`, you can create an endless subscription to charge a
   * monthly fee, until you cancel the subscription.
   *
   * Or, you could use the times parameter to only charge a limited number of times, for example to split a big
   * transaction in multiple parts.
   *
   * A few example usages:
   *
   * `amount[currency]="EUR"` `amount[value]="5.00"` `interval="2 weeks"`
   * Your customer will be charged €5 once every two weeks.
   *
   * `amount[currency]="EUR"` `amount[value]="20.00"` `interval="1 day" times=5`
   * Your customer will be charged €20 every day, for five consecutive days.
   *
   * `amount[currency]="EUR"` `amount[value]="10.00"` `interval="1 month"`
   * `startDate="2018-04-30"`
   * Your customer will be charged €10 on the last day of each month, starting in April 2018.
   */
  async create(
    request: operations.CreateSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<models.SubscriptionResponse> {
    return unwrapAsync(subscriptionsCreate(
      this,
      request,
      options,
    ));
  }

  /**
   * List customer subscriptions
   *
   * @remarks
   * Retrieve all subscriptions of a customer.
   *
   * The results are paginated.
   */
  async list(
    request: operations.ListSubscriptionsRequest,
    options?: RequestOptions,
  ): Promise<operations.ListSubscriptionsResponse> {
    return unwrapAsync(subscriptionsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Get subscription
   *
   * @remarks
   * Retrieve a single subscription by its ID and the ID of its parent customer.
   */
  async get(
    request: operations.GetSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<models.SubscriptionResponse> {
    return unwrapAsync(subscriptionsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Update subscription
   *
   * @remarks
   * Update an existing subscription.
   *
   * Canceled subscriptions cannot be updated.
   *
   * For an in-depth explanation of each parameter, refer to the [Create subscription](create-subscription) endpoint.
   */
  async update(
    request: operations.UpdateSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<models.SubscriptionResponse> {
    return unwrapAsync(subscriptionsUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Cancel subscription
   *
   * @remarks
   * Cancel an existing subscription. Canceling a subscription has no effect on the mandates of the customer.
   */
  async cancel(
    request: operations.CancelSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<models.SubscriptionResponse> {
    return unwrapAsync(subscriptionsCancel(
      this,
      request,
      options,
    ));
  }

  /**
   * List all subscriptions
   *
   * @remarks
   * Retrieve all subscriptions initiated across all your customers.
   *
   * The results are paginated.
   */
  async all(
    request?: operations.ListAllSubscriptionsRequest | undefined,
    options?: RequestOptions,
  ): Promise<operations.ListAllSubscriptionsResponse> {
    return unwrapAsync(subscriptionsAll(
      this,
      request,
      options,
    ));
  }

  /**
   * List subscription payments
   *
   * @remarks
   * Retrieve all payments of a specific subscription.
   *
   * The results are paginated.
   */
  async listPayments(
    request: operations.ListSubscriptionPaymentsRequest,
    options?: RequestOptions,
  ): Promise<operations.ListSubscriptionPaymentsResponse> {
    return unwrapAsync(subscriptionsListPayments(
      this,
      request,
      options,
    ));
  }
}
